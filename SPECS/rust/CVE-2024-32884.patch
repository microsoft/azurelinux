Modified for Mariner by corvus-callidus:
  Removed changes to non-vendored files
  Fixed paths to match vendored code
  Backported patch to apply to version shipped with rust package
  Adjusted checksums to account for applied patches

From d80b5f69772a6e36b0131d3a538e896a8a6a29b1 Mon Sep 17 00:00:00 2001
From: Sebastian Thiel <sebastian.thiel@icloud.com>
Date: Sun, 24 Sep 2023 16:00:34 +0200
Subject: [PATCH] feat: add `Url::host_argument_safe()` and
 `Url::path_argument_safe()`

This will not provide values if they could be confused for an argument
to to a commaneline application.
---
 gix-url/src/lib.rs          | 36 ++++++++++++++++++++++++++++++++++++
 1 files changed, 36 insertions(+)

diff --git a/vendor/gix-url/src/lib.rs b/vendor/gix-url/src/lib.rs
index a5f1ba15443..add7b176b2b 100644
--- a/vendor/gix-url/src/lib.rs
+++ b/vendor/gix-url/src/lib.rs
@@ -47,6 +47,13 @@ pub struct Url {
     /// The port to use when connecting to a host. If `None`, standard ports depending on `scheme` will be used.
     pub port: Option<u16>,
     /// The path portion of the URL, usually the location of the git repository.
+    ///
+    /// # Security-Warning
+    ///
+    /// URLs allow paths to start with `-` which makes it possible to mask command-line arguments as path which then leads to
+    /// the invocation of programs from an attacker controlled URL. See https://secure.phabricator.com/T12961 for details.
+    ///
+    /// If this value is going to be used in a command-line application, call [Self::path_argument_safe()] instead.
     pub path: bstr::BString,
 }
 
@@ -123,9 +128,34 @@ impl Url {
         self.password.as_deref()
     }
     /// Returns the host mentioned in the url, if present.
+    ///
+    /// # Security-Warning
+    ///
+    /// URLs allow hosts to start with `-` which makes it possible to mask command-line arguments as host which then leads to
+    /// the invocation of programs from an attacker controlled URL. See https://secure.phabricator.com/T12961 for details.
+    ///
+    /// If this value is going to be used in a command-line application, call [Self::host_argument_safe()] instead.
     pub fn host(&self) -> Option<&str> {
         self.host.as_deref()
     }
+
+    /// Return the host of this URL if present *and* if it can't be mistaken for a command-line argument.
+    ///
+    /// Use this method if the host is going to be passed to a command-line application.
+    pub fn host_argument_safe(&self) -> Option<&str> {
+        self.host().filter(|host| !looks_like_argument(host.as_bytes()))
+    }
+
+    /// Return the path of this URL *and* if it can't be mistaken for a command-line argument.
+    /// Note that it always begins with a slash, which is ignored for this comparison.
+    ///
+    /// Use this method if the path is going to be passed to a command-line application.
+    pub fn path_argument_safe(&self) -> Option<&BStr> {
+        self.path
+            .get(1..)
+            .and_then(|truncated| (!looks_like_argument(truncated)).then_some(self.path.as_ref()))
+    }
+
     /// Returns true if the path portion of the url is `/`.
     pub fn path_is_root(&self) -> bool {
         self.path == "/"
@@ -144,6 +176,10 @@ impl Url {
     }
 }
 
+fn looks_like_argument(b: &[u8]) -> bool {
+    b.get(0) == Some(&b'-')
+}
+
 /// Transformation
 impl Url {
     /// Turn a file url like `file://relative` into `file:///root/relative`, hence it assures the url's path component is absolute.
From b06a0dd781accad317fdec5f86f069df4c21875c Mon Sep 17 00:00:00 2001
From: Sebastian Thiel <sebastian.thiel@icloud.com>
Date: Sun, 24 Sep 2023 11:07:18 +0200
Subject: [PATCH] fix: prevent hosts or paths that look like arguments to be
 passed to invoked commands.

See https://secure.phabricator.com/T12961 for more details.
---
 gix-transport/src/client/blocking_io/file.rs  |  6 +++++
 .../src/client/blocking_io/ssh/mod.rs         | 23 +++++++++++++------
 .../client/blocking_io/ssh/program_kind.rs    | 17 ++++++++++----
 .../src/client/blocking_io/ssh/tests.rs       | 23 +++++++++++++++----
 gix-transport/src/client/git/mod.rs           | 15 ++++++++++++
 gix-transport/src/client/non_io_types.rs      |  2 ++
 gix-transport/src/lib.rs                      |  1 -
 gix-url/src/lib.rs                            |  6 ++---
 8 files changed, 74 insertions(+), 19 deletions(-)

diff --git a/vendor/gix-transport/src/client/blocking_io/file.rs b/vendor/gix-transport/src/client/blocking_io/file.rs
index 599f56c23e8..613fd23578b 100644
--- a/vendor/gix-transport/src/client/blocking_io/file.rs
+++ b/vendor/gix-transport/src/client/blocking_io/file.rs
@@ -211,6 +211,11 @@ impl client::Transport for SpawnProcessOnDemand {
         };
         cmd.stdin = Stdio::piped();
         cmd.stdout = Stdio::piped();
+        if self.path.first() == Some(&b'-') {
+            return Err(client::Error::AmbiguousPath {
+                path: self.path.clone(),
+            });
+        }
         let repo_path = if self.ssh_cmd.is_some() {
             cmd.args.push(service.as_str().into());
             gix_quote::single(self.path.as_ref()).to_os_str_lossy().into_owned()

diff --git a/vendor/gix-transport/src/client/blocking_io/ssh/mod.rs b/vendor/gix-transport/src/client/blocking_io/ssh/mod.rs
index 7c042dc28b3..642aab9fd4d 100644
--- a/vendor/gix-transport/src/client/blocking_io/ssh/mod.rs
+++ b/vendor/gix-transport/src/client/blocking_io/ssh/mod.rs
@@ -8,6 +8,8 @@ use crate::{client::blocking_io, Protocol};
 pub enum Error {
     #[error("The scheme in \"{}\" is not usable for an ssh connection", .0.to_bstring())]
     UnsupportedScheme(gix_url::Url),
+    #[error("Host name '{host}' could be mistaken for a command-line argument")]
+    AmbiguousHostName { host: String },
 }
 
 impl crate::IsSpuriousError for Error {}
@@ -37,12 +39,17 @@ pub mod invocation {
 
     /// The error returned when producing ssh invocation arguments based on a selected invocation kind.
     #[derive(Debug, thiserror::Error)]
-    #[error("The 'Simple' ssh variant doesn't support {function}")]
-    pub struct Error {
-        /// The simple command that should have been invoked.
-        pub command: OsString,
-        /// The function that was unsupported
-        pub function: &'static str,
+    #[allow(missing_docs)]
+    pub enum Error {
+        #[error("Host name '{host}' could be mistaken for a command-line argument")]
+        AmbiguousHostName { host: String },
+        #[error("The 'Simple' ssh variant doesn't support {function}")]
+        Unsupported {
+            /// The simple command that should have been invoked.
+            command: OsString,
+            /// The function that was unsupported
+            function: &'static str,
+        },
     }
 }
 
@@ -105,7 +112,9 @@ pub fn connect(
                 .stdin(Stdio::null())
                 .with_shell()
                 .arg("-G")
-                .arg(url.host().expect("always set for ssh urls")),
+                .arg(url.host_argument_safe().ok_or_else(|| Error::AmbiguousHostName {
+                    host: url.host().expect("set in ssh urls").into(),
+                })?),
         )
         .status()
         .ok()
diff --git a/vendor/gix-transport/src/client/blocking_io/ssh/program_kind.rs b/vendor/gix-transport/src/client/blocking_io/ssh/program_kind.rs
index f02d4444444..70905829f64 100644
--- a/vendor/gix-transport/src/client/blocking_io/ssh/program_kind.rs
+++ b/vendor/gix-transport/src/client/blocking_io/ssh/program_kind.rs
@@ -31,7 +31,6 @@ impl ProgramKind {
         if disallow_shell {
             prepare.use_shell = false;
         }
-        let host = url.host().expect("present in ssh urls");
         match self {
             ProgramKind::Ssh => {
                 if desired_version != Protocol::V1 {
@@ -54,7 +53,7 @@ impl ProgramKind {
             }
             ProgramKind::Simple => {
                 if url.port.is_some() {
-                    return Err(ssh::invocation::Error {
+                    return Err(ssh::invocation::Error::Unsupported {
                         command: ssh_cmd.into(),
                         function: "setting the port",
                     });
@@ -62,8 +61,18 @@ impl ProgramKind {
             }
         };
         let host_as_ssh_arg = match url.user() {
-            Some(user) => format!("{user}@{host}"),
-            None => host.into(),
+            Some(user) => {
+                let host = url.host().expect("present in ssh urls");
+                format!("{user}@{host}")
+            }
+            None => {
+                let host = url
+                    .host_argument_safe()
+                    .ok_or_else(|| ssh::invocation::Error::AmbiguousHostName {
+                        host: url.host().expect("ssh host always set").into(),
+                    })?;
+                host.into()
+            }
         };
 
         // Try to force ssh to yield english messages (for parsing later)
diff --git a/vendor/gix-transport/src/client/blocking_io/ssh/tests.rs b/vendor/gix-transport/src/client/blocking_io/ssh/tests.rs
index f0820d14ed7..4e4da780703 100644
--- a/vendor/gix-transport/src/client/blocking_io/ssh/tests.rs
+++ b/vendor/gix-transport/src/client/blocking_io/ssh/tests.rs
@@ -144,13 +144,28 @@ mod program_kind {
                 assert!(call_args(kind, "ssh://user@host:43/p", Protocol::V2).ends_with("-P 43 user@host"));
             }
         }
+        #[test]
+        fn ambiguous_host_is_allowed_with_user() {
+            assert_eq!(
+                call_args(ProgramKind::Ssh, "ssh://user@-arg/p", Protocol::V2),
+                joined(&["ssh", "-o", "SendEnv=GIT_PROTOCOL", "user@-arg"])
+            );
+        }
+
+        #[test]
+        fn ambiguous_host_is_disallowed() {
+            assert!(matches!(
+                try_call(ProgramKind::Ssh, "ssh://-arg/p", Protocol::V2),
+                Err(ssh::invocation::Error::AmbiguousHostName { host }) if host == "-arg"
+            ));
+        }
 
         #[test]
         fn simple_cannot_handle_any_arguments() {
-            match try_call(ProgramKind::Simple, "ssh://user@host:42/p", Protocol::V2) {
-                Err(ssh::invocation::Error { .. }) => {}
-                _ => panic!("BUG: unexpected outcome"),
-            }
+            assert!(matches!(
+                try_call(ProgramKind::Simple, "ssh://user@host:42/p", Protocol::V2),
+                Err(ssh::invocation::Error::Unsupported { .. })
+            ));
             assert_eq!(
                 call_args(ProgramKind::Simple, "ssh://user@host/p", Protocol::V2),
                 joined(&["simple", "user@host"]),
diff --git a/vendor/gix-transport/src/client/git/mod.rs b/vendor/gix-transport/src/client/git/mod.rs
index 2b950b44a40..d27f468ff8f 100644
--- a/vendor/gix-transport/src/client/git/mod.rs
+++ b/vendor/gix-transport/src/client/git/mod.rs
@@ -165,6 +165,21 @@ mod message {
                 "git-upload-pack hello\\world\0host=host:404\0"
             )
         }
+
+        #[test]
+        fn with_strange_host_and_port() {
+            assert_eq!(
+                git::message::connect(
+                    Service::UploadPack,
+                    Protocol::V1,
+                    b"--upload-pack=attack",
+                    Some(&("--proxy=other-attack".into(), Some(404))),
+                    &[]
+                ),
+                "git-upload-pack --upload-pack=attack\0host=--proxy=other-attack:404\0",
+                "we explicitly allow possible `-arg` arguments to be passed to the git daemon - the remote must protect against exploitation, we don't want to prevent legitimate cases"
+            )
+        }
     }
 }
 
diff --git a/vendor/gix-transport/src/client/non_io_types.rs b/vendor/gix-transport/src/client/non_io_types.rs
index 807b22a8f5f..a1dbb247c71 100644
--- a/vendor/gix-transport/src/client/non_io_types.rs
+++ b/vendor/gix-transport/src/client/non_io_types.rs
@@ -138,6 +138,8 @@ mod error {
         Http(#[from] HttpError),
         #[error(transparent)]
         SshInvocation(SshInvocationError),
+        #[error("The repository path '{path}' could be mistaken for a command-line argument")]
+        AmbiguousPath { path: BString },
     }
 
     impl crate::IsSpuriousError for Error {
diff --git a/vendor/gix-transport/src/lib.rs b/vendor/gix-transport/src/lib.rs
index 5176125ec95..4ec2ea61557 100644
--- a/vendor/gix-transport/src/lib.rs
+++ b/vendor/gix-transport/src/lib.rs
@@ -21,7 +21,6 @@ pub use gix_packetline as packetline;
 /// The version of the way client and server communicate.
 #[derive(Default, PartialEq, Eq, Debug, Hash, Ord, PartialOrd, Clone, Copy)]
 #[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
-#[allow(missing_docs)]
 pub enum Protocol {
     /// Version 0 is like V1, but doesn't show capabilities at all, at least when hosted without `git-daemon`.
     V0 = 0,
diff --git a/vendor/gix-url/src/lib.rs b/vendor/gix-url/src/lib.rs
index add7b176b2b..1d90689ae61 100644
--- a/vendor/gix-url/src/lib.rs
+++ b/vendor/gix-url/src/lib.rs
@@ -51,7 +51,7 @@ pub struct Url {
     /// # Security-Warning
     ///
     /// URLs allow paths to start with `-` which makes it possible to mask command-line arguments as path which then leads to
-    /// the invocation of programs from an attacker controlled URL. See https://secure.phabricator.com/T12961 for details.
+    /// the invocation of programs from an attacker controlled URL. See <https://secure.phabricator.com/T12961> for details.
     ///
     /// If this value is going to be used in a command-line application, call [Self::path_argument_safe()] instead.
     pub path: bstr::BString,
@@ -132,7 +132,7 @@ impl Url {
     /// # Security-Warning
     ///
     /// URLs allow hosts to start with `-` which makes it possible to mask command-line arguments as host which then leads to
-    /// the invocation of programs from an attacker controlled URL. See https://secure.phabricator.com/T12961 for details.
+    /// the invocation of programs from an attacker controlled URL. See <https://secure.phabricator.com/T12961> for details.
     ///
     /// If this value is going to be used in a command-line application, call [Self::host_argument_safe()] instead.
     pub fn host(&self) -> Option<&str> {
@@ -177,7 +177,7 @@ impl Url {
 }
 
 fn looks_like_argument(b: &[u8]) -> bool {
-    b.get(0) == Some(&b'-')
+    b.first() == Some(&b'-')
 }
 
 /// Transformation
From db40382328c373258aa3bd5f9551511a42af6be5 Mon Sep 17 00:00:00 2001
From: Eliah Kagan <degeneracypressure@gmail.com>
Date: Thu, 11 Apr 2024 22:38:59 +0000
Subject: [PATCH] feat: Add `Url::user_argument_safe()`

This returns `None` if the username begins with a `-`, which would
confuse command-line applications.

It is analogous to the `Url::host_argument_safe()` and
`Url::path_argument_safe()` methods (introduced in d80b5f6), but
for usernames rather than hosts or paths.
---
 gix-url/src/lib.rs          | 14 ++++++++++++++
 gix-url/tests/access/mod.rs |  2 +-
 2 files changed, 15 insertions(+), 1 deletion(-)

diff --git a/vendor/gix-url/src/lib.rs b/vendor/gix-url/src/lib.rs
index fba3ffe6d7..f0373c521b 100644
--- a/vendor/gix-url/src/lib.rs
+++ b/vendor/gix-url/src/lib.rs
@@ -120,9 +120,23 @@ impl Url {
 /// Access
 impl Url {
     /// Returns the user mentioned in the url, if present.
+    ///
+    /// # Security-Warning
+    ///
+    /// URLs allow usernames to start with `-` which makes it possible to mask command-line arguments as username which then leads to
+    /// the invocation of programs from an attacker controlled URL. See <https://secure.phabricator.com/T12961> for details.
+    ///
+    /// If this value is going to be used in a command-line application, call [Self::user_argument_safe()] instead.
     pub fn user(&self) -> Option<&str> {
         self.user.as_deref()
     }
+    /// Return the user from this URL if present *and* if it can't be mistaken for a command-line argument.
+    ///
+    /// Use this method if the user or a portion of the URL that begins with it will be passed to a command-line application.
+    pub fn user_argument_safe(&self) -> Option<&str> {
+        self.user().filter(|user| !looks_like_argument(user.as_bytes()))
+    }
+
     /// Returns the password mentioned in the url, if present.
     pub fn password(&self) -> Option<&str> {
         self.password.as_deref()
     }
From 54286091ebc6e13a8f27f730fa88127e6334cf13 Mon Sep 17 00:00:00 2001
From: Eliah Kagan <degeneracypressure@gmail.com>
Date: Fri, 12 Apr 2024 04:13:34 +0000
Subject: [PATCH] Add ambiguous user unit tests, and more for hostname

Not all of these tests can pass yet, since gix-transport does not
yet detect and refuse to proceed with leading-hypnen usernames.
Some pass; those that do not are, as expected:

- ambiguous_user_is_disallowed_explicit_ssh
- ambiguous_user_is_disallowed_implicit_ssh
- ambiguous_user_and_host_remain_disallowed_together_explicit_ssh
- ambiguous_user_and_host_remain_disallowed_together_implicit_ssh

This also adds AmbiguousUserName in one of the enums that will need
to have it, but nothing fails with this error yet; it is introduced
now only to facilitate writing unit tests that assert it.
---
 .../src/client/blocking_io/ssh/mod.rs         |  2 +
 1 files changed, 2 insertions(+)

diff --git a/vendor/gix-transport/src/client/blocking_io/ssh/mod.rs b/vendor/gix-transport/src/client/blocking_io/ssh/mod.rs
index 16f47bd25f4..00e06582d74 100644
--- a/vendor/gix-transport/src/client/blocking_io/ssh/mod.rs
+++ b/vendor/gix-transport/src/client/blocking_io/ssh/mod.rs
@@ -41,6 +41,8 @@ pub mod invocation {
     #[derive(Debug, thiserror::Error)]
     #[allow(missing_docs)]
     pub enum Error {
+        #[error("Username '{user}' could be mistaken for a command-line argument")]
+        AmbiguousUserName { user: String },
         #[error("Host name '{host}' could be mistaken for a command-line argument")]
         AmbiguousHostName { host: String },
         #[error("The 'Simple' ssh variant doesn't support {function}")]

From f56ad390a5569d0129b7b16632991d18b9ddb4f7 Mon Sep 17 00:00:00 2001
From: Eliah Kagan <degeneracypressure@gmail.com>
Date: Fri, 12 Apr 2024 06:38:19 +0000
Subject: [PATCH] fix: Prevent usernames with leading `-` from being passed to
 SSH

This detects ambiguous usernames in dangerous cases where they
would be passed to external commands to form SSH connections, if
they would be misinterpreted as option arguments.

This change is analogous to b06a0dd, hardening `gix-transport` and
applications that use it against options smuggled in URLs, but for
the non-mandatory username portion of a URL, rather than the host
and path portions that were covered there.

For example, commands like these no longer pass `-F...` options to
`ssh`:

    gix clone 'ssh://-Fconfigfile@example.com/abc'
    gix clone -- '-Fconfigfile@example.com:abc/def'

Instead, they refuse to run `ssh`, producing the error:

    Error: Username '-Fconfigfile' could be mistaken for a command-line argument
---
 .../src/client/blocking_io/ssh/program_kind.rs      | 13 ++++++++++---
 gix-url/src/lib.rs                                  |  7 +++++++
 2 files changed, 17 insertions(+), 3 deletions(-)

diff --git a/vendor/gix-transport/src/client/blocking_io/ssh/program_kind.rs b/vendor/gix-transport/src/client/blocking_io/ssh/program_kind.rs
index 70905829f64..d046db772c1 100644
--- a/vendor/gix-transport/src/client/blocking_io/ssh/program_kind.rs
+++ b/vendor/gix-transport/src/client/blocking_io/ssh/program_kind.rs
@@ -60,8 +60,12 @@ impl ProgramKind {
                 }
             }
         };
-        let host_as_ssh_arg = match url.user() {
+        let host_maybe_with_user_as_ssh_arg = match url.user() {
             Some(user) => {
+                // FIXME: See the fixme comment on Url::user_argument_safe() about its return type.
+                if url.user_argument_safe() != Some(user) {
+                    return Err(ssh::invocation::Error::AmbiguousUserName { user: user.into() });
+                }
                 let host = url.host().expect("present in ssh urls");
                 format!("{user}@{host}")
             }
@@ -75,8 +79,11 @@ impl ProgramKind {
             }
         };
 
-        // Try to force ssh to yield english messages (for parsing later)
-        Ok(prepare.arg(host_as_ssh_arg).env("LANG", "C").env("LC_ALL", "C"))
+        // Try to force ssh to yield English messages (for parsing later).
+        Ok(prepare
+            .arg(host_maybe_with_user_as_ssh_arg)
+            .env("LANG", "C")
+            .env("LC_ALL", "C"))
     }
 
     /// Note that the caller has to assure that the ssh program is launched in English by setting the locale.
diff --git a/vendor/gix-url/src/lib.rs b/vendor/gix-url/src/lib.rs
index 23b7cf59fbd..ff6d5a12f59 100644
--- a/vendor/gix-url/src/lib.rs
+++ b/vendor/gix-url/src/lib.rs
@@ -134,6 +134,13 @@ impl Url {
     ///
     /// Use this method if the user or a portion of the URL that begins with it will be passed to a command-line application.
     pub fn user_argument_safe(&self) -> Option<&str> {
+        // FIXME: A return value of None from this method, or host_argument_safe(), is ambiguous: the user (or host) is
+        // either present but unsafe, or absent. Furthermore, in practice the value is usually needed even if unsafe,
+        // in order to report it in an error message. In gix-transport, the ambiguity makes it easy to write a new bug
+        // while using this interface for user_argument_safe(). In contrast, in host_argument_safe(), the ambiguity is
+        // much less of a problem, because the host is expected to be present. Yet the host() method must still be
+        // called when handling the None case, to include it in the error. If possible, both methods should be replaced
+        // by methods with a richer return type (a new enum). If not, the ambiguity should be prominently documented.
         self.user().filter(|user| !looks_like_argument(user.as_bytes()))
     }
 
diff --git a/vendor/gix-url/.cargo-checksum.json b/vendor/gix-url/.cargo-checksum.json
index f0b09303d..37c2df0fb 100644
--- a/vendor/gix-url/.cargo-checksum.json
+++ b/vendor/gix-url/.cargo-checksum.json
@@ -1 +1 @@
-{"files":{"CHANGELOG.md":"5d9b8377ce6e6d41c00ddad06da5530e9c42f29c625dc598ed90b109a757288a","Cargo.toml":"f55ec09a9dbf19c990124d4a8232f13cf179943af5de337e31cf7565ecf80c47","LICENSE-APACHE":"cb4780590812826851ba250f90bed0ed19506ec98f6865a0e2e20bbf62391ff9","LICENSE-MIT":"49df47913ab2beafe8dc45607877ae64198bf0eee64aaad3e82ed9e4d27424e8","src/expand_path.rs":"b0d2fe688c170dfa1381b3cb7add373a618a8ac2520ebdeb2ea721318bb88566","src/impls.rs":"3e47180ec440b42bbd0ba2bdbcbfc247fbfd4020066ce5ca0f4c137b36807323","src/lib.rs":"fc219a768c3c96a5b649bdba11d03e8f168ed347391208bcf48c40eb49e91c5c","src/parse.rs":"0dd96b53e86df347388c9d05be66e49cc2aa4bdec439304c53d4e28664644a14","src/scheme.rs":"02a6a230eea7459b05959ff4e8ce30f4d45526e1f1a47ff88b260bb1943d2433"},"package":"f1663df25ac42047a2547618d2a6979a26f478073f6306997429235d2cd4c863"}
\ No newline at end of file
+{"files":{"CHANGELOG.md":"5d9b8377ce6e6d41c00ddad06da5530e9c42f29c625dc598ed90b109a757288a","Cargo.toml":"f55ec09a9dbf19c990124d4a8232f13cf179943af5de337e31cf7565ecf80c47","LICENSE-APACHE":"cb4780590812826851ba250f90bed0ed19506ec98f6865a0e2e20bbf62391ff9","LICENSE-MIT":"49df47913ab2beafe8dc45607877ae64198bf0eee64aaad3e82ed9e4d27424e8","src/expand_path.rs":"b0d2fe688c170dfa1381b3cb7add373a618a8ac2520ebdeb2ea721318bb88566","src/impls.rs":"3e47180ec440b42bbd0ba2bdbcbfc247fbfd4020066ce5ca0f4c137b36807323","src/lib.rs":"4afc16f5c79826ed9fe96b438266b39d982aba69c459fc010ac0a2ee3f5a8236","src/parse.rs":"0dd96b53e86df347388c9d05be66e49cc2aa4bdec439304c53d4e28664644a14","src/scheme.rs":"02a6a230eea7459b05959ff4e8ce30f4d45526e1f1a47ff88b260bb1943d2433"},"package":"f1663df25ac42047a2547618d2a6979a26f478073f6306997429235d2cd4c863"}
\ No newline at end of file

diff --git a/vendor/gix-transport/.cargo-checksum.json b/vendor/gix-transport/.cargo-checksum.json
index 24fcaaab0..3d7642bc4 100644
--- a/vendor/gix-transport/.cargo-checksum.json
+++ b/vendor/gix-transport/.cargo-checksum.json
@@ -1 +1 @@
-{"files":{"CHANGELOG.md":"f62eee0a65c00e91dcf1765ad19ae166a17234fa97d21a6c848bd65fa7158df7","Cargo.toml":"97027a5e91451a0eb68225d5a03f123d5fe52c1c446de4d9474c47a7de397d03","LICENSE-APACHE":"cb4780590812826851ba250f90bed0ed19506ec98f6865a0e2e20bbf62391ff9","LICENSE-MIT":"49df47913ab2beafe8dc45607877ae64198bf0eee64aaad3e82ed9e4d27424e8","src/client/async_io/bufread_ext.rs":"d9ef051c5bd1abd62ab43db6a50b4bdf163e1d50e8b25624e12aaed1bd8ece52","src/client/async_io/connect.rs":"d2f64a865612cdf2aefebc8c58c28b0d303e697819ae467b0145d18ab87fd359","src/client/async_io/mod.rs":"dbc880330eea5ab38d2ac7aa8d295352cac1011aa4f6c9d9216ccfb7fa79789d","src/client/async_io/request.rs":"6844d8804f1b99836994fdc2faa636542336b988b7ab15d118ea1aa24315cd65","src/client/async_io/traits.rs":"f0ec02bce105d138e438daa1397ff92b82230c19171039b12e995eb2011b8f1e","src/client/blocking_io/bufread_ext.rs":"ffb691bac5e4c7e35506f01aaee3560c80de8143e9eb5755cab2a3da545ed113","src/client/blocking_io/connect.rs":"e146594221beae80385b08094a128066a8772127b989bb63e8bb0b5d7dc7f82d","src/client/blocking_io/file.rs":"663e3a4b62c3860068c0c3fbc16adbb0d1535ee028c23d084f68a853a5bb2641","src/client/blocking_io/http/curl/mod.rs":"4fa0027b0aabdb71676c5267d8dab446ccd81863dd80dc9ac8f43e7710099ca4","src/client/blocking_io/http/curl/remote.rs":"957c511ed64d7c3fee886ef7d16f56e04bfd8ac266680f9c88907dd150c1b6da","src/client/blocking_io/http/mod.rs":"3a58753707f5ee2d7a59123d3a749bb17864ed70fe6c5b197174bc9b4861e691","src/client/blocking_io/http/redirect.rs":"1f6d57c8a87a9cb4c3699c53f5e05468d99b89d49532c1f805931dcdcff36c0b","src/client/blocking_io/http/reqwest/mod.rs":"08d09aefaddbd0049676bdbe403fca2282c9da4484a6d7cd8e84ec8a46060184","src/client/blocking_io/http/reqwest/remote.rs":"dfcebff86bbf77401e1f22152b570a125dc38c8e983df51e14f8bb1e2459586c","src/client/blocking_io/http/traits.rs":"520d9789ee9e5cee861a068f8ca0bd5309c853f288a065d3cfb86d8e0145942f","src/client/blocking_io/mod.rs":"b3b09948dcad91f5e9060875e5096c3d4155e3fdf33af0415b04f9c6246adec2","src/client/blocking_io/request.rs":"1602b053538b864557729fa6b3f74aa91020ead2bdcd55c86dd10c13c9168b94","src/client/blocking_io/ssh/mod.rs":"a2eb446804b7d377db8a0bae5d74936271dc7cdd71f12629eaf21a0c821453c8","src/client/blocking_io/ssh/program_kind.rs":"e573e45103ac3978da65cb87be3aac476fc40781a953d2c464f754fa79398cee","src/client/blocking_io/ssh/tests.rs":"309e795036635782a005cba1ddf0e8dcf7b1e1fea49429f644996c942cf7ccbe","src/client/blocking_io/traits.rs":"7e1ef1d6cd6c03f493fe55dd3ba6ad2a5059db16a22b9b75bbda8b055c207813","src/client/capabilities.rs":"fd74e87fd6b405de1613d9f5bec9fd6c0705e1ba1f2d2afdc349586af0190381","src/client/git/async_io.rs":"97b8dccc93bf5a62349aec7dc967acb59212ca66a49347564da50e4fc64864ec","src/client/git/blocking_io.rs":"42e3ee0f597cc31bd87027e21573ccfd4270b835795526f65ef193cff0da077c","src/client/git/mod.rs":"46d990e403f5f825fb0f9332d2ee1a3d8b33209d5a74fe8b473840bcf8e873c4","src/client/mod.rs":"563bb655c93af9dde121a6c8ddb94055aac862da5ac3e9d0420ca5eb21892387","src/client/non_io_types.rs":"ec10e9d7cf6270caf087643484dc4935b014124cf5b914f28eaa476a6869349a","src/client/traits.rs":"5c7b1f9d4b35ae049e81aa7aea09c0b142df023005d876765581b6b267a015d6","src/lib.rs":"c96d2ade712012d7babb19673c2097139036d6290b010828365da743700b65e2"},"package":"64a39ffed9a9078ed700605e064b15d7c6ae50aa65e7faa36ca6919e8081df15"}
\ No newline at end of file
+{"files":{"CHANGELOG.md":"f62eee0a65c00e91dcf1765ad19ae166a17234fa97d21a6c848bd65fa7158df7","Cargo.toml":"97027a5e91451a0eb68225d5a03f123d5fe52c1c446de4d9474c47a7de397d03","LICENSE-APACHE":"cb4780590812826851ba250f90bed0ed19506ec98f6865a0e2e20bbf62391ff9","LICENSE-MIT":"49df47913ab2beafe8dc45607877ae64198bf0eee64aaad3e82ed9e4d27424e8","src/client/async_io/bufread_ext.rs":"d9ef051c5bd1abd62ab43db6a50b4bdf163e1d50e8b25624e12aaed1bd8ece52","src/client/async_io/connect.rs":"d2f64a865612cdf2aefebc8c58c28b0d303e697819ae467b0145d18ab87fd359","src/client/async_io/mod.rs":"dbc880330eea5ab38d2ac7aa8d295352cac1011aa4f6c9d9216ccfb7fa79789d","src/client/async_io/request.rs":"6844d8804f1b99836994fdc2faa636542336b988b7ab15d118ea1aa24315cd65","src/client/async_io/traits.rs":"f0ec02bce105d138e438daa1397ff92b82230c19171039b12e995eb2011b8f1e","src/client/blocking_io/bufread_ext.rs":"ffb691bac5e4c7e35506f01aaee3560c80de8143e9eb5755cab2a3da545ed113","src/client/blocking_io/connect.rs":"e146594221beae80385b08094a128066a8772127b989bb63e8bb0b5d7dc7f82d","src/client/blocking_io/file.rs":"acc9357a505a80a24b37794159a4f15b88baff714a351f0e80e201a87d400e34","src/client/blocking_io/http/curl/mod.rs":"4fa0027b0aabdb71676c5267d8dab446ccd81863dd80dc9ac8f43e7710099ca4","src/client/blocking_io/http/curl/remote.rs":"957c511ed64d7c3fee886ef7d16f56e04bfd8ac266680f9c88907dd150c1b6da","src/client/blocking_io/http/mod.rs":"3a58753707f5ee2d7a59123d3a749bb17864ed70fe6c5b197174bc9b4861e691","src/client/blocking_io/http/redirect.rs":"1f6d57c8a87a9cb4c3699c53f5e05468d99b89d49532c1f805931dcdcff36c0b","src/client/blocking_io/http/reqwest/mod.rs":"08d09aefaddbd0049676bdbe403fca2282c9da4484a6d7cd8e84ec8a46060184","src/client/blocking_io/http/reqwest/remote.rs":"dfcebff86bbf77401e1f22152b570a125dc38c8e983df51e14f8bb1e2459586c","src/client/blocking_io/http/traits.rs":"520d9789ee9e5cee861a068f8ca0bd5309c853f288a065d3cfb86d8e0145942f","src/client/blocking_io/mod.rs":"b3b09948dcad91f5e9060875e5096c3d4155e3fdf33af0415b04f9c6246adec2","src/client/blocking_io/request.rs":"1602b053538b864557729fa6b3f74aa91020ead2bdcd55c86dd10c13c9168b94","src/client/blocking_io/ssh/mod.rs":"121a661bb41f49573ee6017bc5a73e68efdf22e687cdd8d358bd14489cdcb4fe","src/client/blocking_io/ssh/program_kind.rs":"1941fda57add6c99413607f9139a49554fa15b1af6da3f6dbcddd63e3a451da2","src/client/blocking_io/ssh/tests.rs":"21836e0188548ea148775861771a7105091f5b0c432f5d84eeb1343b50ad20bd","src/client/blocking_io/traits.rs":"7e1ef1d6cd6c03f493fe55dd3ba6ad2a5059db16a22b9b75bbda8b055c207813","src/client/capabilities.rs":"fd74e87fd6b405de1613d9f5bec9fd6c0705e1ba1f2d2afdc349586af0190381","src/client/git/async_io.rs":"97b8dccc93bf5a62349aec7dc967acb59212ca66a49347564da50e4fc64864ec","src/client/git/blocking_io.rs":"42e3ee0f597cc31bd87027e21573ccfd4270b835795526f65ef193cff0da077c","src/client/git/mod.rs":"1c3ad5b754becfbca63b76fab85ebd97c2c5902f907fffbac994caffb82ee4a1","src/client/mod.rs":"563bb655c93af9dde121a6c8ddb94055aac862da5ac3e9d0420ca5eb21892387","src/client/non_io_types.rs":"9ea8334d6271118b1207634d425bf170ca93c221ab84072d7aa40576ea37ed24","src/client/traits.rs":"5c7b1f9d4b35ae049e81aa7aea09c0b142df023005d876765581b6b267a015d6","src/lib.rs":"220bd015a0ac9ad591fb0df4061206ff285b502802f7d6179c9cd2f3488450b6"},"package":"64a39ffed9a9078ed700605e064b15d7c6ae50aa65e7faa36ca6919e8081df15"}
\ No newline at end of file
