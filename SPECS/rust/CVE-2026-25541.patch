From d0293b0e35838123c51ca5dfdf468ecafee4398f Mon Sep 17 00:00:00 2001
From: Alice Ryhl <aliceryhl@google.com>
Date: Tue, 3 Feb 2026 14:40:22 +0100
Subject: [PATCH] Merge commit from fork

* Add repro for integer overflow

Signed-off-by: Alice Ryhl <aliceryhl@google.com>

* Always check overflow in new_cap + offset

Signed-off-by: Alice Ryhl <aliceryhl@google.com>

Upstream Patch reference: https://github.com/tokio-rs/bytes/commit/d0293b0e35838123c51ca5dfdf468ecafee4398f.patch
---
 vendor/bytes-1.10.0/.cargo-checksum.json |  2 +-
 vendor/bytes-1.10.0/ci/miri.sh           |  3 +++
 vendor/bytes-1.10.0/src/bytes_mut.rs     | 20 ++++++++++++--------
 vendor/bytes-1.10.0/tests/test_bytes.rs  | 13 +++++++++++++
 4 files changed, 29 insertions(+), 9 deletions(-)

diff --git a/vendor/bytes-1.10.0/.cargo-checksum.json b/vendor/bytes-1.10.0/.cargo-checksum.json
index 6496773c4..db97fe467 100644
--- a/vendor/bytes-1.10.0/.cargo-checksum.json
+++ b/vendor/bytes-1.10.0/.cargo-checksum.json
@@ -1 +1 @@
-{"files":{".cargo_vcs_info.json":"c7971e90199ad3af2d17a8ad8b93b705d33a29a9e2e82f939c193e059946c584",".github/workflows/ci.yml":"1e635153dbcbee2afb3fd51a83340439f07f223b179e7cde28a68a8ee7385008","CHANGELOG.md":"6aa60aa8ed901b68734f29061bd47bdfaa38329dc23453d26acfafda6743c1b4","Cargo.lock":"d4b366e110775a100240d38f2515f1585b81dae75fface3b2f57f41172a6351e","Cargo.toml":"af759a984eec99ce46ee45bc0cc3fb47f2b5447cdb1908d6e6359b626b190737","Cargo.toml.orig":"0eae7f688b83f15c775806b661fa22e2514af1147aa019e77b96d5677939e729","LICENSE":"45f522cacecb1023856e46df79ca625dfc550c94910078bd8aec6e02880b3d42","README.md":"275ac7bc295e3cc659d28f05261645ac5bd6286476afe2ee3c1ed719f7b6df02","SECURITY.md":"a3335079977c2f13bad59e323fdc1056bdae5adfe55f18d15ac2c930d741828c","benches/buf.rs":"72e6b6120b52d568da068f17c66a793d65602e400c595778581b63092e41d8dc","benches/bytes.rs":"7084e564f8568f52c9fdb76a06e58701aa7f0c776209d29a0f60c38a19748203","benches/bytes_mut.rs":"1326fe6224b26826228e02b4133151e756f38152c2d9cfe66adf83af76c3ec98","ci/miri.sh":"13b2db3432fcdf9e2db6ef9e6ec20d063c0ce63542981a6f77e09306e1e2198e","ci/panic-abort.sh":"aec2e5427117e533d7a9721a926eb6a9d72f264510066baf2c501357df2d936f","ci/test-stable.sh":"fb751f06f314f728c489b7a7854701f632e24de8d0540ea8cf3449c6a853ac3c","ci/tsan.sh":"466b86b19225dd26c756cf2252cb1973f87a145642c99364b462ed7ceb55c7dd","clippy.toml":"8522f448dfa3b33ac334ce47d233ebb6b58e8ae115e45107a64fc1b4510fe560","src/buf/buf_impl.rs":"a14aa7e5e7fac1d4d1a3617d616af0b478a9a31235b773bcec11255c8c78446e","src/buf/buf_mut.rs":"6cc3800b08dc36eac3dbe0916be67fa535132c69dd920065efb930fd7c7d0a39","src/buf/chain.rs":"27ff0a6fce049c51a24d45003b9741b655c28330b48af23ad1514587760b0c93","src/buf/iter.rs":"d4dca5b7f9b1cb441f22ac1862e28b10086721879163a810955aefb5cd7f3e58","src/buf/limit.rs":"e005ba140b70f68654877c96b981a220477e415ff5c92438c1b0cb9bc866d872","src/buf/mod.rs":"3f60295316d44b510b942abb31a0d975ae488bd4b52c87f5252d73f88f82715a","src/buf/reader.rs":"cda8bc221a1de06c7395d5c6e80f8a5924198eafbc2decc0909082ce8781d789","src/buf/take.rs":"68053cf0edd9e1abd51b0cac9fefd7d3abfc53d2fde1f44d775399720b2d939e","src/buf/uninit_slice.rs":"52629b93ff7a08db45fc69395580b34fa3609fd9309ea01f86e58488b02b08a3","src/buf/vec_deque.rs":"baac165527d1bdfc3bb259380bb4722e70c3f11e8a901e8bab6e4f951b060711","src/buf/writer.rs":"b137608cb40944a5c3e061a73087c5a48e50048dae002d0334a23cf4d3547065","src/bytes.rs":"140ea293c520a0a6c80f7f3aa7ce9a6d33782f6be19a416929450b3fbfcba107","src/bytes_mut.rs":"0498dcaf2b39c0cc4b39c398e095bb4cc0bc001ebc2d90ffd067308e8566b772","src/fmt/debug.rs":"4d217b8f43e489925bb6904010df617efc63b50a3cc1ab126eec54b43b66eb3e","src/fmt/hex.rs":"54c05ab7d95d7381e499079d63773fabd2672f3c4929b56b02ab87d4495902b5","src/fmt/mod.rs":"b38222dcfff70eb3ffb6ce305b95f3fcfd9fa68cca85693eb2ed01d3da7ddb88","src/lib.rs":"6a59680076e75d4b6f966a2202de615ab1107b066b1c8481398131285b6195cf","src/loom.rs":"7c89f9f5f900d5b9b7c43d08d467957933eba90d5dcff1b38cf9a7e48494a577","src/serde.rs":"3ecd7e828cd4c2b7db93c807cb1548fad209e674df493edf7cda69a7b04d405d","tests/test_buf.rs":"c55dc7ab1a7392c2467a079dc77223fbec35ff54e9eda9b05cc1d4e22cb36626","tests/test_buf_mut.rs":"3e6a12a4f546dbf1a0e1346ab2b7ff707fdaf01a06b21714ca64b141484a76c3","tests/test_bytes.rs":"6b4effac07365f8ca24aad8efc32a70e742a4957383a89aa8ebd1d6eaacc1c54","tests/test_bytes_odd_alloc.rs":"ad5df84a35038359413199762c65017989d905e6e965a7b863beaa9962a7e1e8","tests/test_bytes_vec_alloc.rs":"5a0e77cab12b32374b2822df8d9a6479afe68b55c1cba1511ebf4199be532caa","tests/test_chain.rs":"e9f094539bb42b3135f50033c44122a6b44cf0f953e51e8b488f43243f1e7f10","tests/test_debug.rs":"13299107172809e8cbbd823964ac9450cd0d6b6de79f2e6a2e0f44b9225a0593","tests/test_iter.rs":"665e1837c1294d7695ffa352a666ce8673fb46fa603164556524e87d5517a6cb","tests/test_reader.rs":"bf83669d4e0960dad6aa47b46a9a454814fab626eb83572aba914c3d71618f43","tests/test_serde.rs":"2691f891796ba259de0ecf926de05c514f4912cc5fcd3e6a1591efbcd23ed4d0","tests/test_take.rs":"fb34700a8ed75b3c6937a4dee0bffadb64f7c7f735bd9faa8730eb96a9e9b651"},"package":"f61dac84819c6588b558454b194026eb1f09c293b9036ae9b159e74e73ab6cf9"}
\ No newline at end of file
+{"files":{".cargo_vcs_info.json":"c7971e90199ad3af2d17a8ad8b93b705d33a29a9e2e82f939c193e059946c584",".github/workflows/ci.yml":"1e635153dbcbee2afb3fd51a83340439f07f223b179e7cde28a68a8ee7385008","CHANGELOG.md":"6aa60aa8ed901b68734f29061bd47bdfaa38329dc23453d26acfafda6743c1b4","Cargo.lock":"d4b366e110775a100240d38f2515f1585b81dae75fface3b2f57f41172a6351e","Cargo.toml":"af759a984eec99ce46ee45bc0cc3fb47f2b5447cdb1908d6e6359b626b190737","Cargo.toml.orig":"0eae7f688b83f15c775806b661fa22e2514af1147aa019e77b96d5677939e729","LICENSE":"45f522cacecb1023856e46df79ca625dfc550c94910078bd8aec6e02880b3d42","README.md":"275ac7bc295e3cc659d28f05261645ac5bd6286476afe2ee3c1ed719f7b6df02","SECURITY.md":"a3335079977c2f13bad59e323fdc1056bdae5adfe55f18d15ac2c930d741828c","benches/buf.rs":"72e6b6120b52d568da068f17c66a793d65602e400c595778581b63092e41d8dc","benches/bytes.rs":"7084e564f8568f52c9fdb76a06e58701aa7f0c776209d29a0f60c38a19748203","benches/bytes_mut.rs":"1326fe6224b26826228e02b4133151e756f38152c2d9cfe66adf83af76c3ec98","ci/miri.sh":"e74475e7aec647a490a1f491b5dac6a60e3c03926a7c7e1898fa3e7c626415c7","ci/panic-abort.sh":"aec2e5427117e533d7a9721a926eb6a9d72f264510066baf2c501357df2d936f","ci/test-stable.sh":"fb751f06f314f728c489b7a7854701f632e24de8d0540ea8cf3449c6a853ac3c","ci/tsan.sh":"466b86b19225dd26c756cf2252cb1973f87a145642c99364b462ed7ceb55c7dd","clippy.toml":"8522f448dfa3b33ac334ce47d233ebb6b58e8ae115e45107a64fc1b4510fe560","src/buf/buf_impl.rs":"a14aa7e5e7fac1d4d1a3617d616af0b478a9a31235b773bcec11255c8c78446e","src/buf/buf_mut.rs":"6cc3800b08dc36eac3dbe0916be67fa535132c69dd920065efb930fd7c7d0a39","src/buf/chain.rs":"27ff0a6fce049c51a24d45003b9741b655c28330b48af23ad1514587760b0c93","src/buf/iter.rs":"d4dca5b7f9b1cb441f22ac1862e28b10086721879163a810955aefb5cd7f3e58","src/buf/limit.rs":"e005ba140b70f68654877c96b981a220477e415ff5c92438c1b0cb9bc866d872","src/buf/mod.rs":"3f60295316d44b510b942abb31a0d975ae488bd4b52c87f5252d73f88f82715a","src/buf/reader.rs":"cda8bc221a1de06c7395d5c6e80f8a5924198eafbc2decc0909082ce8781d789","src/buf/take.rs":"68053cf0edd9e1abd51b0cac9fefd7d3abfc53d2fde1f44d775399720b2d939e","src/buf/uninit_slice.rs":"52629b93ff7a08db45fc69395580b34fa3609fd9309ea01f86e58488b02b08a3","src/buf/vec_deque.rs":"baac165527d1bdfc3bb259380bb4722e70c3f11e8a901e8bab6e4f951b060711","src/buf/writer.rs":"b137608cb40944a5c3e061a73087c5a48e50048dae002d0334a23cf4d3547065","src/bytes.rs":"140ea293c520a0a6c80f7f3aa7ce9a6d33782f6be19a416929450b3fbfcba107","src/bytes_mut.rs":"f9ee7264e02fbc129e017c75ca500e3b7129d6f9929e9531de187bbe59326246","src/fmt/debug.rs":"4d217b8f43e489925bb6904010df617efc63b50a3cc1ab126eec54b43b66eb3e","src/fmt/hex.rs":"54c05ab7d95d7381e499079d63773fabd2672f3c4929b56b02ab87d4495902b5","src/fmt/mod.rs":"b38222dcfff70eb3ffb6ce305b95f3fcfd9fa68cca85693eb2ed01d3da7ddb88","src/lib.rs":"6a59680076e75d4b6f966a2202de615ab1107b066b1c8481398131285b6195cf","src/loom.rs":"7c89f9f5f900d5b9b7c43d08d467957933eba90d5dcff1b38cf9a7e48494a577","src/serde.rs":"3ecd7e828cd4c2b7db93c807cb1548fad209e674df493edf7cda69a7b04d405d","tests/test_buf.rs":"c55dc7ab1a7392c2467a079dc77223fbec35ff54e9eda9b05cc1d4e22cb36626","tests/test_buf_mut.rs":"3e6a12a4f546dbf1a0e1346ab2b7ff707fdaf01a06b21714ca64b141484a76c3","tests/test_bytes.rs":"a13b57a41f86fab4ed12f56306efa7b7cc4d344129786ae7b5075864be9a5ac7","tests/test_bytes_odd_alloc.rs":"ad5df84a35038359413199762c65017989d905e6e965a7b863beaa9962a7e1e8","tests/test_bytes_vec_alloc.rs":"5a0e77cab12b32374b2822df8d9a6479afe68b55c1cba1511ebf4199be532caa","tests/test_chain.rs":"e9f094539bb42b3135f50033c44122a6b44cf0f953e51e8b488f43243f1e7f10","tests/test_debug.rs":"13299107172809e8cbbd823964ac9450cd0d6b6de79f2e6a2e0f44b9225a0593","tests/test_iter.rs":"665e1837c1294d7695ffa352a666ce8673fb46fa603164556524e87d5517a6cb","tests/test_reader.rs":"bf83669d4e0960dad6aa47b46a9a454814fab626eb83572aba914c3d71618f43","tests/test_serde.rs":"2691f891796ba259de0ecf926de05c514f4912cc5fcd3e6a1591efbcd23ed4d0","tests/test_take.rs":"fb34700a8ed75b3c6937a4dee0bffadb64f7c7f735bd9faa8730eb96a9e9b651"},"package":"f61dac84819c6588b558454b194026eb1f09c293b9036ae9b159e74e73ab6cf9"}
diff --git a/vendor/bytes-1.10.0/ci/miri.sh b/vendor/bytes-1.10.0/ci/miri.sh
index 7df29f360..ca7f41df5 100755
--- a/vendor/bytes-1.10.0/ci/miri.sh
+++ b/vendor/bytes-1.10.0/ci/miri.sh
@@ -8,3 +8,6 @@ export MIRIFLAGS="-Zmiri-strict-provenance"
 
 cargo miri test
 cargo miri test --target mips64-unknown-linux-gnuabi64
+
+# run with wrapping integer overflow instead of panic
+cargo miri test --release
diff --git a/vendor/bytes-1.10.0/src/bytes_mut.rs b/vendor/bytes-1.10.0/src/bytes_mut.rs
index d5db5124b..3026b302a 100644
--- a/vendor/bytes-1.10.0/src/bytes_mut.rs
+++ b/vendor/bytes-1.10.0/src/bytes_mut.rs
@@ -696,9 +696,15 @@ impl BytesMut {
 
                 let offset = offset_from(self.ptr.as_ptr(), ptr);
 
+                let new_cap_plus_offset = match new_cap.checked_add(offset) {
+                    Some(new_cap_plus_offset) => new_cap_plus_offset,
+                    None if !allocate => return false,
+                    None => panic!("overflow"),
+                };
+
                 // Compare the condition in the `kind == KIND_VEC` case above
                 // for more details.
-                if v_capacity >= new_cap + offset {
+                if v_capacity >= new_cap_plus_offset {
                     self.cap = new_cap;
                     // no copy is necessary
                 } else if v_capacity >= new_cap && offset >= len {
@@ -714,14 +720,12 @@ impl BytesMut {
                     if !allocate {
                         return false;
                     }
-                    // calculate offset
-                    let off = (self.ptr.as_ptr() as usize) - (v.as_ptr() as usize);
 
                     // new_cap is calculated in terms of `BytesMut`, not the underlying
                     // `Vec`, so it does not take the offset into account.
                     //
                     // Thus we have to manually add it here.
-                    new_cap = new_cap.checked_add(off).expect("overflow");
+                    new_cap = new_cap_plus_offset;
 
                     // The vector capacity is not sufficient. The reserve request is
                     // asking for more than the initial buffer capacity. Allocate more
@@ -743,13 +747,13 @@ impl BytesMut {
                     // the unused capacity of the vector is copied over to the new
                     // allocation, so we need to ensure that we don't have any data we
                     // care about in the unused capacity before calling `reserve`.
-                    debug_assert!(off + len <= v.capacity());
-                    v.set_len(off + len);
+                    debug_assert!(offset + len <= v.capacity());
+                    v.set_len(offset + len);
                     v.reserve(new_cap - v.len());
 
                     // Update the info
-                    self.ptr = vptr(v.as_mut_ptr().add(off));
-                    self.cap = v.capacity() - off;
+                    self.ptr = vptr(v.as_mut_ptr().add(offset));
+                    self.cap = v.capacity() - offset;
                 }
 
                 return true;
diff --git a/vendor/bytes-1.10.0/tests/test_bytes.rs b/vendor/bytes-1.10.0/tests/test_bytes.rs
index c283a8081..d0f1f4ac9 100644
--- a/vendor/bytes-1.10.0/tests/test_bytes.rs
+++ b/vendor/bytes-1.10.0/tests/test_bytes.rs
@@ -1634,3 +1634,16 @@ fn owned_safe_drop_on_as_ref_panic() {
     assert!(result.is_err());
     assert_eq!(drop_counter.get(), 1);
 }
+
+#[test]
+#[should_panic]
+fn bytes_mut_reserve_overflow() {
+    let mut a = BytesMut::from(&b"hello world"[..]);
+    let mut b = a.split_off(5);
+    // Ensure b becomes the unique owner of the backing storage
+    drop(a);
+    // Trigger overflow in new_cap + offset inside reserve
+    b.reserve(usize::MAX - 6);
+    // This call relies on the corrupted cap and may cause UB & HBO
+    b.put_u8(b'h');
+}
-- 
2.45.4

