From d0293b0e35838123c51ca5dfdf468ecafee4398f Mon Sep 17 00:00:00 2001
From: Alice Ryhl <aliceryhl@google.com>
Date: Tue, 3 Feb 2026 14:40:22 +0100
Subject: [PATCH] Merge commit from fork

* Add repro for integer overflow

Signed-off-by: Alice Ryhl <aliceryhl@google.com>

* Always check overflow in new_cap + offset

Signed-off-by: Alice Ryhl <aliceryhl@google.com>

Upstream Patch reference: https://github.com/tokio-rs/bytes/commit/d0293b0e35838123c51ca5dfdf468ecafee4398f.patch
---
 vendor/bytes-1.10.0/ci/miri.sh          |  3 +++
 vendor/bytes-1.10.0/src/bytes_mut.rs    | 20 ++++++++++++--------
 vendor/bytes-1.10.0/tests/test_bytes.rs | 13 +++++++++++++
 3 files changed, 28 insertions(+), 8 deletions(-)

diff --git a/vendor/bytes-1.10.0/ci/miri.sh b/vendor/bytes-1.10.0/ci/miri.sh
index 7df29f360..ca7f41df5 100755
--- a/vendor/bytes-1.10.0/ci/miri.sh
+++ b/vendor/bytes-1.10.0/ci/miri.sh
@@ -8,3 +8,6 @@ export MIRIFLAGS="-Zmiri-strict-provenance"
 
 cargo miri test
 cargo miri test --target mips64-unknown-linux-gnuabi64
+
+# run with wrapping integer overflow instead of panic
+cargo miri test --release
diff --git a/vendor/bytes-1.10.0/src/bytes_mut.rs b/vendor/bytes-1.10.0/src/bytes_mut.rs
index d5db5124b..3026b302a 100644
--- a/vendor/bytes-1.10.0/src/bytes_mut.rs
+++ b/vendor/bytes-1.10.0/src/bytes_mut.rs
@@ -696,9 +696,15 @@ impl BytesMut {
 
                 let offset = offset_from(self.ptr.as_ptr(), ptr);
 
+                let new_cap_plus_offset = match new_cap.checked_add(offset) {
+                    Some(new_cap_plus_offset) => new_cap_plus_offset,
+                    None if !allocate => return false,
+                    None => panic!("overflow"),
+                };
+
                 // Compare the condition in the `kind == KIND_VEC` case above
                 // for more details.
-                if v_capacity >= new_cap + offset {
+                if v_capacity >= new_cap_plus_offset {
                     self.cap = new_cap;
                     // no copy is necessary
                 } else if v_capacity >= new_cap && offset >= len {
@@ -714,14 +720,12 @@ impl BytesMut {
                     if !allocate {
                         return false;
                     }
-                    // calculate offset
-                    let off = (self.ptr.as_ptr() as usize) - (v.as_ptr() as usize);
 
                     // new_cap is calculated in terms of `BytesMut`, not the underlying
                     // `Vec`, so it does not take the offset into account.
                     //
                     // Thus we have to manually add it here.
-                    new_cap = new_cap.checked_add(off).expect("overflow");
+                    new_cap = new_cap_plus_offset;
 
                     // The vector capacity is not sufficient. The reserve request is
                     // asking for more than the initial buffer capacity. Allocate more
@@ -743,13 +747,13 @@ impl BytesMut {
                     // the unused capacity of the vector is copied over to the new
                     // allocation, so we need to ensure that we don't have any data we
                     // care about in the unused capacity before calling `reserve`.
-                    debug_assert!(off + len <= v.capacity());
-                    v.set_len(off + len);
+                    debug_assert!(offset + len <= v.capacity());
+                    v.set_len(offset + len);
                     v.reserve(new_cap - v.len());
 
                     // Update the info
-                    self.ptr = vptr(v.as_mut_ptr().add(off));
-                    self.cap = v.capacity() - off;
+                    self.ptr = vptr(v.as_mut_ptr().add(offset));
+                    self.cap = v.capacity() - offset;
                 }
 
                 return true;
diff --git a/vendor/bytes-1.10.0/tests/test_bytes.rs b/vendor/bytes-1.10.0/tests/test_bytes.rs
index c283a8081..d0f1f4ac9 100644
--- a/vendor/bytes-1.10.0/tests/test_bytes.rs
+++ b/vendor/bytes-1.10.0/tests/test_bytes.rs
@@ -1634,3 +1634,16 @@ fn owned_safe_drop_on_as_ref_panic() {
     assert!(result.is_err());
     assert_eq!(drop_counter.get(), 1);
 }
+
+#[test]
+#[should_panic]
+fn bytes_mut_reserve_overflow() {
+    let mut a = BytesMut::from(&b"hello world"[..]);
+    let mut b = a.split_off(5);
+    // Ensure b becomes the unique owner of the backing storage
+    drop(a);
+    // Trigger overflow in new_cap + offset inside reserve
+    b.reserve(usize::MAX - 6);
+    // This call relies on the corrupted cap and may cause UB & HBO
+    b.put_u8(b'h');
+}
-- 
2.45.4

