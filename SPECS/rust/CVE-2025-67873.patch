From 4a1544ca83deea3cc24b31f5a675444b253deeec Mon Sep 17 00:00:00 2001
From: Archana Shettigar <v-shettigara@microsoft.com>
Date: Mon, 26 Jan 2026 16:46:54 +0530
Subject: [PATCH] Address CVE-2025-67873

---
 vendor/capstone-sys-0.17.0/capstone/cs.c | 55 ++++++++++++++----------
 1 file changed, 33 insertions(+), 22 deletions(-)

diff --git a/vendor/capstone-sys-0.17.0/capstone/cs.c b/vendor/capstone-sys-0.17.0/capstone/cs.c
index 3c337e8cb..75ae432be 100644
--- a/vendor/capstone-sys-0.17.0/capstone/cs.c
+++ b/vendor/capstone-sys-0.17.0/capstone/cs.c
@@ -1,9 +1,7 @@
 /* Capstone Disassembly Engine */
 /* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2019 */
-#if defined (WIN32) || defined (WIN64) || defined (_WIN32) || defined (_WIN64)
-#pragma warning(disable:4996)			// disable MSVC's warning on strcpy()
-#pragma warning(disable:28719)		// disable MSVC's warning on strcpy()
-#endif
+
+#include "SStream.h"
 #if defined(CAPSTONE_HAS_OSXKERNEL)
 #include <Availability.h>
 #include <libkern/libkern.h>
@@ -764,6 +762,9 @@ cs_err CAPSTONE_API cs_option(csh ud, cs_opt_type type, size_t value)
 							cs_mem_free(tmp);
 							break;
 						}
+						/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2019 */
+
+						#include "SStream.h"
 						prev = tmp;
 						tmp = tmp->next;
 					}
@@ -938,17 +939,22 @@ size_t CAPSTONE_API cs_disasm(csh ud, const uint8_t *buffer, size_t size, uint64
 				skipdata_bytes = handle->skipdata_size;
 
 			// we have to skip some amount of data, depending on arch & mode
-			insn_cache->id = 0;	// invalid ID for this "data" instruction
+			// invalid ID for this "data" instruction
+			insn_cache->id = 0;
 			insn_cache->address = offset;
-			insn_cache->size = (uint16_t)skipdata_bytes;
-			memcpy(insn_cache->bytes, buffer, skipdata_bytes);
+			insn_cache->size = (uint16_t)MIN(
+				skipdata_bytes, sizeof(insn_cache->bytes));
+			memcpy(insn_cache->bytes, buffer,
+			       MIN(skipdata_bytes, sizeof(insn_cache->bytes)));
 #ifdef CAPSTONE_DIET
 			insn_cache->mnemonic[0] = '\0';
 			insn_cache->op_str[0] = '\0';
 #else
-			strncpy(insn_cache->mnemonic, handle->skipdata_setup.mnemonic,
-					sizeof(insn_cache->mnemonic) - 1);
-			skipdata_opstr(insn_cache->op_str, buffer, skipdata_bytes);
+			strncpy(insn_cache->mnemonic,
+				handle->skipdata_setup.mnemonic,
+				sizeof(insn_cache->mnemonic) - 1);
+			skipdata_opstr(insn_cache->op_str, buffer,
+				       skipdata_bytes);
 #endif
 			insn_cache->detail = NULL;
 
@@ -970,7 +976,7 @@ size_t CAPSTONE_API cs_disasm(csh ud, const uint8_t *buffer, size_t size, uint64
 			total_size += (sizeof(cs_insn) * cache_size);
 			tmp = cs_mem_realloc(total, total_size);
 			if (tmp == NULL) {	// insufficient memory
-				if (handle->detail) {
+				if (handle->detail_opt) {
 					insn_cache = (cs_insn *)total;
 					for (i = 0; i < c; i++, insn_cache++)
 						cs_mem_free(insn_cache->detail);
@@ -984,9 +990,10 @@ size_t CAPSTONE_API cs_disasm(csh ud, const uint8_t *buffer, size_t size, uint64
 
 			total = tmp;
 			// continue to fill in the cache after the last instruction
-			insn_cache = (cs_insn *)((char *)total + sizeof(cs_insn) * c);
+			insn_cache = (cs_insn *)((char *)total + 
+					sizeof(cs_insn) * c);
 
-			// reset f back to 0, so we fill in the cache from begining
+			// reset f back to 0, so we fill in the cache from beginning
 			f = 0;
 		} else
 			insn_cache++;
@@ -1002,10 +1009,12 @@ size_t CAPSTONE_API cs_disasm(csh ud, const uint8_t *buffer, size_t size, uint64
 		total = NULL;
 	} else if (f != cache_size) {
 		// total did not fully use the last cache, so downsize it
-		tmp = cs_mem_realloc(total, total_size - (cache_size - f) * sizeof(*insn_cache));
-		if (tmp == NULL) {	// insufficient memory
+		tmp = cs_mem_realloc(total,
+				     total_size - (cache_size - f) *
+							  sizeof(*insn_cache));
+		if (tmp == NULL) { // insufficient memory
 			// free all detail pointers
-			if (handle->detail) {
+			if (handle->detail_opt) {
 				insn_cache = (cs_insn *)total;
 				for (i = 0; i < c; i++, insn_cache++)
 					cs_mem_free(insn_cache->detail);
@@ -1051,7 +1060,7 @@ cs_insn * CAPSTONE_API cs_malloc(csh ud)
 		handle->errnum = CS_ERR_MEM;
 		return NULL;
 	} else {
-		if (handle->detail) {
+		if (handle->detail_opt) {
 			// allocate memory for @detail pointer
 			insn->detail = cs_mem_malloc(sizeof(cs_detail));
 			if (insn->detail == NULL) {	// insufficient memory
@@ -1128,8 +1137,9 @@ bool CAPSTONE_API cs_disasm_iter(csh ud, const uint8_t **code, size_t *size,
 			return false;
 
 		if (handle->skipdata_setup.callback) {
-			skipdata_bytes = handle->skipdata_setup.callback(*code, *size,
-					0, handle->skipdata_setup.user_data);
+			skipdata_bytes = handle->skipdata_setup.callback(
+				*code, *size, 0,
+				handle->skipdata_setup.user_data);
 			if (skipdata_bytes > *size)
 				// remaining data is not enough
 				return false;
@@ -1143,14 +1153,15 @@ bool CAPSTONE_API cs_disasm_iter(csh ud, const uint8_t **code, size_t *size,
 		// we have to skip some amount of data, depending on arch & mode
 		insn->id = 0;	// invalid ID for this "data" instruction
 		insn->address = *address;
-		insn->size = (uint16_t)skipdata_bytes;
+		insn->size = (uint16_t)MIN(skipdata_bytes, sizeof(insn->bytes));
+		memcpy(insn->bytes, *code,
+		       MIN(skipdata_bytes, sizeof(insn->bytes)));
 #ifdef CAPSTONE_DIET
 		insn->mnemonic[0] = '\0';
 		insn->op_str[0] = '\0';
 #else
-		memcpy(insn->bytes, *code, skipdata_bytes);
 		strncpy(insn->mnemonic, handle->skipdata_setup.mnemonic,
-				sizeof(insn->mnemonic) - 1);
+			sizeof(insn->mnemonic) - 1);
 		skipdata_opstr(insn->op_str, *code, skipdata_bytes);
 #endif
 
-- 
2.45.4

