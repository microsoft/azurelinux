From d0293b0e35838123c51ca5dfdf468ecafee4398f Mon Sep 17 00:00:00 2001
From: Alice Ryhl <aliceryhl@google.com>
Date: Tue, 3 Feb 2026 14:40:22 +0100
Subject: [PATCH] Merge commit from fork

* Add repro for integer overflow

Signed-off-by: Alice Ryhl <aliceryhl@google.com>

* Always check overflow in new_cap + offset

Signed-off-by: Alice Ryhl <aliceryhl@google.com>

Upstream Patch reference: https://github.com/tokio-rs/bytes/commit/d0293b0e35838123c51ca5dfdf468ecafee4398f.patch
---
 vendor/bytes/ci/miri.sh          |  3 +++
 vendor/bytes/src/bytes_mut.rs    | 23 +++++++++++++++--------
 vendor/bytes/tests/test_bytes.rs | 13 +++++++++++++
 3 files changed, 31 insertions(+), 8 deletions(-)

diff --git a/vendor/bytes/ci/miri.sh b/vendor/bytes/ci/miri.sh
index 0158756cd..161d581ea 100755
--- a/vendor/bytes/ci/miri.sh
+++ b/vendor/bytes/ci/miri.sh
@@ -9,3 +9,6 @@ export MIRIFLAGS="-Zmiri-strict-provenance"
 
 cargo miri test
 cargo miri test --target mips64-unknown-linux-gnuabi64
+
+# run with wrapping integer overflow instead of panic
+cargo miri test --release
diff --git a/vendor/bytes/src/bytes_mut.rs b/vendor/bytes/src/bytes_mut.rs
index 70613b224..55797d3cc 100644
--- a/vendor/bytes/src/bytes_mut.rs
+++ b/vendor/bytes/src/bytes_mut.rs
@@ -668,9 +668,15 @@ impl BytesMut {
 
                 let offset = offset_from(self.ptr.as_ptr(), ptr);
 
+                let new_cap_plus_offset = match new_cap.checked_add(offset) {
+                    Some(new_cap_plus_offset) => new_cap_plus_offset,
+                    None if !allocate => return false,
+                    None => panic!("overflow"),
+                };
+
                 // Compare the condition in the `kind == KIND_VEC` case above
                 // for more details.
-                if v_capacity >= new_cap + offset {
+                if v_capacity >= new_cap_plus_offset {
                     self.cap = new_cap;
                     // no copy is necessary
                 } else if v_capacity >= new_cap && offset >= len {
@@ -683,14 +689,15 @@ impl BytesMut {
                     self.ptr = vptr(ptr);
                     self.cap = v.capacity();
                 } else {
-                    // calculate offset
-                    let off = (self.ptr.as_ptr() as usize) - (v.as_ptr() as usize);
+                    if !allocate {
+                        return false;
+                    }
 
                     // new_cap is calculated in terms of `BytesMut`, not the underlying
                     // `Vec`, so it does not take the offset into account.
                     //
                     // Thus we have to manually add it here.
-                    new_cap = new_cap.checked_add(off).expect("overflow");
+                    new_cap = new_cap_plus_offset;
 
                     // The vector capacity is not sufficient. The reserve request is
                     // asking for more than the initial buffer capacity. Allocate more
@@ -712,13 +719,13 @@ impl BytesMut {
                     // the unused capacity of the vector is copied over to the new
                     // allocation, so we need to ensure that we don't have any data we
                     // care about in the unused capacity before calling `reserve`.
-                    debug_assert!(off + len <= v.capacity());
-                    v.set_len(off + len);
+                    debug_assert!(offset + len <= v.capacity());
+                    v.set_len(offset + len);
                     v.reserve(new_cap - v.len());
 
                     // Update the info
-                    self.ptr = vptr(v.as_mut_ptr().add(off));
-                    self.cap = v.capacity() - off;
+                    self.ptr = vptr(v.as_mut_ptr().add(offset));
+                    self.cap = v.capacity() - offset;
                 }
 
                 return;
diff --git a/vendor/bytes/tests/test_bytes.rs b/vendor/bytes/tests/test_bytes.rs
index 5ec60a5b0..5f81ea364 100644
--- a/vendor/bytes/tests/test_bytes.rs
+++ b/vendor/bytes/tests/test_bytes.rs
@@ -1208,3 +1208,16 @@ fn test_bytes_capacity_len() {
         }
     }
 }
+
+#[test]
+#[should_panic]
+fn bytes_mut_reserve_overflow() {
+    let mut a = BytesMut::from(&b"hello world"[..]);
+    let mut b = a.split_off(5);
+    // Ensure b becomes the unique owner of the backing storage
+    drop(a);
+    // Trigger overflow in new_cap + offset inside reserve
+    b.reserve(usize::MAX - 6);
+    // This call relies on the corrupted cap and may cause UB & HBO
+    b.put_u8(b'h');
+}
-- 
2.45.4

