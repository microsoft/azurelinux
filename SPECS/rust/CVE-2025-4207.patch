From ec5f89e8a29f32c7dbc4dd8734ed8406d771de2f Mon Sep 17 00:00:00 2001
From: Noah Misch <noah@leadboat.com>
Date: Mon, 5 May 2025 04:52:04 -0700
Subject: [PATCH] With GB18030, prevent SIGSEGV from reading past end of
 allocation.

With GB18030 as source encoding, applications could crash the server via
SQL functions convert() or convert_from().  Applications themselves
could crash after passing unterminated GB18030 input to libpq functions
PQescapeLiteral(), PQescapeIdentifier(), PQescapeStringConn(), or
PQescapeString().  Extension code could crash by passing unterminated
GB18030 input to jsonapi.h functions.  All those functions have been
intended to handle untrusted, unterminated input safely.

A crash required allocating the input such that the last byte of the
allocation was the last byte of a virtual memory page.  Some malloc()
implementations take measures against that, making the SIGSEGV hard to
reach.  Back-patch to v13 (all supported versions).

Author: Noah Misch <noah@leadboat.com>
Author: Andres Freund <andres@anarazel.de>
Reviewed-by: Masahiko Sawada <sawada.mshk@gmail.com>
Backpatch-through: 13
Security: CVE-2025-4207

Upstream Reference Patch: https://git.postgresql.org/gitweb/?p=postgresql.git;a=patch;h=ec5f89e8a29f32c7dbc4dd8734ed8406d771de2f

---
 .../source/src/common/jsonapi.c               |  7 ++-
 .../source/src/common/wchar.c                 | 51 ++++++++++++++++---
 .../source/src/include/mb/pg_wchar.h          |  2 +
 .../source/src/interfaces/libpq/fe-exec.c     |  6 ++-
 .../source/src/interfaces/libpq/fe-misc.c     | 15 +++---
 5 files changed, 62 insertions(+), 19 deletions(-)

diff --git a/vendor/pq-src-0.3.6+libpq-17.4/source/src/common/jsonapi.c b/vendor/pq-src-0.3.6+libpq-17.4/source/src/common/jsonapi.c
index 2527dbe1d..cd34986d1 100644
--- a/vendor/pq-src-0.3.6+libpq-17.4/source/src/common/jsonapi.c
+++ b/vendor/pq-src-0.3.6+libpq-17.4/source/src/common/jsonapi.c
@@ -1689,8 +1689,11 @@ json_lex_string(JsonLexContext *lex)
 	} while (0)
 #define FAIL_AT_CHAR_END(code) \
 	do { \
-		const char	   *term = s + pg_encoding_mblen(lex->input_encoding, s); \
-		lex->token_terminator = (term <= end) ? term : end; \
+		ptrdiff_t	remaining = end - s; \
+		int			charlen; \
+		charlen = pg_encoding_mblen_or_incomplete(lex->input_encoding, \
+												  s, remaining); \
+		lex->token_terminator = (charlen <= remaining) ? s + charlen : end; \
 		return code; \
 	} while (0)
 
diff --git a/vendor/pq-src-0.3.6+libpq-17.4/source/src/common/wchar.c b/vendor/pq-src-0.3.6+libpq-17.4/source/src/common/wchar.c
index 40588beb4..402ad281e 100644
--- a/vendor/pq-src-0.3.6+libpq-17.4/source/src/common/wchar.c
+++ b/vendor/pq-src-0.3.6+libpq-17.4/source/src/common/wchar.c
@@ -12,6 +12,8 @@
  */
 #include "c.h"
 
+#include <limits.h>
+
 #include "mb/pg_wchar.h"
 #include "utils/ascii.h"
 
@@ -2107,10 +2109,27 @@ const pg_wchar_tbl pg_wchar_table[] = {
 /*
  * Returns the byte length of a multibyte character.
  *
- * Caution: when dealing with text that is not certainly valid in the
- * specified encoding, the result may exceed the actual remaining
- * string length.  Callers that are not prepared to deal with that
- * should use pg_encoding_mblen_bounded() instead.
+ * Choose "mblen" functions based on the input string characteristics.
+ * pg_encoding_mblen() can be used when ANY of these conditions are met:
+ *
+ * - The input string is zero-terminated
+ *
+ * - The input string is known to be valid in the encoding (e.g., string
+ *   converted from database encoding)
+ *
+ * - The encoding is not GB18030 (e.g., when only database encodings are
+ *   passed to 'encoding' parameter)
+ *
+ * encoding==GB18030 requires examining up to two bytes to determine character
+ * length.  Therefore, callers satisfying none of those conditions must use
+ * pg_encoding_mblen_or_incomplete() instead, as access to mbstr[1] cannot be
+ * guaranteed to be within allocation bounds.
+ *
+ * When dealing with text that is not certainly valid in the specified
+ * encoding, the result may exceed the actual remaining string length.
+ * Callers that are not prepared to deal with that should use Min(remaining,
+ * pg_encoding_mblen_or_incomplete()).  For zero-terminated strings, that and
+ * pg_encoding_mblen_bounded() are interchangeable.
  */
 int
 pg_encoding_mblen(int encoding, const char *mbstr)
@@ -2121,8 +2140,28 @@ pg_encoding_mblen(int encoding, const char *mbstr)
 }
 
 /*
- * Returns the byte length of a multibyte character; but not more than
- * the distance to end of string.
+ * Returns the byte length of a multibyte character (possibly not
+ * zero-terminated), or INT_MAX if too few bytes remain to determine a length.
+ */
+int
+pg_encoding_mblen_or_incomplete(int encoding, const char *mbstr,
+								size_t remaining)
+{
+	/*
+	 * Define zero remaining as too few, even for single-byte encodings.
+	 * pg_gb18030_mblen() reads one or two bytes; single-byte encodings read
+	 * zero; others read one.
+	 */
+	if (remaining < 1 ||
+		(encoding == PG_GB18030 && IS_HIGHBIT_SET(*mbstr) && remaining < 2))
+		return INT_MAX;
+	return pg_encoding_mblen(encoding, mbstr);
+}
+
+/*
+ * Returns the byte length of a multibyte character; but not more than the
+ * distance to the terminating zero byte.  For input that might lack a
+ * terminating zero, use Min(remaining, pg_encoding_mblen_or_incomplete()).
  */
 int
 pg_encoding_mblen_bounded(int encoding, const char *mbstr)
diff --git a/vendor/pq-src-0.3.6+libpq-17.4/source/src/include/mb/pg_wchar.h b/vendor/pq-src-0.3.6+libpq-17.4/source/src/include/mb/pg_wchar.h
index 08f6fa6e0..e5babf3e3 100644
--- a/vendor/pq-src-0.3.6+libpq-17.4/source/src/include/mb/pg_wchar.h
+++ b/vendor/pq-src-0.3.6+libpq-17.4/source/src/include/mb/pg_wchar.h
@@ -664,6 +664,8 @@ extern int	pg_valid_server_encoding_id(int encoding);
  */
 extern void pg_encoding_set_invalid(int encoding, char *dst);
 extern int	pg_encoding_mblen(int encoding, const char *mbstr);
+extern int	pg_encoding_mblen_or_incomplete(int encoding, const char *mbstr,
+											size_t remaining);
 extern int	pg_encoding_mblen_bounded(int encoding, const char *mbstr);
 extern int	pg_encoding_dsplen(int encoding, const char *mbstr);
 extern int	pg_encoding_verifymbchar(int encoding, const char *mbstr, int len);
diff --git a/vendor/pq-src-0.3.6+libpq-17.4/source/src/interfaces/libpq/fe-exec.c b/vendor/pq-src-0.3.6+libpq-17.4/source/src/interfaces/libpq/fe-exec.c
index cb55b9864..91063b159 100644
--- a/vendor/pq-src-0.3.6+libpq-17.4/source/src/interfaces/libpq/fe-exec.c
+++ b/vendor/pq-src-0.3.6+libpq-17.4/source/src/interfaces/libpq/fe-exec.c
@@ -4101,7 +4101,8 @@ PQescapeStringInternal(PGconn *conn,
 		}
 
 		/* Slow path for possible multibyte characters */
-		charlen = pg_encoding_mblen(encoding, source);
+		charlen = pg_encoding_mblen_or_incomplete(encoding,
+												  source, remaining);
 
 		if (remaining < charlen ||
 			pg_encoding_verifymbchar(encoding, source, charlen) == -1)
@@ -4245,7 +4246,8 @@ PQescapeInternal(PGconn *conn, const char *str, size_t len, bool as_ident)
 			int			charlen;
 
 			/* Slow path for possible multibyte characters */
-			charlen = pg_encoding_mblen(conn->client_encoding, s);
+			charlen = pg_encoding_mblen_or_incomplete(conn->client_encoding,
+													  s, remaining);
 
 			if (charlen > remaining)
 			{
diff --git a/vendor/pq-src-0.3.6+libpq-17.4/source/src/interfaces/libpq/fe-misc.c b/vendor/pq-src-0.3.6+libpq-17.4/source/src/interfaces/libpq/fe-misc.c
index f235bfbb4..c76a9878c 100644
--- a/vendor/pq-src-0.3.6+libpq-17.4/source/src/interfaces/libpq/fe-misc.c
+++ b/vendor/pq-src-0.3.6+libpq-17.4/source/src/interfaces/libpq/fe-misc.c
@@ -1197,13 +1197,9 @@ PQgetCurrentTimeUSec(void)
  */
 
 /*
- * Returns the byte length of the character beginning at s, using the
- * specified encoding.
- *
- * Caution: when dealing with text that is not certainly valid in the
- * specified encoding, the result may exceed the actual remaining
- * string length.  Callers that are not prepared to deal with that
- * should use PQmblenBounded() instead.
+ * Like pg_encoding_mblen().  Use this in callers that want the
+ * dynamically-linked libpq's stance on encodings, even if that means
+ * different behavior in different startups of the executable.
  */
 int
 PQmblen(const char *s, int encoding)
@@ -1212,8 +1208,9 @@ PQmblen(const char *s, int encoding)
 }
 
 /*
- * Returns the byte length of the character beginning at s, using the
- * specified encoding; but not more than the distance to end of string.
+ * Like pg_encoding_mblen_bounded().  Use this in callers that want the
+ * dynamically-linked libpq's stance on encodings, even if that means
+ * different behavior in different startups of the executable.
  */
 int
 PQmblenBounded(const char *s, int encoding)
-- 
2.45.4

