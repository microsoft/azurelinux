From ac92d9bb729ad3a6d93f0724c4c33a0c4a9c0227 Mon Sep 17 00:00:00 2001
From: Chris Fallin <chris@cfallin.org>
Date: Mon, 26 Jan 2026 13:44:45 -0800
Subject: [PATCH] [36.0] Backport Cranelift: x64: fix incorrect load-sinking in
 `copysign` operator. (#12438)

* Cranelift: x64: do not incorrectly widen loads sunk into `fcopysign`.

The implementation of the `fcopysign` operator uses vector bitwise AND
instructions on the floating-point/vector registers containing the
inputs to the operator. This is a reasonable implementation as the
instruction set does not have scalar (single-lane) bitwise
operators. However, when load-sinking automatically kicks in for an
operand to an `andps`, it can turn a 64-bit load (`f64.load`) into a
128-bit load incorrectly.

This load-widening can cause out-of-bounds accesses where they were
not expected. When dynamic bounds checks are enabled, we compile
assuming the correct load-operator width is codegen'd; a too-wide load
could read beyond the checked bound, either into unmapped
memory (crashing the process) or, worse, valid data outside the
sandbox. In the case of `fcopysign` the result of that read is not
directly available, because it will go into the high (unused)
lane, but the out-of-bounds read itself is a problem.

Thanks to louismerlin for reporting!

* Re-bless Cranelift filetests.
Upstream Patch Reference: https://github.com/bytecodealliance/wasmtime/commit/ac92d9bb729ad3a6d93f0724c4c33a0c4a9c0227.patch
---
 .../cranelift-codegen-0.119.0/src/isa/x64/lower.isle      | 8 ++++++--
 vendor/cranelift-codegen-0.121.0/src/isa/x64/lower.isle   | 8 ++++++--
 2 files changed, 12 insertions(+), 4 deletions(-)

diff --git a/src/tools/rustc-perf/collector/compile-benchmarks/cranelift-codegen-0.119.0/src/isa/x64/lower.isle b/src/tools/rustc-perf/collector/compile-benchmarks/cranelift-codegen-0.119.0/src/isa/x64/lower.isle
index 02e8479bf..d952e33fc 100644
--- a/src/tools/rustc-perf/collector/compile-benchmarks/cranelift-codegen-0.119.0/src/isa/x64/lower.isle
+++ b/src/tools/rustc-perf/collector/compile-benchmarks/cranelift-codegen-0.119.0/src/isa/x64/lower.isle
@@ -4225,13 +4225,17 @@
 ;; Rules for `fcopysign` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
 (rule (lower (has_type $F32 (fcopysign a @ (value_type $F32) b)))
-      (let ((sign_bit Xmm (imm $F32 0x80000000)))
+      (let ((sign_bit Xmm (imm $F32 0x80000000))
+            (a Xmm a) ;; force into reg so we don't sink a 128-bit load.
+            (b Xmm b))
         (x64_orps
           (x64_andnps sign_bit a)
           (x64_andps sign_bit b))))
 
 (rule (lower (has_type $F64 (fcopysign a @ (value_type $F64) b)))
-      (let ((sign_bit Xmm (imm $F64 0x8000000000000000)))
+      (let ((sign_bit Xmm (imm $F64 0x8000000000000000))
+            (a Xmm a) ;; force into reg so we don't sink a 128-bit load.
+            (b Xmm b))
         (x64_orpd
           (x64_andnpd sign_bit a)
           (x64_andpd sign_bit b))))
diff --git a/vendor/cranelift-codegen-0.121.0/src/isa/x64/lower.isle b/vendor/cranelift-codegen-0.121.0/src/isa/x64/lower.isle
index 58263912a..611b3a81c 100644
--- a/vendor/cranelift-codegen-0.121.0/src/isa/x64/lower.isle
+++ b/vendor/cranelift-codegen-0.121.0/src/isa/x64/lower.isle
@@ -4284,13 +4284,17 @@
 ;; Rules for `fcopysign` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
 (rule (lower (has_type $F32 (fcopysign a @ (value_type $F32) b)))
-      (let ((sign_bit Xmm (imm $F32 0x80000000)))
+      (let ((sign_bit Xmm (imm $F32 0x80000000))
+            (a Xmm a) ;; force into reg so we don't sink a 128-bit load.
+            (b Xmm b))
         (x64_orps
           (x64_andnps sign_bit a)
           (x64_andps sign_bit b))))
 
 (rule (lower (has_type $F64 (fcopysign a @ (value_type $F64) b)))
-      (let ((sign_bit Xmm (imm $F64 0x8000000000000000)))
+      (let ((sign_bit Xmm (imm $F64 0x8000000000000000))
+            (a Xmm a) ;; force into reg so we don't sink a 128-bit load.
+            (b Xmm b))
         (x64_orpd
           (x64_andnpd sign_bit a)
           (x64_andpd sign_bit b))))
-- 
2.45.4

