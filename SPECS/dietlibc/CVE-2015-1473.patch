From 3e76f9036b2845c988969cfeaefa6b5bd236185f Mon Sep 17 00:00:00 2001
From: jykanase <v-jykanase@microsoft.com>
Date: Mon, 17 Feb 2025 10:11:29 +0000
Subject: [PATCH] CVE-2015-1473

Source Link: https://sourceware.org/git/?p=glibc.git;a=patch;h=5bd80bfe9ca0d955bfbbc002781bc7b01b6bcb06
---
 test/stdio/tst-sscanf.c | 32 ++++++++++++++++++++++++++++++++
 1 file changed, 32 insertions(+)

diff --git a/test/stdio/tst-sscanf.c b/test/stdio/tst-sscanf.c
index 3ec5a28..3472ff2 100644
--- a/test/stdio/tst-sscanf.c
+++ b/test/stdio/tst-sscanf.c
@@ -118,6 +118,38 @@ main (void)
       if (! tst_locale)
 	break;
     }
+   
+   /* BZ #16618
+   The test will segfault during SSCANF if the buffer overflow
+   is not fixed. The size of `s` is such that it forces the use
+   of malloc internally and this triggers the incorrect computation.
+   Thus the value for SIZE is arbitrarily high enough that malloc
+   is used. */
+   {
+    #define SIZE 131072
+    CHAR *s = malloc((SIZE + 1) * sizeof(*s));
+    if (s == NULL)
+        abort();
 
+    for (size_t i = 0; i < SIZE; i++)
+        s[i] = L('0');
+    s[SIZE] = L('\0');
+
+    int i = 42;
+    /* Scan multi-digit zero into `i`. */
+    if (SSCANF(s, L("%d"), &i) != 1) {
+        printf("FAIL: bug16618: SSCANF did not read one input item.\n");
+        result = 1;
+    }
+    if (i != 0) {
+        printf("FAIL: bug16618: Value of `i` was not zero as expected.\n");
+        result = 1;
+    }
+
+    free(s);
+    if (result != 1)
+        printf("PASS: bug16618: Did not crash.\n");
+    #undef SIZE
+   }
   return result;
 }
-- 
2.45.2

