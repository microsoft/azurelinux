From 64c8f32b0349c33fb8382784af468338078851f9 Mon Sep 17 00:00:00 2001
From: Hannes von Haugwitz <hannes@vonhaugwitz.com>
Date: Thu, 7 Aug 2025 18:04:41 +0200
Subject: [PATCH] Escape control characters in report and log output

* this addresses CVE-2025-54389
* thanks to Rajesh Pangare for reporting this issue

Upstream Patch Reference: https://git.rockylinux.org/staging/rpms/aide/-/blob/r9/SOURCES/aide-0.16-CVE-2025-54389.patch
---
 ChangeLog        |  5 ++-
 doc/aide.1.in    | 10 ++++++
 include/util.h   |  3 ++
 src/aide.c       | 18 +++++++---
 src/compare_db.c | 86 ++++++++++++++++++++++++++++++++++++++----------
 src/db_disk.c    | 31 ++++++++++++-----
 src/db_sql.c     |  7 +++-
 src/do_md.c      | 45 ++++++++++++++++++++-----
 src/gen_list.c   | 45 ++++++++++++++++++++-----
 src/util.c       | 47 ++++++++++++++++++++++++--
 10 files changed, 247 insertions(+), 50 deletions(-)

diff --git a/ChangeLog b/ChangeLog
index 263c438..5d286a8 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,5 +1,8 @@
+2025-08-07 Hannes von Haugwitz <hannes@vonhaugwitz.com>
+        * Escape control characters in report and log output (CVE-2025-54389)
+
 2016-07-25 Hannes von Haugwitz <hannes@vonhaugwitz.com>
-	* Release version 0.16
+        * Release version 0.16
 
 2016-07-11 Hannes von Haugwitz <hannes@vonhaugwitz.com>
 	* Fix example aide.conf (xattr -> xattrs)
diff --git a/doc/aide.1.in b/doc/aide.1.in
index 932810e..e932b8d 100644
--- a/doc/aide.1.in
+++ b/doc/aide.1.in
@@ -93,12 +93,22 @@ conditions:
 Please note that due to mmap issues, aide cannot be terminated with
 SIGTERM. Use SIGKILL to terminate.
 
+.IP "Checksum encoding"
+
 The checksums in the database and in the output are by default base64
 encoded (see also report_base16 option).
 To decode them you can use the following shell command:
 
 echo <encoded_checksum> | base64 \-d | hexdump \-v \-e '32/1 "%02x" "\\n"'
 
+.IP "Control characters"
+
+Control characters (00-31 and 127) are always escaped in log and plain report
+output. They are escaped by a literal backslash (\\) followed by exactly 3
+digits representing the character in octal notation (e.g. a newline is output
+as "\\012"). A literal backslash is not escaped unless it is followed by 3 digits
+(0-9), in this case the literal backslash is escaped as "\\134".
+
 .PP
 .SH FILES
 .IP \fB@sysconfdir@/aide.conf\fR
diff --git a/include/util.h b/include/util.h
index 7998853..68e6ee2 100644
--- a/include/util.h
+++ b/include/util.h
@@ -44,6 +44,9 @@ url_t* parse_url(char*);
 
 int contains_unsafe(const char*);
 
+char *strnesc(const char *, size_t);
+char *stresc(const char *);
+
 void decode_string(char*);
 
 char* encode_string(const char*);
diff --git a/src/aide.c b/src/aide.c
index 8dd38b7..2b7eee1 100644
--- a/src/aide.c
+++ b/src/aide.c
@@ -186,10 +186,16 @@ static int read_param(int argc,char**argv)
                 conf->limit=malloc(strlen(optarg)+1);
                 strcpy(conf->limit,optarg);
                 if((conf->limit_crx=pcre_compile(conf->limit, PCRE_ANCHORED, &pcre_error, &pcre_erroffset, NULL)) == NULL) {
-                    error(0,_("Error in limit regexp '%s' at %i: %s\n"), conf->limit, pcre_erroffset, pcre_error);
+                    char *limit_safe = stresc(conf->limit);
+                    error(0,_("Error in limit regexp '%s' at %i: %s\n"), limit_safe, pcre_erroffset, pcre_error);
+                    free(limit_safe);
                     exit(INVALID_ARGUMENT_ERROR);
                 }
-                error(200,_("Limit set to '%s'\n"), conf->limit);
+                {
+                    char *limit_safe = stresc(conf->limit);
+                    error(200,_("Limit set to '%s'\n"), limit_safe);
+                    free(limit_safe);
+                }
             } else {
                 error(0,_("-l must have an argument\n"));
                 exit(INVALID_ARGUMENT_ERROR);
@@ -588,9 +594,13 @@ int main(int argc,char**argv)
       } else {
           char* er=strerror(errno);
           if (er!=NULL) {
-              error(0,"opendir() for root prefix %s failed: %s\n", conf->root_prefix,er);
+              char *rp_safe = stresc(conf->root_prefix);
+              error(0,"opendir() for root prefix %s failed: %s\n", rp_safe,er);
+              free(rp_safe);
           } else {
-              error(0,"opendir() for root prefix %s failed: %i\n", conf->root_prefix,errno);
+              char *rp_safe = stresc(conf->root_prefix);
+              error(0,"opendir() for root prefix %s failed: %i\n", rp_safe,errno);
+              free(rp_safe);
           }
           exit(INVALID_ARGUMENT_ERROR);
       }
diff --git a/src/compare_db.c b/src/compare_db.c
index c17828d..41e2165 100644
--- a/src/compare_db.c
+++ b/src/compare_db.c
@@ -526,15 +526,31 @@ static void print_line(seltree* node) {
             }
         }
         summary[length]='\0';
-        error(2,"\n%s: %s", summary, (node->checked&NODE_REMOVED?node->old_data:node->new_data)->filename);
+        {
+            char *filename_safe = stresc((node->checked&NODE_REMOVED?node->old_data:node->new_data)->filename);
+            error(2,"\n%s: %s", summary, filename_safe);
+            free(filename_safe);
+        }
         free(summary); summary=NULL;
     } else {
         if (node->checked&NODE_ADDED) {
-            error(2,"added: %s\n",(node->new_data)->filename);
+            {
+                char *filename_safe = stresc((node->new_data)->filename);
+                error(2,"added: %s\n",filename_safe);
+                free(filename_safe);
+            }
         } else if (node->checked&NODE_REMOVED) {
-            error(2,"removed: %s\n",(node->old_data)->filename);
+            {
+                char *filename_safe = stresc((node->old_data)->filename);
+                error(2,"removed: %s\n",filename_safe);
+                free(filename_safe);
+            }
         } else if (node->checked&NODE_CHANGED) {
-            error(2,"changed: %s\n",(node->new_data)->filename);
+            {
+                char *filename_safe = stresc((node->new_data)->filename);
+                error(2,"changed: %s\n",filename_safe);
+                free(filename_safe);
+            }
         }
     }
 }
@@ -551,7 +567,11 @@ static void print_dbline_attributes(db_line* oline, db_line* nline, DB_ATTR_TYPE
     if (file_type) {
         error(2,"%s: ", file_type);
     }
-    error(2,"%s\n", (nline==NULL?oline:nline)->filename);
+    {
+        char *filename_safe = stresc((nline==NULL?oline:nline)->filename);
+        error(2,"%s\n", filename_safe);
+        free(filename_safe);
+    }
     attrs=force_attrs|(~(ignored_changed_attrs)&changed_attrs);
     for (j=0; j < length; ++j) {
         if (details_attributes[j]&attrs) {
@@ -559,21 +579,25 @@ static void print_dbline_attributes(db_line* oline, db_line* nline, DB_ATTR_TYPE
             nnumber=get_attribute_values(details_attributes[j], nline, &nvalue);
             i = 0;
             while (i<onumber || i<nnumber) {
-                olen = i<onumber?strlen(ovalue[i]):0;
-                nlen = i<nnumber?strlen(nvalue[i]):0;
+                char *ov = i<onumber?stresc(ovalue[i]):NULL;
+                char *nv = i<nnumber?stresc(nvalue[i]):NULL;
+                olen = ov?strlen(ov):0;
+                nlen = nv?strlen(nv):0;
                 k = 0;
                 while (olen-p*k >= 0 || nlen-p*k >= 0) {
                     c = k*(p-1);
                     if (!onumber) {
-                        error(2," %s%-9s%c %-*c  %.*s\n", width_details%2?"":" ", i+k?"":details_string[j], i+k?' ':':', p, ' ', p-1, nlen-c>0?&nvalue[i][c]:"");
+                        error(2," %s%-9s%c %-*c  %.*s\n", width_details%2?"":" ", i+k?"":details_string[j], i+k?' ':':', p, ' ', p-1, nlen-c>0?&nv[c]:"");
                     } else if (!nnumber) {
-                        error(2," %s%-9s%c %.*s\n", width_details%2?"":" ", i+k?"":details_string[j], i+k?' ':':', p-1, olen-c>0?&ovalue[i][c]:"");
+                        error(2," %s%-9s%c %.*s\n", width_details%2?"":" ", i+k?"":details_string[j], i+k?' ':':', p-1, olen-c>0?&ov[c]:"");
                     } else {
-                        error(2," %s%-9s%c %-*.*s| %.*s\n", width_details%2?"":" ", i+k?"":details_string[j], i+k?' ':':', p, p-1, olen-c>0?&ovalue[i][c]:"", p-1, nlen-c>0?&nvalue[i][c]:"");
+                        error(2," %s%-9s%c %-*.*s| %.*s\n", width_details%2?"":" ", i+k?"":details_string[j], i+k?' ':':', p, p-1, olen-c>0?&ov[c]:"", p-1, nlen-c>0?&nv[c]:"");
                     }
                     k++;
                 }
                 ++i;
+                free(ov);
+                free(nv);
             }
             for(i=0; i < onumber; ++i) { free(ovalue[i]); ovalue[i]=NULL; } free(ovalue); ovalue=NULL;
             for(i=0; i < nnumber; ++i) { free(nvalue[i]); nvalue[i]=NULL; } free(nvalue); nvalue=NULL;
@@ -592,7 +616,11 @@ static void print_dbline_attributes_syslog(db_line* oline, db_line* nline, DB_AT
     if (file_type) {
         error(0,"%s=", file_type);
     }
-    error(0,"%s", (nline==NULL?oline:nline)->filename);
+    {
+        char *filename_safe = stresc((nline==NULL?oline:nline)->filename);
+        error(0,"%s", filename_safe);
+        free(filename_safe);
+    }
     attrs=force_attrs|(~(ignored_changed_attrs)&changed_attrs);
     for (j=0; j < length; ++j) {
         if (details_attributes[j]&attrs) {
@@ -604,18 +632,32 @@ static void print_dbline_attributes_syslog(db_line* oline, db_line* nline, DB_AT
                 error(0, ";%s_old=|", details_string[j]);
 
                 for (i = 0 ; i < onumber ; i++) {
-                    error(0, "%s|", ovalue[i]);
+                {
+                    char *val_safe = stresc(ovalue[i]);
+                    error(0, "%s|", val_safe);
+                    free(val_safe);
+                }
                 }
 
                 error(0, ";%s_new=|", details_string[j]);
 
                 for (i = 0 ; i < nnumber ; i++) {
-                    error(0, "%s|", nvalue[i]);
+                    {
+                        char *val_safe = stresc(nvalue[i]);
+                        error(0, "%s|", val_safe);
+                        free(val_safe);
+                    }
                 }
 
             } else {
 
-                error(0, ";%s_old=%s;%s_new=%s", details_string[j], *ovalue, details_string[j], *nvalue);
+                {
+                    char *ov_safe = stresc(*ovalue);
+                    char *nv_safe = stresc(*nvalue);
+                    error(0, ";%s_old=%s;%s_new=%s", details_string[j], ov_safe, details_string[j], nv_safe);
+                    free(ov_safe);
+                    free(nv_safe);
+                }
 
             }
 
@@ -640,7 +682,11 @@ static void print_attributes_added_node_syslog(db_line* line) {
     if (file_type) {
         error(0,"%s=", file_type);
     }
-    error(0,"%s; added\n", line->filename);
+    {
+        char *filename_safe = stresc(line->filename);
+        error(0,"%s; added\n", filename_safe);
+        free(filename_safe);
+    }
 
 }
 
@@ -650,7 +696,11 @@ static void print_attributes_removed_node_syslog(db_line* line) {
     if (file_type) {
         error(0,"%s=", file_type);
     }
-    error(0,"%s; removed\n", line->filename);
+    {
+        char *filename_safe = stresc(line->filename);
+        error(0,"%s; removed\n", filename_safe);
+        free(filename_safe);
+    }
 
 }
 
@@ -761,7 +811,9 @@ static void print_report_header() {
         error(2,_("Config version used: %s\n"),conf->config_version);
 
     if (conf->limit != NULL) {
-        error (2,_("Limit: %s"), conf->limit);
+        char *limit_safe = stresc(conf->limit);
+        error (2,_("Limit: %s"), limit_safe);
+        free(limit_safe);
         first = 0;
     }
     if (conf->action&(DO_INIT|DO_COMPARE) && conf->root_prefix_length > 0) {
diff --git a/src/db_disk.c b/src/db_disk.c
index 1b08d07..79885de 100644
--- a/src/db_disk.c
+++ b/src/db_disk.c
@@ -139,8 +139,11 @@ void add_child (db_line * fil)
 	int i;
 	struct seltree *new_r;
 
-	error (255, "Adding child %s\n", fil->filename);
-
+  {
+    char *fname_safe = stresc(fil->filename);
+    error (255, "Adding child %s\n", fname_safe);
+    free(fname_safe);
+  }
 	new_r = get_seltree_node (r, fil->filename);
 	if (new_r != NULL) {
 		if (S_ISDIR (fil->perm_o)) {
@@ -182,10 +185,14 @@ static int get_file_status(char *filename, struct AIDE_STAT_TYPE *fs) {
     if(sres == -1){
         char* er = strerror(errno);
         if (er == NULL) {
-            error(0,"get_file_status: lstat() failed for %s. strerror() failed for %i\n", filename, errno);
+				    char *filename_safe = stresc(filename);
+            error(0,"get_file_status: lstat() failed for %s. strerror() failed for %i\n", filename_safe, errno);
+            free(filename_safe);
         } else {
-            error(0,"get_file_status: lstat() failed for %s: %s\n", filename, er);
-        }
+            char *filename_safe = stresc(filename);
+            error(0,"get_file_status: lstat() failed for %s: %s\n", filename_safe, er);
+            free(filename_safe);
+				}
     }
     return sres;
 }
@@ -220,8 +227,12 @@ db_line *db_readline_disk ()
 			error (240, "%s attr=%llu\n", &fullname[conf->root_prefix_length], attr);
 
 			if (fil != NULL) {
-				error (240, "%s attr=%llu\n", fil->filename, fil->attr);
-				return fil;
+			  {
+        char *fname_safe = stresc(fil->filename);       
+				error (240, "%s attr=%llu\n", fname_safe, fil->attr);
+        free(fname_safe); 
+				}
+				 return fil;
 			}
         }
 		}
@@ -269,7 +280,11 @@ recursion:
 			error (240, "%s attr=%llu\n", &fullname[conf->root_prefix_length], attr);
 
 			if (fil != NULL) {
-				error (240, "%s attr=%llu\n", fil->filename, fil->attr);
+			    {
+           char *fname_safe = stresc(fil->filename);
+					 error (240, "%s attr=%llu\n", fname_safe, fil->attr);
+					 free(fname_safe);
+					}
 			} else {
 				/*
 				   Something went wrong during read process -> 
diff --git a/src/db_sql.c b/src/db_sql.c
index 1545790..09a3250 100644
--- a/src/db_sql.c
+++ b/src/db_sql.c
@@ -38,6 +38,7 @@
 #include "db_config.h"
 #include "libpq-fe.h"
 #include "report.h"
+#include "util.h"
 
 #ifdef WITH_MHASH
 #include <mhash.h>
@@ -303,7 +304,11 @@ db_line* db_readline_sql(int db, db_config* conf) {
 #endif
   ((psql_data*)(*db_filep))->curread++;
   
-  error(255,"filename %s\n",rline->filename);
+  {
+    char *filename_safe = stresc(rline->filename);
+    error(255,"filename %s\n",filename_safe);
+    free(filename_safe);
+  }
   
   return rline;
 }
diff --git a/src/do_md.c b/src/do_md.c
index 77d2e15..4a648b6 100644
--- a/src/do_md.c
+++ b/src/do_md.c
@@ -38,6 +38,7 @@
 #include <sys/mman.h>
 
 #include "md.h"
+#include "util.h"
 
 #include "db_config.h"
 #include "do_md.h"
@@ -228,11 +229,15 @@ void calc_md(struct AIDE_STAT_TYPE* old_fs,db_line* line) {
   if (filedes==-1) {
     char* er=strerror(errno);
     if (er!=NULL) {
+      char *fp_safe = stresc(line->fullpath);
       error(3,"do_md(): open() for %s failed: %s\n",
-	    line->fullpath,er);
+            fp_safe,er);
+      free(fp_safe);
     } else {
+      char *fp_safe = stresc(line->fullpath);
       error(3,"do_md(): open() for %s failed: %i\n",
-	    line->fullpath,errno);
+            fp_safe,errno);
+      free(fp_safe);
     }
     /*
       Nop. Cannot cal hashes. Mark it.
@@ -310,7 +315,11 @@ void calc_md(struct AIDE_STAT_TYPE* old_fs,db_line* line) {
 	   r_size-=MMAP_BLOCK_SIZE;
 	 }
 	 if ( buf == MAP_FAILED ) {
-	   error(0,"error mmap'ing %s: %s\n", line->fullpath,strerror(errno));
+           {
+           char *fp_safe = stresc(line->fullpath);
+           error(0,"error mmap'ing %s: %s\n", fp_safe,strerror(errno));
+           free(fp_safe);
+           }
 	   close(filedes);
 	   close_md(&mdc);
 	   return;
@@ -513,9 +522,17 @@ void acl2line(db_line* line) {
       char* er=strerror(errno);
       line->acl->entries=0;
       if (er==NULL) {
-	error(0,"ACL query failed for %s. strerror failed for %i\n",line->fullpath,errno);
+    {
+    char *fp_safe = stresc(line->fullpath);
+    error(0,"ACL query failed for %s. strerror failed for %i\n",fp_safe,errno);
+    free(fp_safe);
+    }
       } else {
-	error(0,"ACL query failed for %s:%s\n",line->fullpath,er);
+    {
+    char *fp_safe = stresc(line->fullpath);
+    error(0,"ACL query failed for %s:%s\n",fp_safe,er);
+    free(fp_safe);
+    }
       }
     } else {
       line->acl->acl=malloc(sizeof(aclent_t)*line->acl->entries);
@@ -593,7 +610,11 @@ void xattrs2line(db_line *line) {
     if ((xret == -1) && ((errno == ENOSYS) || (errno == ENOTSUP))) {
         line->attr&=(~DB_XATTRS);
     } else if (xret == -1) {
-        error(0, "listxattrs failed for %s:%s\n", line->fullpath, strerror(errno));
+        {
+        char *fp_safe = stresc(line->fullpath);
+        error(0, "listxattrs failed for %s:%s\n", fp_safe, strerror(errno));
+        free(fp_safe);
+        }
     } else if (xret) {
         const char *attr = xatrs;
         static ssize_t asz = 1024;
@@ -620,7 +641,11 @@ void xattrs2line(db_line *line) {
             if (aret != -1)
                 xattr_add(xattrs, attr, val, aret);
             else if (errno != ENOATTR)
-                error(0, "getxattr failed for %s:%s\n", line->fullpath, strerror(errno));
+                {
+                char *fp_safe = stresc(line->fullpath);
+                error(0, "getxattr failed for %s:%s\n", fp_safe, strerror(errno));
+                free(fp_safe);
+                }
 
 next_attr:
             attr += len + 1;
@@ -642,7 +667,11 @@ void selinux2line(db_line *line) {
     if (lgetfilecon_raw(line->fullpath, &cntx) == -1) {
         line->attr&=(~DB_SELINUX);
         if ((errno != ENOATTR) && (errno != EOPNOTSUPP))
-            error(0, "lgetfilecon_raw failed for %s:%s\n", line->fullpath, strerror(errno));
+            {
+            char *fp_safe = stresc(line->fullpath);
+            error(0, "lgetfilecon_raw failed for %s:%s\n", fp_safe, strerror(errno));
+            free(fp_safe);
+            }
         return;
     }
 
diff --git a/src/gen_list.c b/src/gen_list.c
index ab25781..5b4a93e 100644
--- a/src/gen_list.c
+++ b/src/gen_list.c
@@ -38,6 +38,7 @@
 #include "gen_list.h"
 #include "seltree.h"
 #include "db.h"
+#include "util.h"
 #include "db_config.h"
 #include "commandconf.h"
 #include "report.h"
@@ -993,16 +994,28 @@ int check_rxtree(char* filename,seltree* tree,DB_ATTR_TYPE* attr, mode_t perm)
   if(conf->limit!=NULL) {
       retval=pcre_exec(conf->limit_crx, NULL, filename, strlen(filename), 0, PCRE_PARTIAL_SOFT, NULL, 0);
       if (retval >= 0) {
-          error(220, "check_rxtree: %s does match limit: %s\n", filename, conf->limit);
+          char *fname_safe = stresc(filename);
+          char *limit_safe = conf->limit?stresc(conf->limit):NULL;
+          error(220, "check_rxtree: %s does match limit: %s\n", fname_safe, limit_safe?limit_safe:"");
+          free(fname_safe);
+          free(limit_safe);
       } else if (retval == PCRE_ERROR_PARTIAL) {
-          error(220, "check_rxtree: %s does PARTIAL match limit: %s\n", filename, conf->limit);
+          char *fname_safe = stresc(filename);
+          char *limit_safe = conf->limit?stresc(conf->limit):NULL;
+          error(220, "check_rxtree: %s does PARTIAL match limit: %s\n", fname_safe, limit_safe?limit_safe:"");
           if(S_ISDIR(perm) && get_seltree_node(tree,filename)==NULL){
-              error(220, "check_rxtree: creating new seltree node for '%s'\n", filename);
+              error(220, "check_rxtree: creating new seltree node for '%s'\n", fname_safe);
               new_seltree_node(tree,filename,0,NULL);
           }
+          free(fname_safe);
+          free(limit_safe);
           return -1;
       } else {
-          error(220, "check_rxtree: %s does NOT match limit: %s\n", filename, conf->limit);
+          char *fname_safe = stresc(filename);
+          char *limit_safe = conf->limit?stresc(conf->limit):NULL;
+          error(220, "check_rxtree: %s does NOT match limit: %s\n", fname_safe, limit_safe?limit_safe:"");
+          free(fname_safe);
+          free(limit_safe);
           return -2;
       }
   }
@@ -1039,13 +1052,25 @@ db_line* get_file_attrs(char* filename,DB_ATTR_TYPE attr, struct AIDE_STAT_TYPE
   } else {
     
     if(fs->st_atime>cur_time){
-      error(CLOCK_SKEW,_("%s atime in future\n"),filename);
+      {
+      char *fname_safe = stresc(filename);
+      error(CLOCK_SKEW,_("%s atime in future\n"),fname_safe);
+      free(fname_safe);
+      }
     }
     if(fs->st_mtime>cur_time){
-      error(CLOCK_SKEW,_("%s mtime in future\n"),filename);
+      {
+      char *fname_safe = stresc(filename);
+      error(CLOCK_SKEW,_("%s mtime in future\n"),fname_safe);
+      free(fname_safe);
+      }
     }
     if(fs->st_ctime>cur_time){
-      error(CLOCK_SKEW,_("%s ctime in future\n"),filename);
+      {
+      char *fname_safe = stresc(filename);
+      error(CLOCK_SKEW,_("%s ctime in future\n"),fname_safe);
+      free(fname_safe);
+      }
     }
   }
   
@@ -1220,7 +1245,11 @@ void hsymlnk(db_line* line) {
       int sres;
       sres=AIDE_STAT_FUNC(line->fullpath,&fs);
       if (sres!=0 && sres!=EACCES) {
-	error(4,"Dead symlink detected at %s\n",line->fullpath);
+  {
+  char *fp_safe = stresc(line->fullpath);
+  error(4,"Dead symlink detected at %s\n",fp_safe);
+  free(fp_safe);
+  }
       }
       if(!(line->attr&DB_RDEV))
 	fs.st_rdev=0;
diff --git a/src/util.c b/src/util.c
index 525eab5..dba58b4 100644
--- a/src/util.c
+++ b/src/util.c
@@ -104,8 +104,10 @@ url_t* parse_url(char* val)
       r+=2;
       for(i=0;r[0]!='/'&&r[0]!='\0';r++,i++);
       if(r[0]=='\0'){
-	error(0,"Invalid file-URL,no path after hostname: file:%s\n",t);
-        free(hostname);
+        char *t_safe = stresc(t);
+        error(0,"Invalid file-URL,no path after hostname: file:%s\n",t_safe);
+        free(t_safe);
+	free(hostname);
 	return NULL;
       }
       u->value=strdup(r);
@@ -118,7 +120,9 @@ url_t* parse_url(char* val)
 	free(hostname);
 	break;
       } else {
-	error(0,"Invalid file-URL, cannot use hostname other than localhost or %s: file:%s\n",hostname,u->value);
+	char *value_safe = stresc(u->value);
+        error(0,"Invalid file-URL, cannot use hostname other than localhost or %s: file:%s\n",hostname,value_safe);
+        free(value_safe);
 	free(hostname);
 	return NULL;
       }
@@ -150,6 +154,43 @@ url_t* parse_url(char* val)
   return u;
 }
 
+static size_t escape_str(const char *unescaped_str, char *str, size_t s) {
+    size_t n = 0;
+    size_t i = 0;
+    char c;
+    while (i < s && (c = unescaped_str[i])) {
+        if ((c >= 0 && (c < 0x1f || c == 0x7f)) ||
+            (c == '\\' && isdigit(unescaped_str[i+1])
+                       && isdigit(unescaped_str[i+2])
+                       && isdigit(unescaped_str[i+3]))) {
+            if (str) { snprintf(&str[n], 5, "\\%03o", c); }
+            n += 4;
+        } else {
+            if (str) { str[n] = c; }
+            n++;
+        }
+        i++;
+    }
+    if (str) { str[n] = '\0'; }
+    n++;
+    return n;
+}
+
+char *strnesc(const char *unescaped_str, size_t s) {
+    int n = escape_str(unescaped_str, NULL, s);
+    char *str = malloc(n);
+    if (str == NULL) {
+        error(0, "malloc: failed to allocate %d bytes of memory\n", n);
+        exit(1);
+    }
+    escape_str(unescaped_str, str, s);
+    return str;
+}
+
+char *stresc(const char *unescaped_str) {
+    return strnesc(unescaped_str, strlen(unescaped_str));
+}
+
 /* Returns 1 if the string contains unsafe characters, 0 otherwise.  */
 int contains_unsafe (const char *s)
 {
-- 
2.45.2

