From 534d8ea4cd83ce9a069213d78bbddcd5d5eef63a Mon Sep 17 00:00:00 2001
From: William Manley <will@stb-tester.com>
Date: Thu, 13 Feb 2025 23:11:38 +0530
Subject: [PATCH] gvariant-core: Consolidate construction of GVariantSerialised

So I only need to change it in one place.

This introduces no functional changes.

Helps: #2121
Signed-off-by: Ankita Pareek <ankitapareek@microsoft.com>
---
 glib/gvariant-core.c            |  185 +-
 glib/gvariant-core.c.orig       | 1229 +++++++
 glib/gvariant-core.h            |    3 +
 glib/gvariant-core.h.orig       |   39 +
 glib/gvariant-serialiser.c      |  367 +-
 glib/gvariant-serialiser.c.orig | 1750 +++++++++
 glib/gvariant-serialiser.h      |   21 +
 glib/gvariant-serialiser.h.orig |   76 +
 glib/gvariant.c                 |  172 +-
 glib/gvariant.c.orig            | 6049 +++++++++++++++++++++++++++++++
 glib/tests/gvariant.c           |  544 ++-
 glib/tests/gvariant.c.orig      | 5206 ++++++++++++++++++++++++++
 12 files changed, 15473 insertions(+), 168 deletions(-)
 create mode 100644 glib/gvariant-core.c.orig
 create mode 100644 glib/gvariant-core.h.orig
 create mode 100644 glib/gvariant-serialiser.c.orig
 create mode 100644 glib/gvariant-serialiser.h.orig
 create mode 100644 glib/gvariant.c.orig
 create mode 100644 glib/tests/gvariant.c.orig

diff --git a/glib/gvariant-core.c b/glib/gvariant-core.c
index a31d396..93544cc 100644
--- a/glib/gvariant-core.c
+++ b/glib/gvariant-core.c
@@ -1,6 +1,7 @@
 /*
  * Copyright © 2007, 2008 Ryan Lortie
  * Copyright © 2010 Codethink Limited
+ * Copyright © 2022 Endless OS Foundation, LLC
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -65,6 +66,8 @@ struct _GVariant
     {
       GBytes *bytes;
       gconstpointer data;
+      gsize ordered_offsets_up_to;
+      gsize checked_offsets_up_to;
     } serialised;
 
     struct
@@ -162,6 +165,42 @@ struct _GVariant
  *                if .data pointed to the appropriate number of nul
  *                bytes.
  *
+ *     .ordered_offsets_up_to: If ordered_offsets_up_to == n this means that all
+ *                             the frame offsets up to and including the frame
+ *                             offset determining the end of element n are in
+ *                             order. This guarantees that the bytes of element
+ *                             n don't overlap with any previous element.
+ *
+ *                             For trusted data this is set to G_MAXSIZE and we
+ *                             don't check that the frame offsets are in order.
+ *
+ *                             Note: This doesn't imply the offsets are good in
+ *                             any way apart from their ordering.  In particular
+ *                             offsets may be out of bounds for this value or
+ *                             may imply that the data overlaps the frame
+ *                             offsets themselves.
+ *
+ *                             This field is only relevant for arrays of non
+ *                             fixed width types and for tuples.
+ *
+ *     .checked_offsets_up_to: Similarly to .ordered_offsets_up_to, this stores
+ *                             the index of the highest element, n, whose frame
+ *                             offsets (and all the preceding frame offsets)
+ *                             have been checked for validity.
+ *
+ *                             It is always the case that
+ *                             .checked_offsets_up_to ≥ .ordered_offsets_up_to.
+ *
+ *                             If .checked_offsets_up_to == .ordered_offsets_up_to,
+ *                             then a bad offset has not been found so far.
+ *
+ *                             If .checked_offsets_up_to > .ordered_offsets_up_to,
+ *                             then a bad offset has been found at
+ *                             (.ordered_offsets_up_to + 1).
+ *
+ *                             This field is only relevant for arrays of non
+ *                             fixed width types and for tuples.
+ *
  *   .tree: Only valid when the instance is in tree form.
  *
  *          Note that accesses from other threads could result in
@@ -349,6 +388,29 @@ g_variant_ensure_size (GVariant *value)
     }
 }
 
+/* < private >
+ * g_variant_to_serialised:
+ * @value: a #GVariant
+ *
+ * Gets a GVariantSerialised for a GVariant in state STATE_SERIALISED.
+ */
+inline static GVariantSerialised
+g_variant_to_serialised (GVariant *value)
+{
+  g_assert (value->state & STATE_SERIALISED);
+  {
+    GVariantSerialised serialised = {
+      value->type_info,
+      (gpointer) value->contents.serialised.data,
+      value->size,
+      value->depth,
+      value->contents.serialised.ordered_offsets_up_to,
+      value->contents.serialised.checked_offsets_up_to,
+    };
+    return serialised;
+  }
+}
+
 /* < private >
  * g_variant_serialise:
  * @value: a #GVariant
@@ -375,6 +437,8 @@ g_variant_serialise (GVariant *value,
   serialised.size = value->size;
   serialised.data = data;
   serialised.depth = value->depth;
+  serialised.ordered_offsets_up_to = 0;
+  serialised.checked_offsets_up_to = 0;
 
   children = (gpointer *) value->contents.tree.children;
   n_children = value->contents.tree.n_children;
@@ -418,6 +482,17 @@ g_variant_fill_gvs (GVariantSerialised *serialised,
   g_assert (serialised->size == value->size);
   serialised->depth = value->depth;
 
+  if (value->state & STATE_SERIALISED)
+    {
+      serialised->ordered_offsets_up_to = value->contents.serialised.ordered_offsets_up_to;
+      serialised->checked_offsets_up_to = value->contents.serialised.checked_offsets_up_to;
+    }
+  else
+    {
+      serialised->ordered_offsets_up_to = 0;
+      serialised->checked_offsets_up_to = 0;
+    }
+
   if (serialised->data)
     /* g_variant_store() is a public API, so it
      * it will reacquire the lock if it needs to.
@@ -460,6 +535,8 @@ g_variant_ensure_serialised (GVariant *value)
       bytes = g_bytes_new_take (data, value->size);
       value->contents.serialised.data = g_bytes_get_data (bytes, NULL);
       value->contents.serialised.bytes = bytes;
+      value->contents.serialised.ordered_offsets_up_to = G_MAXSIZE;
+      value->contents.serialised.checked_offsets_up_to = G_MAXSIZE;
       value->state |= STATE_SERIALISED;
     }
 }
@@ -540,6 +617,8 @@ g_variant_new_from_bytes (const GVariantType *type,
   serialised.type_info = value->type_info;
   serialised.data = (guchar *) g_bytes_get_data (bytes, &serialised.size);
   serialised.depth = 0;
+  serialised.ordered_offsets_up_to = trusted ? G_MAXSIZE : 0;
+  serialised.checked_offsets_up_to = trusted ? G_MAXSIZE : 0;
 
   if (!g_variant_serialised_check (serialised))
     {
@@ -590,6 +669,9 @@ g_variant_new_from_bytes (const GVariantType *type,
       value->contents.serialised.data = g_bytes_get_data (bytes, &value->size);
     }
 
+  value->contents.serialised.ordered_offsets_up_to = trusted ? G_MAXSIZE : 0;
+  value->contents.serialised.checked_offsets_up_to = trusted ? G_MAXSIZE : 0;
+
   g_clear_pointer (&owned_bytes, g_bytes_unref);
 
   return value;
@@ -1007,16 +1089,8 @@ g_variant_n_children (GVariant *value)
   g_variant_lock (value);
 
   if (value->state & STATE_SERIALISED)
-    {
-      GVariantSerialised serialised = {
-        value->type_info,
-        (gpointer) value->contents.serialised.data,
-        value->size,
-        value->depth,
-      };
-
-      n_children = g_variant_serialised_n_children (serialised);
-    }
+    n_children = g_variant_serialised_n_children (
+        g_variant_to_serialised (value));
   else
     n_children = value->contents.tree.n_children;
 
@@ -1083,12 +1157,7 @@ g_variant_get_child_value (GVariant *value,
     }
 
   {
-    GVariantSerialised serialised = {
-      value->type_info,
-      (gpointer) value->contents.serialised.data,
-      value->size,
-      value->depth,
-    };
+    GVariantSerialised serialised = g_variant_to_serialised (value);
     GVariantSerialised s_child;
     GVariant *child;
 
@@ -1097,6 +1166,10 @@ g_variant_get_child_value (GVariant *value,
      */
     s_child = g_variant_serialised_get_child (serialised, index_);
 
+    /* Update the cached ordered_offsets_up_to, since @serialised will be thrown away when this function exits */
+    value->contents.serialised.ordered_offsets_up_to = MAX (value->contents.serialised.ordered_offsets_up_to, serialised.ordered_offsets_up_to);
+    value->contents.serialised.checked_offsets_up_to = MAX (value->contents.serialised.checked_offsets_up_to, serialised.checked_offsets_up_to);
+
     /* Check whether this would cause nesting too deep. If so, return a fake
      * child. The only situation we expect this to happen in is with a variant,
      * as all other deeply-nested types have a static type, and hence should
@@ -1108,6 +1181,7 @@ g_variant_get_child_value (GVariant *value,
         G_VARIANT_MAX_RECURSION_DEPTH - value->depth)
       {
         g_assert (g_variant_is_of_type (value, G_VARIANT_TYPE_VARIANT));
+        g_variant_type_info_unref (s_child.type_info);
         return g_variant_new_tuple (NULL, 0);
       }
 
@@ -1122,11 +1196,81 @@ g_variant_get_child_value (GVariant *value,
     child->contents.serialised.bytes =
       g_bytes_ref (value->contents.serialised.bytes);
     child->contents.serialised.data = s_child.data;
+    child->contents.serialised.ordered_offsets_up_to = s_child.ordered_offsets_up_to;
+    child->contents.serialised.checked_offsets_up_to = s_child.checked_offsets_up_to;
 
     return child;
   }
 }
 
+/**
+ * g_variant_maybe_get_child_value:
+ * @value: a container #GVariant
+ * @index_: the index of the child to fetch
+ *
+ * Reads a child item out of a container #GVariant instance, if it is in normal
+ * form. If it is not in normal form, return %NULL.
+ *
+ * This function behaves the same as g_variant_get_child_value(), except that it
+ * returns %NULL if the child is not in normal form. g_variant_get_child_value()
+ * would instead return a new default value of the correct type.
+ *
+ * This is intended to be used internally to avoid unnecessary #GVariant
+ * allocations.
+ *
+ * The returned value is never floating.  You should free it with
+ * g_variant_unref() when you're done with it.
+ *
+ * This function is O(1).
+ *
+ * Returns: (transfer full): the child at the specified index
+ *
+ * Since: 2.74
+ */
+GVariant *
+g_variant_maybe_get_child_value (GVariant *value,
+                                 gsize     index_)
+{
+  g_return_val_if_fail (index_ < g_variant_n_children (value), NULL);
+  g_return_val_if_fail (value->depth < G_MAXSIZE, NULL);
+
+  if (~g_atomic_int_get (&value->state) & STATE_SERIALISED)
+    {
+      g_variant_lock (value);
+
+      if (~value->state & STATE_SERIALISED)
+        {
+          GVariant *child;
+
+          child = g_variant_ref (value->contents.tree.children[index_]);
+          g_variant_unlock (value);
+
+          return child;
+        }
+
+      g_variant_unlock (value);
+    }
+
+  {
+    GVariantSerialised serialised = g_variant_to_serialised (value);
+    GVariantSerialised s_child;
+
+    /* get the serializer to extract the serialized data for the child
+     * from the serialized data for the container
+     */
+    s_child = g_variant_serialised_get_child (serialised, index_);
+
+    if (!(value->state & STATE_TRUSTED) && s_child.data == NULL)
+      {
+        g_variant_type_info_unref (s_child.type_info);
+        return NULL;
+      }
+
+    g_variant_type_info_unref (s_child.type_info);
+    return g_variant_get_child_value (value, index_);
+  }
+}
+
 /**
  * g_variant_store:
  * @value: the #GVariant to store
@@ -1201,14 +1345,7 @@ g_variant_is_normal_form (GVariant *value)
 
   if (value->state & STATE_SERIALISED)
     {
-      GVariantSerialised serialised = {
-        value->type_info,
-        (gpointer) value->contents.serialised.data,
-        value->size,
-        value->depth
-      };
-
-      if (g_variant_serialised_is_normal (serialised))
+      if (g_variant_serialised_is_normal (g_variant_to_serialised (value)))
         value->state |= STATE_TRUSTED;
     }
   else
diff --git a/glib/gvariant-core.c.orig b/glib/gvariant-core.c.orig
new file mode 100644
index 0000000..a31d396
--- /dev/null
+++ b/glib/gvariant-core.c.orig
@@ -0,0 +1,1229 @@
+/*
+ * Copyright © 2007, 2008 Ryan Lortie
+ * Copyright © 2010 Codethink Limited
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+#include <glib/gvariant-core.h>
+
+#include <glib/gvariant-internal.h>
+#include <glib/gvariant-serialiser.h>
+#include <glib/gtestutils.h>
+#include <glib/gbitlock.h>
+#include <glib/gatomic.h>
+#include <glib/gbytes.h>
+#include <glib/gslice.h>
+#include <glib/gmem.h>
+#include <glib/grefcount.h>
+#include <string.h>
+
+
+/*
+ * This file includes the structure definition for GVariant and a small
+ * set of functions that are allowed to access the structure directly.
+ *
+ * This minimises the amount of code that can possibly touch a GVariant
+ * structure directly to a few simple fundamental operations.  These few
+ * operations are written to be completely threadsafe with respect to
+ * all possible outside access.  This means that we only need to be
+ * concerned about thread safety issues in this one small file.
+ *
+ * Most GVariant API functions are in gvariant.c.
+ */
+
+/**
+ * GVariant:
+ *
+ * #GVariant is an opaque data structure and can only be accessed
+ * using the following functions.
+ *
+ * Since: 2.24
+ **/
+struct _GVariant
+/* see below for field member documentation */
+{
+  GVariantTypeInfo *type_info;
+  gsize size;
+
+  union
+  {
+    struct
+    {
+      GBytes *bytes;
+      gconstpointer data;
+    } serialised;
+
+    struct
+    {
+      GVariant **children;
+      gsize n_children;
+    } tree;
+  } contents;
+
+  gint state;
+  gatomicrefcount ref_count;
+  gsize depth;
+};
+
+/* struct GVariant:
+ *
+ * There are two primary forms of GVariant instances: "serialized form"
+ * and "tree form".
+ *
+ * "serialized form": A serialized GVariant instance stores its value in
+ *                    the GVariant serialization format.  All
+ *                    basic-typed instances (ie: non-containers) are in
+ *                    serialized format, as are some containers.
+ *
+ * "tree form": Some containers are in "tree form".  In this case,
+ *              instead of containing the serialized data for the
+ *              container, the instance contains an array of pointers to
+ *              the child values of the container (thus forming a tree).
+ *
+ * It is possible for an instance to transition from tree form to
+ * serialized form.  This happens, implicitly, if the serialized data is
+ * requested (eg: via g_variant_get_data()).  Serialized form instances
+ * never transition into tree form.
+ *
+ *
+ * The fields of the structure are documented here:
+ *
+ * type_info: this is a reference to a GVariantTypeInfo describing the
+ *            type of the instance.  When the instance is freed, this
+ *            reference must be released with g_variant_type_info_unref().
+ *
+ *            The type_info field never changes during the life of the
+ *            instance, so it can be accessed without a lock.
+ *
+ * size: this is the size of the serialized form for the instance, if it
+ *       is known.  If the instance is in serialized form then it is, by
+ *       definition, known.  If the instance is in tree form then it may
+ *       be unknown (in which case it is -1).  It is possible for the
+ *       size to be known when in tree form if, for example, the user
+ *       has called g_variant_get_size() without calling
+ *       g_variant_get_data().  Additionally, even when the user calls
+ *       g_variant_get_data() the size of the data must first be
+ *       determined so that a large enough buffer can be allocated for
+ *       the data.
+ *
+ *       Once the size is known, it can never become unknown again.
+ *       g_variant_ensure_size() is used to ensure that the size is in
+ *       the known state -- it calculates the size if needed.  After
+ *       that, the size field can be accessed without a lock.
+ *
+ * contents: a union containing either the information associated with
+ *           holding a value in serialized form or holding a value in
+ *           tree form.
+ *
+ *   .serialised: Only valid when the instance is in serialized form.
+ *
+ *                Since an instance can never transition away from
+ *                serialized form, once these fields are set, they will
+ *                never be changed.  It is therefore valid to access
+ *                them without holding a lock.
+ *
+ *     .bytes:  the #GBytes that contains the memory pointed to by
+ *              .data, or %NULL if .data is %NULL.  In the event that
+ *              the instance was deserialized from another instance,
+ *              then the bytes will be shared by both of them.  When
+ *              the instance is freed, this reference must be released
+ *              with g_bytes_unref().
+ *
+ *     .data: the serialized data (of size 'size') of the instance.
+ *            This pointer should not be freed or modified in any way.
+ *            #GBytes is responsible for memory management.
+ *
+ *            This pointer may be %NULL in two cases:
+ *
+ *              - if the serialized size of the instance is 0
+ *
+ *              - if the instance is of a fixed-sized type and was
+ *                deserialized out of a corrupted container such that
+ *                the container contains too few bytes to point to the
+ *                entire proper fixed-size of this instance.  In this
+ *                case, 'size' will still be equal to the proper fixed
+ *                size, but this pointer will be %NULL.  This is exactly
+ *                the reason that g_variant_get_data() sometimes returns
+ *                %NULL.  For all other calls, the effect should be as
+ *                if .data pointed to the appropriate number of nul
+ *                bytes.
+ *
+ *   .tree: Only valid when the instance is in tree form.
+ *
+ *          Note that accesses from other threads could result in
+ *          conversion of the instance from tree form to serialized form
+ *          at any time.  For this reason, the instance lock must always
+ *          be held while performing any operations on 'contents.tree'.
+ *
+ *     .children: the array of the child instances of this instance.
+ *                When the instance is freed (or converted to serialized
+ *                form) then each child must have g_variant_unref()
+ *                called on it and the array must be freed using
+ *                g_free().
+ *
+ *     .n_children: the number of items in the .children array.
+ *
+ * state: a bitfield describing the state of the instance.  It is a
+ *        bitwise-or of the following STATE_* constants:
+ *
+ *    STATE_LOCKED: the instance lock is held.  This is the bit used by
+ *                  g_bit_lock().
+ *
+ *    STATE_SERIALISED: the instance is in serialized form.  If this
+ *                      flag is not set then the instance is in tree
+ *                      form.
+ *
+ *    STATE_TRUSTED: for serialized form instances, this means that the
+ *                   serialized data is known to be in normal form (ie:
+ *                   not corrupted).
+ *
+ *                   For tree form instances, this means that all of the
+ *                   child instances in the contents.tree.children array
+ *                   are trusted.  This means that if the container is
+ *                   serialized then the resulting data will be in
+ *                   normal form.
+ *
+ *                   If this flag is unset it does not imply that the
+ *                   data is corrupted.  It merely means that we're not
+ *                   sure that it's valid.  See g_variant_is_trusted().
+ *
+ *    STATE_FLOATING: if this flag is set then the object has a floating
+ *                    reference.  See g_variant_ref_sink().
+ *
+ * ref_count: the reference count of the instance
+ *
+ * depth: the depth of the GVariant in a hierarchy of nested containers,
+ *        increasing with the level of nesting. The top-most GVariant has depth
+ *        zero.  This is used to avoid recursing too deeply and overflowing the
+ *        stack when handling deeply nested untrusted serialized GVariants.
+ */
+#define STATE_LOCKED     1
+#define STATE_SERIALISED 2
+#define STATE_TRUSTED    4
+#define STATE_FLOATING   8
+
+/* -- private -- */
+/* < private >
+ * g_variant_lock:
+ * @value: a #GVariant
+ *
+ * Locks @value for performing sensitive operations.
+ */
+static void
+g_variant_lock (GVariant *value)
+{
+  g_bit_lock (&value->state, 0);
+}
+
+/* < private >
+ * g_variant_unlock:
+ * @value: a #GVariant
+ *
+ * Unlocks @value after performing sensitive operations.
+ */
+static void
+g_variant_unlock (GVariant *value)
+{
+  g_bit_unlock (&value->state, 0);
+}
+
+/* < private >
+ * g_variant_release_children:
+ * @value: a #GVariant
+ *
+ * Releases the reference held on each child in the 'children' array of
+ * @value and frees the array itself.  @value must be in tree form.
+ *
+ * This is done when freeing a tree-form instance or converting it to
+ * serialized form.
+ *
+ * The current thread must hold the lock on @value.
+ */
+static void
+g_variant_release_children (GVariant *value)
+{
+  gsize i;
+
+  g_assert (value->state & STATE_LOCKED);
+  g_assert (~value->state & STATE_SERIALISED);
+
+  for (i = 0; i < value->contents.tree.n_children; i++)
+    g_variant_unref (value->contents.tree.children[i]);
+
+  g_free (value->contents.tree.children);
+}
+
+/* This begins the main body of the recursive serializer.
+ *
+ * There are 3 functions here that work as a team with the serializer to
+ * get things done.  g_variant_store() has a trivial role, but as a
+ * public API function, it has its definition elsewhere.
+ *
+ * Note that "serialization" of an instance does not mean that the
+ * instance is converted to serialized form -- it means that the
+ * serialized form of an instance is written to an external buffer.
+ * g_variant_ensure_serialised() (which is not part of this set of
+ * functions) is the function that is responsible for converting an
+ * instance to serialized form.
+ *
+ * We are only concerned here with container types since non-container
+ * instances are always in serialized form.  For these instances,
+ * storing their serialized form merely involves a memcpy().
+ *
+ * Serialization is a two-step process.  First, the size of the
+ * serialized data must be calculated so that an appropriately-sized
+ * buffer can be allocated.  Second, the data is written into the
+ * buffer.
+ *
+ * Determining the size:
+ *   The process of determining the size is triggered by a call to
+ *   g_variant_ensure_size() on a container.  This invokes the
+ *   serializer code to determine the size.  The serializer is passed
+ *   g_variant_fill_gvs() as a callback.
+ *
+ *   g_variant_fill_gvs() is called by the serializer on each child of
+ *   the container which, in turn, calls g_variant_ensure_size() on
+ *   itself and fills in the result of its own size calculation.
+ *
+ *   The serializer uses the size information from the children to
+ *   calculate the size needed for the entire container.
+ *
+ * Writing the data:
+ *   After the buffer has been allocated, g_variant_serialise() is
+ *   called on the container.  This invokes the serializer code to write
+ *   the bytes to the container.  The serializer is, again, passed
+ *   g_variant_fill_gvs() as a callback.
+ *
+ *   This time, when g_variant_fill_gvs() is called for each child, the
+ *   child is given a pointer to a sub-region of the allocated buffer
+ *   where it should write its data.  This is done by calling
+ *   g_variant_store().  In the event that the instance is in serialized
+ *   form this means a memcpy() of the serialized data into the
+ *   allocated buffer.  In the event that the instance is in tree form
+ *   this means a recursive call back into g_variant_serialise().
+ *
+ *
+ * The forward declaration here allows corecursion via callback:
+ */
+static void g_variant_fill_gvs (GVariantSerialised *, gpointer);
+
+/* < private >
+ * g_variant_ensure_size:
+ * @value: a #GVariant
+ *
+ * Ensures that the ->size field of @value is filled in properly.  This
+ * must be done as a precursor to any serialization of the value in
+ * order to know how large of a buffer is needed to store the data.
+ *
+ * The current thread must hold the lock on @value.
+ */
+static void
+g_variant_ensure_size (GVariant *value)
+{
+  g_assert (value->state & STATE_LOCKED);
+
+  if (value->size == (gsize) -1)
+    {
+      gpointer *children;
+      gsize n_children;
+
+      children = (gpointer *) value->contents.tree.children;
+      n_children = value->contents.tree.n_children;
+      value->size = g_variant_serialiser_needed_size (value->type_info,
+                                                      g_variant_fill_gvs,
+                                                      children, n_children);
+    }
+}
+
+/* < private >
+ * g_variant_serialise:
+ * @value: a #GVariant
+ * @data: an appropriately-sized buffer
+ *
+ * Serializes @value into @data.  @value must be in tree form.
+ *
+ * No change is made to @value.
+ *
+ * The current thread must hold the lock on @value.
+ */
+static void
+g_variant_serialise (GVariant *value,
+                     gpointer  data)
+{
+  GVariantSerialised serialised = { 0, };
+  gpointer *children;
+  gsize n_children;
+
+  g_assert (~value->state & STATE_SERIALISED);
+  g_assert (value->state & STATE_LOCKED);
+
+  serialised.type_info = value->type_info;
+  serialised.size = value->size;
+  serialised.data = data;
+  serialised.depth = value->depth;
+
+  children = (gpointer *) value->contents.tree.children;
+  n_children = value->contents.tree.n_children;
+
+  g_variant_serialiser_serialise (serialised, g_variant_fill_gvs,
+                                  children, n_children);
+}
+
+/* < private >
+ * g_variant_fill_gvs:
+ * @serialised: a pointer to a #GVariantSerialised
+ * @data: a #GVariant instance
+ *
+ * This is the callback that is passed by a tree-form container instance
+ * to the serializer.  This callback gets called on each child of the
+ * container.  Each child is responsible for performing the following
+ * actions:
+ *
+ *  - reporting its type
+ *
+ *  - reporting its serialized size (requires knowing the size first)
+ *
+ *  - possibly storing its serialized form into the provided buffer
+ */
+static void
+g_variant_fill_gvs (GVariantSerialised *serialised,
+                    gpointer            data)
+{
+  GVariant *value = data;
+
+  g_variant_lock (value);
+  g_variant_ensure_size (value);
+  g_variant_unlock (value);
+
+  if (serialised->type_info == NULL)
+    serialised->type_info = value->type_info;
+  g_assert (serialised->type_info == value->type_info);
+
+  if (serialised->size == 0)
+    serialised->size = value->size;
+  g_assert (serialised->size == value->size);
+  serialised->depth = value->depth;
+
+  if (serialised->data)
+    /* g_variant_store() is a public API, so it
+     * it will reacquire the lock if it needs to.
+     */
+    g_variant_store (value, serialised->data);
+}
+
+/* this ends the main body of the recursive serializer */
+
+/* < private >
+ * g_variant_ensure_serialised:
+ * @value: a #GVariant
+ *
+ * Ensures that @value is in serialized form.
+ *
+ * If @value is in tree form then this function ensures that the
+ * serialized size is known and then allocates a buffer of that size and
+ * serializes the instance into the buffer.  The 'children' array is
+ * then released and the instance is set to serialized form based on the
+ * contents of the buffer.
+ *
+ * The current thread must hold the lock on @value.
+ */
+static void
+g_variant_ensure_serialised (GVariant *value)
+{
+  g_assert (value->state & STATE_LOCKED);
+
+  if (~value->state & STATE_SERIALISED)
+    {
+      GBytes *bytes;
+      gpointer data;
+
+      g_variant_ensure_size (value);
+      data = g_malloc (value->size);
+      g_variant_serialise (value, data);
+
+      g_variant_release_children (value);
+
+      bytes = g_bytes_new_take (data, value->size);
+      value->contents.serialised.data = g_bytes_get_data (bytes, NULL);
+      value->contents.serialised.bytes = bytes;
+      value->state |= STATE_SERIALISED;
+    }
+}
+
+/* < private >
+ * g_variant_alloc:
+ * @type: the type of the new instance
+ * @serialised: if the instance will be in serialised form
+ * @trusted: if the instance will be trusted
+ *
+ * Allocates a #GVariant instance and does some common work (such as
+ * looking up and filling in the type info), setting the state field,
+ * and setting the ref_count to 1.
+ *
+ * Returns: a new #GVariant with a floating reference
+ */
+static GVariant *
+g_variant_alloc (const GVariantType *type,
+                 gboolean            serialised,
+                 gboolean            trusted)
+{
+  GVariant *value;
+
+  value = g_slice_new (GVariant);
+  value->type_info = g_variant_type_info_get (type);
+  value->state = (serialised ? STATE_SERIALISED : 0) |
+                 (trusted ? STATE_TRUSTED : 0) |
+                 STATE_FLOATING;
+  value->size = (gssize) -1;
+  g_atomic_ref_count_init (&value->ref_count);
+  value->depth = 0;
+
+  return value;
+}
+
+/**
+ * g_variant_new_from_bytes:
+ * @type: a #GVariantType
+ * @bytes: a #GBytes
+ * @trusted: if the contents of @bytes are trusted
+ *
+ * Constructs a new serialized-mode #GVariant instance.  This is the
+ * inner interface for creation of new serialized values that gets
+ * called from various functions in gvariant.c.
+ *
+ * A reference is taken on @bytes.
+ *
+ * The data in @bytes must be aligned appropriately for the @type being loaded.
+ * Otherwise this function will internally create a copy of the memory (since
+ * GLib 2.60) or (in older versions) fail and exit the process.
+ *
+ * Returns: (transfer none): a new #GVariant with a floating reference
+ *
+ * Since: 2.36
+ */
+GVariant *
+g_variant_new_from_bytes (const GVariantType *type,
+                          GBytes             *bytes,
+                          gboolean            trusted)
+{
+  GVariant *value;
+  guint alignment;
+  gsize size;
+  GBytes *owned_bytes = NULL;
+  GVariantSerialised serialised;
+
+  value = g_variant_alloc (type, TRUE, trusted);
+
+  g_variant_type_info_query (value->type_info,
+                             &alignment, &size);
+
+  /* Ensure the alignment is correct. This is a huge performance hit if it’s
+   * not correct, but that’s better than aborting if a caller provides data
+   * with the wrong alignment (which is likely to happen very occasionally, and
+   * only cause an abort on some architectures — so is unlikely to be caught
+   * in testing). Callers can always actively ensure they use the correct
+   * alignment to avoid the performance hit. */
+  serialised.type_info = value->type_info;
+  serialised.data = (guchar *) g_bytes_get_data (bytes, &serialised.size);
+  serialised.depth = 0;
+
+  if (!g_variant_serialised_check (serialised))
+    {
+#ifdef HAVE_POSIX_MEMALIGN
+      gpointer aligned_data = NULL;
+      gsize aligned_size = g_bytes_get_size (bytes);
+
+      /* posix_memalign() requires the alignment to be a multiple of
+       * sizeof(void*), and a power of 2. See g_variant_type_info_query() for
+       * details on the alignment format. */
+      if (posix_memalign (&aligned_data, MAX (sizeof (void *), alignment + 1),
+                          aligned_size) != 0)
+        g_error ("posix_memalign failed");
+
+      if (aligned_size != 0)
+        memcpy (aligned_data, g_bytes_get_data (bytes, NULL), aligned_size);
+
+      bytes = owned_bytes = g_bytes_new_with_free_func (aligned_data,
+                                                        aligned_size,
+                                                        free, aligned_data);
+      aligned_data = NULL;
+#else
+      /* NOTE: there may be platforms that lack posix_memalign() and also
+       * have malloc() that returns non-8-aligned.  if so, we need to try
+       * harder here.
+       */
+      bytes = owned_bytes = g_bytes_new (g_bytes_get_data (bytes, NULL),
+                                         g_bytes_get_size (bytes));
+#endif
+    }
+
+  value->contents.serialised.bytes = g_bytes_ref (bytes);
+
+  if (size && g_bytes_get_size (bytes) != size)
+    {
+      /* Creating a fixed-sized GVariant with a bytes of the wrong
+       * size.
+       *
+       * We should do the equivalent of pulling a fixed-sized child out
+       * of a brozen container (ie: data is NULL size is equal to the correct
+       * fixed size).
+       */
+      value->contents.serialised.data = NULL;
+      value->size = size;
+    }
+  else
+    {
+      value->contents.serialised.data = g_bytes_get_data (bytes, &value->size);
+    }
+
+  g_clear_pointer (&owned_bytes, g_bytes_unref);
+
+  return value;
+}
+
+/* -- internal -- */
+
+/* < internal >
+ * g_variant_new_from_children:
+ * @type: a #GVariantType
+ * @children: an array of #GVariant pointers.  Consumed.
+ * @n_children: the length of @children
+ * @trusted: %TRUE if every child in @children in trusted
+ *
+ * Constructs a new tree-mode #GVariant instance.  This is the inner
+ * interface for creation of new serialized values that gets called from
+ * various functions in gvariant.c.
+ *
+ * @children is consumed by this function.  g_free() will be called on
+ * it some time later.
+ *
+ * Returns: a new #GVariant with a floating reference
+ */
+GVariant *
+g_variant_new_from_children (const GVariantType  *type,
+                             GVariant           **children,
+                             gsize                n_children,
+                             gboolean             trusted)
+{
+  GVariant *value;
+
+  value = g_variant_alloc (type, FALSE, trusted);
+  value->contents.tree.children = children;
+  value->contents.tree.n_children = n_children;
+
+  return value;
+}
+
+/* < internal >
+ * g_variant_get_type_info:
+ * @value: a #GVariant
+ *
+ * Returns the #GVariantTypeInfo corresponding to the type of @value.  A
+ * reference is not added, so the return value is only good for the
+ * duration of the life of @value.
+ *
+ * Returns: the #GVariantTypeInfo for @value
+ */
+GVariantTypeInfo *
+g_variant_get_type_info (GVariant *value)
+{
+  return value->type_info;
+}
+
+/* < internal >
+ * g_variant_is_trusted:
+ * @value: a #GVariant
+ *
+ * Determines if @value is trusted by #GVariant to contain only
+ * fully-valid data.  All values constructed solely via #GVariant APIs
+ * are trusted, but values containing data read in from other sources
+ * are usually not trusted.
+ *
+ * The main advantage of trusted data is that certain checks can be
+ * skipped.  For example, we don't need to check that a string is
+ * properly nul-terminated or that an object path is actually a
+ * properly-formatted object path.
+ *
+ * Returns: if @value is trusted
+ */
+gboolean
+g_variant_is_trusted (GVariant *value)
+{
+  return (value->state & STATE_TRUSTED) != 0;
+}
+
+/* < internal >
+ * g_variant_get_depth:
+ * @value: a #GVariant
+ *
+ * Gets the nesting depth of a #GVariant. This is 0 for a #GVariant with no
+ * children.
+ *
+ * Returns: nesting depth of @value
+ */
+gsize
+g_variant_get_depth (GVariant *value)
+{
+  return value->depth;
+}
+
+/* -- public -- */
+
+/**
+ * g_variant_unref:
+ * @value: a #GVariant
+ *
+ * Decreases the reference count of @value.  When its reference count
+ * drops to 0, the memory used by the variant is freed.
+ *
+ * Since: 2.24
+ **/
+void
+g_variant_unref (GVariant *value)
+{
+  g_return_if_fail (value != NULL);
+
+  if (g_atomic_ref_count_dec (&value->ref_count))
+    {
+      if G_UNLIKELY (value->state & STATE_LOCKED)
+        g_critical ("attempting to free a locked GVariant instance.  "
+                    "This should never happen.");
+
+      value->state |= STATE_LOCKED;
+
+      g_variant_type_info_unref (value->type_info);
+
+      if (value->state & STATE_SERIALISED)
+        g_bytes_unref (value->contents.serialised.bytes);
+      else
+        g_variant_release_children (value);
+
+      memset (value, 0, sizeof (GVariant));
+      g_slice_free (GVariant, value);
+    }
+}
+
+/**
+ * g_variant_ref:
+ * @value: a #GVariant
+ *
+ * Increases the reference count of @value.
+ *
+ * Returns: the same @value
+ *
+ * Since: 2.24
+ **/
+GVariant *
+g_variant_ref (GVariant *value)
+{
+  g_return_val_if_fail (value != NULL, NULL);
+
+  g_atomic_ref_count_inc (&value->ref_count);
+
+  return value;
+}
+
+/**
+ * g_variant_ref_sink:
+ * @value: a #GVariant
+ *
+ * #GVariant uses a floating reference count system.  All functions with
+ * names starting with `g_variant_new_` return floating
+ * references.
+ *
+ * Calling g_variant_ref_sink() on a #GVariant with a floating reference
+ * will convert the floating reference into a full reference.  Calling
+ * g_variant_ref_sink() on a non-floating #GVariant results in an
+ * additional normal reference being added.
+ *
+ * In other words, if the @value is floating, then this call "assumes
+ * ownership" of the floating reference, converting it to a normal
+ * reference.  If the @value is not floating, then this call adds a
+ * new normal reference increasing the reference count by one.
+ *
+ * All calls that result in a #GVariant instance being inserted into a
+ * container will call g_variant_ref_sink() on the instance.  This means
+ * that if the value was just created (and has only its floating
+ * reference) then the container will assume sole ownership of the value
+ * at that point and the caller will not need to unreference it.  This
+ * makes certain common styles of programming much easier while still
+ * maintaining normal refcounting semantics in situations where values
+ * are not floating.
+ *
+ * Returns: the same @value
+ *
+ * Since: 2.24
+ **/
+GVariant *
+g_variant_ref_sink (GVariant *value)
+{
+  g_return_val_if_fail (value != NULL, NULL);
+  g_return_val_if_fail (!g_atomic_ref_count_compare (&value->ref_count, 0), NULL);
+
+  g_variant_lock (value);
+
+  if (~value->state & STATE_FLOATING)
+    g_variant_ref (value);
+  else
+    value->state &= ~STATE_FLOATING;
+
+  g_variant_unlock (value);
+
+  return value;
+}
+
+/**
+ * g_variant_take_ref:
+ * @value: a #GVariant
+ *
+ * If @value is floating, sink it.  Otherwise, do nothing.
+ *
+ * Typically you want to use g_variant_ref_sink() in order to
+ * automatically do the correct thing with respect to floating or
+ * non-floating references, but there is one specific scenario where
+ * this function is helpful.
+ *
+ * The situation where this function is helpful is when creating an API
+ * that allows the user to provide a callback function that returns a
+ * #GVariant.  We certainly want to allow the user the flexibility to
+ * return a non-floating reference from this callback (for the case
+ * where the value that is being returned already exists).
+ *
+ * At the same time, the style of the #GVariant API makes it likely that
+ * for newly-created #GVariant instances, the user can be saved some
+ * typing if they are allowed to return a #GVariant with a floating
+ * reference.
+ *
+ * Using this function on the return value of the user's callback allows
+ * the user to do whichever is more convenient for them.  The caller
+ * will always receives exactly one full reference to the value: either
+ * the one that was returned in the first place, or a floating reference
+ * that has been converted to a full reference.
+ *
+ * This function has an odd interaction when combined with
+ * g_variant_ref_sink() running at the same time in another thread on
+ * the same #GVariant instance.  If g_variant_ref_sink() runs first then
+ * the result will be that the floating reference is converted to a hard
+ * reference.  If g_variant_take_ref() runs first then the result will
+ * be that the floating reference is converted to a hard reference and
+ * an additional reference on top of that one is added.  It is best to
+ * avoid this situation.
+ *
+ * Returns: the same @value
+ **/
+GVariant *
+g_variant_take_ref (GVariant *value)
+{
+  g_return_val_if_fail (value != NULL, NULL);
+  g_return_val_if_fail (!g_atomic_ref_count_compare (&value->ref_count, 0), NULL);
+
+  g_atomic_int_and (&value->state, ~STATE_FLOATING);
+
+  return value;
+}
+
+/**
+ * g_variant_is_floating:
+ * @value: a #GVariant
+ *
+ * Checks whether @value has a floating reference count.
+ *
+ * This function should only ever be used to assert that a given variant
+ * is or is not floating, or for debug purposes. To acquire a reference
+ * to a variant that might be floating, always use g_variant_ref_sink()
+ * or g_variant_take_ref().
+ *
+ * See g_variant_ref_sink() for more information about floating reference
+ * counts.
+ *
+ * Returns: whether @value is floating
+ *
+ * Since: 2.26
+ **/
+gboolean
+g_variant_is_floating (GVariant *value)
+{
+  g_return_val_if_fail (value != NULL, FALSE);
+
+  return (value->state & STATE_FLOATING) != 0;
+}
+
+/**
+ * g_variant_get_size:
+ * @value: a #GVariant instance
+ *
+ * Determines the number of bytes that would be required to store @value
+ * with g_variant_store().
+ *
+ * If @value has a fixed-sized type then this function always returned
+ * that fixed size.
+ *
+ * In the case that @value is already in serialized form or the size has
+ * already been calculated (ie: this function has been called before)
+ * then this function is O(1).  Otherwise, the size is calculated, an
+ * operation which is approximately O(n) in the number of values
+ * involved.
+ *
+ * Returns: the serialized size of @value
+ *
+ * Since: 2.24
+ **/
+gsize
+g_variant_get_size (GVariant *value)
+{
+  g_variant_lock (value);
+  g_variant_ensure_size (value);
+  g_variant_unlock (value);
+
+  return value->size;
+}
+
+/**
+ * g_variant_get_data:
+ * @value: a #GVariant instance
+ *
+ * Returns a pointer to the serialized form of a #GVariant instance.
+ * The returned data may not be in fully-normalised form if read from an
+ * untrusted source.  The returned data must not be freed; it remains
+ * valid for as long as @value exists.
+ *
+ * If @value is a fixed-sized value that was deserialized from a
+ * corrupted serialized container then %NULL may be returned.  In this
+ * case, the proper thing to do is typically to use the appropriate
+ * number of nul bytes in place of @value.  If @value is not fixed-sized
+ * then %NULL is never returned.
+ *
+ * In the case that @value is already in serialized form, this function
+ * is O(1).  If the value is not already in serialized form,
+ * serialization occurs implicitly and is approximately O(n) in the size
+ * of the result.
+ *
+ * To deserialize the data returned by this function, in addition to the
+ * serialized data, you must know the type of the #GVariant, and (if the
+ * machine might be different) the endianness of the machine that stored
+ * it. As a result, file formats or network messages that incorporate
+ * serialized #GVariants must include this information either
+ * implicitly (for instance "the file always contains a
+ * %G_VARIANT_TYPE_VARIANT and it is always in little-endian order") or
+ * explicitly (by storing the type and/or endianness in addition to the
+ * serialized data).
+ *
+ * Returns: (transfer none): the serialized form of @value, or %NULL
+ *
+ * Since: 2.24
+ **/
+gconstpointer
+g_variant_get_data (GVariant *value)
+{
+  g_variant_lock (value);
+  g_variant_ensure_serialised (value);
+  g_variant_unlock (value);
+
+  return value->contents.serialised.data;
+}
+
+/**
+ * g_variant_get_data_as_bytes:
+ * @value: a #GVariant
+ *
+ * Returns a pointer to the serialized form of a #GVariant instance.
+ * The semantics of this function are exactly the same as
+ * g_variant_get_data(), except that the returned #GBytes holds
+ * a reference to the variant data.
+ *
+ * Returns: (transfer full): A new #GBytes representing the variant data
+ *
+ * Since: 2.36
+ */ 
+GBytes *
+g_variant_get_data_as_bytes (GVariant *value)
+{
+  const gchar *bytes_data;
+  const gchar *data;
+  gsize bytes_size;
+  gsize size;
+
+  g_variant_lock (value);
+  g_variant_ensure_serialised (value);
+  g_variant_unlock (value);
+
+  bytes_data = g_bytes_get_data (value->contents.serialised.bytes, &bytes_size);
+  data = value->contents.serialised.data;
+  size = value->size;
+
+  if (data == NULL)
+    {
+      g_assert (size == 0);
+      data = bytes_data;
+    }
+
+  if (data == bytes_data && size == bytes_size)
+    return g_bytes_ref (value->contents.serialised.bytes);
+  else
+    return g_bytes_new_from_bytes (value->contents.serialised.bytes,
+                                   data - bytes_data, size);
+}
+
+
+/**
+ * g_variant_n_children:
+ * @value: a container #GVariant
+ *
+ * Determines the number of children in a container #GVariant instance.
+ * This includes variants, maybes, arrays, tuples and dictionary
+ * entries.  It is an error to call this function on any other type of
+ * #GVariant.
+ *
+ * For variants, the return value is always 1.  For values with maybe
+ * types, it is always zero or one.  For arrays, it is the length of the
+ * array.  For tuples it is the number of tuple items (which depends
+ * only on the type).  For dictionary entries, it is always 2
+ *
+ * This function is O(1).
+ *
+ * Returns: the number of children in the container
+ *
+ * Since: 2.24
+ **/
+gsize
+g_variant_n_children (GVariant *value)
+{
+  gsize n_children;
+
+  g_variant_lock (value);
+
+  if (value->state & STATE_SERIALISED)
+    {
+      GVariantSerialised serialised = {
+        value->type_info,
+        (gpointer) value->contents.serialised.data,
+        value->size,
+        value->depth,
+      };
+
+      n_children = g_variant_serialised_n_children (serialised);
+    }
+  else
+    n_children = value->contents.tree.n_children;
+
+  g_variant_unlock (value);
+
+  return n_children;
+}
+
+/**
+ * g_variant_get_child_value:
+ * @value: a container #GVariant
+ * @index_: the index of the child to fetch
+ *
+ * Reads a child item out of a container #GVariant instance.  This
+ * includes variants, maybes, arrays, tuples and dictionary
+ * entries.  It is an error to call this function on any other type of
+ * #GVariant.
+ *
+ * It is an error if @index_ is greater than the number of child items
+ * in the container.  See g_variant_n_children().
+ *
+ * The returned value is never floating.  You should free it with
+ * g_variant_unref() when you're done with it.
+ *
+ * Note that values borrowed from the returned child are not guaranteed to
+ * still be valid after the child is freed even if you still hold a reference
+ * to @value, if @value has not been serialized at the time this function is
+ * called. To avoid this, you can serialize @value by calling
+ * g_variant_get_data() and optionally ignoring the return value.
+ *
+ * There may be implementation specific restrictions on deeply nested values,
+ * which would result in the unit tuple being returned as the child value,
+ * instead of further nested children. #GVariant is guaranteed to handle
+ * nesting up to at least 64 levels.
+ *
+ * This function is O(1).
+ *
+ * Returns: (transfer full): the child at the specified index
+ *
+ * Since: 2.24
+ **/
+GVariant *
+g_variant_get_child_value (GVariant *value,
+                           gsize     index_)
+{
+  g_return_val_if_fail (index_ < g_variant_n_children (value), NULL);
+  g_return_val_if_fail (value->depth < G_MAXSIZE, NULL);
+
+  if (~g_atomic_int_get (&value->state) & STATE_SERIALISED)
+    {
+      g_variant_lock (value);
+
+      if (~value->state & STATE_SERIALISED)
+        {
+          GVariant *child;
+
+          child = g_variant_ref (value->contents.tree.children[index_]);
+          g_variant_unlock (value);
+
+          return child;
+        }
+
+      g_variant_unlock (value);
+    }
+
+  {
+    GVariantSerialised serialised = {
+      value->type_info,
+      (gpointer) value->contents.serialised.data,
+      value->size,
+      value->depth,
+    };
+    GVariantSerialised s_child;
+    GVariant *child;
+
+    /* get the serializer to extract the serialized data for the child
+     * from the serialized data for the container
+     */
+    s_child = g_variant_serialised_get_child (serialised, index_);
+
+    /* Check whether this would cause nesting too deep. If so, return a fake
+     * child. The only situation we expect this to happen in is with a variant,
+     * as all other deeply-nested types have a static type, and hence should
+     * have been rejected earlier. In the case of a variant whose nesting plus
+     * the depth of its child is too great, return a unit variant () instead of
+     * the real child. */
+    if (!(value->state & STATE_TRUSTED) &&
+        g_variant_type_info_query_depth (s_child.type_info) >=
+        G_VARIANT_MAX_RECURSION_DEPTH - value->depth)
+      {
+        g_assert (g_variant_is_of_type (value, G_VARIANT_TYPE_VARIANT));
+        return g_variant_new_tuple (NULL, 0);
+      }
+
+    /* create a new serialized instance out of it */
+    child = g_slice_new (GVariant);
+    child->type_info = s_child.type_info;
+    child->state = (value->state & STATE_TRUSTED) |
+                   STATE_SERIALISED;
+    child->size = s_child.size;
+    g_atomic_ref_count_init (&child->ref_count);
+    child->depth = value->depth + 1;
+    child->contents.serialised.bytes =
+      g_bytes_ref (value->contents.serialised.bytes);
+    child->contents.serialised.data = s_child.data;
+
+    return child;
+  }
+}
+
+/**
+ * g_variant_store:
+ * @value: the #GVariant to store
+ * @data: (not nullable): the location to store the serialized data at
+ *
+ * Stores the serialized form of @value at @data.  @data should be
+ * large enough.  See g_variant_get_size().
+ *
+ * The stored data is in machine native byte order but may not be in
+ * fully-normalised form if read from an untrusted source.  See
+ * g_variant_get_normal_form() for a solution.
+ *
+ * As with g_variant_get_data(), to be able to deserialize the
+ * serialized variant successfully, its type and (if the destination
+ * machine might be different) its endianness must also be available.
+ *
+ * This function is approximately O(n) in the size of @data.
+ *
+ * Since: 2.24
+ **/
+void
+g_variant_store (GVariant *value,
+                 gpointer  data)
+{
+  g_variant_lock (value);
+
+  if (value->state & STATE_SERIALISED)
+    {
+      if (value->contents.serialised.data != NULL)
+        memcpy (data, value->contents.serialised.data, value->size);
+      else
+        memset (data, 0, value->size);
+    }
+  else
+    g_variant_serialise (value, data);
+
+  g_variant_unlock (value);
+}
+
+/**
+ * g_variant_is_normal_form:
+ * @value: a #GVariant instance
+ *
+ * Checks if @value is in normal form.
+ *
+ * The main reason to do this is to detect if a given chunk of
+ * serialized data is in normal form: load the data into a #GVariant
+ * using g_variant_new_from_data() and then use this function to
+ * check.
+ *
+ * If @value is found to be in normal form then it will be marked as
+ * being trusted.  If the value was already marked as being trusted then
+ * this function will immediately return %TRUE.
+ *
+ * There may be implementation specific restrictions on deeply nested values.
+ * GVariant is guaranteed to handle nesting up to at least 64 levels.
+ *
+ * Returns: %TRUE if @value is in normal form
+ *
+ * Since: 2.24
+ **/
+gboolean
+g_variant_is_normal_form (GVariant *value)
+{
+  if (value->state & STATE_TRUSTED)
+    return TRUE;
+
+  g_variant_lock (value);
+
+  if (value->depth >= G_VARIANT_MAX_RECURSION_DEPTH)
+    return FALSE;
+
+  if (value->state & STATE_SERIALISED)
+    {
+      GVariantSerialised serialised = {
+        value->type_info,
+        (gpointer) value->contents.serialised.data,
+        value->size,
+        value->depth
+      };
+
+      if (g_variant_serialised_is_normal (serialised))
+        value->state |= STATE_TRUSTED;
+    }
+  else
+    {
+      gboolean normal = TRUE;
+      gsize i;
+
+      for (i = 0; i < value->contents.tree.n_children; i++)
+        normal &= g_variant_is_normal_form (value->contents.tree.children[i]);
+
+      if (normal)
+        value->state |= STATE_TRUSTED;
+    }
+
+  g_variant_unlock (value);
+
+  return (value->state & STATE_TRUSTED) != 0;
+}
diff --git a/glib/gvariant-core.h b/glib/gvariant-core.h
index fc04711..947a98c 100644
--- a/glib/gvariant-core.h
+++ b/glib/gvariant-core.h
@@ -36,4 +36,7 @@ GVariantTypeInfo *      g_variant_get_type_info                         (GVarian
 
 gsize                   g_variant_get_depth                             (GVariant            *value);
 
+GVariant *              g_variant_maybe_get_child_value                 (GVariant            *value,
+                                                                         gsize                index_);
+
 #endif /* __G_VARIANT_CORE_H__ */
diff --git a/glib/gvariant-core.h.orig b/glib/gvariant-core.h.orig
new file mode 100644
index 0000000..fc04711
--- /dev/null
+++ b/glib/gvariant-core.h.orig
@@ -0,0 +1,39 @@
+/*
+ * Copyright © 2007, 2008 Ryan Lortie
+ * Copyright © 2010 Codethink Limited
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __G_VARIANT_CORE_H__
+#define __G_VARIANT_CORE_H__
+
+#include <glib/gvarianttypeinfo.h>
+#include <glib/gvariant.h>
+#include <glib/gbytes.h>
+
+/* gvariant-core.c */
+
+GVariant *              g_variant_new_from_children                     (const GVariantType  *type,
+                                                                         GVariant           **children,
+                                                                         gsize                n_children,
+                                                                         gboolean             trusted);
+
+gboolean                g_variant_is_trusted                            (GVariant            *value);
+
+GVariantTypeInfo *      g_variant_get_type_info                         (GVariant            *value);
+
+gsize                   g_variant_get_depth                             (GVariant            *value);
+
+#endif /* __G_VARIANT_CORE_H__ */
diff --git a/glib/gvariant-serialiser.c b/glib/gvariant-serialiser.c
index 832a8fd..5915bcd 100644
--- a/glib/gvariant-serialiser.c
+++ b/glib/gvariant-serialiser.c
@@ -1,6 +1,7 @@
 /*
  * Copyright © 2007, 2008 Ryan Lortie
  * Copyright © 2010 Codethink Limited
+ * Copyright © 2020 William Manley
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -119,6 +120,8 @@
  *
  * @depth has no restrictions; the depth of a top-level serialized #GVariant is
  * zero, and it increases for each level of nested child.
+ *
+ * @checked_offsets_up_to is always ≥ @ordered_offsets_up_to
  */
 
 /* < private >
@@ -146,6 +149,9 @@ g_variant_serialised_check (GVariantSerialised serialised)
            !(serialised.size == 0 || serialised.data != NULL))
     return FALSE;
 
+  if (serialised.ordered_offsets_up_to > serialised.checked_offsets_up_to)
+    return FALSE;
+
   /* Depending on the native alignment requirements of the machine, the
    * compiler will insert either 3 or 7 padding bytes after the char.
    * This will result in the sizeof() the struct being 12 or 16.
@@ -264,6 +270,8 @@ gvs_fixed_sized_maybe_get_child (GVariantSerialised value,
   value.type_info = g_variant_type_info_element (value.type_info);
   g_variant_type_info_ref (value.type_info);
   value.depth++;
+  value.ordered_offsets_up_to = 0;
+  value.checked_offsets_up_to = 0;
 
   return value;
 }
@@ -295,7 +303,7 @@ gvs_fixed_sized_maybe_serialise (GVariantSerialised        value,
 {
   if (n_children)
     {
-      GVariantSerialised child = { NULL, value.data, value.size, value.depth + 1 };
+      GVariantSerialised child = { NULL, value.data, value.size, value.depth + 1, 0, 0 };
 
       gvs_filler (&child, children[0]);
     }
@@ -317,6 +325,8 @@ gvs_fixed_sized_maybe_is_normal (GVariantSerialised value)
       /* proper element size: "Just".  recurse to the child. */
       value.type_info = g_variant_type_info_element (value.type_info);
       value.depth++;
+      value.ordered_offsets_up_to = 0;
+      value.checked_offsets_up_to = 0;
 
       return g_variant_serialised_is_normal (value);
     }
@@ -358,6 +368,8 @@ gvs_variable_sized_maybe_get_child (GVariantSerialised value,
     value.data = NULL;
 
   value.depth++;
+  value.ordered_offsets_up_to = 0;
+  value.checked_offsets_up_to = 0;
 
   return value;
 }
@@ -388,7 +400,7 @@ gvs_variable_sized_maybe_serialise (GVariantSerialised        value,
 {
   if (n_children)
     {
-      GVariantSerialised child = { NULL, value.data, value.size - 1, value.depth + 1 };
+      GVariantSerialised child = { NULL, value.data, value.size - 1, value.depth + 1, 0, 0 };
 
       /* write the data for the child.  */
       gvs_filler (&child, children[0]);
@@ -408,6 +420,8 @@ gvs_variable_sized_maybe_is_normal (GVariantSerialised value)
   value.type_info = g_variant_type_info_element (value.type_info);
   value.size--;
   value.depth++;
+  value.ordered_offsets_up_to = 0;
+  value.checked_offsets_up_to = 0;
 
   return g_variant_serialised_is_normal (value);
 }
@@ -633,39 +647,102 @@ gvs_calculate_total_size (gsize body_size,
   return body_size + 8 * offsets;
 }
 
+struct Offsets
+{
+  gsize     data_size;
+
+  guchar   *array;
+  gsize     length;
+  guint     offset_size;
+
+  gboolean  is_normal;
+};
+
 static gsize
-gvs_variable_sized_array_n_children (GVariantSerialised value)
+gvs_offsets_get_offset_n (struct Offsets *offsets,
+                          gsize           n)
+{
+  return gvs_read_unaligned_le (
+      offsets->array + (offsets->offset_size * n), offsets->offset_size);
+}
+
+static struct Offsets
+gvs_variable_sized_array_get_frame_offsets (GVariantSerialised value)
 {
+  struct Offsets out = { 0, };
   gsize offsets_array_size;
-  gsize offset_size;
   gsize last_end;
 
   if (value.size == 0)
-    return 0;
-
-  offset_size = gvs_get_offset_size (value.size);
+    {
+      out.is_normal = TRUE;
+      return out;
+    }
 
-  last_end = gvs_read_unaligned_le (value.data + value.size -
-                                    offset_size, offset_size);
+  out.offset_size = gvs_get_offset_size (value.size);
+  last_end = gvs_read_unaligned_le (value.data + value.size - out.offset_size,
+                                    out.offset_size);
 
   if (last_end > value.size)
-    return 0;
+    return out;  /* offsets not normal */
 
   offsets_array_size = value.size - last_end;
 
-  if (offsets_array_size % offset_size)
-    return 0;
+  if (offsets_array_size % out.offset_size)
+    return out;  /* offsets not normal */
+
+  out.data_size = last_end;
+  out.array = value.data + last_end;
+  out.length = offsets_array_size / out.offset_size;
+
+  if (out.length > 0 && gvs_calculate_total_size (last_end, out.length) != value.size)
+    return out;  /* offset size not minimal */
 
-  return offsets_array_size / offset_size;
+  out.is_normal = TRUE;
+
+  return out;
+}
+
+static gsize
+gvs_variable_sized_array_n_children (GVariantSerialised value)
+{
+  return gvs_variable_sized_array_get_frame_offsets (value).length;
 }
 
+/* Find the index of the first out-of-order element in @data, assuming that
+ * @data is an array of elements of given @type, starting at index @start and
+ * containing a further @len-@start elements. */
+#define DEFINE_FIND_UNORDERED(type) \
+  static gsize \
+  find_unordered_##type (const guint8 *data, gsize start, gsize len) \
+  { \
+    gsize off; \
+    type current, previous; \
+    \
+    memcpy (&previous, data + start * sizeof (current), sizeof (current)); \
+    for (off = (start + 1) * sizeof (current); off < len * sizeof (current); off += sizeof (current)) \
+      { \
+        memcpy (&current, data + off, sizeof (current)); \
+        if (current < previous) \
+          break; \
+        previous = current; \
+      } \
+    return off / sizeof (current) - 1; \
+  }
+
+DEFINE_FIND_UNORDERED (guint8);
+DEFINE_FIND_UNORDERED (guint16);
+DEFINE_FIND_UNORDERED (guint32);
+DEFINE_FIND_UNORDERED (guint64);
+
 static GVariantSerialised
 gvs_variable_sized_array_get_child (GVariantSerialised value,
                                     gsize              index_)
 {
   GVariantSerialised child = { 0, };
-  gsize offset_size;
-  gsize last_end;
+
+  struct Offsets offsets = gvs_variable_sized_array_get_frame_offsets (value);
+
   gsize start;
   gsize end;
 
@@ -673,18 +750,61 @@ gvs_variable_sized_array_get_child (GVariantSerialised value,
   g_variant_type_info_ref (child.type_info);
   child.depth = value.depth + 1;
 
-  offset_size = gvs_get_offset_size (value.size);
+  /* If the requested @index_ is beyond the set of indices whose framing offsets
+   * have been checked, check the remaining offsets to see whether they’re
+   * normal (in order, no overlapping array elements).
+   *
+   * Don’t bother checking if the highest known-good offset is lower than the
+   * highest checked offset, as that means there’s an invalid element at that
+   * index, so there’s no need to check further. */
+  if (index_ > value.checked_offsets_up_to &&
+      value.ordered_offsets_up_to == value.checked_offsets_up_to)
+    {
+      switch (offsets.offset_size)
+        {
+        case 1:
+          {
+            value.ordered_offsets_up_to = find_unordered_guint8 (
+                offsets.array, value.checked_offsets_up_to, index_ + 1);
+            break;
+          }
+        case 2:
+          {
+            value.ordered_offsets_up_to = find_unordered_guint16 (
+                offsets.array, value.checked_offsets_up_to, index_ + 1);
+            break;
+          }
+        case 4:
+          {
+            value.ordered_offsets_up_to = find_unordered_guint32 (
+                offsets.array, value.checked_offsets_up_to, index_ + 1);
+            break;
+          }
+        case 8:
+          {
+            value.ordered_offsets_up_to = find_unordered_guint64 (
+                offsets.array, value.checked_offsets_up_to, index_ + 1);
+            break;
+          }
+        default:
+          /* gvs_get_offset_size() only returns maximum 8 */
+          g_assert_not_reached ();
+        }
 
-  last_end = gvs_read_unaligned_le (value.data + value.size -
-                                    offset_size, offset_size);
+      value.checked_offsets_up_to = index_;
+    }
+
+  if (index_ > value.ordered_offsets_up_to)
+    {
+      /* Offsets are invalid somewhere, so return an empty child. */
+      return child;
+    }
 
   if (index_ > 0)
     {
       guint alignment;
 
-      start = gvs_read_unaligned_le (value.data + last_end +
-                                     (offset_size * (index_ - 1)),
-                                     offset_size);
+      start = gvs_offsets_get_offset_n (&offsets, index_ - 1);
 
       g_variant_type_info_query (child.type_info, &alignment, NULL);
       start += (-start) & alignment;
@@ -692,11 +812,9 @@ gvs_variable_sized_array_get_child (GVariantSerialised value,
   else
     start = 0;
 
-  end = gvs_read_unaligned_le (value.data + last_end +
-                               (offset_size * index_),
-                               offset_size);
+  end = gvs_offsets_get_offset_n (&offsets, index_);
 
-  if (start < end && end <= value.size && end <= last_end)
+  if (start < end && end <= value.size && end <= offsets.data_size)
     {
       child.data = value.data + start;
       child.size = end - start;
@@ -768,34 +886,16 @@ static gboolean
 gvs_variable_sized_array_is_normal (GVariantSerialised value)
 {
   GVariantSerialised child = { 0, };
-  gsize offsets_array_size;
-  guchar *offsets_array;
-  guint offset_size;
   guint alignment;
-  gsize last_end;
-  gsize length;
   gsize offset;
   gsize i;
 
-  if (value.size == 0)
-    return TRUE;
-
-  offset_size = gvs_get_offset_size (value.size);
-  last_end = gvs_read_unaligned_le (value.data + value.size -
-                                    offset_size, offset_size);
-
-  if (last_end > value.size)
-    return FALSE;
-
-  offsets_array_size = value.size - last_end;
+  struct Offsets offsets = gvs_variable_sized_array_get_frame_offsets (value);
 
-  if (offsets_array_size % offset_size)
+  if (!offsets.is_normal)
     return FALSE;
 
-  offsets_array = value.data + value.size - offsets_array_size;
-  length = offsets_array_size / offset_size;
-
-  if (length == 0)
+  if (value.size != 0 && offsets.length == 0)
     return FALSE;
 
   child.type_info = g_variant_type_info_element (value.type_info);
@@ -803,14 +903,14 @@ gvs_variable_sized_array_is_normal (GVariantSerialised value)
   child.depth = value.depth + 1;
   offset = 0;
 
-  for (i = 0; i < length; i++)
+  for (i = 0; i < offsets.length; i++)
     {
       gsize this_end;
 
-      this_end = gvs_read_unaligned_le (offsets_array + offset_size * i,
-                                        offset_size);
+      this_end = gvs_read_unaligned_le (offsets.array + offsets.offset_size * i,
+                                        offsets.offset_size);
 
-      if (this_end < offset || this_end > last_end)
+      if (this_end < offset || this_end > offsets.data_size)
         return FALSE;
 
       while (offset & alignment)
@@ -832,7 +932,11 @@ gvs_variable_sized_array_is_normal (GVariantSerialised value)
       offset = this_end;
     }
 
-  g_assert (offset == last_end);
+  g_assert (offset == offsets.data_size);
+
+  /* All offsets have now been checked. */
+  value.ordered_offsets_up_to = G_MAXSIZE;
+  value.checked_offsets_up_to = G_MAXSIZE;
 
   return TRUE;
 }
@@ -859,6 +963,55 @@ gvs_variable_sized_array_is_normal (GVariantSerialised value)
  * for the tuple.  See the notes in gvarianttypeinfo.h.
  */
 
+/* Note: This doesn’t guarantee that @out_member_end >= @out_member_start; that
+ * condition may not hold true for invalid serialised variants. The caller is
+ * responsible for checking the returned values and handling invalid ones
+ * appropriately. */
+static void
+gvs_tuple_get_member_bounds (GVariantSerialised  value,
+                             gsize               index_,
+                             gsize               offset_size,
+                             gsize              *out_member_start,
+                             gsize              *out_member_end)
+{
+  const GVariantMemberInfo *member_info;
+  gsize member_start, member_end;
+
+  member_info = g_variant_type_info_member_info (value.type_info, index_);
+
+  if (member_info->i + 1)
+    member_start = gvs_read_unaligned_le (value.data + value.size -
+                                          offset_size * (member_info->i + 1),
+                                          offset_size);
+  else
+    member_start = 0;
+
+  member_start += member_info->a;
+  member_start &= member_info->b;
+  member_start |= member_info->c;
+
+  if (member_info->ending_type == G_VARIANT_MEMBER_ENDING_LAST)
+    member_end = value.size - offset_size * (member_info->i + 1);
+
+  else if (member_info->ending_type == G_VARIANT_MEMBER_ENDING_FIXED)
+    {
+      gsize fixed_size;
+
+      g_variant_type_info_query (member_info->type_info, NULL, &fixed_size);
+      member_end = member_start + fixed_size;
+    }
+
+  else /* G_VARIANT_MEMBER_ENDING_OFFSET */
+    member_end = gvs_read_unaligned_le (value.data + value.size -
+                                        offset_size * (member_info->i + 2),
+                                        offset_size);
+
+  if (out_member_start != NULL)
+    *out_member_start = member_start;
+  if (out_member_end != NULL)
+    *out_member_end = member_end;
+}
+
 static gsize
 gvs_tuple_n_children (GVariantSerialised value)
 {
@@ -879,14 +1032,18 @@ gvs_tuple_get_child (GVariantSerialised value,
   child.depth = value.depth + 1;
   offset_size = gvs_get_offset_size (value.size);
 
+  /* Ensure the size is set for fixed-sized children, or
+   * g_variant_serialised_check() will fail, even if we return
+   * (child.data == NULL) to indicate an error. */
+  if (member_info->ending_type == G_VARIANT_MEMBER_ENDING_FIXED)
+    g_variant_type_info_query (child.type_info, NULL, &child.size);
+
   /* tuples are the only (potentially) fixed-sized containers, so the
    * only ones that have to deal with the possibility of having %NULL
    * data with a non-zero %size if errors occurred elsewhere.
    */
   if G_UNLIKELY (value.data == NULL && value.size != 0)
     {
-      g_variant_type_info_query (child.type_info, NULL, &child.size);
-
       /* this can only happen in fixed-sized tuples,
        * so the child must also be fixed sized.
        */
@@ -896,63 +1053,58 @@ gvs_tuple_get_child (GVariantSerialised value,
       return child;
     }
 
-  if (member_info->ending_type == G_VARIANT_MEMBER_ENDING_OFFSET)
-    {
-      if (offset_size * (member_info->i + 2) > value.size)
-        return child;
-    }
-  else
+  /* If the requested @index_ is beyond the set of indices whose framing offsets
+   * have been checked, check the remaining offsets to see whether they’re
+   * normal (in order, no overlapping tuple elements).
+   *
+   * Unlike the checks in gvs_variable_sized_array_get_child(), we have to check
+   * all the tuple *elements* here, not just all the framing offsets, since
+   * tuples contain a mix of elements which use framing offsets and ones which
+   * don’t. None of them are allowed to overlap. */
+  if (index_ > value.checked_offsets_up_to &&
+      value.ordered_offsets_up_to == value.checked_offsets_up_to)
     {
-      if (offset_size * (member_info->i + 1) > value.size)
-        {
-          /* if the child is fixed size, return its size.
-           * if child is not fixed-sized, return size = 0.
-           */
-          g_variant_type_info_query (child.type_info, NULL, &child.size);
+      gsize i, prev_i_end = 0;
 
-          return child;
-        }
-    }
+      if (value.checked_offsets_up_to > 0)
+        gvs_tuple_get_member_bounds (value, value.checked_offsets_up_to - 1, offset_size, NULL, &prev_i_end);
 
-  if (member_info->i + 1)
-    start = gvs_read_unaligned_le (value.data + value.size -
-                                   offset_size * (member_info->i + 1),
-                                   offset_size);
-  else
-    start = 0;
+      for (i = value.checked_offsets_up_to; i <= index_; i++)
+        {
+          gsize i_start, i_end;
 
-  start += member_info->a;
-  start &= member_info->b;
-  start |= member_info->c;
+          gvs_tuple_get_member_bounds (value, i, offset_size, &i_start, &i_end);
 
-  if (member_info->ending_type == G_VARIANT_MEMBER_ENDING_LAST)
-    end = value.size - offset_size * (member_info->i + 1);
+          if (i_start > i_end || i_start < prev_i_end || i_end > value.size)
+            break;
 
-  else if (member_info->ending_type == G_VARIANT_MEMBER_ENDING_FIXED)
-    {
-      gsize fixed_size;
+          prev_i_end = i_end;
+        }
 
-      g_variant_type_info_query (child.type_info, NULL, &fixed_size);
-      end = start + fixed_size;
-      child.size = fixed_size;
+      value.ordered_offsets_up_to = i - 1;
+      value.checked_offsets_up_to = index_;
     }
 
-  else /* G_VARIANT_MEMBER_ENDING_OFFSET */
-    end = gvs_read_unaligned_le (value.data + value.size -
-                                 offset_size * (member_info->i + 2),
-                                 offset_size);
+  if (index_ > value.ordered_offsets_up_to)
+    {
+      /* Offsets are invalid somewhere, so return an empty child. */
+      return child;
+    }
 
-  /* The child should not extend into the offset table. */
-  if (index_ != g_variant_type_info_n_members (value.type_info) - 1)
+  if (member_info->ending_type == G_VARIANT_MEMBER_ENDING_OFFSET)
     {
-      GVariantSerialised last_child;
-      last_child = gvs_tuple_get_child (value,
-                                        g_variant_type_info_n_members (value.type_info) - 1);
-      last_end = last_child.data + last_child.size - value.data;
-      g_variant_type_info_unref (last_child.type_info);
+      if (offset_size * (member_info->i + 2) > value.size)
+        return child;
     }
   else
-    last_end = end;
+    {
+      if (offset_size * (member_info->i + 1) > value.size)
+        return child;
+    }
+
+  /* The child should not extend into the offset table. */
+  gvs_tuple_get_member_bounds (value, index_, offset_size, &start, &end);
+  gvs_tuple_get_member_bounds (value, g_variant_type_info_n_members (value.type_info) - 1, offset_size, NULL, &last_end);
 
   if (start < end && end <= value.size && end <= last_end)
     {
@@ -1053,6 +1205,7 @@ gvs_tuple_is_normal (GVariantSerialised value)
   gsize length;
   gsize offset;
   gsize i;
+  gsize offset_table_size;
 
   /* as per the comment in gvs_tuple_get_child() */
   if G_UNLIKELY (value.data == NULL && value.size != 0)
@@ -1066,7 +1219,7 @@ gvs_tuple_is_normal (GVariantSerialised value)
   for (i = 0; i < length; i++)
     {
       const GVariantMemberInfo *member_info;
-      GVariantSerialised child;
+      GVariantSerialised child = { 0, };
       gsize fixed_size;
       guint alignment;
       gsize end;
@@ -1126,6 +1279,10 @@ gvs_tuple_is_normal (GVariantSerialised value)
       offset = end;
     }
 
+  /* All element bounds have been checked above. */
+  value.ordered_offsets_up_to = G_MAXSIZE;
+  value.checked_offsets_up_to = G_MAXSIZE;
+
   {
     gsize fixed_size;
     guint alignment;
@@ -1153,7 +1310,19 @@ gvs_tuple_is_normal (GVariantSerialised value)
       }
   }
 
-  return offset_ptr == offset;
+  /* @offset_ptr has been counting backwards from the end of the variant, to
+   * find the beginning of the offset table. @offset has been counting forwards
+   * from the beginning of the variant to find the end of the data. They should
+   * have met in the middle. */
+  if (offset_ptr != offset)
+    return FALSE;
+
+  offset_table_size = value.size - offset_ptr;
+  if (value.size > 0 &&
+      gvs_calculate_total_size (offset, offset_table_size / offset_size) != value.size)
+    return FALSE;  /* offset size not minimal */
+
+  return TRUE;
 }
 
 /* Variants {{{2
diff --git a/glib/gvariant-serialiser.c.orig b/glib/gvariant-serialiser.c.orig
new file mode 100644
index 0000000..832a8fd
--- /dev/null
+++ b/glib/gvariant-serialiser.c.orig
@@ -0,0 +1,1750 @@
+/*
+ * Copyright © 2007, 2008 Ryan Lortie
+ * Copyright © 2010 Codethink Limited
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author: Ryan Lortie <desrt@desrt.ca>
+ */
+
+/* Prologue {{{1 */
+#include "config.h"
+
+#include "gvariant-serialiser.h"
+
+#include <glib/gvariant-internal.h>
+#include <glib/gtestutils.h>
+#include <glib/gstrfuncs.h>
+#include <glib/gtypes.h>
+
+#include <string.h>
+
+
+/* GVariantSerialiser
+ *
+ * After this prologue section, this file has roughly 2 parts.
+ *
+ * The first part is split up into sections according to various
+ * container types.  Maybe, Array, Tuple, Variant.  The Maybe and Array
+ * sections are subdivided for element types being fixed or
+ * variable-sized types.
+ *
+ * Each section documents the format of that particular type of
+ * container and implements 5 functions for dealing with it:
+ *
+ *  n_children:
+ *    - determines (according to serialized data) how many child values
+ *      are inside a particular container value.
+ *
+ *  get_child:
+ *    - gets the type of and the serialized data corresponding to a
+ *      given child value within the container value.
+ *
+ *  needed_size:
+ *    - determines how much space would be required to serialize a
+ *      container of this type, containing the given children so that
+ *      buffers can be preallocated before serializing.
+ *
+ *  serialise:
+ *    - write the serialized data for a container of this type,
+ *      containing the given children, to a buffer.
+ *
+ *  is_normal:
+ *    - check the given data to ensure that it is in normal form.  For a
+ *      given set of child values, there is exactly one normal form for
+ *      the serialized data of a container.  Other forms are possible
+ *      while maintaining the same children (for example, by inserting
+ *      something other than zero bytes as padding) but only one form is
+ *      the normal form.
+ *
+ * The second part contains the main entry point for each of the above 5
+ * functions and logic to dispatch it to the handler for the appropriate
+ * container type code.
+ *
+ * The second part also contains a routine to byteswap serialized
+ * values.  This code makes use of the n_children() and get_child()
+ * functions above to do its work so no extra support is needed on a
+ * per-container-type basis.
+ *
+ * There is also additional code for checking for normal form.  All
+ * numeric types are always in normal form since the full range of
+ * values is permitted (eg: 0 to 255 is a valid byte).  Special checks
+ * need to be performed for booleans (only 0 or 1 allowed), strings
+ * (properly nul-terminated) and object paths and signature strings
+ * (meeting the D-Bus specification requirements).  Depth checks need to be
+ * performed for nested types (arrays, tuples, and variants), to avoid massive
+ * recursion which could exhaust our stack when handling untrusted input.
+ */
+
+/* < private >
+ * GVariantSerialised:
+ * @type_info: the #GVariantTypeInfo of this value
+ * @data: (nullable): the serialized data of this value, or %NULL
+ * @size: the size of this value
+ *
+ * A structure representing a GVariant in serialized form.  This
+ * structure is used with #GVariantSerialisedFiller functions and as the
+ * primary interface to the serializer.  See #GVariantSerialisedFiller
+ * for a description of its use there.
+ *
+ * When used with the serializer API functions, the following invariants
+ * apply to all #GVariantTypeSerialised structures passed to and
+ * returned from the serializer.
+ *
+ * @type_info must be non-%NULL.
+ *
+ * @data must be properly aligned for the type described by @type_info.
+ *
+ * If @type_info describes a fixed-sized type then @size must always be
+ * equal to the fixed size of that type.
+ *
+ * For fixed-sized types (and only fixed-sized types), @data may be
+ * %NULL even if @size is non-zero.  This happens when a framing error
+ * occurs while attempting to extract a fixed-sized value out of a
+ * variable-sized container.  There is no data to return for the
+ * fixed-sized type, yet @size must be non-zero.  The effect of this
+ * combination should be as if @data were a pointer to an
+ * appropriately-sized zero-filled region.
+ *
+ * @depth has no restrictions; the depth of a top-level serialized #GVariant is
+ * zero, and it increases for each level of nested child.
+ */
+
+/* < private >
+ * g_variant_serialised_check:
+ * @serialised: a #GVariantSerialised struct
+ *
+ * Checks @serialised for validity according to the invariants described
+ * above.
+ *
+ * Returns: %TRUE if @serialised is valid; %FALSE otherwise
+ */
+gboolean
+g_variant_serialised_check (GVariantSerialised serialised)
+{
+  gsize fixed_size;
+  guint alignment;
+
+  if (serialised.type_info == NULL)
+    return FALSE;
+  g_variant_type_info_query (serialised.type_info, &alignment, &fixed_size);
+
+  if (fixed_size != 0 && serialised.size != fixed_size)
+    return FALSE;
+  else if (fixed_size == 0 &&
+           !(serialised.size == 0 || serialised.data != NULL))
+    return FALSE;
+
+  /* Depending on the native alignment requirements of the machine, the
+   * compiler will insert either 3 or 7 padding bytes after the char.
+   * This will result in the sizeof() the struct being 12 or 16.
+   * Subtract 9 to get 3 or 7 which is a nice bitmask to apply to get
+   * the alignment bits that we "care about" being zero: in the
+   * 4-aligned case, we care about 2 bits, and in the 8-aligned case, we
+   * care about 3 bits.
+   */
+  alignment &= sizeof (struct {
+                         char a;
+                         union {
+                           guint64 x;
+                           void *y;
+                           gdouble z;
+                         } b;
+                       }
+                      ) - 9;
+
+  /* Some OSes (FreeBSD is a known example) have a malloc() that returns
+   * unaligned memory if you request small sizes.  'malloc (1);', for
+   * example, has been seen to return pointers aligned to 6 mod 16.
+   *
+   * Check if this is a small allocation and return without enforcing
+   * the alignment assertion if this is the case.
+   */
+  return (serialised.size <= alignment ||
+          (alignment & (gsize) serialised.data) == 0);
+}
+
+/* < private >
+ * GVariantSerialisedFiller:
+ * @serialised: a #GVariantSerialised instance to fill
+ * @data: data from the children array
+ *
+ * This function is called back from g_variant_serialiser_needed_size()
+ * and g_variant_serialiser_serialise().  It fills in missing details
+ * from a partially-complete #GVariantSerialised.
+ *
+ * The @data parameter passed back to the function is one of the items
+ * that was passed to the serializer in the @children array.  It
+ * represents a single child item of the container that is being
+ * serialized.  The information filled in to @serialised is the
+ * information for this child.
+ *
+ * If the @type_info field of @serialised is %NULL then the callback
+ * function must set it to the type information corresponding to the
+ * type of the child.  No reference should be added.  If it is non-%NULL
+ * then the callback should assert that it is equal to the actual type
+ * of the child.
+ *
+ * If the @size field is zero then the callback must fill it in with the
+ * required amount of space to store the serialized form of the child.
+ * If it is non-zero then the callback should assert that it is equal to
+ * the needed size of the child.
+ *
+ * If @data is non-%NULL then it points to a space that is properly
+ * aligned for and large enough to store the serialized data of the
+ * child.  The callback must store the serialized form of the child at
+ * @data.
+ *
+ * If the child value is another container then the callback will likely
+ * recurse back into the serializer by calling
+ * g_variant_serialiser_needed_size() to determine @size and
+ * g_variant_serialiser_serialise() to write to @data.
+ */
+
+/* PART 1: Container types {{{1
+ *
+ * This section contains the serializer implementation functions for
+ * each container type.
+ */
+
+/* Maybe {{{2
+ *
+ * Maybe types are handled depending on if the element type of the maybe
+ * type is a fixed-sized or variable-sized type.  Although all maybe
+ * types themselves are variable-sized types, herein, a maybe value with
+ * a fixed-sized element type is called a "fixed-sized maybe" for
+ * convenience and a maybe value with a variable-sized element type is
+ * called a "variable-sized maybe".
+ */
+
+/* Fixed-sized Maybe {{{3
+ *
+ * The size of a maybe value with a fixed-sized element type is either 0
+ * or equal to the fixed size of its element type.  The case where the
+ * size of the maybe value is zero corresponds to the "Nothing" case and
+ * the case where the size of the maybe value is equal to the fixed size
+ * of the element type corresponds to the "Just" case; in that case, the
+ * serialized data of the child value forms the entire serialized data
+ * of the maybe value.
+ *
+ * In the event that a fixed-sized maybe value is presented with a size
+ * that is not equal to the fixed size of the element type then the
+ * value must be taken to be "Nothing".
+ */
+
+static gsize
+gvs_fixed_sized_maybe_n_children (GVariantSerialised value)
+{
+  gsize element_fixed_size;
+
+  g_variant_type_info_query_element (value.type_info, NULL,
+                                     &element_fixed_size);
+
+  return (element_fixed_size == value.size) ? 1 : 0;
+}
+
+static GVariantSerialised
+gvs_fixed_sized_maybe_get_child (GVariantSerialised value,
+                                 gsize              index_)
+{
+  /* the child has the same bounds as the
+   * container, so just update the type.
+   */
+  value.type_info = g_variant_type_info_element (value.type_info);
+  g_variant_type_info_ref (value.type_info);
+  value.depth++;
+
+  return value;
+}
+
+static gsize
+gvs_fixed_sized_maybe_needed_size (GVariantTypeInfo         *type_info,
+                                   GVariantSerialisedFiller  gvs_filler,
+                                   const gpointer           *children,
+                                   gsize                     n_children)
+{
+  if (n_children)
+    {
+      gsize element_fixed_size;
+
+      g_variant_type_info_query_element (type_info, NULL,
+                                         &element_fixed_size);
+
+      return element_fixed_size;
+    }
+  else
+    return 0;
+}
+
+static void
+gvs_fixed_sized_maybe_serialise (GVariantSerialised        value,
+                                 GVariantSerialisedFiller  gvs_filler,
+                                 const gpointer           *children,
+                                 gsize                     n_children)
+{
+  if (n_children)
+    {
+      GVariantSerialised child = { NULL, value.data, value.size, value.depth + 1 };
+
+      gvs_filler (&child, children[0]);
+    }
+}
+
+static gboolean
+gvs_fixed_sized_maybe_is_normal (GVariantSerialised value)
+{
+  if (value.size > 0)
+    {
+      gsize element_fixed_size;
+
+      g_variant_type_info_query_element (value.type_info,
+                                         NULL, &element_fixed_size);
+
+      if (value.size != element_fixed_size)
+        return FALSE;
+
+      /* proper element size: "Just".  recurse to the child. */
+      value.type_info = g_variant_type_info_element (value.type_info);
+      value.depth++;
+
+      return g_variant_serialised_is_normal (value);
+    }
+
+  /* size of 0: "Nothing" */
+  return TRUE;
+}
+
+/* Variable-sized Maybe
+ *
+ * The size of a maybe value with a variable-sized element type is
+ * either 0 or strictly greater than 0.  The case where the size of the
+ * maybe value is zero corresponds to the "Nothing" case and the case
+ * where the size of the maybe value is greater than zero corresponds to
+ * the "Just" case; in that case, the serialized data of the child value
+ * forms the first part of the serialized data of the maybe value and is
+ * followed by a single zero byte.  This zero byte is always appended,
+ * regardless of any zero bytes that may already be at the end of the
+ * serialized ata of the child value.
+ */
+
+static gsize
+gvs_variable_sized_maybe_n_children (GVariantSerialised value)
+{
+  return (value.size > 0) ? 1 : 0;
+}
+
+static GVariantSerialised
+gvs_variable_sized_maybe_get_child (GVariantSerialised value,
+                                    gsize              index_)
+{
+  /* remove the padding byte and update the type. */
+  value.type_info = g_variant_type_info_element (value.type_info);
+  g_variant_type_info_ref (value.type_info);
+  value.size--;
+
+  /* if it's zero-sized then it may as well be NULL */
+  if (value.size == 0)
+    value.data = NULL;
+
+  value.depth++;
+
+  return value;
+}
+
+static gsize
+gvs_variable_sized_maybe_needed_size (GVariantTypeInfo         *type_info,
+                                      GVariantSerialisedFiller  gvs_filler,
+                                      const gpointer           *children,
+                                      gsize                     n_children)
+{
+  if (n_children)
+    {
+      GVariantSerialised child = { 0, };
+
+      gvs_filler (&child, children[0]);
+
+      return child.size + 1;
+    }
+  else
+    return 0;
+}
+
+static void
+gvs_variable_sized_maybe_serialise (GVariantSerialised        value,
+                                    GVariantSerialisedFiller  gvs_filler,
+                                    const gpointer           *children,
+                                    gsize                     n_children)
+{
+  if (n_children)
+    {
+      GVariantSerialised child = { NULL, value.data, value.size - 1, value.depth + 1 };
+
+      /* write the data for the child.  */
+      gvs_filler (&child, children[0]);
+      value.data[child.size] = '\0';
+    }
+}
+
+static gboolean
+gvs_variable_sized_maybe_is_normal (GVariantSerialised value)
+{
+  if (value.size == 0)
+    return TRUE;
+
+  if (value.data[value.size - 1] != '\0')
+    return FALSE;
+
+  value.type_info = g_variant_type_info_element (value.type_info);
+  value.size--;
+  value.depth++;
+
+  return g_variant_serialised_is_normal (value);
+}
+
+/* Arrays {{{2
+ *
+ * Just as with maybe types, array types are handled depending on if the
+ * element type of the array type is a fixed-sized or variable-sized
+ * type.  Similar to maybe types, for convenience, an array value with a
+ * fixed-sized element type is called a "fixed-sized array" and an array
+ * value with a variable-sized element type is called a "variable sized
+ * array".
+ */
+
+/* Fixed-sized Array {{{3
+ *
+ * For fixed sized arrays, the serialized data is simply a concatenation
+ * of the serialized data of each element, in order.  Since fixed-sized
+ * values always have a fixed size that is a multiple of their alignment
+ * requirement no extra padding is required.
+ *
+ * In the event that a fixed-sized array is presented with a size that
+ * is not an integer multiple of the element size then the value of the
+ * array must be taken as being empty.
+ */
+
+static gsize
+gvs_fixed_sized_array_n_children (GVariantSerialised value)
+{
+  gsize element_fixed_size;
+
+  g_variant_type_info_query_element (value.type_info, NULL,
+                                     &element_fixed_size);
+
+  if (value.size % element_fixed_size == 0)
+    return value.size / element_fixed_size;
+
+  return 0;
+}
+
+static GVariantSerialised
+gvs_fixed_sized_array_get_child (GVariantSerialised value,
+                                 gsize              index_)
+{
+  GVariantSerialised child = { 0, };
+
+  child.type_info = g_variant_type_info_element (value.type_info);
+  g_variant_type_info_query (child.type_info, NULL, &child.size);
+  child.data = value.data + (child.size * index_);
+  g_variant_type_info_ref (child.type_info);
+  child.depth = value.depth + 1;
+
+  return child;
+}
+
+static gsize
+gvs_fixed_sized_array_needed_size (GVariantTypeInfo         *type_info,
+                                   GVariantSerialisedFiller  gvs_filler,
+                                   const gpointer           *children,
+                                   gsize                     n_children)
+{
+  gsize element_fixed_size;
+
+  g_variant_type_info_query_element (type_info, NULL, &element_fixed_size);
+
+  return element_fixed_size * n_children;
+}
+
+static void
+gvs_fixed_sized_array_serialise (GVariantSerialised        value,
+                                 GVariantSerialisedFiller  gvs_filler,
+                                 const gpointer           *children,
+                                 gsize                     n_children)
+{
+  GVariantSerialised child = { 0, };
+  gsize i;
+
+  child.type_info = g_variant_type_info_element (value.type_info);
+  g_variant_type_info_query (child.type_info, NULL, &child.size);
+  child.data = value.data;
+  child.depth = value.depth + 1;
+
+  for (i = 0; i < n_children; i++)
+    {
+      gvs_filler (&child, children[i]);
+      child.data += child.size;
+    }
+}
+
+static gboolean
+gvs_fixed_sized_array_is_normal (GVariantSerialised value)
+{
+  GVariantSerialised child = { 0, };
+
+  child.type_info = g_variant_type_info_element (value.type_info);
+  g_variant_type_info_query (child.type_info, NULL, &child.size);
+  child.depth = value.depth + 1;
+
+  if (value.size % child.size != 0)
+    return FALSE;
+
+  for (child.data = value.data;
+       child.data < value.data + value.size;
+       child.data += child.size)
+    {
+      if (!g_variant_serialised_is_normal (child))
+        return FALSE;
+    }
+
+  return TRUE;
+}
+
+/* Variable-sized Array {{{3
+ *
+ * Variable sized arrays, containing variable-sized elements, must be
+ * able to determine the boundaries between the elements.  The items
+ * cannot simply be concatenated.  Additionally, we are faced with the
+ * fact that non-fixed-sized values do not necessarily have a size that
+ * is a multiple of their alignment requirement, so we may need to
+ * insert zero-filled padding.
+ *
+ * While it is possible to find the start of an item by starting from
+ * the end of the item before it and padding for alignment, it is not
+ * generally possible to do the reverse operation.  For this reason, we
+ * record the end point of each element in the array.
+ *
+ * GVariant works in terms of "offsets".  An offset is a pointer to a
+ * boundary between two bytes.  In 4 bytes of serialized data, there
+ * would be 5 possible offsets: one at the start ('0'), one between each
+ * pair of adjacent bytes ('1', '2', '3') and one at the end ('4').
+ *
+ * The numeric value of an offset is an unsigned integer given relative
+ * to the start of the serialized data of the array.  Offsets are always
+ * stored in little endian byte order and are always only as big as they
+ * need to be.  For example, in 255 bytes of serialized data, there are
+ * 256 offsets.  All possibilities can be stored in an 8 bit unsigned
+ * integer.  In 256 bytes of serialized data, however, there are 257
+ * possible offsets so 16 bit integers must be used.  The size of an
+ * offset is always a power of 2.
+ *
+ * The offsets are stored at the end of the serialized data of the
+ * array.  They are simply concatenated on without any particular
+ * alignment.  The size of the offsets is included in the size of the
+ * serialized data for purposes of determining the size of the offsets.
+ * This presents a possibly ambiguity; in certain cases, a particular
+ * value of array could have two different serialized forms.
+ *
+ * Imagine an array containing a single string of 253 bytes in length
+ * (so, 254 bytes including the nul terminator).  Now the offset must be
+ * written.  If an 8 bit offset is written, it will bring the size of
+ * the array's serialized data to 255 -- which means that the use of an
+ * 8 bit offset was valid.  If a 16 bit offset is used then the total
+ * size of the array will be 256 -- which means that the use of a 16 bit
+ * offset was valid.  Although both of these will be accepted by the
+ * deserializer, only the smaller of the two is considered to be in
+ * normal form and that is the one that the serializer must produce.
+ */
+
+/* bytes may be NULL if (size == 0). */
+static inline gsize
+gvs_read_unaligned_le (guchar *bytes,
+                       guint   size)
+{
+  union
+  {
+    guchar bytes[GLIB_SIZEOF_SIZE_T];
+    gsize integer;
+  } tmpvalue;
+
+  tmpvalue.integer = 0;
+  if (bytes != NULL)
+    memcpy (&tmpvalue.bytes, bytes, size);
+
+  return GSIZE_FROM_LE (tmpvalue.integer);
+}
+
+static inline void
+gvs_write_unaligned_le (guchar *bytes,
+                        gsize   value,
+                        guint   size)
+{
+  union
+  {
+    guchar bytes[GLIB_SIZEOF_SIZE_T];
+    gsize integer;
+  } tmpvalue;
+
+  tmpvalue.integer = GSIZE_TO_LE (value);
+  memcpy (bytes, &tmpvalue.bytes, size);
+}
+
+static guint
+gvs_get_offset_size (gsize size)
+{
+  if (size > G_MAXUINT32)
+    return 8;
+
+  else if (size > G_MAXUINT16)
+    return 4;
+
+  else if (size > G_MAXUINT8)
+    return 2;
+
+  else if (size > 0)
+    return 1;
+
+  return 0;
+}
+
+static gsize
+gvs_calculate_total_size (gsize body_size,
+                          gsize offsets)
+{
+  if (body_size + 1 * offsets <= G_MAXUINT8)
+    return body_size + 1 * offsets;
+
+  if (body_size + 2 * offsets <= G_MAXUINT16)
+    return body_size + 2 * offsets;
+
+  if (body_size + 4 * offsets <= G_MAXUINT32)
+    return body_size + 4 * offsets;
+
+  return body_size + 8 * offsets;
+}
+
+static gsize
+gvs_variable_sized_array_n_children (GVariantSerialised value)
+{
+  gsize offsets_array_size;
+  gsize offset_size;
+  gsize last_end;
+
+  if (value.size == 0)
+    return 0;
+
+  offset_size = gvs_get_offset_size (value.size);
+
+  last_end = gvs_read_unaligned_le (value.data + value.size -
+                                    offset_size, offset_size);
+
+  if (last_end > value.size)
+    return 0;
+
+  offsets_array_size = value.size - last_end;
+
+  if (offsets_array_size % offset_size)
+    return 0;
+
+  return offsets_array_size / offset_size;
+}
+
+static GVariantSerialised
+gvs_variable_sized_array_get_child (GVariantSerialised value,
+                                    gsize              index_)
+{
+  GVariantSerialised child = { 0, };
+  gsize offset_size;
+  gsize last_end;
+  gsize start;
+  gsize end;
+
+  child.type_info = g_variant_type_info_element (value.type_info);
+  g_variant_type_info_ref (child.type_info);
+  child.depth = value.depth + 1;
+
+  offset_size = gvs_get_offset_size (value.size);
+
+  last_end = gvs_read_unaligned_le (value.data + value.size -
+                                    offset_size, offset_size);
+
+  if (index_ > 0)
+    {
+      guint alignment;
+
+      start = gvs_read_unaligned_le (value.data + last_end +
+                                     (offset_size * (index_ - 1)),
+                                     offset_size);
+
+      g_variant_type_info_query (child.type_info, &alignment, NULL);
+      start += (-start) & alignment;
+    }
+  else
+    start = 0;
+
+  end = gvs_read_unaligned_le (value.data + last_end +
+                               (offset_size * index_),
+                               offset_size);
+
+  if (start < end && end <= value.size && end <= last_end)
+    {
+      child.data = value.data + start;
+      child.size = end - start;
+    }
+
+  return child;
+}
+
+static gsize
+gvs_variable_sized_array_needed_size (GVariantTypeInfo         *type_info,
+                                      GVariantSerialisedFiller  gvs_filler,
+                                      const gpointer           *children,
+                                      gsize                     n_children)
+{
+  guint alignment;
+  gsize offset;
+  gsize i;
+
+  g_variant_type_info_query (type_info, &alignment, NULL);
+  offset = 0;
+
+  for (i = 0; i < n_children; i++)
+    {
+      GVariantSerialised child = { 0, };
+
+      offset += (-offset) & alignment;
+      gvs_filler (&child, children[i]);
+      offset += child.size;
+    }
+
+  return gvs_calculate_total_size (offset, n_children);
+}
+
+static void
+gvs_variable_sized_array_serialise (GVariantSerialised        value,
+                                    GVariantSerialisedFiller  gvs_filler,
+                                    const gpointer           *children,
+                                    gsize                     n_children)
+{
+  guchar *offset_ptr;
+  gsize offset_size;
+  guint alignment;
+  gsize offset;
+  gsize i;
+
+  g_variant_type_info_query (value.type_info, &alignment, NULL);
+  offset_size = gvs_get_offset_size (value.size);
+  offset = 0;
+
+  offset_ptr = value.data + value.size - offset_size * n_children;
+
+  for (i = 0; i < n_children; i++)
+    {
+      GVariantSerialised child = { 0, };
+
+      while (offset & alignment)
+        value.data[offset++] = '\0';
+
+      child.data = value.data + offset;
+      gvs_filler (&child, children[i]);
+      offset += child.size;
+
+      gvs_write_unaligned_le (offset_ptr, offset, offset_size);
+      offset_ptr += offset_size;
+    }
+}
+
+static gboolean
+gvs_variable_sized_array_is_normal (GVariantSerialised value)
+{
+  GVariantSerialised child = { 0, };
+  gsize offsets_array_size;
+  guchar *offsets_array;
+  guint offset_size;
+  guint alignment;
+  gsize last_end;
+  gsize length;
+  gsize offset;
+  gsize i;
+
+  if (value.size == 0)
+    return TRUE;
+
+  offset_size = gvs_get_offset_size (value.size);
+  last_end = gvs_read_unaligned_le (value.data + value.size -
+                                    offset_size, offset_size);
+
+  if (last_end > value.size)
+    return FALSE;
+
+  offsets_array_size = value.size - last_end;
+
+  if (offsets_array_size % offset_size)
+    return FALSE;
+
+  offsets_array = value.data + value.size - offsets_array_size;
+  length = offsets_array_size / offset_size;
+
+  if (length == 0)
+    return FALSE;
+
+  child.type_info = g_variant_type_info_element (value.type_info);
+  g_variant_type_info_query (child.type_info, &alignment, NULL);
+  child.depth = value.depth + 1;
+  offset = 0;
+
+  for (i = 0; i < length; i++)
+    {
+      gsize this_end;
+
+      this_end = gvs_read_unaligned_le (offsets_array + offset_size * i,
+                                        offset_size);
+
+      if (this_end < offset || this_end > last_end)
+        return FALSE;
+
+      while (offset & alignment)
+        {
+          if (!(offset < this_end && value.data[offset] == '\0'))
+            return FALSE;
+          offset++;
+        }
+
+      child.data = value.data + offset;
+      child.size = this_end - offset;
+
+      if (child.size == 0)
+        child.data = NULL;
+
+      if (!g_variant_serialised_is_normal (child))
+        return FALSE;
+
+      offset = this_end;
+    }
+
+  g_assert (offset == last_end);
+
+  return TRUE;
+}
+
+/* Tuples {{{2
+ *
+ * Since tuples can contain a mix of variable- and fixed-sized items,
+ * they are, in terms of serialization, a hybrid of variable-sized and
+ * fixed-sized arrays.
+ *
+ * Offsets are only stored for variable-sized items.  Also, since the
+ * number of items in a tuple is known from its type, we are able to
+ * know exactly how many offsets to expect in the serialized data (and
+ * therefore how much space is taken up by the offset array).  This
+ * means that we know where the end of the serialized data for the last
+ * item is -- we can just subtract the size of the offset array from the
+ * total size of the tuple.  For this reason, the last item in the tuple
+ * doesn't need an offset stored.
+ *
+ * Tuple offsets are stored in reverse.  This design choice allows
+ * iterator-based deserializers to be more efficient.
+ *
+ * Most of the "heavy lifting" here is handled by the GVariantTypeInfo
+ * for the tuple.  See the notes in gvarianttypeinfo.h.
+ */
+
+static gsize
+gvs_tuple_n_children (GVariantSerialised value)
+{
+  return g_variant_type_info_n_members (value.type_info);
+}
+
+static GVariantSerialised
+gvs_tuple_get_child (GVariantSerialised value,
+                     gsize              index_)
+{
+  const GVariantMemberInfo *member_info;
+  GVariantSerialised child = { 0, };
+  gsize offset_size;
+  gsize start, end, last_end;
+
+  member_info = g_variant_type_info_member_info (value.type_info, index_);
+  child.type_info = g_variant_type_info_ref (member_info->type_info);
+  child.depth = value.depth + 1;
+  offset_size = gvs_get_offset_size (value.size);
+
+  /* tuples are the only (potentially) fixed-sized containers, so the
+   * only ones that have to deal with the possibility of having %NULL
+   * data with a non-zero %size if errors occurred elsewhere.
+   */
+  if G_UNLIKELY (value.data == NULL && value.size != 0)
+    {
+      g_variant_type_info_query (child.type_info, NULL, &child.size);
+
+      /* this can only happen in fixed-sized tuples,
+       * so the child must also be fixed sized.
+       */
+      g_assert (child.size != 0);
+      child.data = NULL;
+
+      return child;
+    }
+
+  if (member_info->ending_type == G_VARIANT_MEMBER_ENDING_OFFSET)
+    {
+      if (offset_size * (member_info->i + 2) > value.size)
+        return child;
+    }
+  else
+    {
+      if (offset_size * (member_info->i + 1) > value.size)
+        {
+          /* if the child is fixed size, return its size.
+           * if child is not fixed-sized, return size = 0.
+           */
+          g_variant_type_info_query (child.type_info, NULL, &child.size);
+
+          return child;
+        }
+    }
+
+  if (member_info->i + 1)
+    start = gvs_read_unaligned_le (value.data + value.size -
+                                   offset_size * (member_info->i + 1),
+                                   offset_size);
+  else
+    start = 0;
+
+  start += member_info->a;
+  start &= member_info->b;
+  start |= member_info->c;
+
+  if (member_info->ending_type == G_VARIANT_MEMBER_ENDING_LAST)
+    end = value.size - offset_size * (member_info->i + 1);
+
+  else if (member_info->ending_type == G_VARIANT_MEMBER_ENDING_FIXED)
+    {
+      gsize fixed_size;
+
+      g_variant_type_info_query (child.type_info, NULL, &fixed_size);
+      end = start + fixed_size;
+      child.size = fixed_size;
+    }
+
+  else /* G_VARIANT_MEMBER_ENDING_OFFSET */
+    end = gvs_read_unaligned_le (value.data + value.size -
+                                 offset_size * (member_info->i + 2),
+                                 offset_size);
+
+  /* The child should not extend into the offset table. */
+  if (index_ != g_variant_type_info_n_members (value.type_info) - 1)
+    {
+      GVariantSerialised last_child;
+      last_child = gvs_tuple_get_child (value,
+                                        g_variant_type_info_n_members (value.type_info) - 1);
+      last_end = last_child.data + last_child.size - value.data;
+      g_variant_type_info_unref (last_child.type_info);
+    }
+  else
+    last_end = end;
+
+  if (start < end && end <= value.size && end <= last_end)
+    {
+      child.data = value.data + start;
+      child.size = end - start;
+    }
+
+  return child;
+}
+
+static gsize
+gvs_tuple_needed_size (GVariantTypeInfo         *type_info,
+                       GVariantSerialisedFiller  gvs_filler,
+                       const gpointer           *children,
+                       gsize                     n_children)
+{
+  const GVariantMemberInfo *member_info = NULL;
+  gsize fixed_size;
+  gsize offset;
+  gsize i;
+
+  g_variant_type_info_query (type_info, NULL, &fixed_size);
+
+  if (fixed_size)
+    return fixed_size;
+
+  offset = 0;
+
+  for (i = 0; i < n_children; i++)
+    {
+      guint alignment;
+
+      member_info = g_variant_type_info_member_info (type_info, i);
+      g_variant_type_info_query (member_info->type_info,
+                                 &alignment, &fixed_size);
+      offset += (-offset) & alignment;
+
+      if (fixed_size)
+        offset += fixed_size;
+      else
+        {
+          GVariantSerialised child = { 0, };
+
+          gvs_filler (&child, children[i]);
+          offset += child.size;
+        }
+    }
+
+  return gvs_calculate_total_size (offset, member_info->i + 1);
+}
+
+static void
+gvs_tuple_serialise (GVariantSerialised        value,
+                     GVariantSerialisedFiller  gvs_filler,
+                     const gpointer           *children,
+                     gsize                     n_children)
+{
+  gsize offset_size;
+  gsize offset;
+  gsize i;
+
+  offset_size = gvs_get_offset_size (value.size);
+  offset = 0;
+
+  for (i = 0; i < n_children; i++)
+    {
+      const GVariantMemberInfo *member_info;
+      GVariantSerialised child = { 0, };
+      guint alignment;
+
+      member_info = g_variant_type_info_member_info (value.type_info, i);
+      g_variant_type_info_query (member_info->type_info, &alignment, NULL);
+
+      while (offset & alignment)
+        value.data[offset++] = '\0';
+
+      child.data = value.data + offset;
+      gvs_filler (&child, children[i]);
+      offset += child.size;
+
+      if (member_info->ending_type == G_VARIANT_MEMBER_ENDING_OFFSET)
+        {
+          value.size -= offset_size;
+          gvs_write_unaligned_le (value.data + value.size,
+                                  offset, offset_size);
+        }
+    }
+
+  while (offset < value.size)
+    value.data[offset++] = '\0';
+}
+
+static gboolean
+gvs_tuple_is_normal (GVariantSerialised value)
+{
+  guint offset_size;
+  gsize offset_ptr;
+  gsize length;
+  gsize offset;
+  gsize i;
+
+  /* as per the comment in gvs_tuple_get_child() */
+  if G_UNLIKELY (value.data == NULL && value.size != 0)
+    return FALSE;
+
+  offset_size = gvs_get_offset_size (value.size);
+  length = g_variant_type_info_n_members (value.type_info);
+  offset_ptr = value.size;
+  offset = 0;
+
+  for (i = 0; i < length; i++)
+    {
+      const GVariantMemberInfo *member_info;
+      GVariantSerialised child;
+      gsize fixed_size;
+      guint alignment;
+      gsize end;
+
+      member_info = g_variant_type_info_member_info (value.type_info, i);
+      child.type_info = member_info->type_info;
+      child.depth = value.depth + 1;
+
+      g_variant_type_info_query (child.type_info, &alignment, &fixed_size);
+
+      while (offset & alignment)
+        {
+          if (offset > value.size || value.data[offset] != '\0')
+            return FALSE;
+          offset++;
+        }
+
+      child.data = value.data + offset;
+
+      switch (member_info->ending_type)
+        {
+        case G_VARIANT_MEMBER_ENDING_FIXED:
+          end = offset + fixed_size;
+          break;
+
+        case G_VARIANT_MEMBER_ENDING_LAST:
+          end = offset_ptr;
+          break;
+
+        case G_VARIANT_MEMBER_ENDING_OFFSET:
+          if (offset_ptr < offset_size)
+            return FALSE;
+
+          offset_ptr -= offset_size;
+
+          if (offset_ptr < offset)
+            return FALSE;
+
+          end = gvs_read_unaligned_le (value.data + offset_ptr, offset_size);
+          break;
+
+        default:
+          g_assert_not_reached ();
+        }
+
+      if (end < offset || end > offset_ptr)
+        return FALSE;
+
+      child.size = end - offset;
+
+      if (child.size == 0)
+        child.data = NULL;
+
+      if (!g_variant_serialised_is_normal (child))
+        return FALSE;
+
+      offset = end;
+    }
+
+  {
+    gsize fixed_size;
+    guint alignment;
+
+    g_variant_type_info_query (value.type_info, &alignment, &fixed_size);
+
+    if (fixed_size)
+      {
+        g_assert (fixed_size == value.size);
+        g_assert (offset_ptr == value.size);
+
+        if (i == 0)
+          {
+            if (value.data[offset++] != '\0')
+              return FALSE;
+          }
+        else
+          {
+            while (offset & alignment)
+              if (value.data[offset++] != '\0')
+                return FALSE;
+          }
+
+        g_assert (offset == value.size);
+      }
+  }
+
+  return offset_ptr == offset;
+}
+
+/* Variants {{{2
+ *
+ * Variants are stored by storing the serialized data of the child,
+ * followed by a '\0' character, followed by the type string of the
+ * child.
+ *
+ * In the case that a value is presented that contains no '\0'
+ * character, or doesn't have a single well-formed definite type string
+ * following that character, the variant must be taken as containing the
+ * unit tuple: ().
+ */
+
+static inline gsize
+gvs_variant_n_children (GVariantSerialised value)
+{
+  return 1;
+}
+
+static inline GVariantSerialised
+gvs_variant_get_child (GVariantSerialised value,
+                       gsize              index_)
+{
+  GVariantSerialised child = { 0, };
+
+  /* NOTE: not O(1) and impossible for it to be... */
+  if (value.size)
+    {
+      /* find '\0' character */
+      for (child.size = value.size - 1; child.size; child.size--)
+        if (value.data[child.size] == '\0')
+          break;
+
+      /* ensure we didn't just hit the start of the string */
+      if (value.data[child.size] == '\0')
+        {
+          const gchar *type_string = (gchar *) &value.data[child.size + 1];
+          const gchar *limit = (gchar *) &value.data[value.size];
+          const gchar *end;
+
+          if (g_variant_type_string_scan (type_string, limit, &end) &&
+              end == limit)
+            {
+              const GVariantType *type = (GVariantType *) type_string;
+
+              if (g_variant_type_is_definite (type))
+                {
+                  gsize fixed_size;
+                  gsize child_type_depth;
+
+                  child.type_info = g_variant_type_info_get (type);
+                  child.depth = value.depth + 1;
+
+                  if (child.size != 0)
+                    /* only set to non-%NULL if size > 0 */
+                    child.data = value.data;
+
+                  g_variant_type_info_query (child.type_info,
+                                             NULL, &fixed_size);
+                  child_type_depth = g_variant_type_info_query_depth (child.type_info);
+
+                  if ((!fixed_size || fixed_size == child.size) &&
+                      value.depth < G_VARIANT_MAX_RECURSION_DEPTH - child_type_depth)
+                    return child;
+
+                  g_variant_type_info_unref (child.type_info);
+                }
+            }
+        }
+    }
+
+  child.type_info = g_variant_type_info_get (G_VARIANT_TYPE_UNIT);
+  child.data = NULL;
+  child.size = 1;
+  child.depth = value.depth + 1;
+
+  return child;
+}
+
+static inline gsize
+gvs_variant_needed_size (GVariantTypeInfo         *type_info,
+                         GVariantSerialisedFiller  gvs_filler,
+                         const gpointer           *children,
+                         gsize                     n_children)
+{
+  GVariantSerialised child = { 0, };
+  const gchar *type_string;
+
+  gvs_filler (&child, children[0]);
+  type_string = g_variant_type_info_get_type_string (child.type_info);
+
+  return child.size + 1 + strlen (type_string);
+}
+
+static inline void
+gvs_variant_serialise (GVariantSerialised        value,
+                       GVariantSerialisedFiller  gvs_filler,
+                       const gpointer           *children,
+                       gsize                     n_children)
+{
+  GVariantSerialised child = { 0, };
+  const gchar *type_string;
+
+  child.data = value.data;
+
+  gvs_filler (&child, children[0]);
+  type_string = g_variant_type_info_get_type_string (child.type_info);
+  value.data[child.size] = '\0';
+  memcpy (value.data + child.size + 1, type_string, strlen (type_string));
+}
+
+static inline gboolean
+gvs_variant_is_normal (GVariantSerialised value)
+{
+  GVariantSerialised child;
+  gboolean normal;
+  gsize child_type_depth;
+
+  child = gvs_variant_get_child (value, 0);
+  child_type_depth = g_variant_type_info_query_depth (child.type_info);
+
+  normal = (value.depth < G_VARIANT_MAX_RECURSION_DEPTH - child_type_depth) &&
+           (child.data != NULL || child.size == 0) &&
+           g_variant_serialised_is_normal (child);
+
+  g_variant_type_info_unref (child.type_info);
+
+  return normal;
+}
+
+
+
+/* PART 2: Serializer API {{{1
+ *
+ * This is the implementation of the API of the serializer as advertised
+ * in gvariant-serialiser.h.
+ */
+
+/* Dispatch Utilities {{{2
+ *
+ * These macros allow a given function (for example,
+ * g_variant_serialiser_serialise) to be dispatched to the appropriate
+ * type-specific function above (fixed/variable-sized maybe,
+ * fixed/variable-sized array, tuple or variant).
+ */
+#define DISPATCH_FIXED(type_info, before, after) \
+  {                                                     \
+    gsize fixed_size;                                   \
+                                                        \
+    g_variant_type_info_query_element (type_info, NULL, \
+                                       &fixed_size);    \
+                                                        \
+    if (fixed_size)                                     \
+      {                                                 \
+        before ## fixed_sized ## after                  \
+      }                                                 \
+    else                                                \
+      {                                                 \
+        before ## variable_sized ## after               \
+      }                                                 \
+  }
+
+#define DISPATCH_CASES(type_info, before, after) \
+  switch (g_variant_type_info_get_type_char (type_info))        \
+    {                                                           \
+      case G_VARIANT_TYPE_INFO_CHAR_MAYBE:                      \
+        DISPATCH_FIXED (type_info, before, _maybe ## after)     \
+                                                                \
+      case G_VARIANT_TYPE_INFO_CHAR_ARRAY:                      \
+        DISPATCH_FIXED (type_info, before, _array ## after)     \
+                                                                \
+      case G_VARIANT_TYPE_INFO_CHAR_DICT_ENTRY:                 \
+      case G_VARIANT_TYPE_INFO_CHAR_TUPLE:                      \
+        {                                                       \
+          before ## tuple ## after                              \
+        }                                                       \
+                                                                \
+      case G_VARIANT_TYPE_INFO_CHAR_VARIANT:                    \
+        {                                                       \
+          before ## variant ## after                            \
+        }                                                       \
+    }
+
+/* Serializer entry points {{{2
+ *
+ * These are the functions that are called in order for the serializer
+ * to do its thing.
+ */
+
+/* < private >
+ * g_variant_serialised_n_children:
+ * @serialised: a #GVariantSerialised
+ *
+ * For serialized data that represents a container value (maybes,
+ * tuples, arrays, variants), determine how many child items are inside
+ * that container.
+ *
+ * Returns: the number of children
+ */
+gsize
+g_variant_serialised_n_children (GVariantSerialised serialised)
+{
+  g_assert (g_variant_serialised_check (serialised));
+
+  DISPATCH_CASES (serialised.type_info,
+
+                  return gvs_/**/,/**/_n_children (serialised);
+
+                 )
+  g_assert_not_reached ();
+}
+
+/* < private >
+ * g_variant_serialised_get_child:
+ * @serialised: a #GVariantSerialised
+ * @index_: the index of the child to fetch
+ *
+ * Extracts a child from a serialized data representing a container
+ * value.
+ *
+ * It is an error to call this function with an index out of bounds.
+ *
+ * If the result .data == %NULL and .size > 0 then there has been an
+ * error extracting the requested fixed-sized value.  This number of
+ * zero bytes needs to be allocated instead.
+ *
+ * In the case that .data == %NULL and .size == 0 then a zero-sized
+ * item of a variable-sized type is being returned.
+ *
+ * .data is never non-%NULL if size is 0.
+ *
+ * Returns: a #GVariantSerialised for the child
+ */
+GVariantSerialised
+g_variant_serialised_get_child (GVariantSerialised serialised,
+                                gsize              index_)
+{
+  GVariantSerialised child;
+
+  g_assert (g_variant_serialised_check (serialised));
+
+  if G_LIKELY (index_ < g_variant_serialised_n_children (serialised))
+    {
+      DISPATCH_CASES (serialised.type_info,
+
+                      child = gvs_/**/,/**/_get_child (serialised, index_);
+                      g_assert (child.size || child.data == NULL);
+                      g_assert (g_variant_serialised_check (child));
+                      return child;
+
+                     )
+      g_assert_not_reached ();
+    }
+
+  g_error ("Attempt to access item %"G_GSIZE_FORMAT
+           " in a container with only %"G_GSIZE_FORMAT" items",
+           index_, g_variant_serialised_n_children (serialised));
+}
+
+/* < private >
+ * g_variant_serialiser_serialise:
+ * @serialised: a #GVariantSerialised, properly set up
+ * @gvs_filler: the filler function
+ * @children: an array of child items
+ * @n_children: the size of @children
+ *
+ * Writes data in serialized form.
+ *
+ * The type_info field of @serialised must be filled in to type info for
+ * the type that we are serializing.
+ *
+ * The size field of @serialised must be filled in with the value
+ * returned by a previous call to g_variant_serialiser_needed_size().
+ *
+ * The data field of @serialised must be a pointer to a properly-aligned
+ * memory region large enough to serialize into (ie: at least as big as
+ * the size field).
+ *
+ * This function is only resonsible for serializing the top-level
+ * container.  @gvs_filler is called on each child of the container in
+ * order for all of the data of that child to be filled in.
+ */
+void
+g_variant_serialiser_serialise (GVariantSerialised        serialised,
+                                GVariantSerialisedFiller  gvs_filler,
+                                const gpointer           *children,
+                                gsize                     n_children)
+{
+  g_assert (g_variant_serialised_check (serialised));
+
+  DISPATCH_CASES (serialised.type_info,
+
+                  gvs_/**/,/**/_serialise (serialised, gvs_filler,
+                                           children, n_children);
+                  return;
+
+                 )
+  g_assert_not_reached ();
+}
+
+/* < private >
+ * g_variant_serialiser_needed_size:
+ * @type_info: the type to serialize for
+ * @gvs_filler: the filler function
+ * @children: an array of child items
+ * @n_children: the size of @children
+ *
+ * Determines how much memory would be needed to serialize this value.
+ *
+ * This function is only resonsible for performing calculations for the
+ * top-level container.  @gvs_filler is called on each child of the
+ * container in order to determine its size.
+ */
+gsize
+g_variant_serialiser_needed_size (GVariantTypeInfo         *type_info,
+                                  GVariantSerialisedFiller  gvs_filler,
+                                  const gpointer           *children,
+                                  gsize                     n_children)
+{
+  DISPATCH_CASES (type_info,
+
+                  return gvs_/**/,/**/_needed_size (type_info, gvs_filler,
+                                                    children, n_children);
+
+                 )
+  g_assert_not_reached ();
+}
+
+/* Byteswapping {{{2 */
+
+/* < private >
+ * g_variant_serialised_byteswap:
+ * @value: a #GVariantSerialised
+ *
+ * Byte-swap serialized data.  The result of this function is only
+ * well-defined if the data is in normal form.
+ */
+void
+g_variant_serialised_byteswap (GVariantSerialised serialised)
+{
+  gsize fixed_size;
+  guint alignment;
+
+  g_assert (g_variant_serialised_check (serialised));
+
+  if (!serialised.data)
+    return;
+
+  /* the types we potentially need to byteswap are
+   * exactly those with alignment requirements.
+   */
+  g_variant_type_info_query (serialised.type_info, &alignment, &fixed_size);
+  if (!alignment)
+    return;
+
+  /* if fixed size and alignment are equal then we are down
+   * to the base integer type and we should swap it.  the
+   * only exception to this is if we have a tuple with a
+   * single item, and then swapping it will be OK anyway.
+   */
+  if (alignment + 1 == fixed_size)
+    {
+      switch (fixed_size)
+      {
+        case 2:
+          {
+            guint16 *ptr = (guint16 *) serialised.data;
+
+            g_assert_cmpint (serialised.size, ==, 2);
+            *ptr = GUINT16_SWAP_LE_BE (*ptr);
+          }
+          return;
+
+        case 4:
+          {
+            guint32 *ptr = (guint32 *) serialised.data;
+
+            g_assert_cmpint (serialised.size, ==, 4);
+            *ptr = GUINT32_SWAP_LE_BE (*ptr);
+          }
+          return;
+
+        case 8:
+          {
+            guint64 *ptr = (guint64 *) serialised.data;
+
+            g_assert_cmpint (serialised.size, ==, 8);
+            *ptr = GUINT64_SWAP_LE_BE (*ptr);
+          }
+          return;
+
+        default:
+          g_assert_not_reached ();
+      }
+    }
+
+  /* else, we have a container that potentially contains
+   * some children that need to be byteswapped.
+   */
+  else
+    {
+      gsize children, i;
+
+      children = g_variant_serialised_n_children (serialised);
+      for (i = 0; i < children; i++)
+        {
+          GVariantSerialised child;
+
+          child = g_variant_serialised_get_child (serialised, i);
+          g_variant_serialised_byteswap (child);
+          g_variant_type_info_unref (child.type_info);
+        }
+    }
+}
+
+/* Normal form checking {{{2 */
+
+/* < private >
+ * g_variant_serialised_is_normal:
+ * @serialised: a #GVariantSerialised
+ *
+ * Determines, recursively if @serialised is in normal form.  There is
+ * precisely one normal form of serialized data for each possible value.
+ *
+ * It is possible that multiple byte sequences form the serialized data
+ * for a given value if, for example, the padding bytes are filled in
+ * with something other than zeros, but only one form is the normal
+ * form.
+ */
+gboolean
+g_variant_serialised_is_normal (GVariantSerialised serialised)
+{
+  DISPATCH_CASES (serialised.type_info,
+
+                  return gvs_/**/,/**/_is_normal (serialised);
+
+                 )
+
+  if (serialised.data == NULL)
+    return FALSE;
+  if (serialised.depth >= G_VARIANT_MAX_RECURSION_DEPTH)
+    return FALSE;
+
+  /* some hard-coded terminal cases */
+  switch (g_variant_type_info_get_type_char (serialised.type_info))
+    {
+    case 'b': /* boolean */
+      return serialised.data[0] < 2;
+
+    case 's': /* string */
+      return g_variant_serialiser_is_string (serialised.data,
+                                             serialised.size);
+
+    case 'o':
+      return g_variant_serialiser_is_object_path (serialised.data,
+                                                  serialised.size);
+
+    case 'g':
+      return g_variant_serialiser_is_signature (serialised.data,
+                                                serialised.size);
+
+    default:
+      /* all of the other types are fixed-sized numerical types for
+       * which all possible values are valid (including various NaN
+       * representations for floating point values).
+       */
+      return TRUE;
+    }
+}
+
+/* Validity-checking functions {{{2
+ *
+ * Checks if strings, object paths and signature strings are valid.
+ */
+
+/* < private >
+ * g_variant_serialiser_is_string:
+ * @data: a possible string
+ * @size: the size of @data
+ *
+ * Ensures that @data is a valid string with a nul terminator at the end
+ * and no nul bytes embedded.
+ */
+gboolean
+g_variant_serialiser_is_string (gconstpointer data,
+                                gsize         size)
+{
+  const gchar *expected_end;
+  const gchar *end;
+
+  /* Strings must end with a nul terminator. */
+  if (size == 0)
+    return FALSE;
+
+  expected_end = ((gchar *) data) + size - 1;
+
+  if (*expected_end != '\0')
+    return FALSE;
+
+  g_utf8_validate_len (data, size, &end);
+
+  return end == expected_end;
+}
+
+/* < private >
+ * g_variant_serialiser_is_object_path:
+ * @data: a possible D-Bus object path
+ * @size: the size of @data
+ *
+ * Performs the checks for being a valid string.
+ *
+ * Also, ensures that @data is a valid D-Bus object path, as per the D-Bus
+ * specification.
+ */
+gboolean
+g_variant_serialiser_is_object_path (gconstpointer data,
+                                     gsize         size)
+{
+  const gchar *string = data;
+  gsize i;
+
+  if (!g_variant_serialiser_is_string (data, size))
+    return FALSE;
+
+  /* The path must begin with an ASCII '/' (integer 47) character */
+  if (string[0] != '/')
+    return FALSE;
+
+  for (i = 1; string[i]; i++)
+    /* Each element must only contain the ASCII characters
+     * "[A-Z][a-z][0-9]_"
+     */
+    if (g_ascii_isalnum (string[i]) || string[i] == '_')
+      ;
+
+    /* must consist of elements separated by slash characters. */
+    else if (string[i] == '/')
+      {
+        /* No element may be the empty string. */
+        /* Multiple '/' characters cannot occur in sequence. */
+        if (string[i - 1] == '/')
+          return FALSE;
+      }
+
+    else
+      return FALSE;
+
+  /* A trailing '/' character is not allowed unless the path is the
+   * root path (a single '/' character).
+   */
+  if (i > 1 && string[i - 1] == '/')
+    return FALSE;
+
+  return TRUE;
+}
+
+/* < private >
+ * g_variant_serialiser_is_signature:
+ * @data: a possible D-Bus signature
+ * @size: the size of @data
+ *
+ * Performs the checks for being a valid string.
+ *
+ * Also, ensures that @data is a valid D-Bus type signature, as per the
+ * D-Bus specification. Note that this means the empty string is valid, as the
+ * D-Bus specification defines a signature as “zero or more single complete
+ * types”.
+ */
+gboolean
+g_variant_serialiser_is_signature (gconstpointer data,
+                                   gsize         size)
+{
+  const gchar *string = data;
+  gsize first_invalid;
+
+  if (!g_variant_serialiser_is_string (data, size))
+    return FALSE;
+
+  /* make sure no non-definite characters appear */
+  first_invalid = strspn (string, "ybnqiuxthdvasog(){}");
+  if (string[first_invalid])
+    return FALSE;
+
+  /* make sure each type string is well-formed */
+  while (*string)
+    if (!g_variant_type_string_scan (string, NULL, &string))
+      return FALSE;
+
+  return TRUE;
+}
+
+/* Epilogue {{{1 */
+/* vim:set foldmethod=marker: */
diff --git a/glib/gvariant-serialiser.h b/glib/gvariant-serialiser.h
index 859cb7b..6482ef7 100644
--- a/glib/gvariant-serialiser.h
+++ b/glib/gvariant-serialiser.h
@@ -29,6 +29,27 @@ typedef struct
   guchar           *data;
   gsize             size;
   gsize             depth;  /* same semantics as GVariant.depth */
+
+  /* If ordered_offsets_up_to == n this means that all the frame offsets up to and
+   * including the frame offset determining the end of element n are in order.
+   * This guarantees that the bytes of element n don't overlap with any previous
+   * element.
+   *
+   * This is both read and set by g_variant_serialised_get_child() for arrays of
+   * non-fixed-width types, and for tuples.
+   *
+   * Even when dealing with tuples, @ordered_offsets_up_to is an element index,
+   * rather than an index into the frame offsets. */
+  gsize             ordered_offsets_up_to;
+
+  /* Similar to @ordered_offsets_up_to. This gives the index of the child element
+   * whose frame offset is the highest in the offset table which has been
+   * checked so far.
+   *
+   * This is always ≥ @ordered_offsets_up_to. It is always an element index.
+   *
+   * See documentation in gvariant-core.c for `struct GVariant` for details. */
+  gsize             checked_offsets_up_to;
 } GVariantSerialised;
 
 /* deserialization */
diff --git a/glib/gvariant-serialiser.h.orig b/glib/gvariant-serialiser.h.orig
new file mode 100644
index 0000000..859cb7b
--- /dev/null
+++ b/glib/gvariant-serialiser.h.orig
@@ -0,0 +1,76 @@
+/*
+ * Copyright © 2007, 2008 Ryan Lortie
+ * Copyright © 2010 Codethink Limited
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author: Ryan Lortie <desrt@desrt.ca>
+ */
+
+#ifndef __G_VARIANT_SERIALISER_H__
+#define __G_VARIANT_SERIALISER_H__
+
+#include "gvarianttypeinfo.h"
+
+typedef struct
+{
+  GVariantTypeInfo *type_info;
+  guchar           *data;
+  gsize             size;
+  gsize             depth;  /* same semantics as GVariant.depth */
+} GVariantSerialised;
+
+/* deserialization */
+GLIB_AVAILABLE_IN_ALL
+gsize                           g_variant_serialised_n_children         (GVariantSerialised        container);
+GLIB_AVAILABLE_IN_ALL
+GVariantSerialised              g_variant_serialised_get_child          (GVariantSerialised        container,
+                                                                         gsize                     index);
+
+/* serialization */
+typedef void                  (*GVariantSerialisedFiller)               (GVariantSerialised       *serialised,
+                                                                         gpointer                  data);
+
+GLIB_AVAILABLE_IN_ALL
+gsize                           g_variant_serialiser_needed_size        (GVariantTypeInfo         *info,
+                                                                         GVariantSerialisedFiller  gsv_filler,
+                                                                         const gpointer           *children,
+                                                                         gsize                     n_children);
+
+GLIB_AVAILABLE_IN_ALL
+void                            g_variant_serialiser_serialise          (GVariantSerialised        container,
+                                                                         GVariantSerialisedFiller  gsv_filler,
+                                                                         const gpointer           *children,
+                                                                         gsize                     n_children);
+
+/* misc */
+GLIB_AVAILABLE_IN_2_60
+gboolean                        g_variant_serialised_check              (GVariantSerialised        serialised);
+GLIB_AVAILABLE_IN_ALL
+gboolean                        g_variant_serialised_is_normal          (GVariantSerialised        value);
+GLIB_AVAILABLE_IN_ALL
+void                            g_variant_serialised_byteswap           (GVariantSerialised        value);
+
+/* validation of strings */
+GLIB_AVAILABLE_IN_ALL
+gboolean                        g_variant_serialiser_is_string          (gconstpointer             data,
+                                                                         gsize                     size);
+GLIB_AVAILABLE_IN_ALL
+gboolean                        g_variant_serialiser_is_object_path     (gconstpointer             data,
+                                                                         gsize                     size);
+GLIB_AVAILABLE_IN_ALL
+gboolean                        g_variant_serialiser_is_signature       (gconstpointer             data,
+                                                                         gsize                     size);
+
+#endif /* __G_VARIANT_SERIALISER_H__ */
diff --git a/glib/gvariant.c b/glib/gvariant.c
index 5fa6a82..48fd7c4 100644
--- a/glib/gvariant.c
+++ b/glib/gvariant.c
@@ -5803,32 +5803,96 @@ g_variant_iter_loop (GVariantIter *iter,
 
 /* Serialized data {{{1 */
 static GVariant *
-g_variant_deep_copy (GVariant *value)
+g_variant_deep_copy (GVariant *value,
+                     gboolean  byteswap)
 {
   switch (g_variant_classify (value))
     {
     case G_VARIANT_CLASS_MAYBE:
-    case G_VARIANT_CLASS_ARRAY:
     case G_VARIANT_CLASS_TUPLE:
     case G_VARIANT_CLASS_DICT_ENTRY:
     case G_VARIANT_CLASS_VARIANT:
       {
         GVariantBuilder builder;
-        GVariantIter iter;
-        GVariant *child;
+        gsize i, n_children;
 
         g_variant_builder_init (&builder, g_variant_get_type (value));
-        g_variant_iter_init (&iter, value);
 
-        while ((child = g_variant_iter_next_value (&iter)))
+        for (i = 0, n_children = g_variant_n_children (value); i < n_children; i++)
           {
-            g_variant_builder_add_value (&builder, g_variant_deep_copy (child));
+            GVariant *child = g_variant_get_child_value (value, i);
+            g_variant_builder_add_value (&builder, g_variant_deep_copy (child, byteswap));
             g_variant_unref (child);
           }
 
         return g_variant_builder_end (&builder);
       }
 
+    case G_VARIANT_CLASS_ARRAY:
+      {
+        GVariantBuilder builder;
+        gsize i, n_children;
+        GVariant *first_invalid_child_deep_copy = NULL;
+
+        /* Arrays are in theory treated the same as maybes, tuples, dict entries
+         * and variants, and could be another case in the above block of code.
+         *
+         * However, they have the property that when dealing with non-normal
+         * data (which is the only time g_variant_deep_copy() is currently
+         * called) in a variable-sized array, the code above can easily end up
+         * creating many default child values in order to return an array which
+         * is of the right length and type, but without containing non-normal
+         * data. This can happen if the offset table for the array is malformed.
+         *
+         * In this case, the code above would end up allocating the same default
+         * value for each one of the child indexes beyond the first malformed
+         * entry in the offset table. This can end up being a lot of identical
+         * allocations of default values, particularly if the non-normal array
+         * is crafted maliciously.
+         *
+         * Avoid that problem by returning a new reference to the same default
+         * value for every child after the first invalid one. This results in
+         * returning an equivalent array, in normal form and trusted — but with
+         * significantly fewer memory allocations.
+         *
+         * See https://gitlab.gnome.org/GNOME/glib/-/issues/2540 */
+
+        g_variant_builder_init (&builder, g_variant_get_type (value));
+
+        for (i = 0, n_children = g_variant_n_children (value); i < n_children; i++)
+          {
+            /* Try maybe_get_child_value() first; if it returns NULL, this child
+             * is non-normal. get_child_value() would have constructed and
+             * returned a default value in that case. */
+            GVariant *child = g_variant_maybe_get_child_value (value, i);
+
+            if (child != NULL)
+              {
+                /* Non-normal children may not always be contiguous, as they may
+                 * be non-normal for reasons other than invalid offset table
+                 * entries. As they are all the same type, they will all have
+                 * the same default value though, so keep that around. */
+                g_variant_builder_add_value (&builder, g_variant_deep_copy (child, byteswap));
+              }
+            else if (child == NULL && first_invalid_child_deep_copy != NULL)
+              {
+                g_variant_builder_add_value (&builder, first_invalid_child_deep_copy);
+              }
+            else if (child == NULL)
+              {
+                child = g_variant_get_child_value (value, i);
+                first_invalid_child_deep_copy = g_variant_ref_sink (g_variant_deep_copy (child, byteswap));
+                g_variant_builder_add_value (&builder, first_invalid_child_deep_copy);
+              }
+
+            g_clear_pointer (&child, g_variant_unref);
+          }
+
+        g_clear_pointer (&first_invalid_child_deep_copy, g_variant_unref);
+
+        return g_variant_builder_end (&builder);
+      }
+
     case G_VARIANT_CLASS_BOOLEAN:
       return g_variant_new_boolean (g_variant_get_boolean (value));
 
@@ -5836,28 +5900,63 @@ g_variant_deep_copy (GVariant *value)
       return g_variant_new_byte (g_variant_get_byte (value));
 
     case G_VARIANT_CLASS_INT16:
-      return g_variant_new_int16 (g_variant_get_int16 (value));
+      if (byteswap)
+        return g_variant_new_int16 (GUINT16_SWAP_LE_BE (g_variant_get_int16 (value)));
+      else
+        return g_variant_new_int16 (g_variant_get_int16 (value));
 
     case G_VARIANT_CLASS_UINT16:
-      return g_variant_new_uint16 (g_variant_get_uint16 (value));
+      if (byteswap)
+        return g_variant_new_uint16 (GUINT16_SWAP_LE_BE (g_variant_get_uint16 (value)));
+      else
+        return g_variant_new_uint16 (g_variant_get_uint16 (value));
 
     case G_VARIANT_CLASS_INT32:
-      return g_variant_new_int32 (g_variant_get_int32 (value));
+      if (byteswap)
+        return g_variant_new_int32 (GUINT32_SWAP_LE_BE (g_variant_get_int32 (value)));
+      else
+        return g_variant_new_int32 (g_variant_get_int32 (value));
 
     case G_VARIANT_CLASS_UINT32:
-      return g_variant_new_uint32 (g_variant_get_uint32 (value));
+      if (byteswap)
+        return g_variant_new_uint32 (GUINT32_SWAP_LE_BE (g_variant_get_uint32 (value)));
+      else
+        return g_variant_new_uint32 (g_variant_get_uint32 (value));
 
     case G_VARIANT_CLASS_INT64:
-      return g_variant_new_int64 (g_variant_get_int64 (value));
+      if (byteswap)
+        return g_variant_new_int64 (GUINT64_SWAP_LE_BE (g_variant_get_int64 (value)));
+      else
+        return g_variant_new_int64 (g_variant_get_int64 (value));
 
     case G_VARIANT_CLASS_UINT64:
-      return g_variant_new_uint64 (g_variant_get_uint64 (value));
+      if (byteswap)
+        return g_variant_new_uint64 (GUINT64_SWAP_LE_BE (g_variant_get_uint64 (value)));
+      else
+        return g_variant_new_uint64 (g_variant_get_uint64 (value));
 
     case G_VARIANT_CLASS_HANDLE:
-      return g_variant_new_handle (g_variant_get_handle (value));
+      if (byteswap)
+        return g_variant_new_handle (GUINT32_SWAP_LE_BE (g_variant_get_handle (value)));
+      else
+        return g_variant_new_handle (g_variant_get_handle (value));
 
     case G_VARIANT_CLASS_DOUBLE:
-      return g_variant_new_double (g_variant_get_double (value));
+      if (byteswap)
+        {
+          /* We have to convert the double to a uint64 here using a union,
+           * because a cast will round it numerically. */
+          union
+            {
+              guint64 u64;
+              gdouble dbl;
+            } u1, u2;
+          u1.dbl = g_variant_get_double (value);
+          u2.u64 = GUINT64_SWAP_LE_BE (u1.u64);
+          return g_variant_new_double (u2.dbl);
+        }
+      else
+        return g_variant_new_double (g_variant_get_double (value));
 
     case G_VARIANT_CLASS_STRING:
       return g_variant_new_string (g_variant_get_string (value, NULL));
@@ -5887,7 +5986,9 @@ g_variant_deep_copy (GVariant *value)
  * marked as trusted and a new reference to it is returned.
  *
  * If @value is found not to be in normal form then a new trusted
- * #GVariant is created with the same value as @value.
+ * #GVariant is created with the same value as @value. The non-normal parts of
+ * @value will be replaced with default values which are guaranteed to be in
+ * normal form.
  *
  * It makes sense to call this function if you've received #GVariant
  * data from untrusted sources and you want to ensure your serialized
@@ -5912,7 +6013,7 @@ g_variant_get_normal_form (GVariant *value)
   if (g_variant_is_normal_form (value))
     return g_variant_ref (value);
 
-  trusted = g_variant_deep_copy (value);
+  trusted = g_variant_deep_copy (value, FALSE);
   g_assert (g_variant_is_trusted (trusted));
 
   return g_variant_ref_sink (trusted);
@@ -5932,6 +6033,11 @@ g_variant_get_normal_form (GVariant *value)
  * contain multi-byte numeric data.  That include strings, booleans,
  * bytes and containers containing only these things (recursively).
  *
+ * While this function can safely handle untrusted, non-normal data, it is
+ * recommended to check whether the input is in normal form beforehand, using
+ * g_variant_is_normal_form(), and to reject non-normal inputs if your
+ * application can be strict about what inputs it rejects.
+ *
  * The returned value is always in normal form and is marked as trusted.
  *
  * Returns: (transfer full): the byteswapped form of @value
@@ -5949,32 +6055,38 @@ g_variant_byteswap (GVariant *value)
 
   g_variant_type_info_query (type_info, &alignment, NULL);
 
-  if (alignment)
-    /* (potentially) contains multi-byte numeric data */
+  if (alignment && g_variant_is_normal_form (value))
     {
-      GVariantSerialised serialised;
-      GVariant *trusted;
+      /* (potentially) contains multi-byte numeric data, but is also already in
+       * normal form so we can use a faster byteswapping codepath on the
+       * serialised data */
+      GVariantSerialised serialised = { 0, };
       GBytes *bytes;
 
-      trusted = g_variant_get_normal_form (value);
-      serialised.type_info = g_variant_get_type_info (trusted);
-      serialised.size = g_variant_get_size (trusted);
+      serialised.type_info = g_variant_get_type_info (value);
+      serialised.size = g_variant_get_size (value);
       serialised.data = g_malloc (serialised.size);
-      serialised.depth = g_variant_get_depth (trusted);
-      g_variant_store (trusted, serialised.data);
-      g_variant_unref (trusted);
+      serialised.depth = g_variant_get_depth (value);
+      serialised.ordered_offsets_up_to = G_MAXSIZE;  /* operating on the normal form */
+      serialised.checked_offsets_up_to = G_MAXSIZE;
+      g_variant_store (value, serialised.data);
 
       g_variant_serialised_byteswap (serialised);
 
       bytes = g_bytes_new_take (serialised.data, serialised.size);
-      new = g_variant_new_from_bytes (g_variant_get_type (value), bytes, TRUE);
+      new = g_variant_ref_sink (g_variant_new_from_bytes (g_variant_get_type (value), bytes, TRUE));
       g_bytes_unref (bytes);
     }
+  else if (alignment)
+    /* (potentially) contains multi-byte numeric data */
+    new = g_variant_ref_sink (g_variant_deep_copy (value, TRUE));
   else
     /* contains no multi-byte data */
-    new = value;
+    new = g_variant_get_normal_form (value);
+
+  g_assert (g_variant_is_trusted (new));
 
-  return g_variant_ref_sink (new);
+  return g_steal_pointer (&new);
 }
 
 /**
diff --git a/glib/gvariant.c.orig b/glib/gvariant.c.orig
new file mode 100644
index 0000000..5fa6a82
--- /dev/null
+++ b/glib/gvariant.c.orig
@@ -0,0 +1,6049 @@
+/*
+ * Copyright © 2007, 2008 Ryan Lortie
+ * Copyright © 2010 Codethink Limited
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author: Ryan Lortie <desrt@desrt.ca>
+ */
+
+/* Prologue {{{1 */
+
+#include "config.h"
+
+#include <glib/gvariant-serialiser.h>
+#include "gvariant-internal.h"
+#include <glib/gvariant-core.h>
+#include <glib/gtestutils.h>
+#include <glib/gstrfuncs.h>
+#include <glib/gslice.h>
+#include <glib/ghash.h>
+#include <glib/gmem.h>
+
+#include <string.h>
+
+
+/**
+ * SECTION:gvariant
+ * @title: GVariant
+ * @short_description: strongly typed value datatype
+ * @see_also: GVariantType
+ *
+ * #GVariant is a variant datatype; it can contain one or more values
+ * along with information about the type of the values.
+ *
+ * A #GVariant may contain simple types, like an integer, or a boolean value;
+ * or complex types, like an array of two strings, or a dictionary of key
+ * value pairs. A #GVariant is also immutable: once it's been created neither
+ * its type nor its content can be modified further.
+ *
+ * GVariant is useful whenever data needs to be serialized, for example when
+ * sending method parameters in D-Bus, or when saving settings using GSettings.
+ *
+ * When creating a new #GVariant, you pass the data you want to store in it
+ * along with a string representing the type of data you wish to pass to it.
+ *
+ * For instance, if you want to create a #GVariant holding an integer value you
+ * can use:
+ *
+ * |[<!-- language="C" -->
+ *   GVariant *v = g_variant_new ("u", 40);
+ * ]|
+ *
+ * The string "u" in the first argument tells #GVariant that the data passed to
+ * the constructor (40) is going to be an unsigned integer.
+ *
+ * More advanced examples of #GVariant in use can be found in documentation for
+ * [GVariant format strings][gvariant-format-strings-pointers].
+ *
+ * The range of possible values is determined by the type.
+ *
+ * The type system used by #GVariant is #GVariantType. 
+ *
+ * #GVariant instances always have a type and a value (which are given
+ * at construction time).  The type and value of a #GVariant instance
+ * can never change other than by the #GVariant itself being
+ * destroyed.  A #GVariant cannot contain a pointer.
+ *
+ * #GVariant is reference counted using g_variant_ref() and
+ * g_variant_unref().  #GVariant also has floating reference counts --
+ * see g_variant_ref_sink().
+ *
+ * #GVariant is completely threadsafe.  A #GVariant instance can be
+ * concurrently accessed in any way from any number of threads without
+ * problems.
+ *
+ * #GVariant is heavily optimised for dealing with data in serialized
+ * form.  It works particularly well with data located in memory-mapped
+ * files.  It can perform nearly all deserialization operations in a
+ * small constant time, usually touching only a single memory page.
+ * Serialized #GVariant data can also be sent over the network.
+ *
+ * #GVariant is largely compatible with D-Bus.  Almost all types of
+ * #GVariant instances can be sent over D-Bus.  See #GVariantType for
+ * exceptions.  (However, #GVariant's serialization format is not the same
+ * as the serialization format of a D-Bus message body: use #GDBusMessage,
+ * in the gio library, for those.)
+ *
+ * For space-efficiency, the #GVariant serialization format does not
+ * automatically include the variant's length, type or endianness,
+ * which must either be implied from context (such as knowledge that a
+ * particular file format always contains a little-endian
+ * %G_VARIANT_TYPE_VARIANT which occupies the whole length of the file)
+ * or supplied out-of-band (for instance, a length, type and/or endianness
+ * indicator could be placed at the beginning of a file, network message
+ * or network stream).
+ *
+ * A #GVariant's size is limited mainly by any lower level operating
+ * system constraints, such as the number of bits in #gsize.  For
+ * example, it is reasonable to have a 2GB file mapped into memory
+ * with #GMappedFile, and call g_variant_new_from_data() on it.
+ *
+ * For convenience to C programmers, #GVariant features powerful
+ * varargs-based value construction and destruction.  This feature is
+ * designed to be embedded in other libraries.
+ *
+ * There is a Python-inspired text language for describing #GVariant
+ * values.  #GVariant includes a printer for this language and a parser
+ * with type inferencing.
+ *
+ * ## Memory Use
+ *
+ * #GVariant tries to be quite efficient with respect to memory use.
+ * This section gives a rough idea of how much memory is used by the
+ * current implementation.  The information here is subject to change
+ * in the future.
+ *
+ * The memory allocated by #GVariant can be grouped into 4 broad
+ * purposes: memory for serialized data, memory for the type
+ * information cache, buffer management memory and memory for the
+ * #GVariant structure itself.
+ *
+ * ## Serialized Data Memory
+ *
+ * This is the memory that is used for storing GVariant data in
+ * serialized form.  This is what would be sent over the network or
+ * what would end up on disk, not counting any indicator of the
+ * endianness, or of the length or type of the top-level variant.
+ *
+ * The amount of memory required to store a boolean is 1 byte. 16,
+ * 32 and 64 bit integers and double precision floating point numbers
+ * use their "natural" size.  Strings (including object path and
+ * signature strings) are stored with a nul terminator, and as such
+ * use the length of the string plus 1 byte.
+ *
+ * Maybe types use no space at all to represent the null value and
+ * use the same amount of space (sometimes plus one byte) as the
+ * equivalent non-maybe-typed value to represent the non-null case.
+ *
+ * Arrays use the amount of space required to store each of their
+ * members, concatenated.  Additionally, if the items stored in an
+ * array are not of a fixed-size (ie: strings, other arrays, etc)
+ * then an additional framing offset is stored for each item.  The
+ * size of this offset is either 1, 2 or 4 bytes depending on the
+ * overall size of the container.  Additionally, extra padding bytes
+ * are added as required for alignment of child values.
+ *
+ * Tuples (including dictionary entries) use the amount of space
+ * required to store each of their members, concatenated, plus one
+ * framing offset (as per arrays) for each non-fixed-sized item in
+ * the tuple, except for the last one.  Additionally, extra padding
+ * bytes are added as required for alignment of child values.
+ *
+ * Variants use the same amount of space as the item inside of the
+ * variant, plus 1 byte, plus the length of the type string for the
+ * item inside the variant.
+ *
+ * As an example, consider a dictionary mapping strings to variants.
+ * In the case that the dictionary is empty, 0 bytes are required for
+ * the serialization.
+ *
+ * If we add an item "width" that maps to the int32 value of 500 then
+ * we will use 4 byte to store the int32 (so 6 for the variant
+ * containing it) and 6 bytes for the string.  The variant must be
+ * aligned to 8 after the 6 bytes of the string, so that's 2 extra
+ * bytes.  6 (string) + 2 (padding) + 6 (variant) is 14 bytes used
+ * for the dictionary entry.  An additional 1 byte is added to the
+ * array as a framing offset making a total of 15 bytes.
+ *
+ * If we add another entry, "title" that maps to a nullable string
+ * that happens to have a value of null, then we use 0 bytes for the
+ * null value (and 3 bytes for the variant to contain it along with
+ * its type string) plus 6 bytes for the string.  Again, we need 2
+ * padding bytes.  That makes a total of 6 + 2 + 3 = 11 bytes.
+ *
+ * We now require extra padding between the two items in the array.
+ * After the 14 bytes of the first item, that's 2 bytes required.
+ * We now require 2 framing offsets for an extra two
+ * bytes. 14 + 2 + 11 + 2 = 29 bytes to encode the entire two-item
+ * dictionary.
+ *
+ * ## Type Information Cache
+ *
+ * For each GVariant type that currently exists in the program a type
+ * information structure is kept in the type information cache.  The
+ * type information structure is required for rapid deserialization.
+ *
+ * Continuing with the above example, if a #GVariant exists with the
+ * type "a{sv}" then a type information struct will exist for
+ * "a{sv}", "{sv}", "s", and "v".  Multiple uses of the same type
+ * will share the same type information.  Additionally, all
+ * single-digit types are stored in read-only static memory and do
+ * not contribute to the writable memory footprint of a program using
+ * #GVariant.
+ *
+ * Aside from the type information structures stored in read-only
+ * memory, there are two forms of type information.  One is used for
+ * container types where there is a single element type: arrays and
+ * maybe types.  The other is used for container types where there
+ * are multiple element types: tuples and dictionary entries.
+ *
+ * Array type info structures are 6 * sizeof (void *), plus the
+ * memory required to store the type string itself.  This means that
+ * on 32-bit systems, the cache entry for "a{sv}" would require 30
+ * bytes of memory (plus malloc overhead).
+ *
+ * Tuple type info structures are 6 * sizeof (void *), plus 4 *
+ * sizeof (void *) for each item in the tuple, plus the memory
+ * required to store the type string itself.  A 2-item tuple, for
+ * example, would have a type information structure that consumed
+ * writable memory in the size of 14 * sizeof (void *) (plus type
+ * string)  This means that on 32-bit systems, the cache entry for
+ * "{sv}" would require 61 bytes of memory (plus malloc overhead).
+ *
+ * This means that in total, for our "a{sv}" example, 91 bytes of
+ * type information would be allocated.
+ * 
+ * The type information cache, additionally, uses a #GHashTable to
+ * store and look up the cached items and stores a pointer to this
+ * hash table in static storage.  The hash table is freed when there
+ * are zero items in the type cache.
+ *
+ * Although these sizes may seem large it is important to remember
+ * that a program will probably only have a very small number of
+ * different types of values in it and that only one type information
+ * structure is required for many different values of the same type.
+ *
+ * ## Buffer Management Memory
+ *
+ * #GVariant uses an internal buffer management structure to deal
+ * with the various different possible sources of serialized data
+ * that it uses.  The buffer is responsible for ensuring that the
+ * correct call is made when the data is no longer in use by
+ * #GVariant.  This may involve a g_free() or a g_slice_free() or
+ * even g_mapped_file_unref().
+ *
+ * One buffer management structure is used for each chunk of
+ * serialized data.  The size of the buffer management structure
+ * is 4 * (void *).  On 32-bit systems, that's 16 bytes.
+ *
+ * ## GVariant structure
+ *
+ * The size of a #GVariant structure is 6 * (void *).  On 32-bit
+ * systems, that's 24 bytes.
+ *
+ * #GVariant structures only exist if they are explicitly created
+ * with API calls.  For example, if a #GVariant is constructed out of
+ * serialized data for the example given above (with the dictionary)
+ * then although there are 9 individual values that comprise the
+ * entire dictionary (two keys, two values, two variants containing
+ * the values, two dictionary entries, plus the dictionary itself),
+ * only 1 #GVariant instance exists -- the one referring to the
+ * dictionary.
+ *
+ * If calls are made to start accessing the other values then
+ * #GVariant instances will exist for those values only for as long
+ * as they are in use (ie: until you call g_variant_unref()).  The
+ * type information is shared.  The serialized data and the buffer
+ * management structure for that serialized data is shared by the
+ * child.
+ *
+ * ## Summary
+ *
+ * To put the entire example together, for our dictionary mapping
+ * strings to variants (with two entries, as given above), we are
+ * using 91 bytes of memory for type information, 29 bytes of memory
+ * for the serialized data, 16 bytes for buffer management and 24
+ * bytes for the #GVariant instance, or a total of 160 bytes, plus
+ * malloc overhead.  If we were to use g_variant_get_child_value() to
+ * access the two dictionary entries, we would use an additional 48
+ * bytes.  If we were to have other dictionaries of the same type, we
+ * would use more memory for the serialized data and buffer
+ * management for those dictionaries, but the type information would
+ * be shared.
+ */
+
+/* definition of GVariant structure is in gvariant-core.c */
+
+/* this is a g_return_val_if_fail() for making
+ * sure a (GVariant *) has the required type.
+ */
+#define TYPE_CHECK(value, TYPE, val) \
+  if G_UNLIKELY (!g_variant_is_of_type (value, TYPE)) {           \
+    g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC,            \
+                              "g_variant_is_of_type (" #value     \
+                              ", " #TYPE ")");                    \
+    return val;                                                   \
+  }
+
+/* Numeric Type Constructor/Getters {{{1 */
+/* < private >
+ * g_variant_new_from_trusted:
+ * @type: the #GVariantType
+ * @data: the data to use
+ * @size: the size of @data
+ *
+ * Constructs a new trusted #GVariant instance from the provided data.
+ * This is used to implement g_variant_new_* for all the basic types.
+ *
+ * Note: @data must be backed by memory that is aligned appropriately for the
+ * @type being loaded. Otherwise this function will internally create a copy of
+ * the memory (since GLib 2.60) or (in older versions) fail and exit the
+ * process.
+ *
+ * Returns: a new floating #GVariant
+ */
+static GVariant *
+g_variant_new_from_trusted (const GVariantType *type,
+                            gconstpointer       data,
+                            gsize               size)
+{
+  GVariant *value;
+  GBytes *bytes;
+
+  bytes = g_bytes_new (data, size);
+  value = g_variant_new_from_bytes (type, bytes, TRUE);
+  g_bytes_unref (bytes);
+
+  return value;
+}
+
+/**
+ * g_variant_new_boolean:
+ * @value: a #gboolean value
+ *
+ * Creates a new boolean #GVariant instance -- either %TRUE or %FALSE.
+ *
+ * Returns: (transfer none): a floating reference to a new boolean #GVariant instance
+ *
+ * Since: 2.24
+ **/
+GVariant *
+g_variant_new_boolean (gboolean value)
+{
+  guchar v = value;
+
+  return g_variant_new_from_trusted (G_VARIANT_TYPE_BOOLEAN, &v, 1);
+}
+
+/**
+ * g_variant_get_boolean:
+ * @value: a boolean #GVariant instance
+ *
+ * Returns the boolean value of @value.
+ *
+ * It is an error to call this function with a @value of any type
+ * other than %G_VARIANT_TYPE_BOOLEAN.
+ *
+ * Returns: %TRUE or %FALSE
+ *
+ * Since: 2.24
+ **/
+gboolean
+g_variant_get_boolean (GVariant *value)
+{
+  const guchar *data;
+
+  TYPE_CHECK (value, G_VARIANT_TYPE_BOOLEAN, FALSE);
+
+  data = g_variant_get_data (value);
+
+  return data != NULL ? *data != 0 : FALSE;
+}
+
+/* the constructors and accessors for byte, int{16,32,64}, handles and
+ * doubles all look pretty much exactly the same, so we reduce
+ * copy/pasting here.
+ */
+#define NUMERIC_TYPE(TYPE, type, ctype) \
+  GVariant *g_variant_new_##type (ctype value) {                \
+    return g_variant_new_from_trusted (G_VARIANT_TYPE_##TYPE,   \
+                                       &value, sizeof value);   \
+  }                                                             \
+  ctype g_variant_get_##type (GVariant *value) {                \
+    const ctype *data;                                          \
+    TYPE_CHECK (value, G_VARIANT_TYPE_ ## TYPE, 0);             \
+    data = g_variant_get_data (value);                          \
+    return data != NULL ? *data : 0;                            \
+  }
+
+
+/**
+ * g_variant_new_byte:
+ * @value: a #guint8 value
+ *
+ * Creates a new byte #GVariant instance.
+ *
+ * Returns: (transfer none): a floating reference to a new byte #GVariant instance
+ *
+ * Since: 2.24
+ **/
+/**
+ * g_variant_get_byte:
+ * @value: a byte #GVariant instance
+ *
+ * Returns the byte value of @value.
+ *
+ * It is an error to call this function with a @value of any type
+ * other than %G_VARIANT_TYPE_BYTE.
+ *
+ * Returns: a #guint8
+ *
+ * Since: 2.24
+ **/
+NUMERIC_TYPE (BYTE, byte, guint8)
+
+/**
+ * g_variant_new_int16:
+ * @value: a #gint16 value
+ *
+ * Creates a new int16 #GVariant instance.
+ *
+ * Returns: (transfer none): a floating reference to a new int16 #GVariant instance
+ *
+ * Since: 2.24
+ **/
+/**
+ * g_variant_get_int16:
+ * @value: an int16 #GVariant instance
+ *
+ * Returns the 16-bit signed integer value of @value.
+ *
+ * It is an error to call this function with a @value of any type
+ * other than %G_VARIANT_TYPE_INT16.
+ *
+ * Returns: a #gint16
+ *
+ * Since: 2.24
+ **/
+NUMERIC_TYPE (INT16, int16, gint16)
+
+/**
+ * g_variant_new_uint16:
+ * @value: a #guint16 value
+ *
+ * Creates a new uint16 #GVariant instance.
+ *
+ * Returns: (transfer none): a floating reference to a new uint16 #GVariant instance
+ *
+ * Since: 2.24
+ **/
+/**
+ * g_variant_get_uint16:
+ * @value: a uint16 #GVariant instance
+ *
+ * Returns the 16-bit unsigned integer value of @value.
+ *
+ * It is an error to call this function with a @value of any type
+ * other than %G_VARIANT_TYPE_UINT16.
+ *
+ * Returns: a #guint16
+ *
+ * Since: 2.24
+ **/
+NUMERIC_TYPE (UINT16, uint16, guint16)
+
+/**
+ * g_variant_new_int32:
+ * @value: a #gint32 value
+ *
+ * Creates a new int32 #GVariant instance.
+ *
+ * Returns: (transfer none): a floating reference to a new int32 #GVariant instance
+ *
+ * Since: 2.24
+ **/
+/**
+ * g_variant_get_int32:
+ * @value: an int32 #GVariant instance
+ *
+ * Returns the 32-bit signed integer value of @value.
+ *
+ * It is an error to call this function with a @value of any type
+ * other than %G_VARIANT_TYPE_INT32.
+ *
+ * Returns: a #gint32
+ *
+ * Since: 2.24
+ **/
+NUMERIC_TYPE (INT32, int32, gint32)
+
+/**
+ * g_variant_new_uint32:
+ * @value: a #guint32 value
+ *
+ * Creates a new uint32 #GVariant instance.
+ *
+ * Returns: (transfer none): a floating reference to a new uint32 #GVariant instance
+ *
+ * Since: 2.24
+ **/
+/**
+ * g_variant_get_uint32:
+ * @value: a uint32 #GVariant instance
+ *
+ * Returns the 32-bit unsigned integer value of @value.
+ *
+ * It is an error to call this function with a @value of any type
+ * other than %G_VARIANT_TYPE_UINT32.
+ *
+ * Returns: a #guint32
+ *
+ * Since: 2.24
+ **/
+NUMERIC_TYPE (UINT32, uint32, guint32)
+
+/**
+ * g_variant_new_int64:
+ * @value: a #gint64 value
+ *
+ * Creates a new int64 #GVariant instance.
+ *
+ * Returns: (transfer none): a floating reference to a new int64 #GVariant instance
+ *
+ * Since: 2.24
+ **/
+/**
+ * g_variant_get_int64:
+ * @value: an int64 #GVariant instance
+ *
+ * Returns the 64-bit signed integer value of @value.
+ *
+ * It is an error to call this function with a @value of any type
+ * other than %G_VARIANT_TYPE_INT64.
+ *
+ * Returns: a #gint64
+ *
+ * Since: 2.24
+ **/
+NUMERIC_TYPE (INT64, int64, gint64)
+
+/**
+ * g_variant_new_uint64:
+ * @value: a #guint64 value
+ *
+ * Creates a new uint64 #GVariant instance.
+ *
+ * Returns: (transfer none): a floating reference to a new uint64 #GVariant instance
+ *
+ * Since: 2.24
+ **/
+/**
+ * g_variant_get_uint64:
+ * @value: a uint64 #GVariant instance
+ *
+ * Returns the 64-bit unsigned integer value of @value.
+ *
+ * It is an error to call this function with a @value of any type
+ * other than %G_VARIANT_TYPE_UINT64.
+ *
+ * Returns: a #guint64
+ *
+ * Since: 2.24
+ **/
+NUMERIC_TYPE (UINT64, uint64, guint64)
+
+/**
+ * g_variant_new_handle:
+ * @value: a #gint32 value
+ *
+ * Creates a new handle #GVariant instance.
+ *
+ * By convention, handles are indexes into an array of file descriptors
+ * that are sent alongside a D-Bus message.  If you're not interacting
+ * with D-Bus, you probably don't need them.
+ *
+ * Returns: (transfer none): a floating reference to a new handle #GVariant instance
+ *
+ * Since: 2.24
+ **/
+/**
+ * g_variant_get_handle:
+ * @value: a handle #GVariant instance
+ *
+ * Returns the 32-bit signed integer value of @value.
+ *
+ * It is an error to call this function with a @value of any type other
+ * than %G_VARIANT_TYPE_HANDLE.
+ *
+ * By convention, handles are indexes into an array of file descriptors
+ * that are sent alongside a D-Bus message.  If you're not interacting
+ * with D-Bus, you probably don't need them.
+ *
+ * Returns: a #gint32
+ *
+ * Since: 2.24
+ **/
+NUMERIC_TYPE (HANDLE, handle, gint32)
+
+/**
+ * g_variant_new_double:
+ * @value: a #gdouble floating point value
+ *
+ * Creates a new double #GVariant instance.
+ *
+ * Returns: (transfer none): a floating reference to a new double #GVariant instance
+ *
+ * Since: 2.24
+ **/
+/**
+ * g_variant_get_double:
+ * @value: a double #GVariant instance
+ *
+ * Returns the double precision floating point value of @value.
+ *
+ * It is an error to call this function with a @value of any type
+ * other than %G_VARIANT_TYPE_DOUBLE.
+ *
+ * Returns: a #gdouble
+ *
+ * Since: 2.24
+ **/
+NUMERIC_TYPE (DOUBLE, double, gdouble)
+
+/* Container type Constructor / Deconstructors {{{1 */
+/**
+ * g_variant_new_maybe:
+ * @child_type: (nullable): the #GVariantType of the child, or %NULL
+ * @child: (nullable): the child value, or %NULL
+ *
+ * Depending on if @child is %NULL, either wraps @child inside of a
+ * maybe container or creates a Nothing instance for the given @type.
+ *
+ * At least one of @child_type and @child must be non-%NULL.
+ * If @child_type is non-%NULL then it must be a definite type.
+ * If they are both non-%NULL then @child_type must be the type
+ * of @child.
+ *
+ * If @child is a floating reference (see g_variant_ref_sink()), the new
+ * instance takes ownership of @child.
+ *
+ * Returns: (transfer none): a floating reference to a new #GVariant maybe instance
+ *
+ * Since: 2.24
+ **/
+GVariant *
+g_variant_new_maybe (const GVariantType *child_type,
+                     GVariant           *child)
+{
+  GVariantType *maybe_type;
+  GVariant *value;
+
+  g_return_val_if_fail (child_type == NULL || g_variant_type_is_definite
+                        (child_type), 0);
+  g_return_val_if_fail (child_type != NULL || child != NULL, NULL);
+  g_return_val_if_fail (child_type == NULL || child == NULL ||
+                        g_variant_is_of_type (child, child_type),
+                        NULL);
+
+  if (child_type == NULL)
+    child_type = g_variant_get_type (child);
+
+  maybe_type = g_variant_type_new_maybe (child_type);
+
+  if (child != NULL)
+    {
+      GVariant **children;
+      gboolean trusted;
+
+      children = g_new (GVariant *, 1);
+      children[0] = g_variant_ref_sink (child);
+      trusted = g_variant_is_trusted (children[0]);
+
+      value = g_variant_new_from_children (maybe_type, children, 1, trusted);
+    }
+  else
+    value = g_variant_new_from_children (maybe_type, NULL, 0, TRUE);
+
+  g_variant_type_free (maybe_type);
+
+  return value;
+}
+
+/**
+ * g_variant_get_maybe:
+ * @value: a maybe-typed value
+ *
+ * Given a maybe-typed #GVariant instance, extract its value.  If the
+ * value is Nothing, then this function returns %NULL.
+ *
+ * Returns: (nullable) (transfer full): the contents of @value, or %NULL
+ *
+ * Since: 2.24
+ **/
+GVariant *
+g_variant_get_maybe (GVariant *value)
+{
+  TYPE_CHECK (value, G_VARIANT_TYPE_MAYBE, NULL);
+
+  if (g_variant_n_children (value))
+    return g_variant_get_child_value (value, 0);
+
+  return NULL;
+}
+
+/**
+ * g_variant_new_variant: (constructor)
+ * @value: a #GVariant instance
+ *
+ * Boxes @value.  The result is a #GVariant instance representing a
+ * variant containing the original value.
+ *
+ * If @child is a floating reference (see g_variant_ref_sink()), the new
+ * instance takes ownership of @child.
+ *
+ * Returns: (transfer none): a floating reference to a new variant #GVariant instance
+ *
+ * Since: 2.24
+ **/
+GVariant *
+g_variant_new_variant (GVariant *value)
+{
+  g_return_val_if_fail (value != NULL, NULL);
+
+  g_variant_ref_sink (value);
+
+  return g_variant_new_from_children (G_VARIANT_TYPE_VARIANT,
+                                      g_memdup2 (&value, sizeof value),
+                                      1, g_variant_is_trusted (value));
+}
+
+/**
+ * g_variant_get_variant:
+ * @value: a variant #GVariant instance
+ *
+ * Unboxes @value.  The result is the #GVariant instance that was
+ * contained in @value.
+ *
+ * Returns: (transfer full): the item contained in the variant
+ *
+ * Since: 2.24
+ **/
+GVariant *
+g_variant_get_variant (GVariant *value)
+{
+  TYPE_CHECK (value, G_VARIANT_TYPE_VARIANT, NULL);
+
+  return g_variant_get_child_value (value, 0);
+}
+
+/**
+ * g_variant_new_array:
+ * @child_type: (nullable): the element type of the new array
+ * @children: (nullable) (array length=n_children): an array of
+ *            #GVariant pointers, the children
+ * @n_children: the length of @children
+ *
+ * Creates a new #GVariant array from @children.
+ *
+ * @child_type must be non-%NULL if @n_children is zero.  Otherwise, the
+ * child type is determined by inspecting the first element of the
+ * @children array.  If @child_type is non-%NULL then it must be a
+ * definite type.
+ *
+ * The items of the array are taken from the @children array.  No entry
+ * in the @children array may be %NULL.
+ *
+ * All items in the array must have the same type, which must be the
+ * same as @child_type, if given.
+ *
+ * If the @children are floating references (see g_variant_ref_sink()), the
+ * new instance takes ownership of them as if via g_variant_ref_sink().
+ *
+ * Returns: (transfer none): a floating reference to a new #GVariant array
+ *
+ * Since: 2.24
+ **/
+GVariant *
+g_variant_new_array (const GVariantType *child_type,
+                     GVariant * const   *children,
+                     gsize               n_children)
+{
+  GVariantType *array_type;
+  GVariant **my_children;
+  gboolean trusted;
+  GVariant *value;
+  gsize i;
+
+  g_return_val_if_fail (n_children > 0 || child_type != NULL, NULL);
+  g_return_val_if_fail (n_children == 0 || children != NULL, NULL);
+  g_return_val_if_fail (child_type == NULL ||
+                        g_variant_type_is_definite (child_type), NULL);
+
+  my_children = g_new (GVariant *, n_children);
+  trusted = TRUE;
+
+  if (child_type == NULL)
+    child_type = g_variant_get_type (children[0]);
+  array_type = g_variant_type_new_array (child_type);
+
+  for (i = 0; i < n_children; i++)
+    {
+      if G_UNLIKELY (!g_variant_is_of_type (children[i], child_type))
+        {
+          while (i != 0)
+            g_variant_unref (my_children[--i]);
+          g_free (my_children);
+	  g_return_val_if_fail (g_variant_is_of_type (children[i], child_type), NULL);
+        }
+      my_children[i] = g_variant_ref_sink (children[i]);
+      trusted &= g_variant_is_trusted (children[i]);
+    }
+
+  value = g_variant_new_from_children (array_type, my_children,
+                                       n_children, trusted);
+  g_variant_type_free (array_type);
+
+  return value;
+}
+
+/*< private >
+ * g_variant_make_tuple_type:
+ * @children: (array length=n_children): an array of GVariant *
+ * @n_children: the length of @children
+ *
+ * Return the type of a tuple containing @children as its items.
+ **/
+static GVariantType *
+g_variant_make_tuple_type (GVariant * const *children,
+                           gsize             n_children)
+{
+  const GVariantType **types;
+  GVariantType *type;
+  gsize i;
+
+  types = g_new (const GVariantType *, n_children);
+
+  for (i = 0; i < n_children; i++)
+    types[i] = g_variant_get_type (children[i]);
+
+  type = g_variant_type_new_tuple (types, n_children);
+  g_free (types);
+
+  return type;
+}
+
+/**
+ * g_variant_new_tuple:
+ * @children: (array length=n_children): the items to make the tuple out of
+ * @n_children: the length of @children
+ *
+ * Creates a new tuple #GVariant out of the items in @children.  The
+ * type is determined from the types of @children.  No entry in the
+ * @children array may be %NULL.
+ *
+ * If @n_children is 0 then the unit tuple is constructed.
+ *
+ * If the @children are floating references (see g_variant_ref_sink()), the
+ * new instance takes ownership of them as if via g_variant_ref_sink().
+ *
+ * Returns: (transfer none): a floating reference to a new #GVariant tuple
+ *
+ * Since: 2.24
+ **/
+GVariant *
+g_variant_new_tuple (GVariant * const *children,
+                     gsize             n_children)
+{
+  GVariantType *tuple_type;
+  GVariant **my_children;
+  gboolean trusted;
+  GVariant *value;
+  gsize i;
+
+  g_return_val_if_fail (n_children == 0 || children != NULL, NULL);
+
+  my_children = g_new (GVariant *, n_children);
+  trusted = TRUE;
+
+  for (i = 0; i < n_children; i++)
+    {
+      my_children[i] = g_variant_ref_sink (children[i]);
+      trusted &= g_variant_is_trusted (children[i]);
+    }
+
+  tuple_type = g_variant_make_tuple_type (children, n_children);
+  value = g_variant_new_from_children (tuple_type, my_children,
+                                       n_children, trusted);
+  g_variant_type_free (tuple_type);
+
+  return value;
+}
+
+/*< private >
+ * g_variant_make_dict_entry_type:
+ * @key: a #GVariant, the key
+ * @val: a #GVariant, the value
+ *
+ * Return the type of a dictionary entry containing @key and @val as its
+ * children.
+ **/
+static GVariantType *
+g_variant_make_dict_entry_type (GVariant *key,
+                                GVariant *val)
+{
+  return g_variant_type_new_dict_entry (g_variant_get_type (key),
+                                        g_variant_get_type (val));
+}
+
+/**
+ * g_variant_new_dict_entry: (constructor)
+ * @key: a basic #GVariant, the key
+ * @value: a #GVariant, the value
+ *
+ * Creates a new dictionary entry #GVariant. @key and @value must be
+ * non-%NULL. @key must be a value of a basic type (ie: not a container).
+ *
+ * If the @key or @value are floating references (see g_variant_ref_sink()),
+ * the new instance takes ownership of them as if via g_variant_ref_sink().
+ *
+ * Returns: (transfer none): a floating reference to a new dictionary entry #GVariant
+ *
+ * Since: 2.24
+ **/
+GVariant *
+g_variant_new_dict_entry (GVariant *key,
+                          GVariant *value)
+{
+  GVariantType *dict_type;
+  GVariant **children;
+  gboolean trusted;
+
+  g_return_val_if_fail (key != NULL && value != NULL, NULL);
+  g_return_val_if_fail (!g_variant_is_container (key), NULL);
+
+  children = g_new (GVariant *, 2);
+  children[0] = g_variant_ref_sink (key);
+  children[1] = g_variant_ref_sink (value);
+  trusted = g_variant_is_trusted (key) && g_variant_is_trusted (value);
+
+  dict_type = g_variant_make_dict_entry_type (key, value);
+  value = g_variant_new_from_children (dict_type, children, 2, trusted);
+  g_variant_type_free (dict_type);
+
+  return value;
+}
+
+/**
+ * g_variant_lookup: (skip)
+ * @dictionary: a dictionary #GVariant
+ * @key: the key to look up in the dictionary
+ * @format_string: a GVariant format string
+ * @...: the arguments to unpack the value into
+ *
+ * Looks up a value in a dictionary #GVariant.
+ *
+ * This function is a wrapper around g_variant_lookup_value() and
+ * g_variant_get().  In the case that %NULL would have been returned,
+ * this function returns %FALSE.  Otherwise, it unpacks the returned
+ * value and returns %TRUE.
+ *
+ * @format_string determines the C types that are used for unpacking
+ * the values and also determines if the values are copied or borrowed,
+ * see the section on
+ * [GVariant format strings][gvariant-format-strings-pointers].
+ *
+ * This function is currently implemented with a linear scan.  If you
+ * plan to do many lookups then #GVariantDict may be more efficient.
+ *
+ * Returns: %TRUE if a value was unpacked
+ *
+ * Since: 2.28
+ */
+gboolean
+g_variant_lookup (GVariant    *dictionary,
+                  const gchar *key,
+                  const gchar *format_string,
+                  ...)
+{
+  GVariantType *type;
+  GVariant *value;
+
+  /* flatten */
+  g_variant_get_data (dictionary);
+
+  type = g_variant_format_string_scan_type (format_string, NULL, NULL);
+  value = g_variant_lookup_value (dictionary, key, type);
+  g_variant_type_free (type);
+
+  if (value)
+    {
+      va_list ap;
+
+      va_start (ap, format_string);
+      g_variant_get_va (value, format_string, NULL, &ap);
+      g_variant_unref (value);
+      va_end (ap);
+
+      return TRUE;
+    }
+
+  else
+    return FALSE;
+}
+
+/**
+ * g_variant_lookup_value:
+ * @dictionary: a dictionary #GVariant
+ * @key: the key to look up in the dictionary
+ * @expected_type: (nullable): a #GVariantType, or %NULL
+ *
+ * Looks up a value in a dictionary #GVariant.
+ *
+ * This function works with dictionaries of the type a{s*} (and equally
+ * well with type a{o*}, but we only further discuss the string case
+ * for sake of clarity).
+ *
+ * In the event that @dictionary has the type a{sv}, the @expected_type
+ * string specifies what type of value is expected to be inside of the
+ * variant. If the value inside the variant has a different type then
+ * %NULL is returned. In the event that @dictionary has a value type other
+ * than v then @expected_type must directly match the value type and it is
+ * used to unpack the value directly or an error occurs.
+ *
+ * In either case, if @key is not found in @dictionary, %NULL is returned.
+ *
+ * If the key is found and the value has the correct type, it is
+ * returned.  If @expected_type was specified then any non-%NULL return
+ * value will have this type.
+ *
+ * This function is currently implemented with a linear scan.  If you
+ * plan to do many lookups then #GVariantDict may be more efficient.
+ *
+ * Returns: (transfer full): the value of the dictionary key, or %NULL
+ *
+ * Since: 2.28
+ */
+GVariant *
+g_variant_lookup_value (GVariant           *dictionary,
+                        const gchar        *key,
+                        const GVariantType *expected_type)
+{
+  GVariantIter iter;
+  GVariant *entry;
+  GVariant *value;
+
+  g_return_val_if_fail (g_variant_is_of_type (dictionary,
+                                              G_VARIANT_TYPE ("a{s*}")) ||
+                        g_variant_is_of_type (dictionary,
+                                              G_VARIANT_TYPE ("a{o*}")),
+                        NULL);
+
+  g_variant_iter_init (&iter, dictionary);
+
+  while ((entry = g_variant_iter_next_value (&iter)))
+    {
+      GVariant *entry_key;
+      gboolean matches;
+
+      entry_key = g_variant_get_child_value (entry, 0);
+      matches = strcmp (g_variant_get_string (entry_key, NULL), key) == 0;
+      g_variant_unref (entry_key);
+
+      if (matches)
+        break;
+
+      g_variant_unref (entry);
+    }
+
+  if (entry == NULL)
+    return NULL;
+
+  value = g_variant_get_child_value (entry, 1);
+  g_variant_unref (entry);
+
+  if (g_variant_is_of_type (value, G_VARIANT_TYPE_VARIANT))
+    {
+      GVariant *tmp;
+
+      tmp = g_variant_get_variant (value);
+      g_variant_unref (value);
+
+      if (expected_type && !g_variant_is_of_type (tmp, expected_type))
+        {
+          g_variant_unref (tmp);
+          tmp = NULL;
+        }
+
+      value = tmp;
+    }
+
+  g_return_val_if_fail (expected_type == NULL || value == NULL ||
+                        g_variant_is_of_type (value, expected_type), NULL);
+
+  return value;
+}
+
+/**
+ * g_variant_get_fixed_array:
+ * @value: a #GVariant array with fixed-sized elements
+ * @n_elements: (out): a pointer to the location to store the number of items
+ * @element_size: the size of each element
+ *
+ * Provides access to the serialized data for an array of fixed-sized
+ * items.
+ *
+ * @value must be an array with fixed-sized elements.  Numeric types are
+ * fixed-size, as are tuples containing only other fixed-sized types.
+ *
+ * @element_size must be the size of a single element in the array,
+ * as given by the section on
+ * [serialized data memory][gvariant-serialized-data-memory].
+ *
+ * In particular, arrays of these fixed-sized types can be interpreted
+ * as an array of the given C type, with @element_size set to the size
+ * the appropriate type:
+ * - %G_VARIANT_TYPE_INT16 (etc.): #gint16 (etc.)
+ * - %G_VARIANT_TYPE_BOOLEAN: #guchar (not #gboolean!)
+ * - %G_VARIANT_TYPE_BYTE: #guint8
+ * - %G_VARIANT_TYPE_HANDLE: #guint32
+ * - %G_VARIANT_TYPE_DOUBLE: #gdouble
+ *
+ * For example, if calling this function for an array of 32-bit integers,
+ * you might say `sizeof(gint32)`. This value isn't used except for the purpose
+ * of a double-check that the form of the serialized data matches the caller's
+ * expectation.
+ *
+ * @n_elements, which must be non-%NULL, is set equal to the number of
+ * items in the array.
+ *
+ * Returns: (array length=n_elements) (transfer none): a pointer to
+ *     the fixed array
+ *
+ * Since: 2.24
+ **/
+gconstpointer
+g_variant_get_fixed_array (GVariant *value,
+                           gsize    *n_elements,
+                           gsize     element_size)
+{
+  GVariantTypeInfo *array_info;
+  gsize array_element_size;
+  gconstpointer data;
+  gsize size;
+
+  TYPE_CHECK (value, G_VARIANT_TYPE_ARRAY, NULL);
+
+  g_return_val_if_fail (n_elements != NULL, NULL);
+  g_return_val_if_fail (element_size > 0, NULL);
+
+  array_info = g_variant_get_type_info (value);
+  g_variant_type_info_query_element (array_info, NULL, &array_element_size);
+
+  g_return_val_if_fail (array_element_size, NULL);
+
+  if G_UNLIKELY (array_element_size != element_size)
+    {
+      if (array_element_size)
+        g_critical ("g_variant_get_fixed_array: assertion "
+                    "'g_variant_array_has_fixed_size (value, element_size)' "
+                    "failed: array size %"G_GSIZE_FORMAT" does not match "
+                    "given element_size %"G_GSIZE_FORMAT".",
+                    array_element_size, element_size);
+      else
+        g_critical ("g_variant_get_fixed_array: assertion "
+                    "'g_variant_array_has_fixed_size (value, element_size)' "
+                    "failed: array does not have fixed size.");
+    }
+
+  data = g_variant_get_data (value);
+  size = g_variant_get_size (value);
+
+  if (size % element_size)
+    *n_elements = 0;
+  else
+    *n_elements = size / element_size;
+
+  if (*n_elements)
+    return data;
+
+  return NULL;
+}
+
+/**
+ * g_variant_new_fixed_array:
+ * @element_type: the #GVariantType of each element
+ * @elements: a pointer to the fixed array of contiguous elements
+ * @n_elements: the number of elements
+ * @element_size: the size of each element
+ *
+ * Constructs a new array #GVariant instance, where the elements are
+ * of @element_type type.
+ *
+ * @elements must be an array with fixed-sized elements.  Numeric types are
+ * fixed-size as are tuples containing only other fixed-sized types.
+ *
+ * @element_size must be the size of a single element in the array.
+ * For example, if calling this function for an array of 32-bit integers,
+ * you might say sizeof(gint32). This value isn't used except for the purpose
+ * of a double-check that the form of the serialized data matches the caller's
+ * expectation.
+ *
+ * @n_elements must be the length of the @elements array.
+ *
+ * Returns: (transfer none): a floating reference to a new array #GVariant instance
+ *
+ * Since: 2.32
+ **/
+GVariant *
+g_variant_new_fixed_array (const GVariantType  *element_type,
+                           gconstpointer        elements,
+                           gsize                n_elements,
+                           gsize                element_size)
+{
+  GVariantType *array_type;
+  gsize array_element_size;
+  GVariantTypeInfo *array_info;
+  GVariant *value;
+  gpointer data;
+
+  g_return_val_if_fail (g_variant_type_is_definite (element_type), NULL);
+  g_return_val_if_fail (element_size > 0, NULL);
+
+  array_type = g_variant_type_new_array (element_type);
+  array_info = g_variant_type_info_get (array_type);
+  g_variant_type_info_query_element (array_info, NULL, &array_element_size);
+  if G_UNLIKELY (array_element_size != element_size)
+    {
+      if (array_element_size)
+        g_critical ("g_variant_new_fixed_array: array size %" G_GSIZE_FORMAT
+                    " does not match given element_size %" G_GSIZE_FORMAT ".",
+                    array_element_size, element_size);
+      else
+        g_critical ("g_variant_get_fixed_array: array does not have fixed size.");
+      return NULL;
+    }
+
+  data = g_memdup2 (elements, n_elements * element_size);
+  value = g_variant_new_from_data (array_type, data,
+                                   n_elements * element_size,
+                                   FALSE, g_free, data);
+
+  g_variant_type_free (array_type);
+  g_variant_type_info_unref (array_info);
+
+  return value;
+}
+
+/* String type constructor/getters/validation {{{1 */
+/**
+ * g_variant_new_string:
+ * @string: a normal UTF-8 nul-terminated string
+ *
+ * Creates a string #GVariant with the contents of @string.
+ *
+ * @string must be valid UTF-8, and must not be %NULL. To encode
+ * potentially-%NULL strings, use g_variant_new() with `ms` as the
+ * [format string][gvariant-format-strings-maybe-types].
+ *
+ * Returns: (transfer none): a floating reference to a new string #GVariant instance
+ *
+ * Since: 2.24
+ **/
+GVariant *
+g_variant_new_string (const gchar *string)
+{
+  g_return_val_if_fail (string != NULL, NULL);
+  g_return_val_if_fail (g_utf8_validate (string, -1, NULL), NULL);
+
+  return g_variant_new_from_trusted (G_VARIANT_TYPE_STRING,
+                                     string, strlen (string) + 1);
+}
+
+/**
+ * g_variant_new_take_string: (skip)
+ * @string: a normal UTF-8 nul-terminated string
+ *
+ * Creates a string #GVariant with the contents of @string.
+ *
+ * @string must be valid UTF-8, and must not be %NULL. To encode
+ * potentially-%NULL strings, use this with g_variant_new_maybe().
+ *
+ * This function consumes @string.  g_free() will be called on @string
+ * when it is no longer required.
+ *
+ * You must not modify or access @string in any other way after passing
+ * it to this function.  It is even possible that @string is immediately
+ * freed.
+ *
+ * Returns: (transfer none): a floating reference to a new string
+ *   #GVariant instance
+ *
+ * Since: 2.38
+ **/
+GVariant *
+g_variant_new_take_string (gchar *string)
+{
+  GVariant *value;
+  GBytes *bytes;
+
+  g_return_val_if_fail (string != NULL, NULL);
+  g_return_val_if_fail (g_utf8_validate (string, -1, NULL), NULL);
+
+  bytes = g_bytes_new_take (string, strlen (string) + 1);
+  value = g_variant_new_from_bytes (G_VARIANT_TYPE_STRING, bytes, TRUE);
+  g_bytes_unref (bytes);
+
+  return value;
+}
+
+/**
+ * g_variant_new_printf: (skip)
+ * @format_string: a printf-style format string
+ * @...: arguments for @format_string
+ *
+ * Creates a string-type GVariant using printf formatting.
+ *
+ * This is similar to calling g_strdup_printf() and then
+ * g_variant_new_string() but it saves a temporary variable and an
+ * unnecessary copy.
+ *
+ * Returns: (transfer none): a floating reference to a new string
+ *   #GVariant instance
+ *
+ * Since: 2.38
+ **/
+GVariant *
+g_variant_new_printf (const gchar *format_string,
+                      ...)
+{
+  GVariant *value;
+  GBytes *bytes;
+  gchar *string;
+  va_list ap;
+
+  g_return_val_if_fail (format_string != NULL, NULL);
+
+  va_start (ap, format_string);
+  string = g_strdup_vprintf (format_string, ap);
+  va_end (ap);
+
+  bytes = g_bytes_new_take (string, strlen (string) + 1);
+  value = g_variant_new_from_bytes (G_VARIANT_TYPE_STRING, bytes, TRUE);
+  g_bytes_unref (bytes);
+
+  return value;
+}
+
+/**
+ * g_variant_new_object_path:
+ * @object_path: a normal C nul-terminated string
+ *
+ * Creates a D-Bus object path #GVariant with the contents of @string.
+ * @string must be a valid D-Bus object path.  Use
+ * g_variant_is_object_path() if you're not sure.
+ *
+ * Returns: (transfer none): a floating reference to a new object path #GVariant instance
+ *
+ * Since: 2.24
+ **/
+GVariant *
+g_variant_new_object_path (const gchar *object_path)
+{
+  g_return_val_if_fail (g_variant_is_object_path (object_path), NULL);
+
+  return g_variant_new_from_trusted (G_VARIANT_TYPE_OBJECT_PATH,
+                                     object_path, strlen (object_path) + 1);
+}
+
+/**
+ * g_variant_is_object_path:
+ * @string: a normal C nul-terminated string
+ *
+ * Determines if a given string is a valid D-Bus object path.  You
+ * should ensure that a string is a valid D-Bus object path before
+ * passing it to g_variant_new_object_path().
+ *
+ * A valid object path starts with `/` followed by zero or more
+ * sequences of characters separated by `/` characters.  Each sequence
+ * must contain only the characters `[A-Z][a-z][0-9]_`.  No sequence
+ * (including the one following the final `/` character) may be empty.
+ *
+ * Returns: %TRUE if @string is a D-Bus object path
+ *
+ * Since: 2.24
+ **/
+gboolean
+g_variant_is_object_path (const gchar *string)
+{
+  g_return_val_if_fail (string != NULL, FALSE);
+
+  return g_variant_serialiser_is_object_path (string, strlen (string) + 1);
+}
+
+/**
+ * g_variant_new_signature:
+ * @signature: a normal C nul-terminated string
+ *
+ * Creates a D-Bus type signature #GVariant with the contents of
+ * @string.  @string must be a valid D-Bus type signature.  Use
+ * g_variant_is_signature() if you're not sure.
+ *
+ * Returns: (transfer none): a floating reference to a new signature #GVariant instance
+ *
+ * Since: 2.24
+ **/
+GVariant *
+g_variant_new_signature (const gchar *signature)
+{
+  g_return_val_if_fail (g_variant_is_signature (signature), NULL);
+
+  return g_variant_new_from_trusted (G_VARIANT_TYPE_SIGNATURE,
+                                     signature, strlen (signature) + 1);
+}
+
+/**
+ * g_variant_is_signature:
+ * @string: a normal C nul-terminated string
+ *
+ * Determines if a given string is a valid D-Bus type signature.  You
+ * should ensure that a string is a valid D-Bus type signature before
+ * passing it to g_variant_new_signature().
+ *
+ * D-Bus type signatures consist of zero or more definite #GVariantType
+ * strings in sequence.
+ *
+ * Returns: %TRUE if @string is a D-Bus type signature
+ *
+ * Since: 2.24
+ **/
+gboolean
+g_variant_is_signature (const gchar *string)
+{
+  g_return_val_if_fail (string != NULL, FALSE);
+
+  return g_variant_serialiser_is_signature (string, strlen (string) + 1);
+}
+
+/**
+ * g_variant_get_string:
+ * @value: a string #GVariant instance
+ * @length: (optional) (default 0) (out): a pointer to a #gsize,
+ *          to store the length
+ *
+ * Returns the string value of a #GVariant instance with a string
+ * type.  This includes the types %G_VARIANT_TYPE_STRING,
+ * %G_VARIANT_TYPE_OBJECT_PATH and %G_VARIANT_TYPE_SIGNATURE.
+ *
+ * The string will always be UTF-8 encoded, will never be %NULL, and will never
+ * contain nul bytes.
+ *
+ * If @length is non-%NULL then the length of the string (in bytes) is
+ * returned there.  For trusted values, this information is already
+ * known.  Untrusted values will be validated and, if valid, a strlen() will be
+ * performed. If invalid, a default value will be returned — for
+ * %G_VARIANT_TYPE_OBJECT_PATH, this is `"/"`, and for other types it is the
+ * empty string.
+ *
+ * It is an error to call this function with a @value of any type
+ * other than those three.
+ *
+ * The return value remains valid as long as @value exists.
+ *
+ * Returns: (transfer none): the constant string, UTF-8 encoded
+ *
+ * Since: 2.24
+ **/
+const gchar *
+g_variant_get_string (GVariant *value,
+                      gsize    *length)
+{
+  gconstpointer data;
+  gsize size;
+
+  g_return_val_if_fail (value != NULL, NULL);
+  g_return_val_if_fail (
+    g_variant_is_of_type (value, G_VARIANT_TYPE_STRING) ||
+    g_variant_is_of_type (value, G_VARIANT_TYPE_OBJECT_PATH) ||
+    g_variant_is_of_type (value, G_VARIANT_TYPE_SIGNATURE), NULL);
+
+  data = g_variant_get_data (value);
+  size = g_variant_get_size (value);
+
+  if (!g_variant_is_trusted (value))
+    {
+      switch (g_variant_classify (value))
+        {
+        case G_VARIANT_CLASS_STRING:
+          if (g_variant_serialiser_is_string (data, size))
+            break;
+
+          data = "";
+          size = 1;
+          break;
+
+        case G_VARIANT_CLASS_OBJECT_PATH:
+          if (g_variant_serialiser_is_object_path (data, size))
+            break;
+
+          data = "/";
+          size = 2;
+          break;
+
+        case G_VARIANT_CLASS_SIGNATURE:
+          if (g_variant_serialiser_is_signature (data, size))
+            break;
+
+          data = "";
+          size = 1;
+          break;
+
+        default:
+          g_assert_not_reached ();
+        }
+    }
+
+  if (length)
+    *length = size - 1;
+
+  return data;
+}
+
+/**
+ * g_variant_dup_string:
+ * @value: a string #GVariant instance
+ * @length: (out): a pointer to a #gsize, to store the length
+ *
+ * Similar to g_variant_get_string() except that instead of returning
+ * a constant string, the string is duplicated.
+ *
+ * The string will always be UTF-8 encoded.
+ *
+ * The return value must be freed using g_free().
+ *
+ * Returns: (transfer full): a newly allocated string, UTF-8 encoded
+ *
+ * Since: 2.24
+ **/
+gchar *
+g_variant_dup_string (GVariant *value,
+                      gsize    *length)
+{
+  return g_strdup (g_variant_get_string (value, length));
+}
+
+/**
+ * g_variant_new_strv:
+ * @strv: (array length=length) (element-type utf8): an array of strings
+ * @length: the length of @strv, or -1
+ *
+ * Constructs an array of strings #GVariant from the given array of
+ * strings.
+ *
+ * If @length is -1 then @strv is %NULL-terminated.
+ *
+ * Returns: (transfer none): a new floating #GVariant instance
+ *
+ * Since: 2.24
+ **/
+GVariant *
+g_variant_new_strv (const gchar * const *strv,
+                    gssize               length)
+{
+  GVariant **strings;
+  gsize i, length_unsigned;
+
+  g_return_val_if_fail (length == 0 || strv != NULL, NULL);
+
+  if (length < 0)
+    length = g_strv_length ((gchar **) strv);
+  length_unsigned = length;
+
+  strings = g_new (GVariant *, length_unsigned);
+  for (i = 0; i < length_unsigned; i++)
+    strings[i] = g_variant_ref_sink (g_variant_new_string (strv[i]));
+
+  return g_variant_new_from_children (G_VARIANT_TYPE_STRING_ARRAY,
+                                      strings, length_unsigned, TRUE);
+}
+
+/**
+ * g_variant_get_strv:
+ * @value: an array of strings #GVariant
+ * @length: (out) (optional): the length of the result, or %NULL
+ *
+ * Gets the contents of an array of strings #GVariant.  This call
+ * makes a shallow copy; the return result should be released with
+ * g_free(), but the individual strings must not be modified.
+ *
+ * If @length is non-%NULL then the number of elements in the result
+ * is stored there.  In any case, the resulting array will be
+ * %NULL-terminated.
+ *
+ * For an empty array, @length will be set to 0 and a pointer to a
+ * %NULL pointer will be returned.
+ *
+ * Returns: (array length=length zero-terminated=1) (transfer container): an array of constant strings
+ *
+ * Since: 2.24
+ **/
+const gchar **
+g_variant_get_strv (GVariant *value,
+                    gsize    *length)
+{
+  const gchar **strv;
+  gsize n;
+  gsize i;
+
+  TYPE_CHECK (value, G_VARIANT_TYPE_STRING_ARRAY, NULL);
+
+  g_variant_get_data (value);
+  n = g_variant_n_children (value);
+  strv = g_new (const gchar *, n + 1);
+
+  for (i = 0; i < n; i++)
+    {
+      GVariant *string;
+
+      string = g_variant_get_child_value (value, i);
+      strv[i] = g_variant_get_string (string, NULL);
+      g_variant_unref (string);
+    }
+  strv[i] = NULL;
+
+  if (length)
+    *length = n;
+
+  return strv;
+}
+
+/**
+ * g_variant_dup_strv:
+ * @value: an array of strings #GVariant
+ * @length: (out) (optional): the length of the result, or %NULL
+ *
+ * Gets the contents of an array of strings #GVariant.  This call
+ * makes a deep copy; the return result should be released with
+ * g_strfreev().
+ *
+ * If @length is non-%NULL then the number of elements in the result
+ * is stored there.  In any case, the resulting array will be
+ * %NULL-terminated.
+ *
+ * For an empty array, @length will be set to 0 and a pointer to a
+ * %NULL pointer will be returned.
+ *
+ * Returns: (array length=length zero-terminated=1) (transfer full): an array of strings
+ *
+ * Since: 2.24
+ **/
+gchar **
+g_variant_dup_strv (GVariant *value,
+                    gsize    *length)
+{
+  gchar **strv;
+  gsize n;
+  gsize i;
+
+  TYPE_CHECK (value, G_VARIANT_TYPE_STRING_ARRAY, NULL);
+
+  n = g_variant_n_children (value);
+  strv = g_new (gchar *, n + 1);
+
+  for (i = 0; i < n; i++)
+    {
+      GVariant *string;
+
+      string = g_variant_get_child_value (value, i);
+      strv[i] = g_variant_dup_string (string, NULL);
+      g_variant_unref (string);
+    }
+  strv[i] = NULL;
+
+  if (length)
+    *length = n;
+
+  return strv;
+}
+
+/**
+ * g_variant_new_objv:
+ * @strv: (array length=length) (element-type utf8): an array of strings
+ * @length: the length of @strv, or -1
+ *
+ * Constructs an array of object paths #GVariant from the given array of
+ * strings.
+ *
+ * Each string must be a valid #GVariant object path; see
+ * g_variant_is_object_path().
+ *
+ * If @length is -1 then @strv is %NULL-terminated.
+ *
+ * Returns: (transfer none): a new floating #GVariant instance
+ *
+ * Since: 2.30
+ **/
+GVariant *
+g_variant_new_objv (const gchar * const *strv,
+                    gssize               length)
+{
+  GVariant **strings;
+  gsize i, length_unsigned;
+
+  g_return_val_if_fail (length == 0 || strv != NULL, NULL);
+
+  if (length < 0)
+    length = g_strv_length ((gchar **) strv);
+  length_unsigned = length;
+
+  strings = g_new (GVariant *, length_unsigned);
+  for (i = 0; i < length_unsigned; i++)
+    strings[i] = g_variant_ref_sink (g_variant_new_object_path (strv[i]));
+
+  return g_variant_new_from_children (G_VARIANT_TYPE_OBJECT_PATH_ARRAY,
+                                      strings, length_unsigned, TRUE);
+}
+
+/**
+ * g_variant_get_objv:
+ * @value: an array of object paths #GVariant
+ * @length: (out) (optional): the length of the result, or %NULL
+ *
+ * Gets the contents of an array of object paths #GVariant.  This call
+ * makes a shallow copy; the return result should be released with
+ * g_free(), but the individual strings must not be modified.
+ *
+ * If @length is non-%NULL then the number of elements in the result
+ * is stored there.  In any case, the resulting array will be
+ * %NULL-terminated.
+ *
+ * For an empty array, @length will be set to 0 and a pointer to a
+ * %NULL pointer will be returned.
+ *
+ * Returns: (array length=length zero-terminated=1) (transfer container): an array of constant strings
+ *
+ * Since: 2.30
+ **/
+const gchar **
+g_variant_get_objv (GVariant *value,
+                    gsize    *length)
+{
+  const gchar **strv;
+  gsize n;
+  gsize i;
+
+  TYPE_CHECK (value, G_VARIANT_TYPE_OBJECT_PATH_ARRAY, NULL);
+
+  g_variant_get_data (value);
+  n = g_variant_n_children (value);
+  strv = g_new (const gchar *, n + 1);
+
+  for (i = 0; i < n; i++)
+    {
+      GVariant *string;
+
+      string = g_variant_get_child_value (value, i);
+      strv[i] = g_variant_get_string (string, NULL);
+      g_variant_unref (string);
+    }
+  strv[i] = NULL;
+
+  if (length)
+    *length = n;
+
+  return strv;
+}
+
+/**
+ * g_variant_dup_objv:
+ * @value: an array of object paths #GVariant
+ * @length: (out) (optional): the length of the result, or %NULL
+ *
+ * Gets the contents of an array of object paths #GVariant.  This call
+ * makes a deep copy; the return result should be released with
+ * g_strfreev().
+ *
+ * If @length is non-%NULL then the number of elements in the result
+ * is stored there.  In any case, the resulting array will be
+ * %NULL-terminated.
+ *
+ * For an empty array, @length will be set to 0 and a pointer to a
+ * %NULL pointer will be returned.
+ *
+ * Returns: (array length=length zero-terminated=1) (transfer full): an array of strings
+ *
+ * Since: 2.30
+ **/
+gchar **
+g_variant_dup_objv (GVariant *value,
+                    gsize    *length)
+{
+  gchar **strv;
+  gsize n;
+  gsize i;
+
+  TYPE_CHECK (value, G_VARIANT_TYPE_OBJECT_PATH_ARRAY, NULL);
+
+  n = g_variant_n_children (value);
+  strv = g_new (gchar *, n + 1);
+
+  for (i = 0; i < n; i++)
+    {
+      GVariant *string;
+
+      string = g_variant_get_child_value (value, i);
+      strv[i] = g_variant_dup_string (string, NULL);
+      g_variant_unref (string);
+    }
+  strv[i] = NULL;
+
+  if (length)
+    *length = n;
+
+  return strv;
+}
+
+
+/**
+ * g_variant_new_bytestring:
+ * @string: (array zero-terminated=1) (element-type guint8): a normal
+ *          nul-terminated string in no particular encoding
+ *
+ * Creates an array-of-bytes #GVariant with the contents of @string.
+ * This function is just like g_variant_new_string() except that the
+ * string need not be valid UTF-8.
+ *
+ * The nul terminator character at the end of the string is stored in
+ * the array.
+ *
+ * Returns: (transfer none): a floating reference to a new bytestring #GVariant instance
+ *
+ * Since: 2.26
+ **/
+GVariant *
+g_variant_new_bytestring (const gchar *string)
+{
+  g_return_val_if_fail (string != NULL, NULL);
+
+  return g_variant_new_from_trusted (G_VARIANT_TYPE_BYTESTRING,
+                                     string, strlen (string) + 1);
+}
+
+/**
+ * g_variant_get_bytestring:
+ * @value: an array-of-bytes #GVariant instance
+ *
+ * Returns the string value of a #GVariant instance with an
+ * array-of-bytes type.  The string has no particular encoding.
+ *
+ * If the array does not end with a nul terminator character, the empty
+ * string is returned.  For this reason, you can always trust that a
+ * non-%NULL nul-terminated string will be returned by this function.
+ *
+ * If the array contains a nul terminator character somewhere other than
+ * the last byte then the returned string is the string, up to the first
+ * such nul character.
+ *
+ * g_variant_get_fixed_array() should be used instead if the array contains
+ * arbitrary data that could not be nul-terminated or could contain nul bytes.
+ *
+ * It is an error to call this function with a @value that is not an
+ * array of bytes.
+ *
+ * The return value remains valid as long as @value exists.
+ *
+ * Returns: (transfer none) (array zero-terminated=1) (element-type guint8):
+ *          the constant string
+ *
+ * Since: 2.26
+ **/
+const gchar *
+g_variant_get_bytestring (GVariant *value)
+{
+  const gchar *string;
+  gsize size;
+
+  TYPE_CHECK (value, G_VARIANT_TYPE_BYTESTRING, NULL);
+
+  /* Won't be NULL since this is an array type */
+  string = g_variant_get_data (value);
+  size = g_variant_get_size (value);
+
+  if (size && string[size - 1] == '\0')
+    return string;
+  else
+    return "";
+}
+
+/**
+ * g_variant_dup_bytestring:
+ * @value: an array-of-bytes #GVariant instance
+ * @length: (out) (optional) (default NULL): a pointer to a #gsize, to store
+ *          the length (not including the nul terminator)
+ *
+ * Similar to g_variant_get_bytestring() except that instead of
+ * returning a constant string, the string is duplicated.
+ *
+ * The return value must be freed using g_free().
+ *
+ * Returns: (transfer full) (array zero-terminated=1 length=length) (element-type guint8):
+ *          a newly allocated string
+ *
+ * Since: 2.26
+ **/
+gchar *
+g_variant_dup_bytestring (GVariant *value,
+                          gsize    *length)
+{
+  const gchar *original = g_variant_get_bytestring (value);
+  gsize size;
+
+  /* don't crash in case get_bytestring() had an assert failure */
+  if (original == NULL)
+    return NULL;
+
+  size = strlen (original);
+
+  if (length)
+    *length = size;
+
+  return g_memdup2 (original, size + 1);
+}
+
+/**
+ * g_variant_new_bytestring_array:
+ * @strv: (array length=length): an array of strings
+ * @length: the length of @strv, or -1
+ *
+ * Constructs an array of bytestring #GVariant from the given array of
+ * strings.
+ *
+ * If @length is -1 then @strv is %NULL-terminated.
+ *
+ * Returns: (transfer none): a new floating #GVariant instance
+ *
+ * Since: 2.26
+ **/
+GVariant *
+g_variant_new_bytestring_array (const gchar * const *strv,
+                                gssize               length)
+{
+  GVariant **strings;
+  gsize i, length_unsigned;
+
+  g_return_val_if_fail (length == 0 || strv != NULL, NULL);
+
+  if (length < 0)
+    length = g_strv_length ((gchar **) strv);
+  length_unsigned = length;
+
+  strings = g_new (GVariant *, length_unsigned);
+  for (i = 0; i < length_unsigned; i++)
+    strings[i] = g_variant_ref_sink (g_variant_new_bytestring (strv[i]));
+
+  return g_variant_new_from_children (G_VARIANT_TYPE_BYTESTRING_ARRAY,
+                                      strings, length_unsigned, TRUE);
+}
+
+/**
+ * g_variant_get_bytestring_array:
+ * @value: an array of array of bytes #GVariant ('aay')
+ * @length: (out) (optional): the length of the result, or %NULL
+ *
+ * Gets the contents of an array of array of bytes #GVariant.  This call
+ * makes a shallow copy; the return result should be released with
+ * g_free(), but the individual strings must not be modified.
+ *
+ * If @length is non-%NULL then the number of elements in the result is
+ * stored there.  In any case, the resulting array will be
+ * %NULL-terminated.
+ *
+ * For an empty array, @length will be set to 0 and a pointer to a
+ * %NULL pointer will be returned.
+ *
+ * Returns: (array length=length) (transfer container): an array of constant strings
+ *
+ * Since: 2.26
+ **/
+const gchar **
+g_variant_get_bytestring_array (GVariant *value,
+                                gsize    *length)
+{
+  const gchar **strv;
+  gsize n;
+  gsize i;
+
+  TYPE_CHECK (value, G_VARIANT_TYPE_BYTESTRING_ARRAY, NULL);
+
+  g_variant_get_data (value);
+  n = g_variant_n_children (value);
+  strv = g_new (const gchar *, n + 1);
+
+  for (i = 0; i < n; i++)
+    {
+      GVariant *string;
+
+      string = g_variant_get_child_value (value, i);
+      strv[i] = g_variant_get_bytestring (string);
+      g_variant_unref (string);
+    }
+  strv[i] = NULL;
+
+  if (length)
+    *length = n;
+
+  return strv;
+}
+
+/**
+ * g_variant_dup_bytestring_array:
+ * @value: an array of array of bytes #GVariant ('aay')
+ * @length: (out) (optional): the length of the result, or %NULL
+ *
+ * Gets the contents of an array of array of bytes #GVariant.  This call
+ * makes a deep copy; the return result should be released with
+ * g_strfreev().
+ *
+ * If @length is non-%NULL then the number of elements in the result is
+ * stored there.  In any case, the resulting array will be
+ * %NULL-terminated.
+ *
+ * For an empty array, @length will be set to 0 and a pointer to a
+ * %NULL pointer will be returned.
+ *
+ * Returns: (array length=length) (transfer full): an array of strings
+ *
+ * Since: 2.26
+ **/
+gchar **
+g_variant_dup_bytestring_array (GVariant *value,
+                                gsize    *length)
+{
+  gchar **strv;
+  gsize n;
+  gsize i;
+
+  TYPE_CHECK (value, G_VARIANT_TYPE_BYTESTRING_ARRAY, NULL);
+
+  g_variant_get_data (value);
+  n = g_variant_n_children (value);
+  strv = g_new (gchar *, n + 1);
+
+  for (i = 0; i < n; i++)
+    {
+      GVariant *string;
+
+      string = g_variant_get_child_value (value, i);
+      strv[i] = g_variant_dup_bytestring (string, NULL);
+      g_variant_unref (string);
+    }
+  strv[i] = NULL;
+
+  if (length)
+    *length = n;
+
+  return strv;
+}
+
+/* Type checking and querying {{{1 */
+/**
+ * g_variant_get_type:
+ * @value: a #GVariant
+ *
+ * Determines the type of @value.
+ *
+ * The return value is valid for the lifetime of @value and must not
+ * be freed.
+ *
+ * Returns: a #GVariantType
+ *
+ * Since: 2.24
+ **/
+const GVariantType *
+g_variant_get_type (GVariant *value)
+{
+  GVariantTypeInfo *type_info;
+
+  g_return_val_if_fail (value != NULL, NULL);
+
+  type_info = g_variant_get_type_info (value);
+
+  return (GVariantType *) g_variant_type_info_get_type_string (type_info);
+}
+
+/**
+ * g_variant_get_type_string:
+ * @value: a #GVariant
+ *
+ * Returns the type string of @value.  Unlike the result of calling
+ * g_variant_type_peek_string(), this string is nul-terminated.  This
+ * string belongs to #GVariant and must not be freed.
+ *
+ * Returns: the type string for the type of @value
+ *
+ * Since: 2.24
+ **/
+const gchar *
+g_variant_get_type_string (GVariant *value)
+{
+  GVariantTypeInfo *type_info;
+
+  g_return_val_if_fail (value != NULL, NULL);
+
+  type_info = g_variant_get_type_info (value);
+
+  return g_variant_type_info_get_type_string (type_info);
+}
+
+/**
+ * g_variant_is_of_type:
+ * @value: a #GVariant instance
+ * @type: a #GVariantType
+ *
+ * Checks if a value has a type matching the provided type.
+ *
+ * Returns: %TRUE if the type of @value matches @type
+ *
+ * Since: 2.24
+ **/
+gboolean
+g_variant_is_of_type (GVariant           *value,
+                      const GVariantType *type)
+{
+  return g_variant_type_is_subtype_of (g_variant_get_type (value), type);
+}
+
+/**
+ * g_variant_is_container:
+ * @value: a #GVariant instance
+ *
+ * Checks if @value is a container.
+ *
+ * Returns: %TRUE if @value is a container
+ *
+ * Since: 2.24
+ */
+gboolean
+g_variant_is_container (GVariant *value)
+{
+  return g_variant_type_is_container (g_variant_get_type (value));
+}
+
+
+/**
+ * g_variant_classify:
+ * @value: a #GVariant
+ *
+ * Classifies @value according to its top-level type.
+ *
+ * Returns: the #GVariantClass of @value
+ *
+ * Since: 2.24
+ **/
+/**
+ * GVariantClass:
+ * @G_VARIANT_CLASS_BOOLEAN: The #GVariant is a boolean.
+ * @G_VARIANT_CLASS_BYTE: The #GVariant is a byte.
+ * @G_VARIANT_CLASS_INT16: The #GVariant is a signed 16 bit integer.
+ * @G_VARIANT_CLASS_UINT16: The #GVariant is an unsigned 16 bit integer.
+ * @G_VARIANT_CLASS_INT32: The #GVariant is a signed 32 bit integer.
+ * @G_VARIANT_CLASS_UINT32: The #GVariant is an unsigned 32 bit integer.
+ * @G_VARIANT_CLASS_INT64: The #GVariant is a signed 64 bit integer.
+ * @G_VARIANT_CLASS_UINT64: The #GVariant is an unsigned 64 bit integer.
+ * @G_VARIANT_CLASS_HANDLE: The #GVariant is a file handle index.
+ * @G_VARIANT_CLASS_DOUBLE: The #GVariant is a double precision floating 
+ *                          point value.
+ * @G_VARIANT_CLASS_STRING: The #GVariant is a normal string.
+ * @G_VARIANT_CLASS_OBJECT_PATH: The #GVariant is a D-Bus object path 
+ *                               string.
+ * @G_VARIANT_CLASS_SIGNATURE: The #GVariant is a D-Bus signature string.
+ * @G_VARIANT_CLASS_VARIANT: The #GVariant is a variant.
+ * @G_VARIANT_CLASS_MAYBE: The #GVariant is a maybe-typed value.
+ * @G_VARIANT_CLASS_ARRAY: The #GVariant is an array.
+ * @G_VARIANT_CLASS_TUPLE: The #GVariant is a tuple.
+ * @G_VARIANT_CLASS_DICT_ENTRY: The #GVariant is a dictionary entry.
+ *
+ * The range of possible top-level types of #GVariant instances.
+ *
+ * Since: 2.24
+ **/
+GVariantClass
+g_variant_classify (GVariant *value)
+{
+  g_return_val_if_fail (value != NULL, 0);
+
+  return *g_variant_get_type_string (value);
+}
+
+/* Pretty printer {{{1 */
+/* This function is not introspectable because if @string is NULL,
+   @returns is (transfer full), otherwise it is (transfer none), which
+   is not supported by GObjectIntrospection */
+/**
+ * g_variant_print_string: (skip)
+ * @value: a #GVariant
+ * @string: (nullable) (default NULL): a #GString, or %NULL
+ * @type_annotate: %TRUE if type information should be included in
+ *                 the output
+ *
+ * Behaves as g_variant_print(), but operates on a #GString.
+ *
+ * If @string is non-%NULL then it is appended to and returned.  Else,
+ * a new empty #GString is allocated and it is returned.
+ *
+ * Returns: a #GString containing the string
+ *
+ * Since: 2.24
+ **/
+GString *
+g_variant_print_string (GVariant *value,
+                        GString  *string,
+                        gboolean  type_annotate)
+{
+  if G_UNLIKELY (string == NULL)
+    string = g_string_new (NULL);
+
+  switch (g_variant_classify (value))
+    {
+    case G_VARIANT_CLASS_MAYBE:
+      if (type_annotate)
+        g_string_append_printf (string, "@%s ",
+                                g_variant_get_type_string (value));
+
+      if (g_variant_n_children (value))
+        {
+          gchar *printed_child;
+          GVariant *element;
+
+          /* Nested maybes:
+           *
+           * Consider the case of the type "mmi".  In this case we could
+           * write "just just 4", but "4" alone is totally unambiguous,
+           * so we try to drop "just" where possible.
+           *
+           * We have to be careful not to always drop "just", though,
+           * since "nothing" needs to be distinguishable from "just
+           * nothing".  The case where we need to ensure we keep the
+           * "just" is actually exactly the case where we have a nested
+           * Nothing.
+           *
+           * Instead of searching for that nested Nothing, we just print
+           * the contained value into a separate string and see if we
+           * end up with "nothing" at the end of it.  If so, we need to
+           * add "just" at our level.
+           */
+          element = g_variant_get_child_value (value, 0);
+          printed_child = g_variant_print (element, FALSE);
+          g_variant_unref (element);
+
+          if (g_str_has_suffix (printed_child, "nothing"))
+            g_string_append (string, "just ");
+          g_string_append (string, printed_child);
+          g_free (printed_child);
+        }
+      else
+        g_string_append (string, "nothing");
+
+      break;
+
+    case G_VARIANT_CLASS_ARRAY:
+      /* it's an array so the first character of the type string is 'a'
+       *
+       * if the first two characters are 'ay' then it's a bytestring.
+       * under certain conditions we print those as strings.
+       */
+      if (g_variant_get_type_string (value)[1] == 'y')
+        {
+          const gchar *str;
+          gsize size;
+          gsize i;
+
+          /* first determine if it is a byte string.
+           * that's when there's a single nul character: at the end.
+           */
+          str = g_variant_get_data (value);
+          size = g_variant_get_size (value);
+
+          for (i = 0; i < size; i++)
+            if (str[i] == '\0')
+              break;
+
+          /* first nul byte is the last byte -> it's a byte string. */
+          if (i == size - 1)
+            {
+              gchar *escaped = g_strescape (str, NULL);
+
+              /* use double quotes only if a ' is in the string */
+              if (strchr (str, '\''))
+                g_string_append_printf (string, "b\"%s\"", escaped);
+              else
+                g_string_append_printf (string, "b'%s'", escaped);
+
+              g_free (escaped);
+              break;
+            }
+
+          else
+            {
+              /* fall through and handle normally... */
+            }
+        }
+
+      /*
+       * if the first two characters are 'a{' then it's an array of
+       * dictionary entries (ie: a dictionary) so we print that
+       * differently.
+       */
+      if (g_variant_get_type_string (value)[1] == '{')
+        /* dictionary */
+        {
+          const gchar *comma = "";
+          gsize n, i;
+
+          if ((n = g_variant_n_children (value)) == 0)
+            {
+              if (type_annotate)
+                g_string_append_printf (string, "@%s ",
+                                        g_variant_get_type_string (value));
+              g_string_append (string, "{}");
+              break;
+            }
+
+          g_string_append_c (string, '{');
+          for (i = 0; i < n; i++)
+            {
+              GVariant *entry, *key, *val;
+
+              g_string_append (string, comma);
+              comma = ", ";
+
+              entry = g_variant_get_child_value (value, i);
+              key = g_variant_get_child_value (entry, 0);
+              val = g_variant_get_child_value (entry, 1);
+              g_variant_unref (entry);
+
+              g_variant_print_string (key, string, type_annotate);
+              g_variant_unref (key);
+              g_string_append (string, ": ");
+              g_variant_print_string (val, string, type_annotate);
+              g_variant_unref (val);
+              type_annotate = FALSE;
+            }
+          g_string_append_c (string, '}');
+        }
+      else
+        /* normal (non-dictionary) array */
+        {
+          const gchar *comma = "";
+          gsize n, i;
+
+          if ((n = g_variant_n_children (value)) == 0)
+            {
+              if (type_annotate)
+                g_string_append_printf (string, "@%s ",
+                                        g_variant_get_type_string (value));
+              g_string_append (string, "[]");
+              break;
+            }
+
+          g_string_append_c (string, '[');
+          for (i = 0; i < n; i++)
+            {
+              GVariant *element;
+
+              g_string_append (string, comma);
+              comma = ", ";
+
+              element = g_variant_get_child_value (value, i);
+
+              g_variant_print_string (element, string, type_annotate);
+              g_variant_unref (element);
+              type_annotate = FALSE;
+            }
+          g_string_append_c (string, ']');
+        }
+
+      break;
+
+    case G_VARIANT_CLASS_TUPLE:
+      {
+        gsize n, i;
+
+        n = g_variant_n_children (value);
+
+        g_string_append_c (string, '(');
+        for (i = 0; i < n; i++)
+          {
+            GVariant *element;
+
+            element = g_variant_get_child_value (value, i);
+            g_variant_print_string (element, string, type_annotate);
+            g_string_append (string, ", ");
+            g_variant_unref (element);
+          }
+
+        /* for >1 item:  remove final ", "
+         * for 1 item:   remove final " ", but leave the ","
+         * for 0 items:  there is only "(", so remove nothing
+         */
+        g_string_truncate (string, string->len - (n > 0) - (n > 1));
+        g_string_append_c (string, ')');
+      }
+      break;
+
+    case G_VARIANT_CLASS_DICT_ENTRY:
+      {
+        GVariant *element;
+
+        g_string_append_c (string, '{');
+
+        element = g_variant_get_child_value (value, 0);
+        g_variant_print_string (element, string, type_annotate);
+        g_variant_unref (element);
+
+        g_string_append (string, ", ");
+
+        element = g_variant_get_child_value (value, 1);
+        g_variant_print_string (element, string, type_annotate);
+        g_variant_unref (element);
+
+        g_string_append_c (string, '}');
+      }
+      break;
+
+    case G_VARIANT_CLASS_VARIANT:
+      {
+        GVariant *child = g_variant_get_variant (value);
+
+        /* Always annotate types in nested variants, because they are
+         * (by nature) of variable type.
+         */
+        g_string_append_c (string, '<');
+        g_variant_print_string (child, string, TRUE);
+        g_string_append_c (string, '>');
+
+        g_variant_unref (child);
+      }
+      break;
+
+    case G_VARIANT_CLASS_BOOLEAN:
+      if (g_variant_get_boolean (value))
+        g_string_append (string, "true");
+      else
+        g_string_append (string, "false");
+      break;
+
+    case G_VARIANT_CLASS_STRING:
+      {
+        const gchar *str = g_variant_get_string (value, NULL);
+        gunichar quote = strchr (str, '\'') ? '"' : '\'';
+
+        g_string_append_c (string, quote);
+
+        while (*str)
+          {
+            gunichar c = g_utf8_get_char (str);
+
+            if (c == quote || c == '\\')
+              g_string_append_c (string, '\\');
+
+            if (g_unichar_isprint (c))
+              g_string_append_unichar (string, c);
+
+            else
+              {
+                g_string_append_c (string, '\\');
+                if (c < 0x10000)
+                  switch (c)
+                    {
+                    case '\a':
+                      g_string_append_c (string, 'a');
+                      break;
+
+                    case '\b':
+                      g_string_append_c (string, 'b');
+                      break;
+
+                    case '\f':
+                      g_string_append_c (string, 'f');
+                      break;
+
+                    case '\n':
+                      g_string_append_c (string, 'n');
+                      break;
+
+                    case '\r':
+                      g_string_append_c (string, 'r');
+                      break;
+
+                    case '\t':
+                      g_string_append_c (string, 't');
+                      break;
+
+                    case '\v':
+                      g_string_append_c (string, 'v');
+                      break;
+
+                    default:
+                      g_string_append_printf (string, "u%04x", c);
+                      break;
+                    }
+                 else
+                   g_string_append_printf (string, "U%08x", c);
+              }
+
+            str = g_utf8_next_char (str);
+          }
+
+        g_string_append_c (string, quote);
+      }
+      break;
+
+    case G_VARIANT_CLASS_BYTE:
+      if (type_annotate)
+        g_string_append (string, "byte ");
+      g_string_append_printf (string, "0x%02x",
+                              g_variant_get_byte (value));
+      break;
+
+    case G_VARIANT_CLASS_INT16:
+      if (type_annotate)
+        g_string_append (string, "int16 ");
+      g_string_append_printf (string, "%"G_GINT16_FORMAT,
+                              g_variant_get_int16 (value));
+      break;
+
+    case G_VARIANT_CLASS_UINT16:
+      if (type_annotate)
+        g_string_append (string, "uint16 ");
+      g_string_append_printf (string, "%"G_GUINT16_FORMAT,
+                              g_variant_get_uint16 (value));
+      break;
+
+    case G_VARIANT_CLASS_INT32:
+      /* Never annotate this type because it is the default for numbers
+       * (and this is a *pretty* printer)
+       */
+      g_string_append_printf (string, "%"G_GINT32_FORMAT,
+                              g_variant_get_int32 (value));
+      break;
+
+    case G_VARIANT_CLASS_HANDLE:
+      if (type_annotate)
+        g_string_append (string, "handle ");
+      g_string_append_printf (string, "%"G_GINT32_FORMAT,
+                              g_variant_get_handle (value));
+      break;
+
+    case G_VARIANT_CLASS_UINT32:
+      if (type_annotate)
+        g_string_append (string, "uint32 ");
+      g_string_append_printf (string, "%"G_GUINT32_FORMAT,
+                              g_variant_get_uint32 (value));
+      break;
+
+    case G_VARIANT_CLASS_INT64:
+      if (type_annotate)
+        g_string_append (string, "int64 ");
+      g_string_append_printf (string, "%"G_GINT64_FORMAT,
+                              g_variant_get_int64 (value));
+      break;
+
+    case G_VARIANT_CLASS_UINT64:
+      if (type_annotate)
+        g_string_append (string, "uint64 ");
+      g_string_append_printf (string, "%"G_GUINT64_FORMAT,
+                              g_variant_get_uint64 (value));
+      break;
+
+    case G_VARIANT_CLASS_DOUBLE:
+      {
+        gchar buffer[100];
+        gint i;
+
+        g_ascii_dtostr (buffer, sizeof buffer, g_variant_get_double (value));
+
+        for (i = 0; buffer[i]; i++)
+          if (buffer[i] == '.' || buffer[i] == 'e' ||
+              buffer[i] == 'n' || buffer[i] == 'N')
+            break;
+
+        /* if there is no '.' or 'e' in the float then add one */
+        if (buffer[i] == '\0')
+          {
+            buffer[i++] = '.';
+            buffer[i++] = '0';
+            buffer[i++] = '\0';
+          }
+
+        g_string_append (string, buffer);
+      }
+      break;
+
+    case G_VARIANT_CLASS_OBJECT_PATH:
+      if (type_annotate)
+        g_string_append (string, "objectpath ");
+      g_string_append_printf (string, "\'%s\'",
+                              g_variant_get_string (value, NULL));
+      break;
+
+    case G_VARIANT_CLASS_SIGNATURE:
+      if (type_annotate)
+        g_string_append (string, "signature ");
+      g_string_append_printf (string, "\'%s\'",
+                              g_variant_get_string (value, NULL));
+      break;
+
+    default:
+      g_assert_not_reached ();
+  }
+
+  return string;
+}
+
+/**
+ * g_variant_print:
+ * @value: a #GVariant
+ * @type_annotate: %TRUE if type information should be included in
+ *                 the output
+ *
+ * Pretty-prints @value in the format understood by g_variant_parse().
+ *
+ * The format is described [here][gvariant-text].
+ *
+ * If @type_annotate is %TRUE, then type information is included in
+ * the output.
+ *
+ * Returns: (transfer full): a newly-allocated string holding the result.
+ *
+ * Since: 2.24
+ */
+gchar *
+g_variant_print (GVariant *value,
+                 gboolean  type_annotate)
+{
+  return g_string_free (g_variant_print_string (value, NULL, type_annotate),
+                        FALSE);
+}
+
+/* Hash, Equal, Compare {{{1 */
+/**
+ * g_variant_hash:
+ * @value: (type GVariant): a basic #GVariant value as a #gconstpointer
+ *
+ * Generates a hash value for a #GVariant instance.
+ *
+ * The output of this function is guaranteed to be the same for a given
+ * value only per-process.  It may change between different processor
+ * architectures or even different versions of GLib.  Do not use this
+ * function as a basis for building protocols or file formats.
+ *
+ * The type of @value is #gconstpointer only to allow use of this
+ * function with #GHashTable.  @value must be a #GVariant.
+ *
+ * Returns: a hash value corresponding to @value
+ *
+ * Since: 2.24
+ **/
+guint
+g_variant_hash (gconstpointer value_)
+{
+  GVariant *value = (GVariant *) value_;
+
+  switch (g_variant_classify (value))
+    {
+    case G_VARIANT_CLASS_STRING:
+    case G_VARIANT_CLASS_OBJECT_PATH:
+    case G_VARIANT_CLASS_SIGNATURE:
+      return g_str_hash (g_variant_get_string (value, NULL));
+
+    case G_VARIANT_CLASS_BOOLEAN:
+      /* this is a very odd thing to hash... */
+      return g_variant_get_boolean (value);
+
+    case G_VARIANT_CLASS_BYTE:
+      return g_variant_get_byte (value);
+
+    case G_VARIANT_CLASS_INT16:
+    case G_VARIANT_CLASS_UINT16:
+      {
+        const guint16 *ptr;
+
+        ptr = g_variant_get_data (value);
+
+        if (ptr)
+          return *ptr;
+        else
+          return 0;
+      }
+
+    case G_VARIANT_CLASS_INT32:
+    case G_VARIANT_CLASS_UINT32:
+    case G_VARIANT_CLASS_HANDLE:
+      {
+        const guint *ptr;
+
+        ptr = g_variant_get_data (value);
+
+        if (ptr)
+          return *ptr;
+        else
+          return 0;
+      }
+
+    case G_VARIANT_CLASS_INT64:
+    case G_VARIANT_CLASS_UINT64:
+    case G_VARIANT_CLASS_DOUBLE:
+      /* need a separate case for these guys because otherwise
+       * performance could be quite bad on big endian systems
+       */
+      {
+        const guint *ptr;
+
+        ptr = g_variant_get_data (value);
+
+        if (ptr)
+          return ptr[0] + ptr[1];
+        else
+          return 0;
+      }
+
+    default:
+      g_return_val_if_fail (!g_variant_is_container (value), 0);
+      g_assert_not_reached ();
+    }
+}
+
+/**
+ * g_variant_equal:
+ * @one: (type GVariant): a #GVariant instance
+ * @two: (type GVariant): a #GVariant instance
+ *
+ * Checks if @one and @two have the same type and value.
+ *
+ * The types of @one and @two are #gconstpointer only to allow use of
+ * this function with #GHashTable.  They must each be a #GVariant.
+ *
+ * Returns: %TRUE if @one and @two are equal
+ *
+ * Since: 2.24
+ **/
+gboolean
+g_variant_equal (gconstpointer one,
+                 gconstpointer two)
+{
+  gboolean equal;
+
+  g_return_val_if_fail (one != NULL && two != NULL, FALSE);
+
+  if (g_variant_get_type_info ((GVariant *) one) !=
+      g_variant_get_type_info ((GVariant *) two))
+    return FALSE;
+
+  /* if both values are trusted to be in their canonical serialized form
+   * then a simple memcmp() of their serialized data will answer the
+   * question.
+   *
+   * if not, then this might generate a false negative (since it is
+   * possible for two different byte sequences to represent the same
+   * value).  for now we solve this by pretty-printing both values and
+   * comparing the result.
+   */
+  if (g_variant_is_trusted ((GVariant *) one) &&
+      g_variant_is_trusted ((GVariant *) two))
+    {
+      gconstpointer data_one, data_two;
+      gsize size_one, size_two;
+
+      size_one = g_variant_get_size ((GVariant *) one);
+      size_two = g_variant_get_size ((GVariant *) two);
+
+      if (size_one != size_two)
+        return FALSE;
+
+      data_one = g_variant_get_data ((GVariant *) one);
+      data_two = g_variant_get_data ((GVariant *) two);
+
+      if (size_one)
+        equal = memcmp (data_one, data_two, size_one) == 0;
+      else
+        equal = TRUE;
+    }
+  else
+    {
+      gchar *strone, *strtwo;
+
+      strone = g_variant_print ((GVariant *) one, FALSE);
+      strtwo = g_variant_print ((GVariant *) two, FALSE);
+      equal = strcmp (strone, strtwo) == 0;
+      g_free (strone);
+      g_free (strtwo);
+    }
+
+  return equal;
+}
+
+/**
+ * g_variant_compare:
+ * @one: (type GVariant): a basic-typed #GVariant instance
+ * @two: (type GVariant): a #GVariant instance of the same type
+ *
+ * Compares @one and @two.
+ *
+ * The types of @one and @two are #gconstpointer only to allow use of
+ * this function with #GTree, #GPtrArray, etc.  They must each be a
+ * #GVariant.
+ *
+ * Comparison is only defined for basic types (ie: booleans, numbers,
+ * strings).  For booleans, %FALSE is less than %TRUE.  Numbers are
+ * ordered in the usual way.  Strings are in ASCII lexographical order.
+ *
+ * It is a programmer error to attempt to compare container values or
+ * two values that have types that are not exactly equal.  For example,
+ * you cannot compare a 32-bit signed integer with a 32-bit unsigned
+ * integer.  Also note that this function is not particularly
+ * well-behaved when it comes to comparison of doubles; in particular,
+ * the handling of incomparable values (ie: NaN) is undefined.
+ *
+ * If you only require an equality comparison, g_variant_equal() is more
+ * general.
+ *
+ * Returns: negative value if a < b;
+ *          zero if a = b;
+ *          positive value if a > b.
+ *
+ * Since: 2.26
+ **/
+gint
+g_variant_compare (gconstpointer one,
+                   gconstpointer two)
+{
+  GVariant *a = (GVariant *) one;
+  GVariant *b = (GVariant *) two;
+
+  g_return_val_if_fail (g_variant_classify (a) == g_variant_classify (b), 0);
+
+  switch (g_variant_classify (a))
+    {
+    case G_VARIANT_CLASS_BOOLEAN:
+      return g_variant_get_boolean (a) -
+             g_variant_get_boolean (b);
+
+    case G_VARIANT_CLASS_BYTE:
+      return ((gint) g_variant_get_byte (a)) -
+             ((gint) g_variant_get_byte (b));
+
+    case G_VARIANT_CLASS_INT16:
+      return ((gint) g_variant_get_int16 (a)) -
+             ((gint) g_variant_get_int16 (b));
+
+    case G_VARIANT_CLASS_UINT16:
+      return ((gint) g_variant_get_uint16 (a)) -
+             ((gint) g_variant_get_uint16 (b));
+
+    case G_VARIANT_CLASS_INT32:
+      {
+        gint32 a_val = g_variant_get_int32 (a);
+        gint32 b_val = g_variant_get_int32 (b);
+
+        return (a_val == b_val) ? 0 : (a_val > b_val) ? 1 : -1;
+      }
+
+    case G_VARIANT_CLASS_UINT32:
+      {
+        guint32 a_val = g_variant_get_uint32 (a);
+        guint32 b_val = g_variant_get_uint32 (b);
+
+        return (a_val == b_val) ? 0 : (a_val > b_val) ? 1 : -1;
+      }
+
+    case G_VARIANT_CLASS_INT64:
+      {
+        gint64 a_val = g_variant_get_int64 (a);
+        gint64 b_val = g_variant_get_int64 (b);
+
+        return (a_val == b_val) ? 0 : (a_val > b_val) ? 1 : -1;
+      }
+
+    case G_VARIANT_CLASS_UINT64:
+      {
+        guint64 a_val = g_variant_get_uint64 (a);
+        guint64 b_val = g_variant_get_uint64 (b);
+
+        return (a_val == b_val) ? 0 : (a_val > b_val) ? 1 : -1;
+      }
+
+    case G_VARIANT_CLASS_DOUBLE:
+      {
+        gdouble a_val = g_variant_get_double (a);
+        gdouble b_val = g_variant_get_double (b);
+
+        return (a_val == b_val) ? 0 : (a_val > b_val) ? 1 : -1;
+      }
+
+    case G_VARIANT_CLASS_STRING:
+    case G_VARIANT_CLASS_OBJECT_PATH:
+    case G_VARIANT_CLASS_SIGNATURE:
+      return strcmp (g_variant_get_string (a, NULL),
+                     g_variant_get_string (b, NULL));
+
+    default:
+      g_return_val_if_fail (!g_variant_is_container (a), 0);
+      g_assert_not_reached ();
+    }
+}
+
+/* GVariantIter {{{1 */
+/**
+ * GVariantIter: (skip)
+ *
+ * #GVariantIter is an opaque data structure and can only be accessed
+ * using the following functions.
+ **/
+struct stack_iter
+{
+  GVariant *value;
+  gssize n, i;
+
+  const gchar *loop_format;
+
+  gsize padding[3];
+  gsize magic;
+};
+
+G_STATIC_ASSERT (sizeof (struct stack_iter) <= sizeof (GVariantIter));
+
+struct heap_iter
+{
+  struct stack_iter iter;
+
+  GVariant *value_ref;
+  gsize magic;
+};
+
+#define GVSI(i)                 ((struct stack_iter *) (i))
+#define GVHI(i)                 ((struct heap_iter *) (i))
+#define GVSI_MAGIC              ((gsize) 3579507750u)
+#define GVHI_MAGIC              ((gsize) 1450270775u)
+#define is_valid_iter(i)        (i != NULL && \
+                                 GVSI(i)->magic == GVSI_MAGIC)
+#define is_valid_heap_iter(i)   (is_valid_iter(i) && \
+                                 GVHI(i)->magic == GVHI_MAGIC)
+
+/**
+ * g_variant_iter_new:
+ * @value: a container #GVariant
+ *
+ * Creates a heap-allocated #GVariantIter for iterating over the items
+ * in @value.
+ *
+ * Use g_variant_iter_free() to free the return value when you no longer
+ * need it.
+ *
+ * A reference is taken to @value and will be released only when
+ * g_variant_iter_free() is called.
+ *
+ * Returns: (transfer full): a new heap-allocated #GVariantIter
+ *
+ * Since: 2.24
+ **/
+GVariantIter *
+g_variant_iter_new (GVariant *value)
+{
+  GVariantIter *iter;
+
+  iter = (GVariantIter *) g_slice_new (struct heap_iter);
+  GVHI(iter)->value_ref = g_variant_ref (value);
+  GVHI(iter)->magic = GVHI_MAGIC;
+
+  g_variant_iter_init (iter, value);
+
+  return iter;
+}
+
+/**
+ * g_variant_iter_init: (skip)
+ * @iter: a pointer to a #GVariantIter
+ * @value: a container #GVariant
+ *
+ * Initialises (without allocating) a #GVariantIter.  @iter may be
+ * completely uninitialised prior to this call; its old value is
+ * ignored.
+ *
+ * The iterator remains valid for as long as @value exists, and need not
+ * be freed in any way.
+ *
+ * Returns: the number of items in @value
+ *
+ * Since: 2.24
+ **/
+gsize
+g_variant_iter_init (GVariantIter *iter,
+                     GVariant     *value)
+{
+  GVSI(iter)->magic = GVSI_MAGIC;
+  GVSI(iter)->value = value;
+  GVSI(iter)->n = g_variant_n_children (value);
+  GVSI(iter)->i = -1;
+  GVSI(iter)->loop_format = NULL;
+
+  return GVSI(iter)->n;
+}
+
+/**
+ * g_variant_iter_copy:
+ * @iter: a #GVariantIter
+ *
+ * Creates a new heap-allocated #GVariantIter to iterate over the
+ * container that was being iterated over by @iter.  Iteration begins on
+ * the new iterator from the current position of the old iterator but
+ * the two copies are independent past that point.
+ *
+ * Use g_variant_iter_free() to free the return value when you no longer
+ * need it.
+ *
+ * A reference is taken to the container that @iter is iterating over
+ * and will be related only when g_variant_iter_free() is called.
+ *
+ * Returns: (transfer full): a new heap-allocated #GVariantIter
+ *
+ * Since: 2.24
+ **/
+GVariantIter *
+g_variant_iter_copy (GVariantIter *iter)
+{
+  GVariantIter *copy;
+
+  g_return_val_if_fail (is_valid_iter (iter), 0);
+
+  copy = g_variant_iter_new (GVSI(iter)->value);
+  GVSI(copy)->i = GVSI(iter)->i;
+
+  return copy;
+}
+
+/**
+ * g_variant_iter_n_children:
+ * @iter: a #GVariantIter
+ *
+ * Queries the number of child items in the container that we are
+ * iterating over.  This is the total number of items -- not the number
+ * of items remaining.
+ *
+ * This function might be useful for preallocation of arrays.
+ *
+ * Returns: the number of children in the container
+ *
+ * Since: 2.24
+ **/
+gsize
+g_variant_iter_n_children (GVariantIter *iter)
+{
+  g_return_val_if_fail (is_valid_iter (iter), 0);
+
+  return GVSI(iter)->n;
+}
+
+/**
+ * g_variant_iter_free:
+ * @iter: (transfer full): a heap-allocated #GVariantIter
+ *
+ * Frees a heap-allocated #GVariantIter.  Only call this function on
+ * iterators that were returned by g_variant_iter_new() or
+ * g_variant_iter_copy().
+ *
+ * Since: 2.24
+ **/
+void
+g_variant_iter_free (GVariantIter *iter)
+{
+  g_return_if_fail (is_valid_heap_iter (iter));
+
+  g_variant_unref (GVHI(iter)->value_ref);
+  GVHI(iter)->magic = 0;
+
+  g_slice_free (struct heap_iter, GVHI(iter));
+}
+
+/**
+ * g_variant_iter_next_value:
+ * @iter: a #GVariantIter
+ *
+ * Gets the next item in the container.  If no more items remain then
+ * %NULL is returned.
+ *
+ * Use g_variant_unref() to drop your reference on the return value when
+ * you no longer need it.
+ *
+ * Here is an example for iterating with g_variant_iter_next_value():
+ * |[<!-- language="C" --> 
+ *   // recursively iterate a container
+ *   void
+ *   iterate_container_recursive (GVariant *container)
+ *   {
+ *     GVariantIter iter;
+ *     GVariant *child;
+ *
+ *     g_variant_iter_init (&iter, container);
+ *     while ((child = g_variant_iter_next_value (&iter)))
+ *       {
+ *         g_print ("type '%s'\n", g_variant_get_type_string (child));
+ *
+ *         if (g_variant_is_container (child))
+ *           iterate_container_recursive (child);
+ *
+ *         g_variant_unref (child);
+ *       }
+ *   }
+ * ]|
+ *
+ * Returns: (nullable) (transfer full): a #GVariant, or %NULL
+ *
+ * Since: 2.24
+ **/
+GVariant *
+g_variant_iter_next_value (GVariantIter *iter)
+{
+  g_return_val_if_fail (is_valid_iter (iter), FALSE);
+
+  if G_UNLIKELY (GVSI(iter)->i >= GVSI(iter)->n)
+    {
+      g_critical ("g_variant_iter_next_value: must not be called again "
+                  "after NULL has already been returned.");
+      return NULL;
+    }
+
+  GVSI(iter)->i++;
+
+  if (GVSI(iter)->i < GVSI(iter)->n)
+    return g_variant_get_child_value (GVSI(iter)->value, GVSI(iter)->i);
+
+  return NULL;
+}
+
+/* GVariantBuilder {{{1 */
+/**
+ * GVariantBuilder:
+ *
+ * A utility type for constructing container-type #GVariant instances.
+ *
+ * This is an opaque structure and may only be accessed using the
+ * following functions.
+ *
+ * #GVariantBuilder is not threadsafe in any way.  Do not attempt to
+ * access it from more than one thread.
+ **/
+
+struct stack_builder
+{
+  GVariantBuilder *parent;
+  GVariantType *type;
+
+  /* type constraint explicitly specified by 'type'.
+   * for tuple types, this moves along as we add more items.
+   */
+  const GVariantType *expected_type;
+
+  /* type constraint implied by previous array item.
+   */
+  const GVariantType *prev_item_type;
+
+  /* constraints on the number of children.  max = -1 for unlimited. */
+  gsize min_items;
+  gsize max_items;
+
+  /* dynamically-growing pointer array */
+  GVariant **children;
+  gsize allocated_children;
+  gsize offset;
+
+  /* set to '1' if all items in the container will have the same type
+   * (ie: maybe, array, variant) '0' if not (ie: tuple, dict entry)
+   */
+  guint uniform_item_types : 1;
+
+  /* set to '1' initially and changed to '0' if an untrusted value is
+   * added
+   */
+  guint trusted : 1;
+
+  gsize magic;
+};
+
+G_STATIC_ASSERT (sizeof (struct stack_builder) <= sizeof (GVariantBuilder));
+
+struct heap_builder
+{
+  GVariantBuilder builder;
+  gsize magic;
+
+  gint ref_count;
+};
+
+#define GVSB(b)                  ((struct stack_builder *) (b))
+#define GVHB(b)                  ((struct heap_builder *) (b))
+#define GVSB_MAGIC               ((gsize) 1033660112u)
+#define GVSB_MAGIC_PARTIAL       ((gsize) 2942751021u)
+#define GVHB_MAGIC               ((gsize) 3087242682u)
+#define is_valid_builder(b)      (GVSB(b)->magic == GVSB_MAGIC)
+#define is_valid_heap_builder(b) (GVHB(b)->magic == GVHB_MAGIC)
+
+/* Just to make sure that by adding a union to GVariantBuilder, we
+ * didn't accidentally change ABI. */
+G_STATIC_ASSERT (sizeof (GVariantBuilder) == sizeof (gsize[16]));
+
+static gboolean
+ensure_valid_builder (GVariantBuilder *builder)
+{
+  if (builder == NULL)
+    return FALSE;
+  else if (is_valid_builder (builder))
+    return TRUE;
+  if (builder->u.s.partial_magic == GVSB_MAGIC_PARTIAL)
+    {
+      static GVariantBuilder cleared_builder;
+
+      /* Make sure that only first two fields were set and the rest is
+       * zeroed to avoid messing up the builder that had parent
+       * address equal to GVSB_MAGIC_PARTIAL. */
+      if (memcmp (cleared_builder.u.s.y, builder->u.s.y, sizeof cleared_builder.u.s.y))
+        return FALSE;
+
+      g_variant_builder_init (builder, builder->u.s.type);
+    }
+  return is_valid_builder (builder);
+}
+
+/**
+ * g_variant_builder_new:
+ * @type: a container type
+ *
+ * Allocates and initialises a new #GVariantBuilder.
+ *
+ * You should call g_variant_builder_unref() on the return value when it
+ * is no longer needed.  The memory will not be automatically freed by
+ * any other call.
+ *
+ * In most cases it is easier to place a #GVariantBuilder directly on
+ * the stack of the calling function and initialise it with
+ * g_variant_builder_init().
+ *
+ * Returns: (transfer full): a #GVariantBuilder
+ *
+ * Since: 2.24
+ **/
+GVariantBuilder *
+g_variant_builder_new (const GVariantType *type)
+{
+  GVariantBuilder *builder;
+
+  builder = (GVariantBuilder *) g_slice_new (struct heap_builder);
+  g_variant_builder_init (builder, type);
+  GVHB(builder)->magic = GVHB_MAGIC;
+  GVHB(builder)->ref_count = 1;
+
+  return builder;
+}
+
+/**
+ * g_variant_builder_unref:
+ * @builder: (transfer full): a #GVariantBuilder allocated by g_variant_builder_new()
+ *
+ * Decreases the reference count on @builder.
+ *
+ * In the event that there are no more references, releases all memory
+ * associated with the #GVariantBuilder.
+ *
+ * Don't call this on stack-allocated #GVariantBuilder instances or bad
+ * things will happen.
+ *
+ * Since: 2.24
+ **/
+void
+g_variant_builder_unref (GVariantBuilder *builder)
+{
+  g_return_if_fail (is_valid_heap_builder (builder));
+
+  if (--GVHB(builder)->ref_count)
+    return;
+
+  g_variant_builder_clear (builder);
+  GVHB(builder)->magic = 0;
+
+  g_slice_free (struct heap_builder, GVHB(builder));
+}
+
+/**
+ * g_variant_builder_ref:
+ * @builder: a #GVariantBuilder allocated by g_variant_builder_new()
+ *
+ * Increases the reference count on @builder.
+ *
+ * Don't call this on stack-allocated #GVariantBuilder instances or bad
+ * things will happen.
+ *
+ * Returns: (transfer full): a new reference to @builder
+ *
+ * Since: 2.24
+ **/
+GVariantBuilder *
+g_variant_builder_ref (GVariantBuilder *builder)
+{
+  g_return_val_if_fail (is_valid_heap_builder (builder), NULL);
+
+  GVHB(builder)->ref_count++;
+
+  return builder;
+}
+
+/**
+ * g_variant_builder_clear: (skip)
+ * @builder: a #GVariantBuilder
+ *
+ * Releases all memory associated with a #GVariantBuilder without
+ * freeing the #GVariantBuilder structure itself.
+ *
+ * It typically only makes sense to do this on a stack-allocated
+ * #GVariantBuilder if you want to abort building the value part-way
+ * through.  This function need not be called if you call
+ * g_variant_builder_end() and it also doesn't need to be called on
+ * builders allocated with g_variant_builder_new() (see
+ * g_variant_builder_unref() for that).
+ *
+ * This function leaves the #GVariantBuilder structure set to all-zeros.
+ * It is valid to call this function on either an initialised
+ * #GVariantBuilder or one that is set to all-zeros but it is not valid
+ * to call this function on uninitialised memory.
+ *
+ * Since: 2.24
+ **/
+void
+g_variant_builder_clear (GVariantBuilder *builder)
+{
+  gsize i;
+
+  if (GVSB(builder)->magic == 0)
+    /* all-zeros or partial case */
+    return;
+
+  g_return_if_fail (ensure_valid_builder (builder));
+
+  g_variant_type_free (GVSB(builder)->type);
+
+  for (i = 0; i < GVSB(builder)->offset; i++)
+    g_variant_unref (GVSB(builder)->children[i]);
+
+  g_free (GVSB(builder)->children);
+
+  if (GVSB(builder)->parent)
+    {
+      g_variant_builder_clear (GVSB(builder)->parent);
+      g_slice_free (GVariantBuilder, GVSB(builder)->parent);
+    }
+
+  memset (builder, 0, sizeof (GVariantBuilder));
+}
+
+/**
+ * g_variant_builder_init: (skip)
+ * @builder: a #GVariantBuilder
+ * @type: a container type
+ *
+ * Initialises a #GVariantBuilder structure.
+ *
+ * @type must be non-%NULL.  It specifies the type of container to
+ * construct.  It can be an indefinite type such as
+ * %G_VARIANT_TYPE_ARRAY or a definite type such as "as" or "(ii)".
+ * Maybe, array, tuple, dictionary entry and variant-typed values may be
+ * constructed.
+ *
+ * After the builder is initialised, values are added using
+ * g_variant_builder_add_value() or g_variant_builder_add().
+ *
+ * After all the child values are added, g_variant_builder_end() frees
+ * the memory associated with the builder and returns the #GVariant that
+ * was created.
+ *
+ * This function completely ignores the previous contents of @builder.
+ * On one hand this means that it is valid to pass in completely
+ * uninitialised memory.  On the other hand, this means that if you are
+ * initialising over top of an existing #GVariantBuilder you need to
+ * first call g_variant_builder_clear() in order to avoid leaking
+ * memory.
+ *
+ * You must not call g_variant_builder_ref() or
+ * g_variant_builder_unref() on a #GVariantBuilder that was initialised
+ * with this function.  If you ever pass a reference to a
+ * #GVariantBuilder outside of the control of your own code then you
+ * should assume that the person receiving that reference may try to use
+ * reference counting; you should use g_variant_builder_new() instead of
+ * this function.
+ *
+ * Since: 2.24
+ **/
+void
+g_variant_builder_init (GVariantBuilder    *builder,
+                        const GVariantType *type)
+{
+  g_return_if_fail (type != NULL);
+  g_return_if_fail (g_variant_type_is_container (type));
+
+  memset (builder, 0, sizeof (GVariantBuilder));
+
+  GVSB(builder)->type = g_variant_type_copy (type);
+  GVSB(builder)->magic = GVSB_MAGIC;
+  GVSB(builder)->trusted = TRUE;
+
+  switch (*(const gchar *) type)
+    {
+    case G_VARIANT_CLASS_VARIANT:
+      GVSB(builder)->uniform_item_types = TRUE;
+      GVSB(builder)->allocated_children = 1;
+      GVSB(builder)->expected_type = NULL;
+      GVSB(builder)->min_items = 1;
+      GVSB(builder)->max_items = 1;
+      break;
+
+    case G_VARIANT_CLASS_ARRAY:
+      GVSB(builder)->uniform_item_types = TRUE;
+      GVSB(builder)->allocated_children = 8;
+      GVSB(builder)->expected_type =
+        g_variant_type_element (GVSB(builder)->type);
+      GVSB(builder)->min_items = 0;
+      GVSB(builder)->max_items = -1;
+      break;
+
+    case G_VARIANT_CLASS_MAYBE:
+      GVSB(builder)->uniform_item_types = TRUE;
+      GVSB(builder)->allocated_children = 1;
+      GVSB(builder)->expected_type =
+        g_variant_type_element (GVSB(builder)->type);
+      GVSB(builder)->min_items = 0;
+      GVSB(builder)->max_items = 1;
+      break;
+
+    case G_VARIANT_CLASS_DICT_ENTRY:
+      GVSB(builder)->uniform_item_types = FALSE;
+      GVSB(builder)->allocated_children = 2;
+      GVSB(builder)->expected_type =
+        g_variant_type_key (GVSB(builder)->type);
+      GVSB(builder)->min_items = 2;
+      GVSB(builder)->max_items = 2;
+      break;
+
+    case 'r': /* G_VARIANT_TYPE_TUPLE was given */
+      GVSB(builder)->uniform_item_types = FALSE;
+      GVSB(builder)->allocated_children = 8;
+      GVSB(builder)->expected_type = NULL;
+      GVSB(builder)->min_items = 0;
+      GVSB(builder)->max_items = -1;
+      break;
+
+    case G_VARIANT_CLASS_TUPLE: /* a definite tuple type was given */
+      GVSB(builder)->allocated_children = g_variant_type_n_items (type);
+      GVSB(builder)->expected_type =
+        g_variant_type_first (GVSB(builder)->type);
+      GVSB(builder)->min_items = GVSB(builder)->allocated_children;
+      GVSB(builder)->max_items = GVSB(builder)->allocated_children;
+      GVSB(builder)->uniform_item_types = FALSE;
+      break;
+
+    default:
+      g_assert_not_reached ();
+   }
+
+  GVSB(builder)->children = g_new (GVariant *,
+                                   GVSB(builder)->allocated_children);
+}
+
+static void
+g_variant_builder_make_room (struct stack_builder *builder)
+{
+  if (builder->offset == builder->allocated_children)
+    {
+      builder->allocated_children *= 2;
+      builder->children = g_renew (GVariant *, builder->children,
+                                   builder->allocated_children);
+    }
+}
+
+/**
+ * g_variant_builder_add_value:
+ * @builder: a #GVariantBuilder
+ * @value: a #GVariant
+ *
+ * Adds @value to @builder.
+ *
+ * It is an error to call this function in any way that would create an
+ * inconsistent value to be constructed.  Some examples of this are
+ * putting different types of items into an array, putting the wrong
+ * types or number of items in a tuple, putting more than one value into
+ * a variant, etc.
+ *
+ * If @value is a floating reference (see g_variant_ref_sink()),
+ * the @builder instance takes ownership of @value.
+ *
+ * Since: 2.24
+ **/
+void
+g_variant_builder_add_value (GVariantBuilder *builder,
+                             GVariant        *value)
+{
+  g_return_if_fail (ensure_valid_builder (builder));
+  g_return_if_fail (GVSB(builder)->offset < GVSB(builder)->max_items);
+  g_return_if_fail (!GVSB(builder)->expected_type ||
+                    g_variant_is_of_type (value,
+                                          GVSB(builder)->expected_type));
+  g_return_if_fail (!GVSB(builder)->prev_item_type ||
+                    g_variant_is_of_type (value,
+                                          GVSB(builder)->prev_item_type));
+
+  GVSB(builder)->trusted &= g_variant_is_trusted (value);
+
+  if (!GVSB(builder)->uniform_item_types)
+    {
+      /* advance our expected type pointers */
+      if (GVSB(builder)->expected_type)
+        GVSB(builder)->expected_type =
+          g_variant_type_next (GVSB(builder)->expected_type);
+
+      if (GVSB(builder)->prev_item_type)
+        GVSB(builder)->prev_item_type =
+          g_variant_type_next (GVSB(builder)->prev_item_type);
+    }
+  else
+    GVSB(builder)->prev_item_type = g_variant_get_type (value);
+
+  g_variant_builder_make_room (GVSB(builder));
+
+  GVSB(builder)->children[GVSB(builder)->offset++] =
+    g_variant_ref_sink (value);
+}
+
+/**
+ * g_variant_builder_open:
+ * @builder: a #GVariantBuilder
+ * @type: the #GVariantType of the container
+ *
+ * Opens a subcontainer inside the given @builder.  When done adding
+ * items to the subcontainer, g_variant_builder_close() must be called. @type
+ * is the type of the container: so to build a tuple of several values, @type
+ * must include the tuple itself.
+ *
+ * It is an error to call this function in any way that would cause an
+ * inconsistent value to be constructed (ie: adding too many values or
+ * a value of an incorrect type).
+ *
+ * Example of building a nested variant:
+ * |[<!-- language="C" -->
+ * GVariantBuilder builder;
+ * guint32 some_number = get_number ();
+ * g_autoptr (GHashTable) some_dict = get_dict ();
+ * GHashTableIter iter;
+ * const gchar *key;
+ * const GVariant *value;
+ * g_autoptr (GVariant) output = NULL;
+ *
+ * g_variant_builder_init (&builder, G_VARIANT_TYPE ("(ua{sv})"));
+ * g_variant_builder_add (&builder, "u", some_number);
+ * g_variant_builder_open (&builder, G_VARIANT_TYPE ("a{sv}"));
+ *
+ * g_hash_table_iter_init (&iter, some_dict);
+ * while (g_hash_table_iter_next (&iter, (gpointer *) &key, (gpointer *) &value))
+ *   {
+ *     g_variant_builder_open (&builder, G_VARIANT_TYPE ("{sv}"));
+ *     g_variant_builder_add (&builder, "s", key);
+ *     g_variant_builder_add (&builder, "v", value);
+ *     g_variant_builder_close (&builder);
+ *   }
+ *
+ * g_variant_builder_close (&builder);
+ *
+ * output = g_variant_builder_end (&builder);
+ * ]|
+ *
+ * Since: 2.24
+ **/
+void
+g_variant_builder_open (GVariantBuilder    *builder,
+                        const GVariantType *type)
+{
+  GVariantBuilder *parent;
+
+  g_return_if_fail (ensure_valid_builder (builder));
+  g_return_if_fail (GVSB(builder)->offset < GVSB(builder)->max_items);
+  g_return_if_fail (!GVSB(builder)->expected_type ||
+                    g_variant_type_is_subtype_of (type,
+                                                  GVSB(builder)->expected_type));
+  g_return_if_fail (!GVSB(builder)->prev_item_type ||
+                    g_variant_type_is_subtype_of (GVSB(builder)->prev_item_type,
+                                                  type));
+
+  parent = g_slice_dup (GVariantBuilder, builder);
+  g_variant_builder_init (builder, type);
+  GVSB(builder)->parent = parent;
+
+  /* push the prev_item_type down into the subcontainer */
+  if (GVSB(parent)->prev_item_type)
+    {
+      if (!GVSB(builder)->uniform_item_types)
+        /* tuples and dict entries */
+        GVSB(builder)->prev_item_type =
+          g_variant_type_first (GVSB(parent)->prev_item_type);
+
+      else if (!g_variant_type_is_variant (GVSB(builder)->type))
+        /* maybes and arrays */
+        GVSB(builder)->prev_item_type =
+          g_variant_type_element (GVSB(parent)->prev_item_type);
+    }
+}
+
+/**
+ * g_variant_builder_close:
+ * @builder: a #GVariantBuilder
+ *
+ * Closes the subcontainer inside the given @builder that was opened by
+ * the most recent call to g_variant_builder_open().
+ *
+ * It is an error to call this function in any way that would create an
+ * inconsistent value to be constructed (ie: too few values added to the
+ * subcontainer).
+ *
+ * Since: 2.24
+ **/
+void
+g_variant_builder_close (GVariantBuilder *builder)
+{
+  GVariantBuilder *parent;
+
+  g_return_if_fail (ensure_valid_builder (builder));
+  g_return_if_fail (GVSB(builder)->parent != NULL);
+
+  parent = GVSB(builder)->parent;
+  GVSB(builder)->parent = NULL;
+
+  g_variant_builder_add_value (parent, g_variant_builder_end (builder));
+  *builder = *parent;
+
+  g_slice_free (GVariantBuilder, parent);
+}
+
+/*< private >
+ * g_variant_make_maybe_type:
+ * @element: a #GVariant
+ *
+ * Return the type of a maybe containing @element.
+ */
+static GVariantType *
+g_variant_make_maybe_type (GVariant *element)
+{
+  return g_variant_type_new_maybe (g_variant_get_type (element));
+}
+
+/*< private >
+ * g_variant_make_array_type:
+ * @element: a #GVariant
+ *
+ * Return the type of an array containing @element.
+ */
+static GVariantType *
+g_variant_make_array_type (GVariant *element)
+{
+  return g_variant_type_new_array (g_variant_get_type (element));
+}
+
+/**
+ * g_variant_builder_end:
+ * @builder: a #GVariantBuilder
+ *
+ * Ends the builder process and returns the constructed value.
+ *
+ * It is not permissible to use @builder in any way after this call
+ * except for reference counting operations (in the case of a
+ * heap-allocated #GVariantBuilder) or by reinitialising it with
+ * g_variant_builder_init() (in the case of stack-allocated). This
+ * means that for the stack-allocated builders there is no need to
+ * call g_variant_builder_clear() after the call to
+ * g_variant_builder_end().
+ *
+ * It is an error to call this function in any way that would create an
+ * inconsistent value to be constructed (ie: insufficient number of
+ * items added to a container with a specific number of children
+ * required).  It is also an error to call this function if the builder
+ * was created with an indefinite array or maybe type and no children
+ * have been added; in this case it is impossible to infer the type of
+ * the empty array.
+ *
+ * Returns: (transfer none): a new, floating, #GVariant
+ *
+ * Since: 2.24
+ **/
+GVariant *
+g_variant_builder_end (GVariantBuilder *builder)
+{
+  GVariantType *my_type;
+  GVariant *value;
+
+  g_return_val_if_fail (ensure_valid_builder (builder), NULL);
+  g_return_val_if_fail (GVSB(builder)->offset >= GVSB(builder)->min_items,
+                        NULL);
+  g_return_val_if_fail (!GVSB(builder)->uniform_item_types ||
+                        GVSB(builder)->prev_item_type != NULL ||
+                        g_variant_type_is_definite (GVSB(builder)->type),
+                        NULL);
+
+  if (g_variant_type_is_definite (GVSB(builder)->type))
+    my_type = g_variant_type_copy (GVSB(builder)->type);
+
+  else if (g_variant_type_is_maybe (GVSB(builder)->type))
+    my_type = g_variant_make_maybe_type (GVSB(builder)->children[0]);
+
+  else if (g_variant_type_is_array (GVSB(builder)->type))
+    my_type = g_variant_make_array_type (GVSB(builder)->children[0]);
+
+  else if (g_variant_type_is_tuple (GVSB(builder)->type))
+    my_type = g_variant_make_tuple_type (GVSB(builder)->children,
+                                         GVSB(builder)->offset);
+
+  else if (g_variant_type_is_dict_entry (GVSB(builder)->type))
+    my_type = g_variant_make_dict_entry_type (GVSB(builder)->children[0],
+                                              GVSB(builder)->children[1]);
+  else
+    g_assert_not_reached ();
+
+  value = g_variant_new_from_children (my_type,
+                                       g_renew (GVariant *,
+                                                GVSB(builder)->children,
+                                                GVSB(builder)->offset),
+                                       GVSB(builder)->offset,
+                                       GVSB(builder)->trusted);
+  GVSB(builder)->children = NULL;
+  GVSB(builder)->offset = 0;
+
+  g_variant_builder_clear (builder);
+  g_variant_type_free (my_type);
+
+  return value;
+}
+
+/* GVariantDict {{{1 */
+
+/**
+ * GVariantDict:
+ *
+ * #GVariantDict is a mutable interface to #GVariant dictionaries.
+ *
+ * It can be used for doing a sequence of dictionary lookups in an
+ * efficient way on an existing #GVariant dictionary or it can be used
+ * to construct new dictionaries with a hashtable-like interface.  It
+ * can also be used for taking existing dictionaries and modifying them
+ * in order to create new ones.
+ *
+ * #GVariantDict can only be used with %G_VARIANT_TYPE_VARDICT
+ * dictionaries.
+ *
+ * It is possible to use #GVariantDict allocated on the stack or on the
+ * heap.  When using a stack-allocated #GVariantDict, you begin with a
+ * call to g_variant_dict_init() and free the resources with a call to
+ * g_variant_dict_clear().
+ *
+ * Heap-allocated #GVariantDict follows normal refcounting rules: you
+ * allocate it with g_variant_dict_new() and use g_variant_dict_ref()
+ * and g_variant_dict_unref().
+ *
+ * g_variant_dict_end() is used to convert the #GVariantDict back into a
+ * dictionary-type #GVariant.  When used with stack-allocated instances,
+ * this also implicitly frees all associated memory, but for
+ * heap-allocated instances, you must still call g_variant_dict_unref()
+ * afterwards.
+ *
+ * You will typically want to use a heap-allocated #GVariantDict when
+ * you expose it as part of an API.  For most other uses, the
+ * stack-allocated form will be more convenient.
+ *
+ * Consider the following two examples that do the same thing in each
+ * style: take an existing dictionary and look up the "count" uint32
+ * key, adding 1 to it if it is found, or returning an error if the
+ * key is not found.  Each returns the new dictionary as a floating
+ * #GVariant.
+ *
+ * ## Using a stack-allocated GVariantDict
+ *
+ * |[<!-- language="C" -->
+ *   GVariant *
+ *   add_to_count (GVariant  *orig,
+ *                 GError   **error)
+ *   {
+ *     GVariantDict dict;
+ *     guint32 count;
+ *
+ *     g_variant_dict_init (&dict, orig);
+ *     if (!g_variant_dict_lookup (&dict, "count", "u", &count))
+ *       {
+ *         g_set_error (...);
+ *         g_variant_dict_clear (&dict);
+ *         return NULL;
+ *       }
+ *
+ *     g_variant_dict_insert (&dict, "count", "u", count + 1);
+ *
+ *     return g_variant_dict_end (&dict);
+ *   }
+ * ]|
+ *
+ * ## Using heap-allocated GVariantDict
+ *
+ * |[<!-- language="C" -->
+ *   GVariant *
+ *   add_to_count (GVariant  *orig,
+ *                 GError   **error)
+ *   {
+ *     GVariantDict *dict;
+ *     GVariant *result;
+ *     guint32 count;
+ *
+ *     dict = g_variant_dict_new (orig);
+ *
+ *     if (g_variant_dict_lookup (dict, "count", "u", &count))
+ *       {
+ *         g_variant_dict_insert (dict, "count", "u", count + 1);
+ *         result = g_variant_dict_end (dict);
+ *       }
+ *     else
+ *       {
+ *         g_set_error (...);
+ *         result = NULL;
+ *       }
+ *
+ *     g_variant_dict_unref (dict);
+ *
+ *     return result;
+ *   }
+ * ]|
+ *
+ * Since: 2.40
+ **/
+struct stack_dict
+{
+  GHashTable *values;
+  gsize magic;
+};
+
+G_STATIC_ASSERT (sizeof (struct stack_dict) <= sizeof (GVariantDict));
+
+struct heap_dict
+{
+  struct stack_dict dict;
+  gint ref_count;
+  gsize magic;
+};
+
+#define GVSD(d)                 ((struct stack_dict *) (d))
+#define GVHD(d)                 ((struct heap_dict *) (d))
+#define GVSD_MAGIC              ((gsize) 2579507750u)
+#define GVSD_MAGIC_PARTIAL      ((gsize) 3488698669u)
+#define GVHD_MAGIC              ((gsize) 2450270775u)
+#define is_valid_dict(d)        (GVSD(d)->magic == GVSD_MAGIC)
+#define is_valid_heap_dict(d)   (GVHD(d)->magic == GVHD_MAGIC)
+
+/* Just to make sure that by adding a union to GVariantDict, we didn't
+ * accidentally change ABI. */
+G_STATIC_ASSERT (sizeof (GVariantDict) == sizeof (gsize[16]));
+
+static gboolean
+ensure_valid_dict (GVariantDict *dict)
+{
+  if (dict == NULL)
+    return FALSE;
+  else if (is_valid_dict (dict))
+    return TRUE;
+  if (dict->u.s.partial_magic == GVSD_MAGIC_PARTIAL)
+    {
+      static GVariantDict cleared_dict;
+
+      /* Make sure that only first two fields were set and the rest is
+       * zeroed to avoid messing up the builder that had parent
+       * address equal to GVSB_MAGIC_PARTIAL. */
+      if (memcmp (cleared_dict.u.s.y, dict->u.s.y, sizeof cleared_dict.u.s.y))
+        return FALSE;
+
+      g_variant_dict_init (dict, dict->u.s.asv);
+    }
+  return is_valid_dict (dict);
+}
+
+/**
+ * g_variant_dict_new:
+ * @from_asv: (nullable): the #GVariant with which to initialise the
+ *   dictionary
+ *
+ * Allocates and initialises a new #GVariantDict.
+ *
+ * You should call g_variant_dict_unref() on the return value when it
+ * is no longer needed.  The memory will not be automatically freed by
+ * any other call.
+ *
+ * In some cases it may be easier to place a #GVariantDict directly on
+ * the stack of the calling function and initialise it with
+ * g_variant_dict_init().  This is particularly useful when you are
+ * using #GVariantDict to construct a #GVariant.
+ *
+ * Returns: (transfer full): a #GVariantDict
+ *
+ * Since: 2.40
+ **/
+GVariantDict *
+g_variant_dict_new (GVariant *from_asv)
+{
+  GVariantDict *dict;
+
+  dict = g_slice_alloc (sizeof (struct heap_dict));
+  g_variant_dict_init (dict, from_asv);
+  GVHD(dict)->magic = GVHD_MAGIC;
+  GVHD(dict)->ref_count = 1;
+
+  return dict;
+}
+
+/**
+ * g_variant_dict_init: (skip)
+ * @dict: a #GVariantDict
+ * @from_asv: (nullable): the initial value for @dict
+ *
+ * Initialises a #GVariantDict structure.
+ *
+ * If @from_asv is given, it is used to initialise the dictionary.
+ *
+ * This function completely ignores the previous contents of @dict.  On
+ * one hand this means that it is valid to pass in completely
+ * uninitialised memory.  On the other hand, this means that if you are
+ * initialising over top of an existing #GVariantDict you need to first
+ * call g_variant_dict_clear() in order to avoid leaking memory.
+ *
+ * You must not call g_variant_dict_ref() or g_variant_dict_unref() on a
+ * #GVariantDict that was initialised with this function.  If you ever
+ * pass a reference to a #GVariantDict outside of the control of your
+ * own code then you should assume that the person receiving that
+ * reference may try to use reference counting; you should use
+ * g_variant_dict_new() instead of this function.
+ *
+ * Since: 2.40
+ **/
+void
+g_variant_dict_init (GVariantDict *dict,
+                     GVariant     *from_asv)
+{
+  GVariantIter iter;
+  gchar *key;
+  GVariant *value;
+
+  GVSD(dict)->values = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, (GDestroyNotify) g_variant_unref);
+  GVSD(dict)->magic = GVSD_MAGIC;
+
+  if (from_asv)
+    {
+      g_variant_iter_init (&iter, from_asv);
+      while (g_variant_iter_next (&iter, "{sv}", &key, &value))
+        g_hash_table_insert (GVSD(dict)->values, key, value);
+    }
+}
+
+/**
+ * g_variant_dict_lookup:
+ * @dict: a #GVariantDict
+ * @key: the key to look up in the dictionary
+ * @format_string: a GVariant format string
+ * @...: the arguments to unpack the value into
+ *
+ * Looks up a value in a #GVariantDict.
+ *
+ * This function is a wrapper around g_variant_dict_lookup_value() and
+ * g_variant_get().  In the case that %NULL would have been returned,
+ * this function returns %FALSE.  Otherwise, it unpacks the returned
+ * value and returns %TRUE.
+ *
+ * @format_string determines the C types that are used for unpacking the
+ * values and also determines if the values are copied or borrowed, see the
+ * section on [GVariant format strings][gvariant-format-strings-pointers].
+ *
+ * Returns: %TRUE if a value was unpacked
+ *
+ * Since: 2.40
+ **/
+gboolean
+g_variant_dict_lookup (GVariantDict *dict,
+                       const gchar  *key,
+                       const gchar  *format_string,
+                       ...)
+{
+  GVariant *value;
+  va_list ap;
+
+  g_return_val_if_fail (ensure_valid_dict (dict), FALSE);
+  g_return_val_if_fail (key != NULL, FALSE);
+  g_return_val_if_fail (format_string != NULL, FALSE);
+
+  value = g_hash_table_lookup (GVSD(dict)->values, key);
+
+  if (value == NULL || !g_variant_check_format_string (value, format_string, FALSE))
+    return FALSE;
+
+  va_start (ap, format_string);
+  g_variant_get_va (value, format_string, NULL, &ap);
+  va_end (ap);
+
+  return TRUE;
+}
+
+/**
+ * g_variant_dict_lookup_value:
+ * @dict: a #GVariantDict
+ * @key: the key to look up in the dictionary
+ * @expected_type: (nullable): a #GVariantType, or %NULL
+ *
+ * Looks up a value in a #GVariantDict.
+ *
+ * If @key is not found in @dictionary, %NULL is returned.
+ *
+ * The @expected_type string specifies what type of value is expected.
+ * If the value associated with @key has a different type then %NULL is
+ * returned.
+ *
+ * If the key is found and the value has the correct type, it is
+ * returned.  If @expected_type was specified then any non-%NULL return
+ * value will have this type.
+ *
+ * Returns: (transfer full): the value of the dictionary key, or %NULL
+ *
+ * Since: 2.40
+ **/
+GVariant *
+g_variant_dict_lookup_value (GVariantDict       *dict,
+                             const gchar        *key,
+                             const GVariantType *expected_type)
+{
+  GVariant *result;
+
+  g_return_val_if_fail (ensure_valid_dict (dict), NULL);
+  g_return_val_if_fail (key != NULL, NULL);
+
+  result = g_hash_table_lookup (GVSD(dict)->values, key);
+
+  if (result && (!expected_type || g_variant_is_of_type (result, expected_type)))
+    return g_variant_ref (result);
+
+  return NULL;
+}
+
+/**
+ * g_variant_dict_contains:
+ * @dict: a #GVariantDict
+ * @key: the key to look up in the dictionary
+ *
+ * Checks if @key exists in @dict.
+ *
+ * Returns: %TRUE if @key is in @dict
+ *
+ * Since: 2.40
+ **/
+gboolean
+g_variant_dict_contains (GVariantDict *dict,
+                         const gchar  *key)
+{
+  g_return_val_if_fail (ensure_valid_dict (dict), FALSE);
+  g_return_val_if_fail (key != NULL, FALSE);
+
+  return g_hash_table_contains (GVSD(dict)->values, key);
+}
+
+/**
+ * g_variant_dict_insert:
+ * @dict: a #GVariantDict
+ * @key: the key to insert a value for
+ * @format_string: a #GVariant varargs format string
+ * @...: arguments, as per @format_string
+ *
+ * Inserts a value into a #GVariantDict.
+ *
+ * This call is a convenience wrapper that is exactly equivalent to
+ * calling g_variant_new() followed by g_variant_dict_insert_value().
+ *
+ * Since: 2.40
+ **/
+void
+g_variant_dict_insert (GVariantDict *dict,
+                       const gchar  *key,
+                       const gchar  *format_string,
+                       ...)
+{
+  va_list ap;
+
+  g_return_if_fail (ensure_valid_dict (dict));
+  g_return_if_fail (key != NULL);
+  g_return_if_fail (format_string != NULL);
+
+  va_start (ap, format_string);
+  g_variant_dict_insert_value (dict, key, g_variant_new_va (format_string, NULL, &ap));
+  va_end (ap);
+}
+
+/**
+ * g_variant_dict_insert_value:
+ * @dict: a #GVariantDict
+ * @key: the key to insert a value for
+ * @value: the value to insert
+ *
+ * Inserts (or replaces) a key in a #GVariantDict.
+ *
+ * @value is consumed if it is floating.
+ *
+ * Since: 2.40
+ **/
+void
+g_variant_dict_insert_value (GVariantDict *dict,
+                             const gchar  *key,
+                             GVariant     *value)
+{
+  g_return_if_fail (ensure_valid_dict (dict));
+  g_return_if_fail (key != NULL);
+  g_return_if_fail (value != NULL);
+
+  g_hash_table_insert (GVSD(dict)->values, g_strdup (key), g_variant_ref_sink (value));
+}
+
+/**
+ * g_variant_dict_remove:
+ * @dict: a #GVariantDict
+ * @key: the key to remove
+ *
+ * Removes a key and its associated value from a #GVariantDict.
+ *
+ * Returns: %TRUE if the key was found and removed
+ *
+ * Since: 2.40
+ **/
+gboolean
+g_variant_dict_remove (GVariantDict *dict,
+                       const gchar  *key)
+{
+  g_return_val_if_fail (ensure_valid_dict (dict), FALSE);
+  g_return_val_if_fail (key != NULL, FALSE);
+
+  return g_hash_table_remove (GVSD(dict)->values, key);
+}
+
+/**
+ * g_variant_dict_clear:
+ * @dict: a #GVariantDict
+ *
+ * Releases all memory associated with a #GVariantDict without freeing
+ * the #GVariantDict structure itself.
+ *
+ * It typically only makes sense to do this on a stack-allocated
+ * #GVariantDict if you want to abort building the value part-way
+ * through.  This function need not be called if you call
+ * g_variant_dict_end() and it also doesn't need to be called on dicts
+ * allocated with g_variant_dict_new (see g_variant_dict_unref() for
+ * that).
+ *
+ * It is valid to call this function on either an initialised
+ * #GVariantDict or one that was previously cleared by an earlier call
+ * to g_variant_dict_clear() but it is not valid to call this function
+ * on uninitialised memory.
+ *
+ * Since: 2.40
+ **/
+void
+g_variant_dict_clear (GVariantDict *dict)
+{
+  if (GVSD(dict)->magic == 0)
+    /* all-zeros case */
+    return;
+
+  g_return_if_fail (ensure_valid_dict (dict));
+
+  g_hash_table_unref (GVSD(dict)->values);
+  GVSD(dict)->values = NULL;
+
+  GVSD(dict)->magic = 0;
+}
+
+/**
+ * g_variant_dict_end:
+ * @dict: a #GVariantDict
+ *
+ * Returns the current value of @dict as a #GVariant of type
+ * %G_VARIANT_TYPE_VARDICT, clearing it in the process.
+ *
+ * It is not permissible to use @dict in any way after this call except
+ * for reference counting operations (in the case of a heap-allocated
+ * #GVariantDict) or by reinitialising it with g_variant_dict_init() (in
+ * the case of stack-allocated).
+ *
+ * Returns: (transfer none): a new, floating, #GVariant
+ *
+ * Since: 2.40
+ **/
+GVariant *
+g_variant_dict_end (GVariantDict *dict)
+{
+  GVariantBuilder builder;
+  GHashTableIter iter;
+  gpointer key, value;
+
+  g_return_val_if_fail (ensure_valid_dict (dict), NULL);
+
+  g_variant_builder_init (&builder, G_VARIANT_TYPE_VARDICT);
+
+  g_hash_table_iter_init (&iter, GVSD(dict)->values);
+  while (g_hash_table_iter_next (&iter, &key, &value))
+    g_variant_builder_add (&builder, "{sv}", (const gchar *) key, (GVariant *) value);
+
+  g_variant_dict_clear (dict);
+
+  return g_variant_builder_end (&builder);
+}
+
+/**
+ * g_variant_dict_ref:
+ * @dict: a heap-allocated #GVariantDict
+ *
+ * Increases the reference count on @dict.
+ *
+ * Don't call this on stack-allocated #GVariantDict instances or bad
+ * things will happen.
+ *
+ * Returns: (transfer full): a new reference to @dict
+ *
+ * Since: 2.40
+ **/
+GVariantDict *
+g_variant_dict_ref (GVariantDict *dict)
+{
+  g_return_val_if_fail (is_valid_heap_dict (dict), NULL);
+
+  GVHD(dict)->ref_count++;
+
+  return dict;
+}
+
+/**
+ * g_variant_dict_unref:
+ * @dict: (transfer full): a heap-allocated #GVariantDict
+ *
+ * Decreases the reference count on @dict.
+ *
+ * In the event that there are no more references, releases all memory
+ * associated with the #GVariantDict.
+ *
+ * Don't call this on stack-allocated #GVariantDict instances or bad
+ * things will happen.
+ *
+ * Since: 2.40
+ **/
+void
+g_variant_dict_unref (GVariantDict *dict)
+{
+  g_return_if_fail (is_valid_heap_dict (dict));
+
+  if (--GVHD(dict)->ref_count == 0)
+    {
+      g_variant_dict_clear (dict);
+      g_slice_free (struct heap_dict, (struct heap_dict *) dict);
+    }
+}
+
+
+/* Format strings {{{1 */
+/*< private >
+ * g_variant_format_string_scan:
+ * @string: a string that may be prefixed with a format string
+ * @limit: (nullable) (default NULL): a pointer to the end of @string,
+ *         or %NULL
+ * @endptr: (nullable) (default NULL): location to store the end pointer,
+ *          or %NULL
+ *
+ * Checks the string pointed to by @string for starting with a properly
+ * formed #GVariant varargs format string.  If no valid format string is
+ * found then %FALSE is returned.
+ *
+ * If @string does start with a valid format string then %TRUE is
+ * returned.  If @endptr is non-%NULL then it is updated to point to the
+ * first character after the format string.
+ *
+ * If @limit is non-%NULL then @limit (and any character after it) will
+ * not be accessed and the effect is otherwise equivalent to if the
+ * character at @limit were nul.
+ *
+ * See the section on [GVariant format strings][gvariant-format-strings].
+ *
+ * Returns: %TRUE if there was a valid format string
+ *
+ * Since: 2.24
+ */
+gboolean
+g_variant_format_string_scan (const gchar  *string,
+                              const gchar  *limit,
+                              const gchar **endptr)
+{
+#define next_char() (string == limit ? '\0' : *(string++))
+#define peek_char() (string == limit ? '\0' : *string)
+  char c;
+
+  switch (next_char())
+    {
+    case 'b': case 'y': case 'n': case 'q': case 'i': case 'u':
+    case 'x': case 't': case 'h': case 'd': case 's': case 'o':
+    case 'g': case 'v': case '*': case '?': case 'r':
+      break;
+
+    case 'm':
+      return g_variant_format_string_scan (string, limit, endptr);
+
+    case 'a':
+    case '@':
+      return g_variant_type_string_scan (string, limit, endptr);
+
+    case '(':
+      while (peek_char() != ')')
+        if (!g_variant_format_string_scan (string, limit, &string))
+          return FALSE;
+
+      next_char(); /* consume ')' */
+      break;
+
+    case '{':
+      c = next_char();
+
+      if (c == '&')
+        {
+          c = next_char ();
+
+          if (c != 's' && c != 'o' && c != 'g')
+            return FALSE;
+        }
+      else
+        {
+          if (c == '@')
+            c = next_char ();
+
+          /* ISO/IEC 9899:1999 (C99) §7.21.5.2:
+           *    The terminating null character is considered to be
+           *    part of the string.
+           */
+          if (c != '\0' && strchr ("bynqiuxthdsog?", c) == NULL)
+            return FALSE;
+        }
+
+      if (!g_variant_format_string_scan (string, limit, &string))
+        return FALSE;
+
+      if (next_char() != '}')
+        return FALSE;
+
+      break;
+
+    case '^':
+      if ((c = next_char()) == 'a')
+        {
+          if ((c = next_char()) == '&')
+            {
+              if ((c = next_char()) == 'a')
+                {
+                  if ((c = next_char()) == 'y')
+                    break;      /* '^a&ay' */
+                }
+
+              else if (c == 's' || c == 'o')
+                break;          /* '^a&s', '^a&o' */
+            }
+
+          else if (c == 'a')
+            {
+              if ((c = next_char()) == 'y')
+                break;          /* '^aay' */
+            }
+
+          else if (c == 's' || c == 'o')
+            break;              /* '^as', '^ao' */
+
+          else if (c == 'y')
+            break;              /* '^ay' */
+        }
+      else if (c == '&')
+        {
+          if ((c = next_char()) == 'a')
+            {
+              if ((c = next_char()) == 'y')
+                break;          /* '^&ay' */
+            }
+        }
+
+      return FALSE;
+
+    case '&':
+      c = next_char();
+
+      if (c != 's' && c != 'o' && c != 'g')
+        return FALSE;
+
+      break;
+
+    default:
+      return FALSE;
+    }
+
+  if (endptr != NULL)
+    *endptr = string;
+
+#undef next_char
+#undef peek_char
+
+  return TRUE;
+}
+
+/**
+ * g_variant_check_format_string:
+ * @value: a #GVariant
+ * @format_string: a valid #GVariant format string
+ * @copy_only: %TRUE to ensure the format string makes deep copies
+ *
+ * Checks if calling g_variant_get() with @format_string on @value would
+ * be valid from a type-compatibility standpoint.  @format_string is
+ * assumed to be a valid format string (from a syntactic standpoint).
+ *
+ * If @copy_only is %TRUE then this function additionally checks that it
+ * would be safe to call g_variant_unref() on @value immediately after
+ * the call to g_variant_get() without invalidating the result.  This is
+ * only possible if deep copies are made (ie: there are no pointers to
+ * the data inside of the soon-to-be-freed #GVariant instance).  If this
+ * check fails then a g_critical() is printed and %FALSE is returned.
+ *
+ * This function is meant to be used by functions that wish to provide
+ * varargs accessors to #GVariant values of uncertain values (eg:
+ * g_variant_lookup() or g_menu_model_get_item_attribute()).
+ *
+ * Returns: %TRUE if @format_string is safe to use
+ *
+ * Since: 2.34
+ */
+gboolean
+g_variant_check_format_string (GVariant    *value,
+                               const gchar *format_string,
+                               gboolean     copy_only)
+{
+  const gchar *original_format = format_string;
+  const gchar *type_string;
+
+  /* Interesting factoid: assuming a format string is valid, it can be
+   * converted to a type string by removing all '@' '&' and '^'
+   * characters.
+   *
+   * Instead of doing that, we can just skip those characters when
+   * comparing it to the type string of @value.
+   *
+   * For the copy-only case we can just drop the '&' from the list of
+   * characters to skip over.  A '&' will never appear in a type string
+   * so we know that it won't be possible to return %TRUE if it is in a
+   * format string.
+   */
+  type_string = g_variant_get_type_string (value);
+
+  while (*type_string || *format_string)
+    {
+      gchar format = *format_string++;
+
+      switch (format)
+        {
+        case '&':
+          if G_UNLIKELY (copy_only)
+            {
+              /* for the love of all that is good, please don't mark this string for translation... */
+              g_critical ("g_variant_check_format_string() is being called by a function with a GVariant varargs "
+                          "interface to validate the passed format string for type safety.  The passed format "
+                          "(%s) contains a '&' character which would result in a pointer being returned to the "
+                          "data inside of a GVariant instance that may no longer exist by the time the function "
+                          "returns.  Modify your code to use a format string without '&'.", original_format);
+              return FALSE;
+            }
+
+          G_GNUC_FALLTHROUGH;
+        case '^':
+        case '@':
+          /* ignore these 2 (or 3) */
+          continue;
+
+        case '?':
+          /* attempt to consume one of 'bynqiuxthdsog' */
+          {
+            char s = *type_string++;
+
+            if (s == '\0' || strchr ("bynqiuxthdsog", s) == NULL)
+              return FALSE;
+          }
+          continue;
+
+        case 'r':
+          /* ensure it's a tuple */
+          if (*type_string != '(')
+            return FALSE;
+
+          G_GNUC_FALLTHROUGH;
+        case '*':
+          /* consume a full type string for the '*' or 'r' */
+          if (!g_variant_type_string_scan (type_string, NULL, &type_string))
+            return FALSE;
+
+          continue;
+
+        default:
+          /* attempt to consume exactly one character equal to the format */
+          if (format != *type_string++)
+            return FALSE;
+        }
+    }
+
+  return TRUE;
+}
+
+/*< private >
+ * g_variant_format_string_scan_type:
+ * @string: a string that may be prefixed with a format string
+ * @limit: (nullable) (default NULL): a pointer to the end of @string,
+ *         or %NULL
+ * @endptr: (nullable) (default NULL): location to store the end pointer,
+ *          or %NULL
+ *
+ * If @string starts with a valid format string then this function will
+ * return the type that the format string corresponds to.  Otherwise
+ * this function returns %NULL.
+ *
+ * Use g_variant_type_free() to free the return value when you no longer
+ * need it.
+ *
+ * This function is otherwise exactly like
+ * g_variant_format_string_scan().
+ *
+ * Returns: (nullable): a #GVariantType if there was a valid format string
+ *
+ * Since: 2.24
+ */
+GVariantType *
+g_variant_format_string_scan_type (const gchar  *string,
+                                   const gchar  *limit,
+                                   const gchar **endptr)
+{
+  const gchar *my_end;
+  gchar *dest;
+  gchar *new;
+
+  if (endptr == NULL)
+    endptr = &my_end;
+
+  if (!g_variant_format_string_scan (string, limit, endptr))
+    return NULL;
+
+  dest = new = g_malloc (*endptr - string + 1);
+  while (string != *endptr)
+    {
+      if (*string != '@' && *string != '&' && *string != '^')
+        *dest++ = *string;
+      string++;
+    }
+  *dest = '\0';
+
+  return (GVariantType *) G_VARIANT_TYPE (new);
+}
+
+static gboolean
+valid_format_string (const gchar *format_string,
+                     gboolean     single,
+                     GVariant    *value)
+{
+  const gchar *endptr;
+  GVariantType *type;
+
+  type = g_variant_format_string_scan_type (format_string, NULL, &endptr);
+
+  if G_UNLIKELY (type == NULL || (single && *endptr != '\0'))
+    {
+      if (single)
+        g_critical ("'%s' is not a valid GVariant format string",
+                    format_string);
+      else
+        g_critical ("'%s' does not have a valid GVariant format "
+                    "string as a prefix", format_string);
+
+      if (type != NULL)
+        g_variant_type_free (type);
+
+      return FALSE;
+    }
+
+  if G_UNLIKELY (value && !g_variant_is_of_type (value, type))
+    {
+      gchar *fragment;
+      gchar *typestr;
+
+      fragment = g_strndup (format_string, endptr - format_string);
+      typestr = g_variant_type_dup_string (type);
+
+      g_critical ("the GVariant format string '%s' has a type of "
+                  "'%s' but the given value has a type of '%s'",
+                  fragment, typestr, g_variant_get_type_string (value));
+
+      g_variant_type_free (type);
+      g_free (fragment);
+      g_free (typestr);
+
+      return FALSE;
+    }
+
+  g_variant_type_free (type);
+
+  return TRUE;
+}
+
+/* Variable Arguments {{{1 */
+/* We consider 2 main classes of format strings:
+ *
+ *   - recursive format strings
+ *      these are ones that result in recursion and the collection of
+ *      possibly more than one argument.  Maybe types, tuples,
+ *      dictionary entries.
+ *
+ *   - leaf format string
+ *      these result in the collection of a single argument.
+ *
+ * Leaf format strings are further subdivided into two categories:
+ *
+ *   - single non-null pointer ("nnp")
+ *      these either collect or return a single non-null pointer.
+ *
+ *   - other
+ *      these collect or return something else (bool, number, etc).
+ *
+ * Based on the above, the varargs handling code is split into 4 main parts:
+ *
+ *   - nnp handling code
+ *   - leaf handling code (which may invoke nnp code)
+ *   - generic handling code (may be recursive, may invoke leaf code)
+ *   - user-facing API (which invokes the generic code)
+ *
+ * Each section implements some of the following functions:
+ *
+ *   - skip:
+ *      collect the arguments for the format string as if
+ *      g_variant_new() had been called, but do nothing with them.  used
+ *      for skipping over arguments when constructing a Nothing maybe
+ *      type.
+ *
+ *   - new:
+ *      create a GVariant *
+ *
+ *   - get:
+ *      unpack a GVariant *
+ *
+ *   - free (nnp only):
+ *      free a previously allocated item
+ */
+
+static gboolean
+g_variant_format_string_is_leaf (const gchar *str)
+{
+  return str[0] != 'm' && str[0] != '(' && str[0] != '{';
+}
+
+static gboolean
+g_variant_format_string_is_nnp (const gchar *str)
+{
+  return str[0] == 'a' || str[0] == 's' || str[0] == 'o' || str[0] == 'g' ||
+         str[0] == '^' || str[0] == '@' || str[0] == '*' || str[0] == '?' ||
+         str[0] == 'r' || str[0] == 'v' || str[0] == '&';
+}
+
+/* Single non-null pointer ("nnp") {{{2 */
+static void
+g_variant_valist_free_nnp (const gchar *str,
+                           gpointer     ptr)
+{
+  switch (*str)
+    {
+    case 'a':
+      g_variant_iter_free (ptr);
+      break;
+
+    case '^':
+      if (g_str_has_suffix (str, "y"))
+        {
+          if (str[2] != 'a') /* '^a&ay', '^ay' */
+            g_free (ptr);
+          else if (str[1] == 'a') /* '^aay' */
+            g_strfreev (ptr);
+          break; /* '^&ay' */
+        }
+      else if (str[2] != '&') /* '^as', '^ao' */
+        g_strfreev (ptr);
+      else                      /* '^a&s', '^a&o' */
+        g_free (ptr);
+      break;
+
+    case 's':
+    case 'o':
+    case 'g':
+      g_free (ptr);
+      break;
+
+    case '@':
+    case '*':
+    case '?':
+    case 'v':
+      g_variant_unref (ptr);
+      break;
+
+    case '&':
+      break;
+
+    default:
+      g_assert_not_reached ();
+    }
+}
+
+static gchar
+g_variant_scan_convenience (const gchar **str,
+                            gboolean     *constant,
+                            guint        *arrays)
+{
+  *constant = FALSE;
+  *arrays = 0;
+
+  for (;;)
+    {
+      char c = *(*str)++;
+
+      if (c == '&')
+        *constant = TRUE;
+
+      else if (c == 'a')
+        (*arrays)++;
+
+      else
+        return c;
+    }
+}
+
+static GVariant *
+g_variant_valist_new_nnp (const gchar **str,
+                          gpointer      ptr)
+{
+  if (**str == '&')
+    (*str)++;
+
+  switch (*(*str)++)
+    {
+    case 'a':
+      if (ptr != NULL)
+        {
+          const GVariantType *type;
+          GVariant *value;
+
+          value = g_variant_builder_end (ptr);
+          type = g_variant_get_type (value);
+
+          if G_UNLIKELY (!g_variant_type_is_array (type))
+            g_error ("g_variant_new: expected array GVariantBuilder but "
+                     "the built value has type '%s'",
+                     g_variant_get_type_string (value));
+
+          type = g_variant_type_element (type);
+
+          if G_UNLIKELY (!g_variant_type_is_subtype_of (type, (GVariantType *) *str))
+            {
+              gchar *type_string = g_variant_type_dup_string ((GVariantType *) *str);
+              g_error ("g_variant_new: expected GVariantBuilder array element "
+                       "type '%s' but the built value has element type '%s'",
+                       type_string, g_variant_get_type_string (value) + 1);
+              g_free (type_string);
+            }
+
+          g_variant_type_string_scan (*str, NULL, str);
+
+          return value;
+        }
+      else
+
+        /* special case: NULL pointer for empty array */
+        {
+          const GVariantType *type = (GVariantType *) *str;
+
+          g_variant_type_string_scan (*str, NULL, str);
+
+          if G_UNLIKELY (!g_variant_type_is_definite (type))
+            g_error ("g_variant_new: NULL pointer given with indefinite "
+                     "array type; unable to determine which type of empty "
+                     "array to construct.");
+
+          return g_variant_new_array (type, NULL, 0);
+        }
+
+    case 's':
+      {
+        GVariant *value;
+
+        value = g_variant_new_string (ptr);
+
+        if (value == NULL)
+          value = g_variant_new_string ("[Invalid UTF-8]");
+
+        return value;
+      }
+
+    case 'o':
+      return g_variant_new_object_path (ptr);
+
+    case 'g':
+      return g_variant_new_signature (ptr);
+
+    case '^':
+      {
+        gboolean constant;
+        guint arrays;
+        gchar type;
+
+        type = g_variant_scan_convenience (str, &constant, &arrays);
+
+        if (type == 's')
+          return g_variant_new_strv (ptr, -1);
+
+        if (type == 'o')
+          return g_variant_new_objv (ptr, -1);
+
+        if (arrays > 1)
+          return g_variant_new_bytestring_array (ptr, -1);
+
+        return g_variant_new_bytestring (ptr);
+      }
+
+    case '@':
+      if G_UNLIKELY (!g_variant_is_of_type (ptr, (GVariantType *) *str))
+        {
+          gchar *type_string = g_variant_type_dup_string ((GVariantType *) *str);
+          g_error ("g_variant_new: expected GVariant of type '%s' but "
+                   "received value has type '%s'",
+                   type_string, g_variant_get_type_string (ptr));
+          g_free (type_string);
+        }
+
+      g_variant_type_string_scan (*str, NULL, str);
+
+      return ptr;
+
+    case '*':
+      return ptr;
+
+    case '?':
+      if G_UNLIKELY (!g_variant_type_is_basic (g_variant_get_type (ptr)))
+        g_error ("g_variant_new: format string '?' expects basic-typed "
+                 "GVariant, but received value has type '%s'",
+                 g_variant_get_type_string (ptr));
+
+      return ptr;
+
+    case 'r':
+      if G_UNLIKELY (!g_variant_type_is_tuple (g_variant_get_type (ptr)))
+        g_error ("g_variant_new: format string 'r' expects tuple-typed "
+                 "GVariant, but received value has type '%s'",
+                 g_variant_get_type_string (ptr));
+
+      return ptr;
+
+    case 'v':
+      return g_variant_new_variant (ptr);
+
+    default:
+      g_assert_not_reached ();
+    }
+}
+
+static gpointer
+g_variant_valist_get_nnp (const gchar **str,
+                          GVariant     *value)
+{
+  switch (*(*str)++)
+    {
+    case 'a':
+      g_variant_type_string_scan (*str, NULL, str);
+      return g_variant_iter_new (value);
+
+    case '&':
+      (*str)++;
+      return (gchar *) g_variant_get_string (value, NULL);
+
+    case 's':
+    case 'o':
+    case 'g':
+      return g_variant_dup_string (value, NULL);
+
+    case '^':
+      {
+        gboolean constant;
+        guint arrays;
+        gchar type;
+
+        type = g_variant_scan_convenience (str, &constant, &arrays);
+
+        if (type == 's')
+          {
+            if (constant)
+              return g_variant_get_strv (value, NULL);
+            else
+              return g_variant_dup_strv (value, NULL);
+          }
+
+        else if (type == 'o')
+          {
+            if (constant)
+              return g_variant_get_objv (value, NULL);
+            else
+              return g_variant_dup_objv (value, NULL);
+          }
+
+        else if (arrays > 1)
+          {
+            if (constant)
+              return g_variant_get_bytestring_array (value, NULL);
+            else
+              return g_variant_dup_bytestring_array (value, NULL);
+          }
+
+        else
+          {
+            if (constant)
+              return (gchar *) g_variant_get_bytestring (value);
+            else
+              return g_variant_dup_bytestring (value, NULL);
+          }
+      }
+
+    case '@':
+      g_variant_type_string_scan (*str, NULL, str);
+      G_GNUC_FALLTHROUGH;
+
+    case '*':
+    case '?':
+    case 'r':
+      return g_variant_ref (value);
+
+    case 'v':
+      return g_variant_get_variant (value);
+
+    default:
+      g_assert_not_reached ();
+    }
+}
+
+/* Leaves {{{2 */
+static void
+g_variant_valist_skip_leaf (const gchar **str,
+                            va_list      *app)
+{
+  if (g_variant_format_string_is_nnp (*str))
+    {
+      g_variant_format_string_scan (*str, NULL, str);
+      va_arg (*app, gpointer);
+      return;
+    }
+
+  switch (*(*str)++)
+    {
+    case 'b':
+    case 'y':
+    case 'n':
+    case 'q':
+    case 'i':
+    case 'u':
+    case 'h':
+      va_arg (*app, int);
+      return;
+
+    case 'x':
+    case 't':
+      va_arg (*app, guint64);
+      return;
+
+    case 'd':
+      va_arg (*app, gdouble);
+      return;
+
+    default:
+      g_assert_not_reached ();
+    }
+}
+
+static GVariant *
+g_variant_valist_new_leaf (const gchar **str,
+                           va_list      *app)
+{
+  if (g_variant_format_string_is_nnp (*str))
+    return g_variant_valist_new_nnp (str, va_arg (*app, gpointer));
+
+  switch (*(*str)++)
+    {
+    case 'b':
+      return g_variant_new_boolean (va_arg (*app, gboolean));
+
+    case 'y':
+      return g_variant_new_byte (va_arg (*app, guint));
+
+    case 'n':
+      return g_variant_new_int16 (va_arg (*app, gint));
+
+    case 'q':
+      return g_variant_new_uint16 (va_arg (*app, guint));
+
+    case 'i':
+      return g_variant_new_int32 (va_arg (*app, gint));
+
+    case 'u':
+      return g_variant_new_uint32 (va_arg (*app, guint));
+
+    case 'x':
+      return g_variant_new_int64 (va_arg (*app, gint64));
+
+    case 't':
+      return g_variant_new_uint64 (va_arg (*app, guint64));
+
+    case 'h':
+      return g_variant_new_handle (va_arg (*app, gint));
+
+    case 'd':
+      return g_variant_new_double (va_arg (*app, gdouble));
+
+    default:
+      g_assert_not_reached ();
+    }
+}
+
+/* The code below assumes this */
+G_STATIC_ASSERT (sizeof (gboolean) == sizeof (guint32));
+G_STATIC_ASSERT (sizeof (gdouble) == sizeof (guint64));
+
+static void
+g_variant_valist_get_leaf (const gchar **str,
+                           GVariant     *value,
+                           gboolean      free,
+                           va_list      *app)
+{
+  gpointer ptr = va_arg (*app, gpointer);
+
+  if (ptr == NULL)
+    {
+      g_variant_format_string_scan (*str, NULL, str);
+      return;
+    }
+
+  if (g_variant_format_string_is_nnp (*str))
+    {
+      gpointer *nnp = (gpointer *) ptr;
+
+      if (free && *nnp != NULL)
+        g_variant_valist_free_nnp (*str, *nnp);
+
+      *nnp = NULL;
+
+      if (value != NULL)
+        *nnp = g_variant_valist_get_nnp (str, value);
+      else
+        g_variant_format_string_scan (*str, NULL, str);
+
+      return;
+    }
+
+  if (value != NULL)
+    {
+      switch (*(*str)++)
+        {
+        case 'b':
+          *(gboolean *) ptr = g_variant_get_boolean (value);
+          return;
+
+        case 'y':
+          *(guint8 *) ptr = g_variant_get_byte (value);
+          return;
+
+        case 'n':
+          *(gint16 *) ptr = g_variant_get_int16 (value);
+          return;
+
+        case 'q':
+          *(guint16 *) ptr = g_variant_get_uint16 (value);
+          return;
+
+        case 'i':
+          *(gint32 *) ptr = g_variant_get_int32 (value);
+          return;
+
+        case 'u':
+          *(guint32 *) ptr = g_variant_get_uint32 (value);
+          return;
+
+        case 'x':
+          *(gint64 *) ptr = g_variant_get_int64 (value);
+          return;
+
+        case 't':
+          *(guint64 *) ptr = g_variant_get_uint64 (value);
+          return;
+
+        case 'h':
+          *(gint32 *) ptr = g_variant_get_handle (value);
+          return;
+
+        case 'd':
+          *(gdouble *) ptr = g_variant_get_double (value);
+          return;
+        }
+    }
+  else
+    {
+      switch (*(*str)++)
+        {
+        case 'y':
+          *(guint8 *) ptr = 0;
+          return;
+
+        case 'n':
+        case 'q':
+          *(guint16 *) ptr = 0;
+          return;
+
+        case 'i':
+        case 'u':
+        case 'h':
+        case 'b':
+          *(guint32 *) ptr = 0;
+          return;
+
+        case 'x':
+        case 't':
+        case 'd':
+          *(guint64 *) ptr = 0;
+          return;
+        }
+    }
+
+  g_assert_not_reached ();
+}
+
+/* Generic (recursive) {{{2 */
+static void
+g_variant_valist_skip (const gchar **str,
+                       va_list      *app)
+{
+  if (g_variant_format_string_is_leaf (*str))
+    g_variant_valist_skip_leaf (str, app);
+
+  else if (**str == 'm') /* maybe */
+    {
+      (*str)++;
+
+      if (!g_variant_format_string_is_nnp (*str))
+        va_arg (*app, gboolean);
+
+      g_variant_valist_skip (str, app);
+    }
+  else /* tuple, dictionary entry */
+    {
+      g_assert (**str == '(' || **str == '{');
+      (*str)++;
+      while (**str != ')' && **str != '}')
+        g_variant_valist_skip (str, app);
+      (*str)++;
+    }
+}
+
+static GVariant *
+g_variant_valist_new (const gchar **str,
+                      va_list      *app)
+{
+  if (g_variant_format_string_is_leaf (*str))
+    return g_variant_valist_new_leaf (str, app);
+
+  if (**str == 'm') /* maybe */
+    {
+      GVariantType *type = NULL;
+      GVariant *value = NULL;
+
+      (*str)++;
+
+      if (g_variant_format_string_is_nnp (*str))
+        {
+          gpointer nnp = va_arg (*app, gpointer);
+
+          if (nnp != NULL)
+            value = g_variant_valist_new_nnp (str, nnp);
+          else
+            type = g_variant_format_string_scan_type (*str, NULL, str);
+        }
+      else
+        {
+          gboolean just = va_arg (*app, gboolean);
+
+          if (just)
+            value = g_variant_valist_new (str, app);
+          else
+            {
+              type = g_variant_format_string_scan_type (*str, NULL, NULL);
+              g_variant_valist_skip (str, app);
+            }
+        }
+
+      value = g_variant_new_maybe (type, value);
+
+      if (type != NULL)
+        g_variant_type_free (type);
+
+      return value;
+    }
+  else /* tuple, dictionary entry */
+    {
+      GVariantBuilder b;
+
+      if (**str == '(')
+        g_variant_builder_init (&b, G_VARIANT_TYPE_TUPLE);
+      else
+        {
+          g_assert (**str == '{');
+          g_variant_builder_init (&b, G_VARIANT_TYPE_DICT_ENTRY);
+        }
+
+      (*str)++; /* '(' */
+      while (**str != ')' && **str != '}')
+        g_variant_builder_add_value (&b, g_variant_valist_new (str, app));
+      (*str)++; /* ')' */
+
+      return g_variant_builder_end (&b);
+    }
+}
+
+static void
+g_variant_valist_get (const gchar **str,
+                      GVariant     *value,
+                      gboolean      free,
+                      va_list      *app)
+{
+  if (g_variant_format_string_is_leaf (*str))
+    g_variant_valist_get_leaf (str, value, free, app);
+
+  else if (**str == 'm')
+    {
+      (*str)++;
+
+      if (value != NULL)
+        value = g_variant_get_maybe (value);
+
+      if (!g_variant_format_string_is_nnp (*str))
+        {
+          gboolean *ptr = va_arg (*app, gboolean *);
+
+          if (ptr != NULL)
+            *ptr = value != NULL;
+        }
+
+      g_variant_valist_get (str, value, free, app);
+
+      if (value != NULL)
+        g_variant_unref (value);
+    }
+
+  else /* tuple, dictionary entry */
+    {
+      gint index = 0;
+
+      g_assert (**str == '(' || **str == '{');
+
+      (*str)++;
+      while (**str != ')' && **str != '}')
+        {
+          if (value != NULL)
+            {
+              GVariant *child = g_variant_get_child_value (value, index++);
+              g_variant_valist_get (str, child, free, app);
+              g_variant_unref (child);
+            }
+          else
+            g_variant_valist_get (str, NULL, free, app);
+        }
+      (*str)++;
+    }
+}
+
+/* User-facing API {{{2 */
+/**
+ * g_variant_new: (skip)
+ * @format_string: a #GVariant format string
+ * @...: arguments, as per @format_string
+ *
+ * Creates a new #GVariant instance.
+ *
+ * Think of this function as an analogue to g_strdup_printf().
+ *
+ * The type of the created instance and the arguments that are expected
+ * by this function are determined by @format_string. See the section on
+ * [GVariant format strings][gvariant-format-strings]. Please note that
+ * the syntax of the format string is very likely to be extended in the
+ * future.
+ *
+ * The first character of the format string must not be '*' '?' '@' or
+ * 'r'; in essence, a new #GVariant must always be constructed by this
+ * function (and not merely passed through it unmodified).
+ *
+ * Note that the arguments must be of the correct width for their types
+ * specified in @format_string. This can be achieved by casting them. See
+ * the [GVariant varargs documentation][gvariant-varargs].
+ *
+ * |[<!-- language="C" -->
+ * MyFlags some_flags = FLAG_ONE | FLAG_TWO;
+ * const gchar *some_strings[] = { "a", "b", "c", NULL };
+ * GVariant *new_variant;
+ *
+ * new_variant = g_variant_new ("(t^as)",
+ *                              // This cast is required.
+ *                              (guint64) some_flags,
+ *                              some_strings);
+ * ]|
+ *
+ * Returns: a new floating #GVariant instance
+ *
+ * Since: 2.24
+ **/
+GVariant *
+g_variant_new (const gchar *format_string,
+               ...)
+{
+  GVariant *value;
+  va_list ap;
+
+  g_return_val_if_fail (valid_format_string (format_string, TRUE, NULL) &&
+                        format_string[0] != '?' && format_string[0] != '@' &&
+                        format_string[0] != '*' && format_string[0] != 'r',
+                        NULL);
+
+  va_start (ap, format_string);
+  value = g_variant_new_va (format_string, NULL, &ap);
+  va_end (ap);
+
+  return value;
+}
+
+/**
+ * g_variant_new_va: (skip)
+ * @format_string: a string that is prefixed with a format string
+ * @endptr: (nullable) (default NULL): location to store the end pointer,
+ *          or %NULL
+ * @app: a pointer to a #va_list
+ *
+ * This function is intended to be used by libraries based on
+ * #GVariant that want to provide g_variant_new()-like functionality
+ * to their users.
+ *
+ * The API is more general than g_variant_new() to allow a wider range
+ * of possible uses.
+ *
+ * @format_string must still point to a valid format string, but it only
+ * needs to be nul-terminated if @endptr is %NULL.  If @endptr is
+ * non-%NULL then it is updated to point to the first character past the
+ * end of the format string.
+ *
+ * @app is a pointer to a #va_list.  The arguments, according to
+ * @format_string, are collected from this #va_list and the list is left
+ * pointing to the argument following the last.
+ *
+ * Note that the arguments in @app must be of the correct width for their
+ * types specified in @format_string when collected into the #va_list.
+ * See the [GVariant varargs documentation][gvariant-varargs].
+ *
+ * These two generalisations allow mixing of multiple calls to
+ * g_variant_new_va() and g_variant_get_va() within a single actual
+ * varargs call by the user.
+ *
+ * The return value will be floating if it was a newly created GVariant
+ * instance (for example, if the format string was "(ii)").  In the case
+ * that the format_string was '*', '?', 'r', or a format starting with
+ * '@' then the collected #GVariant pointer will be returned unmodified,
+ * without adding any additional references.
+ *
+ * In order to behave correctly in all cases it is necessary for the
+ * calling function to g_variant_ref_sink() the return result before
+ * returning control to the user that originally provided the pointer.
+ * At this point, the caller will have their own full reference to the
+ * result.  This can also be done by adding the result to a container,
+ * or by passing it to another g_variant_new() call.
+ *
+ * Returns: a new, usually floating, #GVariant
+ *
+ * Since: 2.24
+ **/
+GVariant *
+g_variant_new_va (const gchar  *format_string,
+                  const gchar **endptr,
+                  va_list      *app)
+{
+  GVariant *value;
+
+  g_return_val_if_fail (valid_format_string (format_string, !endptr, NULL),
+                        NULL);
+  g_return_val_if_fail (app != NULL, NULL);
+
+  value = g_variant_valist_new (&format_string, app);
+
+  if (endptr != NULL)
+    *endptr = format_string;
+
+  return value;
+}
+
+/**
+ * g_variant_get: (skip)
+ * @value: a #GVariant instance
+ * @format_string: a #GVariant format string
+ * @...: arguments, as per @format_string
+ *
+ * Deconstructs a #GVariant instance.
+ *
+ * Think of this function as an analogue to scanf().
+ *
+ * The arguments that are expected by this function are entirely
+ * determined by @format_string.  @format_string also restricts the
+ * permissible types of @value.  It is an error to give a value with
+ * an incompatible type.  See the section on
+ * [GVariant format strings][gvariant-format-strings].
+ * Please note that the syntax of the format string is very likely to be
+ * extended in the future.
+ *
+ * @format_string determines the C types that are used for unpacking
+ * the values and also determines if the values are copied or borrowed,
+ * see the section on
+ * [GVariant format strings][gvariant-format-strings-pointers].
+ *
+ * Since: 2.24
+ **/
+void
+g_variant_get (GVariant    *value,
+               const gchar *format_string,
+               ...)
+{
+  va_list ap;
+
+  g_return_if_fail (value != NULL);
+  g_return_if_fail (valid_format_string (format_string, TRUE, value));
+
+  /* if any direct-pointer-access formats are in use, flatten first */
+  if (strchr (format_string, '&'))
+    g_variant_get_data (value);
+
+  va_start (ap, format_string);
+  g_variant_get_va (value, format_string, NULL, &ap);
+  va_end (ap);
+}
+
+/**
+ * g_variant_get_va: (skip)
+ * @value: a #GVariant
+ * @format_string: a string that is prefixed with a format string
+ * @endptr: (nullable) (default NULL): location to store the end pointer,
+ *          or %NULL
+ * @app: a pointer to a #va_list
+ *
+ * This function is intended to be used by libraries based on #GVariant
+ * that want to provide g_variant_get()-like functionality to their
+ * users.
+ *
+ * The API is more general than g_variant_get() to allow a wider range
+ * of possible uses.
+ *
+ * @format_string must still point to a valid format string, but it only
+ * need to be nul-terminated if @endptr is %NULL.  If @endptr is
+ * non-%NULL then it is updated to point to the first character past the
+ * end of the format string.
+ *
+ * @app is a pointer to a #va_list.  The arguments, according to
+ * @format_string, are collected from this #va_list and the list is left
+ * pointing to the argument following the last.
+ *
+ * These two generalisations allow mixing of multiple calls to
+ * g_variant_new_va() and g_variant_get_va() within a single actual
+ * varargs call by the user.
+ *
+ * @format_string determines the C types that are used for unpacking
+ * the values and also determines if the values are copied or borrowed,
+ * see the section on
+ * [GVariant format strings][gvariant-format-strings-pointers].
+ *
+ * Since: 2.24
+ **/
+void
+g_variant_get_va (GVariant     *value,
+                  const gchar  *format_string,
+                  const gchar **endptr,
+                  va_list      *app)
+{
+  g_return_if_fail (valid_format_string (format_string, !endptr, value));
+  g_return_if_fail (value != NULL);
+  g_return_if_fail (app != NULL);
+
+  /* if any direct-pointer-access formats are in use, flatten first */
+  if (strchr (format_string, '&'))
+    g_variant_get_data (value);
+
+  g_variant_valist_get (&format_string, value, FALSE, app);
+
+  if (endptr != NULL)
+    *endptr = format_string;
+}
+
+/* Varargs-enabled Utility Functions {{{1 */
+
+/**
+ * g_variant_builder_add: (skip)
+ * @builder: a #GVariantBuilder
+ * @format_string: a #GVariant varargs format string
+ * @...: arguments, as per @format_string
+ *
+ * Adds to a #GVariantBuilder.
+ *
+ * This call is a convenience wrapper that is exactly equivalent to
+ * calling g_variant_new() followed by g_variant_builder_add_value().
+ *
+ * Note that the arguments must be of the correct width for their types
+ * specified in @format_string. This can be achieved by casting them. See
+ * the [GVariant varargs documentation][gvariant-varargs].
+ *
+ * This function might be used as follows:
+ *
+ * |[<!-- language="C" --> 
+ * GVariant *
+ * make_pointless_dictionary (void)
+ * {
+ *   GVariantBuilder builder;
+ *   int i;
+ *
+ *   g_variant_builder_init (&builder, G_VARIANT_TYPE_ARRAY);
+ *   for (i = 0; i < 16; i++)
+ *     {
+ *       gchar buf[3];
+ *
+ *       sprintf (buf, "%d", i);
+ *       g_variant_builder_add (&builder, "{is}", i, buf);
+ *     }
+ *
+ *   return g_variant_builder_end (&builder);
+ * }
+ * ]|
+ *
+ * Since: 2.24
+ */
+void
+g_variant_builder_add (GVariantBuilder *builder,
+                       const gchar     *format_string,
+                       ...)
+{
+  GVariant *variant;
+  va_list ap;
+
+  va_start (ap, format_string);
+  variant = g_variant_new_va (format_string, NULL, &ap);
+  va_end (ap);
+
+  g_variant_builder_add_value (builder, variant);
+}
+
+/**
+ * g_variant_get_child: (skip)
+ * @value: a container #GVariant
+ * @index_: the index of the child to deconstruct
+ * @format_string: a #GVariant format string
+ * @...: arguments, as per @format_string
+ *
+ * Reads a child item out of a container #GVariant instance and
+ * deconstructs it according to @format_string.  This call is
+ * essentially a combination of g_variant_get_child_value() and
+ * g_variant_get().
+ *
+ * @format_string determines the C types that are used for unpacking
+ * the values and also determines if the values are copied or borrowed,
+ * see the section on
+ * [GVariant format strings][gvariant-format-strings-pointers].
+ *
+ * Since: 2.24
+ **/
+void
+g_variant_get_child (GVariant    *value,
+                     gsize        index_,
+                     const gchar *format_string,
+                     ...)
+{
+  GVariant *child;
+  va_list ap;
+
+  /* if any direct-pointer-access formats are in use, flatten first */
+  if (strchr (format_string, '&'))
+    g_variant_get_data (value);
+
+  child = g_variant_get_child_value (value, index_);
+  g_return_if_fail (valid_format_string (format_string, TRUE, child));
+
+  va_start (ap, format_string);
+  g_variant_get_va (child, format_string, NULL, &ap);
+  va_end (ap);
+
+  g_variant_unref (child);
+}
+
+/**
+ * g_variant_iter_next: (skip)
+ * @iter: a #GVariantIter
+ * @format_string: a GVariant format string
+ * @...: the arguments to unpack the value into
+ *
+ * Gets the next item in the container and unpacks it into the variable
+ * argument list according to @format_string, returning %TRUE.
+ *
+ * If no more items remain then %FALSE is returned.
+ *
+ * All of the pointers given on the variable arguments list of this
+ * function are assumed to point at uninitialised memory.  It is the
+ * responsibility of the caller to free all of the values returned by
+ * the unpacking process.
+ *
+ * Here is an example for memory management with g_variant_iter_next():
+ * |[<!-- language="C" --> 
+ *   // Iterates a dictionary of type 'a{sv}'
+ *   void
+ *   iterate_dictionary (GVariant *dictionary)
+ *   {
+ *     GVariantIter iter;
+ *     GVariant *value;
+ *     gchar *key;
+ *
+ *     g_variant_iter_init (&iter, dictionary);
+ *     while (g_variant_iter_next (&iter, "{sv}", &key, &value))
+ *       {
+ *         g_print ("Item '%s' has type '%s'\n", key,
+ *                  g_variant_get_type_string (value));
+ *
+ *         // must free data for ourselves
+ *         g_variant_unref (value);
+ *         g_free (key);
+ *       }
+ *   }
+ * ]|
+ *
+ * For a solution that is likely to be more convenient to C programmers
+ * when dealing with loops, see g_variant_iter_loop().
+ *
+ * @format_string determines the C types that are used for unpacking
+ * the values and also determines if the values are copied or borrowed.
+ *
+ * See the section on
+ * [GVariant format strings][gvariant-format-strings-pointers].
+ *
+ * Returns: %TRUE if a value was unpacked, or %FALSE if there as no value
+ *
+ * Since: 2.24
+ **/
+gboolean
+g_variant_iter_next (GVariantIter *iter,
+                     const gchar  *format_string,
+                     ...)
+{
+  GVariant *value;
+
+  value = g_variant_iter_next_value (iter);
+
+  g_return_val_if_fail (valid_format_string (format_string, TRUE, value),
+                        FALSE);
+
+  if (value != NULL)
+    {
+      va_list ap;
+
+      va_start (ap, format_string);
+      g_variant_valist_get (&format_string, value, FALSE, &ap);
+      va_end (ap);
+
+      g_variant_unref (value);
+    }
+
+  return value != NULL;
+}
+
+/**
+ * g_variant_iter_loop: (skip)
+ * @iter: a #GVariantIter
+ * @format_string: a GVariant format string
+ * @...: the arguments to unpack the value into
+ *
+ * Gets the next item in the container and unpacks it into the variable
+ * argument list according to @format_string, returning %TRUE.
+ *
+ * If no more items remain then %FALSE is returned.
+ *
+ * On the first call to this function, the pointers appearing on the
+ * variable argument list are assumed to point at uninitialised memory.
+ * On the second and later calls, it is assumed that the same pointers
+ * will be given and that they will point to the memory as set by the
+ * previous call to this function.  This allows the previous values to
+ * be freed, as appropriate.
+ *
+ * This function is intended to be used with a while loop as
+ * demonstrated in the following example.  This function can only be
+ * used when iterating over an array.  It is only valid to call this
+ * function with a string constant for the format string and the same
+ * string constant must be used each time.  Mixing calls to this
+ * function and g_variant_iter_next() or g_variant_iter_next_value() on
+ * the same iterator causes undefined behavior.
+ *
+ * If you break out of a such a while loop using g_variant_iter_loop() then
+ * you must free or unreference all the unpacked values as you would with
+ * g_variant_get(). Failure to do so will cause a memory leak.
+ *
+ * Here is an example for memory management with g_variant_iter_loop():
+ * |[<!-- language="C" --> 
+ *   // Iterates a dictionary of type 'a{sv}'
+ *   void
+ *   iterate_dictionary (GVariant *dictionary)
+ *   {
+ *     GVariantIter iter;
+ *     GVariant *value;
+ *     gchar *key;
+ *
+ *     g_variant_iter_init (&iter, dictionary);
+ *     while (g_variant_iter_loop (&iter, "{sv}", &key, &value))
+ *       {
+ *         g_print ("Item '%s' has type '%s'\n", key,
+ *                  g_variant_get_type_string (value));
+ *
+ *         // no need to free 'key' and 'value' here
+ *         // unless breaking out of this loop
+ *       }
+ *   }
+ * ]|
+ *
+ * For most cases you should use g_variant_iter_next().
+ *
+ * This function is really only useful when unpacking into #GVariant or
+ * #GVariantIter in order to allow you to skip the call to
+ * g_variant_unref() or g_variant_iter_free().
+ *
+ * For example, if you are only looping over simple integer and string
+ * types, g_variant_iter_next() is definitely preferred.  For string
+ * types, use the '&' prefix to avoid allocating any memory at all (and
+ * thereby avoiding the need to free anything as well).
+ *
+ * @format_string determines the C types that are used for unpacking
+ * the values and also determines if the values are copied or borrowed.
+ *
+ * See the section on
+ * [GVariant format strings][gvariant-format-strings-pointers].
+ *
+ * Returns: %TRUE if a value was unpacked, or %FALSE if there was no
+ *          value
+ *
+ * Since: 2.24
+ **/
+gboolean
+g_variant_iter_loop (GVariantIter *iter,
+                     const gchar  *format_string,
+                     ...)
+{
+  gboolean first_time = GVSI(iter)->loop_format == NULL;
+  GVariant *value;
+  va_list ap;
+
+  g_return_val_if_fail (first_time ||
+                        format_string == GVSI(iter)->loop_format,
+                        FALSE);
+
+  if (first_time)
+    {
+      TYPE_CHECK (GVSI(iter)->value, G_VARIANT_TYPE_ARRAY, FALSE);
+      GVSI(iter)->loop_format = format_string;
+
+      if (strchr (format_string, '&'))
+        g_variant_get_data (GVSI(iter)->value);
+    }
+
+  value = g_variant_iter_next_value (iter);
+
+  g_return_val_if_fail (!first_time ||
+                        valid_format_string (format_string, TRUE, value),
+                        FALSE);
+
+  va_start (ap, format_string);
+  g_variant_valist_get (&format_string, value, !first_time, &ap);
+  va_end (ap);
+
+  if (value != NULL)
+    g_variant_unref (value);
+
+  return value != NULL;
+}
+
+/* Serialized data {{{1 */
+static GVariant *
+g_variant_deep_copy (GVariant *value)
+{
+  switch (g_variant_classify (value))
+    {
+    case G_VARIANT_CLASS_MAYBE:
+    case G_VARIANT_CLASS_ARRAY:
+    case G_VARIANT_CLASS_TUPLE:
+    case G_VARIANT_CLASS_DICT_ENTRY:
+    case G_VARIANT_CLASS_VARIANT:
+      {
+        GVariantBuilder builder;
+        GVariantIter iter;
+        GVariant *child;
+
+        g_variant_builder_init (&builder, g_variant_get_type (value));
+        g_variant_iter_init (&iter, value);
+
+        while ((child = g_variant_iter_next_value (&iter)))
+          {
+            g_variant_builder_add_value (&builder, g_variant_deep_copy (child));
+            g_variant_unref (child);
+          }
+
+        return g_variant_builder_end (&builder);
+      }
+
+    case G_VARIANT_CLASS_BOOLEAN:
+      return g_variant_new_boolean (g_variant_get_boolean (value));
+
+    case G_VARIANT_CLASS_BYTE:
+      return g_variant_new_byte (g_variant_get_byte (value));
+
+    case G_VARIANT_CLASS_INT16:
+      return g_variant_new_int16 (g_variant_get_int16 (value));
+
+    case G_VARIANT_CLASS_UINT16:
+      return g_variant_new_uint16 (g_variant_get_uint16 (value));
+
+    case G_VARIANT_CLASS_INT32:
+      return g_variant_new_int32 (g_variant_get_int32 (value));
+
+    case G_VARIANT_CLASS_UINT32:
+      return g_variant_new_uint32 (g_variant_get_uint32 (value));
+
+    case G_VARIANT_CLASS_INT64:
+      return g_variant_new_int64 (g_variant_get_int64 (value));
+
+    case G_VARIANT_CLASS_UINT64:
+      return g_variant_new_uint64 (g_variant_get_uint64 (value));
+
+    case G_VARIANT_CLASS_HANDLE:
+      return g_variant_new_handle (g_variant_get_handle (value));
+
+    case G_VARIANT_CLASS_DOUBLE:
+      return g_variant_new_double (g_variant_get_double (value));
+
+    case G_VARIANT_CLASS_STRING:
+      return g_variant_new_string (g_variant_get_string (value, NULL));
+
+    case G_VARIANT_CLASS_OBJECT_PATH:
+      return g_variant_new_object_path (g_variant_get_string (value, NULL));
+
+    case G_VARIANT_CLASS_SIGNATURE:
+      return g_variant_new_signature (g_variant_get_string (value, NULL));
+    }
+
+  g_assert_not_reached ();
+}
+
+/**
+ * g_variant_get_normal_form:
+ * @value: a #GVariant
+ *
+ * Gets a #GVariant instance that has the same value as @value and is
+ * trusted to be in normal form.
+ *
+ * If @value is already trusted to be in normal form then a new
+ * reference to @value is returned.
+ *
+ * If @value is not already trusted, then it is scanned to check if it
+ * is in normal form.  If it is found to be in normal form then it is
+ * marked as trusted and a new reference to it is returned.
+ *
+ * If @value is found not to be in normal form then a new trusted
+ * #GVariant is created with the same value as @value.
+ *
+ * It makes sense to call this function if you've received #GVariant
+ * data from untrusted sources and you want to ensure your serialized
+ * output is definitely in normal form.
+ *
+ * If @value is already in normal form, a new reference will be returned
+ * (which will be floating if @value is floating). If it is not in normal form,
+ * the newly created #GVariant will be returned with a single non-floating
+ * reference. Typically, g_variant_take_ref() should be called on the return
+ * value from this function to guarantee ownership of a single non-floating
+ * reference to it.
+ *
+ * Returns: (transfer full): a trusted #GVariant
+ *
+ * Since: 2.24
+ **/
+GVariant *
+g_variant_get_normal_form (GVariant *value)
+{
+  GVariant *trusted;
+
+  if (g_variant_is_normal_form (value))
+    return g_variant_ref (value);
+
+  trusted = g_variant_deep_copy (value);
+  g_assert (g_variant_is_trusted (trusted));
+
+  return g_variant_ref_sink (trusted);
+}
+
+/**
+ * g_variant_byteswap:
+ * @value: a #GVariant
+ *
+ * Performs a byteswapping operation on the contents of @value.  The
+ * result is that all multi-byte numeric data contained in @value is
+ * byteswapped.  That includes 16, 32, and 64bit signed and unsigned
+ * integers as well as file handles and double precision floating point
+ * values.
+ *
+ * This function is an identity mapping on any value that does not
+ * contain multi-byte numeric data.  That include strings, booleans,
+ * bytes and containers containing only these things (recursively).
+ *
+ * The returned value is always in normal form and is marked as trusted.
+ *
+ * Returns: (transfer full): the byteswapped form of @value
+ *
+ * Since: 2.24
+ **/
+GVariant *
+g_variant_byteswap (GVariant *value)
+{
+  GVariantTypeInfo *type_info;
+  guint alignment;
+  GVariant *new;
+
+  type_info = g_variant_get_type_info (value);
+
+  g_variant_type_info_query (type_info, &alignment, NULL);
+
+  if (alignment)
+    /* (potentially) contains multi-byte numeric data */
+    {
+      GVariantSerialised serialised;
+      GVariant *trusted;
+      GBytes *bytes;
+
+      trusted = g_variant_get_normal_form (value);
+      serialised.type_info = g_variant_get_type_info (trusted);
+      serialised.size = g_variant_get_size (trusted);
+      serialised.data = g_malloc (serialised.size);
+      serialised.depth = g_variant_get_depth (trusted);
+      g_variant_store (trusted, serialised.data);
+      g_variant_unref (trusted);
+
+      g_variant_serialised_byteswap (serialised);
+
+      bytes = g_bytes_new_take (serialised.data, serialised.size);
+      new = g_variant_new_from_bytes (g_variant_get_type (value), bytes, TRUE);
+      g_bytes_unref (bytes);
+    }
+  else
+    /* contains no multi-byte data */
+    new = value;
+
+  return g_variant_ref_sink (new);
+}
+
+/**
+ * g_variant_new_from_data:
+ * @type: a definite #GVariantType
+ * @data: (array length=size) (element-type guint8): the serialized data
+ * @size: the size of @data
+ * @trusted: %TRUE if @data is definitely in normal form
+ * @notify: (scope async): function to call when @data is no longer needed
+ * @user_data: data for @notify
+ *
+ * Creates a new #GVariant instance from serialized data.
+ *
+ * @type is the type of #GVariant instance that will be constructed.
+ * The interpretation of @data depends on knowing the type.
+ *
+ * @data is not modified by this function and must remain valid with an
+ * unchanging value until such a time as @notify is called with
+ * @user_data.  If the contents of @data change before that time then
+ * the result is undefined.
+ *
+ * If @data is trusted to be serialized data in normal form then
+ * @trusted should be %TRUE.  This applies to serialized data created
+ * within this process or read from a trusted location on the disk (such
+ * as a file installed in /usr/lib alongside your application).  You
+ * should set trusted to %FALSE if @data is read from the network, a
+ * file in the user's home directory, etc.
+ *
+ * If @data was not stored in this machine's native endianness, any multi-byte
+ * numeric values in the returned variant will also be in non-native
+ * endianness. g_variant_byteswap() can be used to recover the original values.
+ *
+ * @notify will be called with @user_data when @data is no longer
+ * needed.  The exact time of this call is unspecified and might even be
+ * before this function returns.
+ *
+ * Note: @data must be backed by memory that is aligned appropriately for the
+ * @type being loaded. Otherwise this function will internally create a copy of
+ * the memory (since GLib 2.60) or (in older versions) fail and exit the
+ * process.
+ *
+ * Returns: (transfer none): a new floating #GVariant of type @type
+ *
+ * Since: 2.24
+ **/
+GVariant *
+g_variant_new_from_data (const GVariantType *type,
+                         gconstpointer       data,
+                         gsize               size,
+                         gboolean            trusted,
+                         GDestroyNotify      notify,
+                         gpointer            user_data)
+{
+  GVariant *value;
+  GBytes *bytes;
+
+  g_return_val_if_fail (g_variant_type_is_definite (type), NULL);
+  g_return_val_if_fail (data != NULL || size == 0, NULL);
+
+  if (notify)
+    bytes = g_bytes_new_with_free_func (data, size, notify, user_data);
+  else
+    bytes = g_bytes_new_static (data, size);
+
+  value = g_variant_new_from_bytes (type, bytes, trusted);
+  g_bytes_unref (bytes);
+
+  return value;
+}
+
+/* Epilogue {{{1 */
+/* vim:set foldmethod=marker: */
diff --git a/glib/tests/gvariant.c b/glib/tests/gvariant.c
index 0110f26..fb00b5d 100644
--- a/glib/tests/gvariant.c
+++ b/glib/tests/gvariant.c
@@ -1,5 +1,7 @@
 /*
  * Copyright © 2010 Codethink Limited
+ * Copyright © 2020 William Manley
+ * Copyright © 2022 Endless OS Foundation, LLC
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -1227,6 +1229,7 @@ random_instance_assert (RandomInstance *instance,
   GRand *rand;
   gsize i;
 
+  g_assert_true (size == 0 || buffer != NULL);
   g_assert_cmpint ((gsize) buffer & ALIGN_BITS & instance->alignment, ==, 0);
   g_assert_cmpint (size, ==, instance->size);
 
@@ -1279,6 +1282,8 @@ random_instance_filler (GVariantSerialised *serialised,
     serialised->size = instance->size;
 
   serialised->depth = 0;
+  serialised->ordered_offsets_up_to = 0;
+  serialised->checked_offsets_up_to = 0;
 
   g_assert_true (serialised->type_info == instance->type_info);
   g_assert_cmpuint (serialised->size, ==, instance->size);
@@ -1438,21 +1443,26 @@ test_maybe (void)
 
     for (flavour = 0; flavour < 8; flavour += alignment)
       {
-        GVariantSerialised serialised;
+        GVariantSerialised serialised = { 0, };
         GVariantSerialised child;
 
         serialised.type_info = type_info;
         serialised.data = flavoured_malloc (needed_size, flavour);
         serialised.size = needed_size;
         serialised.depth = 0;
+        serialised.ordered_offsets_up_to = 0;
+        serialised.checked_offsets_up_to = 0;
 
         g_variant_serialiser_serialise (serialised,
                                         random_instance_filler,
                                         (gpointer *) &instance, 1);
+
         child = g_variant_serialised_get_child (serialised, 0);
         g_assert_true (child.type_info == instance->type_info);
-        random_instance_assert (instance, child.data, child.size);
+        if (child.data != NULL)  /* could be NULL if element is non-normal */
+          random_instance_assert (instance, child.data, child.size);
         g_variant_type_info_unref (child.type_info);
+
         flavoured_free (serialised.data, flavour);
       }
   }
@@ -1562,12 +1572,14 @@ test_array (void)
 
     for (flavour = 0; flavour < 8; flavour += alignment)
       {
-        GVariantSerialised serialised;
+        GVariantSerialised serialised = { 0, };
 
         serialised.type_info = array_info;
         serialised.data = flavoured_malloc (needed_size, flavour);
         serialised.size = needed_size;
         serialised.depth = 0;
+        serialised.ordered_offsets_up_to = 0;
+        serialised.checked_offsets_up_to = 0;
 
         g_variant_serialiser_serialise (serialised, random_instance_filler,
                                         (gpointer *) instances, n_children);
@@ -1583,7 +1595,8 @@ test_array (void)
 
             child = g_variant_serialised_get_child (serialised, i);
             g_assert_true (child.type_info == instances[i]->type_info);
-            random_instance_assert (instances[i], child.data, child.size);
+            if (child.data != NULL)  /* could be NULL if element is non-normal */
+              random_instance_assert (instances[i], child.data, child.size);
             g_variant_type_info_unref (child.type_info);
           }
 
@@ -1726,12 +1739,14 @@ test_tuple (void)
 
     for (flavour = 0; flavour < 8; flavour += alignment)
       {
-        GVariantSerialised serialised;
+        GVariantSerialised serialised = { 0, };
 
         serialised.type_info = type_info;
         serialised.data = flavoured_malloc (needed_size, flavour);
         serialised.size = needed_size;
         serialised.depth = 0;
+        serialised.ordered_offsets_up_to = 0;
+        serialised.checked_offsets_up_to = 0;
 
         g_variant_serialiser_serialise (serialised, random_instance_filler,
                                         (gpointer *) instances, n_children);
@@ -1747,7 +1762,8 @@ test_tuple (void)
 
             child = g_variant_serialised_get_child (serialised, i);
             g_assert_true (child.type_info == instances[i]->type_info);
-            random_instance_assert (instances[i], child.data, child.size);
+            if (child.data != NULL)  /* could be NULL if element is non-normal */
+              random_instance_assert (instances[i], child.data, child.size);
             g_variant_type_info_unref (child.type_info);
           }
 
@@ -1821,13 +1837,15 @@ test_variant (void)
 
     for (flavour = 0; flavour < 8; flavour += alignment)
       {
-        GVariantSerialised serialised;
+        GVariantSerialised serialised = { 0, };
         GVariantSerialised child;
 
         serialised.type_info = type_info;
         serialised.data = flavoured_malloc (needed_size, flavour);
         serialised.size = needed_size;
         serialised.depth = 0;
+        serialised.ordered_offsets_up_to = 0;
+        serialised.checked_offsets_up_to = 0;
 
         g_variant_serialiser_serialise (serialised, random_instance_filler,
                                         (gpointer *) &instance, 1);
@@ -2268,24 +2286,67 @@ serialise_tree (TreeInstance       *tree,
 static void
 test_byteswap (void)
 {
-  GVariantSerialised one, two;
+  GVariantSerialised one = { 0, }, two = { 0, }, three = { 0, };
   TreeInstance *tree;
-
+  GVariant *one_variant = NULL;
+  GVariant *two_variant = NULL;
+  GVariant *two_byteswapped = NULL;
+  GVariant *three_variant = NULL;
+  GVariant *three_byteswapped = NULL;
+  guint8 *three_data_copy = NULL;
+  gsize three_size_copy = 0;
+
+  /* Write a tree out twice, once normally and once byteswapped. */
   tree = tree_instance_new (NULL, 3);
   serialise_tree (tree, &one);
 
+  one_variant = g_variant_new_from_data (G_VARIANT_TYPE (g_variant_type_info_get_type_string (one.type_info)),
+                                         one.data, one.size, FALSE, NULL, NULL);
+
   i_am_writing_byteswapped = TRUE;
   serialise_tree (tree, &two);
+  serialise_tree (tree, &three);
   i_am_writing_byteswapped = FALSE;
 
-  g_variant_serialised_byteswap (two);
-
-  g_assert_cmpmem (one.data, one.size, two.data, two.size);
-  g_assert_cmpuint (one.depth, ==, two.depth);
-
+  /* Swap the first byteswapped one back using the function we want to test. */
+  two_variant = g_variant_new_from_data (G_VARIANT_TYPE (g_variant_type_info_get_type_string (two.type_info)),
+                                         two.data, two.size, FALSE, NULL, NULL);
+  two_byteswapped = g_variant_byteswap (two_variant);
+
+  /* Make the second byteswapped one non-normal (hopefully), and then byteswap
+   * it back using the function we want to test in its non-normal mode.
+   * This might not work because it’s not necessarily possible to make an
+   * arbitrary random variant non-normal. Adding a single zero byte to the end
+   * often makes something non-normal but still readable. */
+  three_size_copy = three.size + 1;
+  three_data_copy = g_malloc (three_size_copy);
+  memcpy (three_data_copy, three.data, three.size);
+  three_data_copy[three.size] = '\0';
+
+  three_variant = g_variant_new_from_data (G_VARIANT_TYPE (g_variant_type_info_get_type_string (three.type_info)),
+                                           three_data_copy, three_size_copy, FALSE, NULL, NULL);
+  three_byteswapped = g_variant_byteswap (three_variant);
+
+  /* Check they’re the same. We can always compare @one_variant and
+   * @two_byteswapped. We can only compare @two_byteswapped and
+   * @three_byteswapped if @two_variant and @three_variant are equal: in that
+   * case, the corruption to @three_variant was enough to make it non-normal but
+   * not enough to change its value. */
+  g_assert_cmpvariant (one_variant, two_byteswapped);
+
+  if (g_variant_equal (two_variant, three_variant))
+    g_assert_cmpvariant (two_byteswapped, three_byteswapped);
+
+  g_variant_unref (three_byteswapped);
+  g_variant_unref (three_variant);
+  g_variant_unref (two_byteswapped);
+  g_variant_unref (two_variant);
+  g_variant_unref (one_variant);
   tree_instance_free (tree);
   g_free (one.data);
   g_free (two.data);
+  g_free (three.data);
+  g_free (three_data_copy);
 }
 
 static void
@@ -2342,7 +2403,7 @@ test_serialiser_children (void)
 static void
 test_fuzz (gdouble *fuzziness)
 {
-  GVariantSerialised serialised;
+  GVariantSerialised serialised = { 0, };
   TreeInstance *tree;
 
   /* make an instance */
@@ -3806,6 +3867,29 @@ test_gv_byteswap (void)
   g_free (string);
 }
 
+static void
+test_gv_byteswap_non_normal_non_aligned (void)
+{
+  const guint8 data[] = { 0x02 };
+  GVariant *v = NULL;
+  GVariant *v_byteswapped = NULL;
+
+  g_test_summary ("Test that calling g_variant_byteswap() on a variant which "
+                  "is in non-normal form and doesn’t need byteswapping returns "
+                  "the same variant in normal form.");
+
+  v = g_variant_new_from_data (G_VARIANT_TYPE_BOOLEAN, data, sizeof (data), FALSE, NULL, NULL);
+  g_assert_false (g_variant_is_normal_form (v));
+
+  v_byteswapped = g_variant_byteswap (v);
+  g_assert_true (g_variant_is_normal_form (v_byteswapped));
+
+  g_assert_cmpvariant (v, v_byteswapped);
+
+  g_variant_unref (v);
+  g_variant_unref (v_byteswapped);
+}
+
 static void
 test_parser (void)
 {
@@ -4999,6 +5083,38 @@ test_recursion_limits_array_in_variant (void)
   g_variant_unref (wrapper_variant);
 }
 
+/* Test that a nested array with invalid values in its offset table (which point
+ * from the inner to the outer array) is normalised successfully without
+ * looping infinitely. */
+static void
+test_normal_checking_array_offsets_overlapped (void)
+{
+  const guint8 data[] = {
+    0x01, 0x00,
+  };
+  gsize size = sizeof (data);
+  GVariant *variant = NULL;
+  GVariant *normal_variant = NULL;
+  GVariant *expected_variant = NULL;
+
+  variant = g_variant_new_from_data (G_VARIANT_TYPE ("aay"), data, size,
+                                     FALSE, NULL, NULL);
+  g_assert_nonnull (variant);
+
+  normal_variant = g_variant_get_normal_form (variant);
+  g_assert_nonnull (normal_variant);
+
+  expected_variant = g_variant_new_parsed ("[@ay [], []]");
+  g_assert_cmpvariant (normal_variant, expected_variant);
+
+  g_assert_cmpmem (g_variant_get_data (normal_variant), g_variant_get_size (normal_variant),
+                   g_variant_get_data (expected_variant), g_variant_get_size (expected_variant));
+
+  g_variant_unref (expected_variant);
+  g_variant_unref (normal_variant);
+  g_variant_unref (variant);
+}
+
 /* Test that an array with invalidly large values in its offset table is
  * normalised successfully without looping infinitely. */
 static void
@@ -5023,6 +5139,127 @@ test_normal_checking_array_offsets (void)
   g_variant_unref (variant);
 }
 
+/* This is a regression test that we can't have non-normal values that take up
+ * significantly more space than the normal equivalent, by specifying the
+ * offset table entries so that array elements overlap.
+ *
+ * See https://gitlab.gnome.org/GNOME/glib/-/issues/2121#note_832242 */
+static void
+test_normal_checking_array_offsets2 (void)
+{
+  const guint8 data[] = {
+    'h', 'i', '\0',
+    0x03, 0x00, 0x03,
+    0x06, 0x00, 0x06,
+    0x09, 0x00, 0x09,
+    0x0c, 0x00, 0x0c,
+    0x0f, 0x00, 0x0f,
+    0x12, 0x00, 0x12,
+    0x15, 0x00, 0x15,
+  };
+  gsize size = sizeof (data);
+  const GVariantType *aaaaaaas = G_VARIANT_TYPE ("aaaaaaas");
+  GVariant *variant = NULL;
+  GVariant *normal_variant = NULL;
+  GVariant *expected = NULL;
+
+  variant = g_variant_new_from_data (aaaaaaas, data, size, FALSE, NULL, NULL);
+  g_assert_nonnull (variant);
+
+  normal_variant = g_variant_get_normal_form (variant);
+  g_assert_nonnull (normal_variant);
+  g_assert_cmpuint (g_variant_get_size (normal_variant), <=, size * 2);
+
+  expected = g_variant_new_parsed (
+      "[[[[[[['hi', '', ''], [], []], [], []], [], []], [], []], [], []], [], []]");
+  g_assert_cmpvariant (expected, variant);
+  g_assert_cmpvariant (expected, normal_variant);
+
+  g_variant_unref (expected);
+  g_variant_unref (normal_variant);
+  g_variant_unref (variant);
+}
+
+/* Test that an otherwise-valid serialised GVariant is considered non-normal if
+ * its offset table entries are too wide.
+ *
+ * See §2.3.6 (Framing Offsets) of the GVariant specification. */
+static void
+test_normal_checking_array_offsets_minimal_sized (void)
+{
+  GVariantBuilder builder;
+  gsize i;
+  GVariant *aay_constructed = NULL;
+  const guint8 *data = NULL;
+  guint8 *data_owned = NULL;
+  GVariant *aay_deserialised = NULL;
+  GVariant *aay_normalised = NULL;
+
+  /* Construct an array of type aay, consisting of 128 elements which are each
+   * an empty array, i.e. `[[] * 128]`. This is chosen because the inner
+   * elements are variable sized (making the outer array variable sized, so it
+   * must have an offset table), but they are also zero-sized when serialised.
+   * So the serialised representation of @aay_constructed consists entirely of
+   * its offset table, which is entirely zeroes.
+   *
+   * The array is chosen to be 128 elements long because that means offset
+   * table entries which are 1 byte long. If the elements in the array were
+   * non-zero-sized (to the extent that the overall array is ≥256 bytes long),
+   * the offset table entries would end up being 2 bytes long. */
+  g_variant_builder_init (&builder, G_VARIANT_TYPE ("aay"));
+
+  for (i = 0; i < 128; i++)
+    g_variant_builder_add_value (&builder, g_variant_new_array (G_VARIANT_TYPE_BYTE, NULL, 0));
+
+  aay_constructed = g_variant_builder_end (&builder);
+
+  /* Verify that the constructed array is in normal form, and its serialised
+   * form is `b'\0' * 128`. */
+  g_assert_true (g_variant_is_normal_form (aay_constructed));
+  g_assert_cmpuint (g_variant_n_children (aay_constructed), ==, 128);
+  g_assert_cmpuint (g_variant_get_size (aay_constructed), ==, 128);
+
+  data = g_variant_get_data (aay_constructed);
+  for (i = 0; i < g_variant_get_size (aay_constructed); i++)
+    g_assert_cmpuint (data[i], ==, 0);
+
+  /* Construct a serialised `aay` GVariant which is `b'\0' * 256`. This has to
+   * be a non-normal form of `[[] * 128]`, with 2-byte-long offset table
+   * entries, because each offset table entry has to be able to reference all of
+   * the byte boundaries in the container. All the entries in the offset table
+   * are zero, so all the elements of the array are zero-sized. */
+  data = data_owned = g_malloc0 (256);
+  aay_deserialised = g_variant_new_from_data (G_VARIANT_TYPE ("aay"),
+                                              data,
+                                              256,
+                                              FALSE,
+                                              g_free,
+                                              g_steal_pointer (&data_owned));
+
+  g_assert_false (g_variant_is_normal_form (aay_deserialised));
+  g_assert_cmpuint (g_variant_n_children (aay_deserialised), ==, 128);
+  g_assert_cmpuint (g_variant_get_size (aay_deserialised), ==, 256);
+
+  data = g_variant_get_data (aay_deserialised);
+  for (i = 0; i < g_variant_get_size (aay_deserialised); i++)
+    g_assert_cmpuint (data[i], ==, 0);
+
+  /* Get its normal form. That should change the serialised size. */
+  aay_normalised = g_variant_get_normal_form (aay_deserialised);
+
+  g_assert_true (g_variant_is_normal_form (aay_normalised));
+  g_assert_cmpuint (g_variant_n_children (aay_normalised), ==, 128);
+  g_assert_cmpuint (g_variant_get_size (aay_normalised), ==, 128);
+
+  data = g_variant_get_data (aay_normalised);
+  for (i = 0; i < g_variant_get_size (aay_normalised); i++)
+    g_assert_cmpuint (data[i], ==, 0);
+
+  g_variant_unref (aay_normalised);
+  g_variant_unref (aay_deserialised);
+  g_variant_unref (aay_constructed);
+}
+
 /* Test that a tuple with invalidly large values in its offset table is
  * normalised successfully without looping infinitely. */
 static void
@@ -5047,6 +5284,268 @@ test_normal_checking_tuple_offsets (void)
   g_variant_unref (variant);
 }
 
+/* This is a regression test that we can't have non-normal values that take up
+ * significantly more space than the normal equivalent, by specifying the
+ * offset table entries so that tuple elements overlap.
+ *
+ * See https://gitlab.gnome.org/GNOME/glib/-/issues/2121#note_838503 and
+ * https://gitlab.gnome.org/GNOME/glib/-/issues/2121#note_838513 */
+static void
+test_normal_checking_tuple_offsets2 (void)
+{
+  const GVariantType *data_type = G_VARIANT_TYPE ("(yyaiyyaiyy)");
+  const guint8 data[] = {
+    0x12, 0x34, 0x56, 0x78, 0x01,
+    /*
+         ^───────────────────┘
+
+    ^^^^^^^^^^                   1st yy
+          ^^^^^^^^^^             2nd yy
+                ^^^^^^^^^^       3rd yy
+                            ^^^^ Framing offsets
+     */
+
+  /* If this variant was encoded normally, it would be something like this:
+   * 0x12, 0x34,  pad,  pad, [array bytes], 0x56, 0x78,  pad,  pad, [array bytes], 0x9A, 0xBC, 0xXX
+   *                                      ^─────────────────────────────────────────────────────┘
+   *
+   * ^^^^^^^^^^                                                                                     1st yy
+   *                                        ^^^^^^^^^^                                              2nd yy
+   *                                                                               ^^^^^^^^^^       3rd yy
+   *                                                                                           ^^^^ Framing offsets
+   */
+  };
+  gsize size = sizeof (data);
+  GVariant *variant = NULL;
+  GVariant *normal_variant = NULL;
+  GVariant *expected = NULL;
+
+  variant = g_variant_new_from_data (data_type, data, size, FALSE, NULL, NULL);
+  g_assert_nonnull (variant);
+
+  normal_variant = g_variant_get_normal_form (variant);
+  g_assert_nonnull (normal_variant);
+  g_assert_cmpuint (g_variant_get_size (normal_variant), <=, size * 3);
+
+  expected = g_variant_new_parsed (
+      "@(yyaiyyaiyy) (0x12, 0x34, [], 0x00, 0x00, [], 0x00, 0x00)");
+  g_assert_cmpvariant (expected, variant);
+  g_assert_cmpvariant (expected, normal_variant);
+
+  g_variant_unref (expected);
+  g_variant_unref (normal_variant);
+  g_variant_unref (variant);
+}
+
+/* This is a regression test that overlapping entries in the offset table are
+ * decoded consistently, even though they’re non-normal.
+ *
+ * See https://gitlab.gnome.org/GNOME/glib/-/issues/2121#note_910935 */
+static void
+test_normal_checking_tuple_offsets3 (void)
+{
+  /* The expected decoding of this non-normal byte stream is complex. See
+   * section 2.7.3 (Handling Non-Normal Serialised Data) of the GVariant
+   * specification.
+   *
+   * The rule “Child Values Overlapping Framing Offsets” from the specification
+   * says that the first `ay` must be decoded as `[0x01]` even though it
+   * overlaps the first byte of the offset table. However, since commit
+   * 7eedcd76f7d5b8c98fa60013e1fe6e960bf19df3, GLib explicitly doesn’t allow
+   * this as it’s exploitable. So the first `ay` must be given a default value.
+   *
+   * The second and third `ay`s must be given default values because of rule
+   * “End Boundary Precedes Start Boundary”.
+   *
+   * The `i` must be given a default value because of rule “Start or End
+   * Boundary of a Child Falls Outside the Container”.
+   */
+  const GVariantType *data_type = G_VARIANT_TYPE ("(ayayiay)");
+  const guint8 data[] = {
+    0x01, 0x00, 0x02,
+    /*
+               ^──┘
+
+    ^^^^^^^^^^                   1st ay, bytes 0-2 (but given a default value anyway, see above)
+                                 2nd ay, bytes 2-0
+                                     i,  bytes 0-4
+                                 3rd ay, bytes 4-1
+          ^^^^^^^^^^ Framing offsets
+     */
+  };
+  gsize size = sizeof (data);
+  GVariant *variant = NULL;
+  GVariant *normal_variant = NULL;
+  GVariant *expected = NULL;
+
+  variant = g_variant_new_from_data (data_type, data, size, FALSE, NULL, NULL);
+  g_assert_nonnull (variant);
+
+  g_assert_false (g_variant_is_normal_form (variant));
+
+  normal_variant = g_variant_get_normal_form (variant);
+  g_assert_nonnull (normal_variant);
+  g_assert_cmpuint (g_variant_get_size (normal_variant), <=, size * 3);
+
+  expected = g_variant_new_parsed ("@(ayayiay) ([], [], 0, [])");
+  g_assert_cmpvariant (expected, variant);
+  g_assert_cmpvariant (expected, normal_variant);
+
+  g_variant_unref (expected);
+  g_variant_unref (normal_variant);
+  g_variant_unref (variant);
+}
+
+/* This is a regression test that overlapping entries in the offset table are
+ * decoded consistently, even though they’re non-normal.
+ *
+ * See https://gitlab.gnome.org/GNOME/glib/-/issues/2121#note_910935 */
+static void
+test_normal_checking_tuple_offsets4 (void)
+{
+  /* The expected decoding of this non-normal byte stream is complex. See
+   * section 2.7.3 (Handling Non-Normal Serialised Data) of the GVariant
+   * specification.
+   *
+   * The rule “Child Values Overlapping Framing Offsets” from the specification
+   * says that the first `ay` must be decoded as `[0x01]` even though it
+   * overlaps the first byte of the offset table. However, since commit
+   * 7eedcd76f7d5b8c98fa60013e1fe6e960bf19df3, GLib explicitly doesn’t allow
+   * this as it’s exploitable. So the first `ay` must be given a default value.
+   *
+   * The second `ay` must be given a default value because of rule “End Boundary
+   * Precedes Start Boundary”.
+   *
+   * The third `ay` must be given a default value because its framing offsets
+   * overlap that of the first `ay`.
+   */
+  const GVariantType *data_type = G_VARIANT_TYPE ("(ayayay)");
+  const guint8 data[] = {
+    0x01, 0x00, 0x02,
+    /*
+               ^──┘
+
+    ^^^^^^^^^^                   1st ay, bytes 0-2 (but given a default value anyway, see above)
+                                 2nd ay, bytes 2-0
+                                 3rd ay, bytes 0-1
+          ^^^^^^^^^^ Framing offsets
+     */
+  };
+  gsize size = sizeof (data);
+  GVariant *variant = NULL;
+  GVariant *normal_variant = NULL;
+  GVariant *expected = NULL;
+
+  variant = g_variant_new_from_data (data_type, data, size, FALSE, NULL, NULL);
+  g_assert_nonnull (variant);
+
+  g_assert_false (g_variant_is_normal_form (variant));
+
+  normal_variant = g_variant_get_normal_form (variant);
+  g_assert_nonnull (normal_variant);
+  g_assert_cmpuint (g_variant_get_size (normal_variant), <=, size * 3);
+
+  expected = g_variant_new_parsed ("@(ayayay) ([], [], [])");
+  g_assert_cmpvariant (expected, variant);
+  g_assert_cmpvariant (expected, normal_variant);
+
+  g_variant_unref (expected);
+  g_variant_unref (normal_variant);
+  g_variant_unref (variant);
+}
+
+/* Test that an otherwise-valid serialised GVariant is considered non-normal if
+ * its offset table entries are too wide.
+ *
+ * See §2.3.6 (Framing Offsets) of the GVariant specification. */
+static void
+test_normal_checking_tuple_offsets_minimal_sized (void)
+{
+  GString *type_string = NULL;
+  GVariantBuilder builder;
+  gsize i;
+  GVariant *ray_constructed = NULL;
+  const guint8 *data = NULL;
+  guint8 *data_owned = NULL;
+  GVariant *ray_deserialised = NULL;
+  GVariant *ray_normalised = NULL;
+
+  /* Construct a tuple of type (ay…ay), consisting of 129 members which are each
+   * an empty array, i.e. `([] * 129)`. This is chosen because the inner
+   * members are variable sized, so the outer tuple must have an offset table,
+   * but they are also zero-sized when serialised. So the serialised
+   * representation of @ray_constructed consists entirely of its offset table,
+   * which is entirely zeroes.
+   *
+   * The tuple is chosen to be 129 members long because that means it has 128
+   * offset table entries which are 1 byte long each. If the members in the
+   * tuple were non-zero-sized (to the extent that the overall tuple is ≥256
+   * bytes long), the offset table entries would end up being 2 bytes long.
+   *
+   * 129 members are used unlike 128 array elements in
+   * test_normal_checking_array_offsets_minimal_sized(), because the last member
+   * in a tuple never needs an offset table entry. */
+  type_string = g_string_new ("");
+  g_string_append_c (type_string, '(');
+  for (i = 0; i < 129; i++)
+    g_string_append (type_string, "ay");
+  g_string_append_c (type_string, ')');
+
+  g_variant_builder_init (&builder, G_VARIANT_TYPE (type_string->str));
+
+  for (i = 0; i < 129; i++)
+    g_variant_builder_add_value (&builder, g_variant_new_array (G_VARIANT_TYPE_BYTE, NULL, 0));
+
+  ray_constructed = g_variant_builder_end (&builder);
+
+  /* Verify that the constructed tuple is in normal form, and its serialised
+   * form is `b'\0' * 128`. */
+  g_assert_true (g_variant_is_normal_form (ray_constructed));
+  g_assert_cmpuint (g_variant_n_children (ray_constructed), ==, 129);
+  g_assert_cmpuint (g_variant_get_size (ray_constructed), ==, 128);
+
+  data = g_variant_get_data (ray_constructed);
+  for (i = 0; i < g_variant_get_size (ray_constructed); i++)
+    g_assert_cmpuint (data[i], ==, 0);
+
+  /* Construct a serialised `(ay…ay)` GVariant which is `b'\0' * 256`. This has
+   * to be a non-normal form of `([] * 129)`, with 2-byte-long offset table
+   * entries, because each offset table entry has to be able to reference all of
+   * the byte boundaries in the container. All the entries in the offset table
+   * are zero, so all the members of the tuple are zero-sized. */
+  data = data_owned = g_malloc0 (256);
+  ray_deserialised = g_variant_new_from_data (G_VARIANT_TYPE (type_string->str),
+                                              data,
+                                              256,
+                                              FALSE,
+                                              g_free,
+                                              g_steal_pointer (&data_owned));
+
+  g_assert_false (g_variant_is_normal_form (ray_deserialised));
+  g_assert_cmpuint (g_variant_n_children (ray_deserialised), ==, 129);
+  g_assert_cmpuint (g_variant_get_size (ray_deserialised), ==, 256);
+
+  data = g_variant_get_data (ray_deserialised);
+  for (i = 0; i < g_variant_get_size (ray_deserialised); i++)
+    g_assert_cmpuint (data[i], ==, 0);
+
+  /* Get its normal form. That should change the serialised size. */
+  ray_normalised = g_variant_get_normal_form (ray_deserialised);
+
+  g_assert_true (g_variant_is_normal_form (ray_normalised));
+  g_assert_cmpuint (g_variant_n_children (ray_normalised), ==, 129);
+  g_assert_cmpuint (g_variant_get_size (ray_normalised), ==, 128);
+
+  data = g_variant_get_data (ray_normalised);
+  for (i = 0; i < g_variant_get_size (ray_normalised); i++)
+    g_assert_cmpuint (data[i], ==, 0);
+
+  g_variant_unref (ray_normalised);
+  g_variant_unref (ray_deserialised);
+  g_variant_unref (ray_constructed);
+  g_string_free (type_string, TRUE);
+}
+
 /* Test that an empty object path is normalised successfully to the base object
  * path, ‘/’. */
 static void
@@ -5158,6 +5657,7 @@ main (int argc, char **argv)
   g_test_add_func ("/gvariant/builder-memory", test_builder_memory);
   g_test_add_func ("/gvariant/hashing", test_hashing);
   g_test_add_func ("/gvariant/byteswap", test_gv_byteswap);
+  g_test_add_func ("/gvariant/byteswap/non-normal-non-aligned", test_gv_byteswap_non_normal_non_aligned);
   g_test_add_func ("/gvariant/parser", test_parses);
   g_test_add_func ("/gvariant/parser/integer-bounds", test_parser_integer_bounds);
   g_test_add_func ("/gvariant/parser/recursion", test_parser_recursion);
@@ -5187,10 +5687,24 @@ main (int argc, char **argv)
 
   g_test_add_func ("/gvariant/normal-checking/tuples",
                    test_normal_checking_tuples);
+  g_test_add_func ("/gvariant/normal-checking/array-offsets/overlapped",
+                   test_normal_checking_array_offsets_overlapped);
   g_test_add_func ("/gvariant/normal-checking/array-offsets",
                    test_normal_checking_array_offsets);
+  g_test_add_func ("/gvariant/normal-checking/array-offsets2",
+                   test_normal_checking_array_offsets2);
+  g_test_add_func ("/gvariant/normal-checking/array-offsets/minimal-sized",
+                   test_normal_checking_array_offsets_minimal_sized);
   g_test_add_func ("/gvariant/normal-checking/tuple-offsets",
                    test_normal_checking_tuple_offsets);
+  g_test_add_func ("/gvariant/normal-checking/tuple-offsets2",
+                   test_normal_checking_tuple_offsets2);
+  g_test_add_func ("/gvariant/normal-checking/tuple-offsets3",
+                   test_normal_checking_tuple_offsets3);
+  g_test_add_func ("/gvariant/normal-checking/tuple-offsets4",
+                   test_normal_checking_tuple_offsets4);
+  g_test_add_func ("/gvariant/normal-checking/tuple-offsets/minimal-sized",
+                   test_normal_checking_tuple_offsets_minimal_sized);
   g_test_add_func ("/gvariant/normal-checking/empty-object-path",
                    test_normal_checking_empty_object_path);
 
diff --git a/glib/tests/gvariant.c.orig b/glib/tests/gvariant.c.orig
new file mode 100644
index 0000000..0110f26
--- /dev/null
+++ b/glib/tests/gvariant.c.orig
@@ -0,0 +1,5206 @@
+/*
+ * Copyright © 2010 Codethink Limited
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * See the included COPYING file for more information.
+ *
+ * Author: Ryan Lortie <desrt@desrt.ca>
+ */
+
+#include "config.h"
+
+#include <glib/gvariant-internal.h>
+#include <string.h>
+#include <stdlib.h>
+#include <glib.h>
+
+#define BASIC "bynqiuxthdsog?"
+#define N_BASIC (G_N_ELEMENTS (BASIC) - 1)
+
+#define INVALIDS "cefjklpwz&@^$"
+#define N_INVALIDS (G_N_ELEMENTS (INVALIDS) - 1)
+
+/* see comment in gvariant-serialiser.c about this madness.
+ *
+ * we use this to get testing of non-strictly-aligned GVariant instances
+ * on machines that can tolerate it.  it is necessary to support this
+ * because some systems have malloc() that returns non-8-aligned
+ * pointers.  it is necessary to have special support in the tests
+ * because on most machines malloc() is 8-aligned.
+ */
+#define ALIGN_BITS (sizeof (struct { char a; union {                       \
+                      guint64 x; void *y; gdouble z; } b; }) - 9)
+
+static gboolean
+randomly (gdouble prob)
+{
+  return g_test_rand_double_range (0, 1) < prob;
+}
+
+/* corecursion */
+static GVariantType *
+append_tuple_type_string (GString *, GString *, gboolean, gint);
+
+/* append a random GVariantType to a GString
+ * append a description of the type to another GString
+ * return what the type is
+ */
+static GVariantType *
+append_type_string (GString  *string,
+                    GString  *description,
+                    gboolean  definite,
+                    gint      depth)
+{
+  if (!depth-- || randomly (0.3))
+    {
+      gchar b = BASIC[g_test_rand_int_range (0, N_BASIC - definite)];
+      g_string_append_c (string, b);
+      g_string_append_c (description, b);
+
+      switch (b)
+        {
+        case 'b':
+          return g_variant_type_copy (G_VARIANT_TYPE_BOOLEAN);
+        case 'y':
+          return g_variant_type_copy (G_VARIANT_TYPE_BYTE);
+        case 'n':
+          return g_variant_type_copy (G_VARIANT_TYPE_INT16);
+        case 'q':
+          return g_variant_type_copy (G_VARIANT_TYPE_UINT16);
+        case 'i':
+          return g_variant_type_copy (G_VARIANT_TYPE_INT32);
+        case 'u':
+          return g_variant_type_copy (G_VARIANT_TYPE_UINT32);
+        case 'x':
+          return g_variant_type_copy (G_VARIANT_TYPE_INT64);
+        case 't':
+          return g_variant_type_copy (G_VARIANT_TYPE_UINT64);
+        case 'h':
+          return g_variant_type_copy (G_VARIANT_TYPE_HANDLE);
+        case 'd':
+          return g_variant_type_copy (G_VARIANT_TYPE_DOUBLE);
+        case 's':
+          return g_variant_type_copy (G_VARIANT_TYPE_STRING);
+        case 'o':
+          return g_variant_type_copy (G_VARIANT_TYPE_OBJECT_PATH);
+        case 'g':
+          return g_variant_type_copy (G_VARIANT_TYPE_SIGNATURE);
+        case '?':
+          return g_variant_type_copy (G_VARIANT_TYPE_BASIC);
+        default:
+          g_assert_not_reached ();
+        }
+    }
+  else
+    {
+      GVariantType *result;
+
+      switch (g_test_rand_int_range (0, definite ? 5 : 7))
+        {
+        case 0:
+          {
+            GVariantType *element;
+
+            g_string_append_c (string, 'a');
+            g_string_append (description, "a of ");
+            element = append_type_string (string, description,
+                                          definite, depth);
+            result = g_variant_type_new_array (element);
+            g_variant_type_free (element);
+          }
+
+          g_assert_true (g_variant_type_is_array (result));
+          break;
+
+        case 1:
+          {
+            GVariantType *element;
+
+            g_string_append_c (string, 'm');
+            g_string_append (description, "m of ");
+            element = append_type_string (string, description,
+                                          definite, depth);
+            result = g_variant_type_new_maybe (element);
+            g_variant_type_free (element);
+          }
+
+          g_assert_true (g_variant_type_is_maybe (result));
+          break;
+
+        case 2:
+          result = append_tuple_type_string (string, description,
+                                             definite, depth);
+
+          g_assert_true (g_variant_type_is_tuple (result));
+          break;
+
+        case 3:
+          {
+            GVariantType *key, *value;
+
+            g_string_append_c (string, '{');
+            g_string_append (description, "e of [");
+            key = append_type_string (string, description, definite, 0);
+            g_string_append (description, ", ");
+            value = append_type_string (string, description, definite, depth);
+            g_string_append_c (description, ']');
+            g_string_append_c (string, '}');
+            result = g_variant_type_new_dict_entry (key, value);
+            g_variant_type_free (key);
+            g_variant_type_free (value);
+          }
+
+          g_assert_true (g_variant_type_is_dict_entry (result));
+          break;
+
+        case 4:
+          g_string_append_c (string, 'v');
+          g_string_append_c (description, 'V');
+          result = g_variant_type_copy (G_VARIANT_TYPE_VARIANT);
+          g_assert_true (g_variant_type_equal (result, G_VARIANT_TYPE_VARIANT));
+          break;
+
+        case 5:
+          g_string_append_c (string, '*');
+          g_string_append_c (description, 'S');
+          result = g_variant_type_copy (G_VARIANT_TYPE_ANY);
+          g_assert_true (g_variant_type_equal (result, G_VARIANT_TYPE_ANY));
+          break;
+
+        case 6:
+          g_string_append_c (string, 'r');
+          g_string_append_c (description, 'R');
+          result = g_variant_type_copy (G_VARIANT_TYPE_TUPLE);
+          g_assert_true (g_variant_type_is_tuple (result));
+          break;
+
+        default:
+          g_assert_not_reached ();
+        }
+
+      return result;
+    }
+}
+
+static GVariantType *
+append_tuple_type_string (GString  *string,
+                          GString  *description,
+                          gboolean  definite,
+                          gint      depth)
+{
+  GVariantType *result, *other_result;
+  GVariantType **types;
+  gsize i, size;
+
+  g_string_append_c (string, '(');
+  g_string_append (description, "t of [");
+
+  size = g_test_rand_int_range (0, 20);
+  types = g_new (GVariantType *, size + 1);
+
+  for (i = 0; i < size; i++)
+    {
+      types[i] = append_type_string (string, description, definite, depth);
+
+      if (i < size - 1)
+        g_string_append (description, ", ");
+    }
+
+  types[i] = NULL;
+
+  g_string_append_c (description, ']');
+  g_string_append_c (string, ')');
+
+  result = g_variant_type_new_tuple ((gpointer) types, size);
+  other_result = g_variant_type_new_tuple ((gpointer) types, -1);
+  g_assert_true (g_variant_type_equal (result, other_result));
+  g_variant_type_free (other_result);
+  for (i = 0; i < size; i++)
+    g_variant_type_free (types[i]);
+  g_free (types);
+
+  return result;
+}
+
+/* given a valid type string, make it invalid */
+static gchar *
+invalid_mutation (const gchar *type_string)
+{
+  gboolean have_parens, have_braces;
+
+  /* it's valid, so '(' implies ')' and same for '{' and '}' */
+  have_parens = strchr (type_string, '(') != NULL;
+  have_braces = strchr (type_string, '{') != NULL;
+
+  if (have_parens && have_braces && randomly (0.3))
+    {
+      /* swap a paren and a brace */
+      gchar *pp, *bp;
+      gint np, nb;
+      gchar p, b;
+      gchar *new;
+
+      new = g_strdup (type_string);
+
+      if (randomly (0.5))
+        p = '(', b = '{';
+      else
+        p = ')', b = '}';
+
+      np = nb = 0;
+      pp = bp = new - 1;
+
+      /* count number of parens/braces */
+      while ((pp = strchr (pp + 1, p))) np++;
+      while ((bp = strchr (bp + 1, b))) nb++;
+
+      /* randomly pick one of each */
+      np = g_test_rand_int_range (0, np) + 1;
+      nb = g_test_rand_int_range (0, nb) + 1;
+
+      /* find it */
+      pp = bp = new - 1;
+      while (np--) pp = strchr (pp + 1, p);
+      while (nb--) bp = strchr (bp + 1, b);
+
+      /* swap */
+      g_assert_true (*bp == b && *pp == p);
+      *bp = p;
+      *pp = b;
+
+      return new;
+    }
+
+  if ((have_parens || have_braces) && randomly (0.3))
+    {
+      /* drop a paren/brace */
+      gchar *new;
+      gchar *pp;
+      gint np;
+      gchar p;
+
+      if (have_parens)
+        if (randomly (0.5)) p = '('; else p = ')';
+      else
+        if (randomly (0.5)) p = '{'; else p = '}';
+
+      new = g_strdup (type_string);
+
+      np = 0;
+      pp = new - 1;
+      while ((pp = strchr (pp + 1, p))) np++;
+      np = g_test_rand_int_range (0, np) + 1;
+      pp = new - 1;
+      while (np--) pp = strchr (pp + 1, p);
+      g_assert_cmpint (*pp, ==, p);
+
+      while (*pp)
+        {
+          *pp = *(pp + 1);
+          pp++;
+        }
+
+      return new;
+    }
+
+  /* else, perform a random mutation at a random point */
+  {
+    gint length, n;
+    gchar *new;
+    gchar p;
+
+    if (randomly (0.3))
+      {
+        /* insert a paren/brace */
+        if (randomly (0.5))
+          if (randomly (0.5)) p = '('; else p = ')';
+        else
+          if (randomly (0.5)) p = '{'; else p = '}';
+      }
+    else if (randomly (0.5))
+      {
+        /* insert junk */
+        p = INVALIDS[g_test_rand_int_range (0, N_INVALIDS)];
+      }
+    else
+      {
+        /* truncate */
+        p = '\0';
+      }
+
+
+    length = strlen (type_string);
+    new = g_malloc (length + 2);
+    n = g_test_rand_int_range (0, length);
+    memcpy (new, type_string, n);
+    new[n] = p;
+    memcpy (new + n + 1, type_string + n, length - n);
+    new[length + 1] = '\0';
+
+    return new;
+  }
+}
+
+/* describe a type using the same language as is generated
+ * while generating the type with append_type_string
+ */
+static gchar *
+describe_type (const GVariantType *type)
+{
+  gchar *result;
+
+  if (g_variant_type_is_container (type))
+    {
+      g_assert_false (g_variant_type_is_basic (type));
+
+      if (g_variant_type_is_array (type))
+        {
+          gchar *subtype = describe_type (g_variant_type_element (type));
+          result = g_strdup_printf ("a of %s", subtype);
+          g_free (subtype);
+        }
+      else if (g_variant_type_is_maybe (type))
+        {
+          gchar *subtype = describe_type (g_variant_type_element (type));
+          result = g_strdup_printf ("m of %s", subtype);
+          g_free (subtype);
+        }
+      else if (g_variant_type_is_tuple (type))
+        {
+          if (!g_variant_type_equal (type, G_VARIANT_TYPE_TUPLE))
+            {
+              const GVariantType *sub;
+              GString *string;
+              gsize i, length;
+
+              string = g_string_new ("t of [");
+
+              length = g_variant_type_n_items (type);
+              sub = g_variant_type_first (type);
+              for (i = 0; i < length; i++)
+                {
+                  gchar *subtype = describe_type (sub);
+                  g_string_append (string, subtype);
+                  g_free (subtype);
+
+                  if ((sub = g_variant_type_next (sub)))
+                    g_string_append (string, ", ");
+                }
+              g_assert_null (sub);
+              g_string_append_c (string, ']');
+
+              result = g_string_free (string, FALSE);
+            }
+          else
+            result = g_strdup ("R");
+        }
+      else if (g_variant_type_is_dict_entry (type))
+        {
+          gchar *key, *value, *key2, *value2;
+
+          key = describe_type (g_variant_type_key (type));
+          value = describe_type (g_variant_type_value (type));
+          key2 = describe_type (g_variant_type_first (type));
+          value2 = describe_type (
+            g_variant_type_next (g_variant_type_first (type)));
+          g_assert_null (g_variant_type_next (g_variant_type_next (
+            g_variant_type_first (type))));
+          g_assert_cmpstr (key, ==, key2);
+          g_assert_cmpstr (value, ==, value2);
+          result = g_strjoin ("", "e of [", key, ", ", value, "]", NULL);
+          g_free (key2);
+          g_free (value2);
+          g_free (key);
+          g_free (value);
+        }
+      else if (g_variant_type_equal (type, G_VARIANT_TYPE_VARIANT))
+        {
+          result = g_strdup ("V");
+        }
+      else
+        g_assert_not_reached ();
+    }
+  else
+    {
+      if (g_variant_type_is_definite (type))
+        {
+          g_assert_true (g_variant_type_is_basic (type));
+
+          if (g_variant_type_equal (type, G_VARIANT_TYPE_BOOLEAN))
+            result = g_strdup ("b");
+          else if (g_variant_type_equal (type, G_VARIANT_TYPE_BYTE))
+            result = g_strdup ("y");
+          else if (g_variant_type_equal (type, G_VARIANT_TYPE_INT16))
+            result = g_strdup ("n");
+          else if (g_variant_type_equal (type, G_VARIANT_TYPE_UINT16))
+            result = g_strdup ("q");
+          else if (g_variant_type_equal (type, G_VARIANT_TYPE_INT32))
+            result = g_strdup ("i");
+          else if (g_variant_type_equal (type, G_VARIANT_TYPE_UINT32))
+            result = g_strdup ("u");
+          else if (g_variant_type_equal (type, G_VARIANT_TYPE_INT64))
+            result = g_strdup ("x");
+          else if (g_variant_type_equal (type, G_VARIANT_TYPE_UINT64))
+            result = g_strdup ("t");
+          else if (g_variant_type_equal (type, G_VARIANT_TYPE_HANDLE))
+            result = g_strdup ("h");
+          else if (g_variant_type_equal (type, G_VARIANT_TYPE_DOUBLE))
+            result = g_strdup ("d");
+          else if (g_variant_type_equal (type, G_VARIANT_TYPE_STRING))
+            result = g_strdup ("s");
+          else if (g_variant_type_equal (type, G_VARIANT_TYPE_OBJECT_PATH))
+            result = g_strdup ("o");
+          else if (g_variant_type_equal (type, G_VARIANT_TYPE_SIGNATURE))
+            result = g_strdup ("g");
+          else
+            g_assert_not_reached ();
+        }
+      else
+        {
+          if (g_variant_type_equal (type, G_VARIANT_TYPE_ANY))
+            {
+              result = g_strdup ("S");
+            }
+          else if (g_variant_type_equal (type, G_VARIANT_TYPE_BASIC))
+            {
+              result = g_strdup ("?");
+            }
+          else
+            g_assert_not_reached ();
+        }
+    }
+
+  return result;
+}
+
+/* given a type string, replace one of the indefinite type characters in
+ * it with a matching type (possibly the same type).
+ */
+static gchar *
+generate_subtype (const gchar *type_string)
+{
+  GVariantType *replacement;
+  GString *result, *junk;
+  gint l;
+  gsize length, n = 0;
+
+  result = g_string_new (NULL);
+  junk = g_string_new (NULL);
+
+  /* count the number of indefinite type characters */
+  for (length = 0; type_string[length]; length++)
+    n += type_string[length] == 'r' ||
+         type_string[length] == '?' ||
+         type_string[length] == '*';
+  /* length now is strlen (type_string) */
+
+  /* pick one at random to replace */
+  n = g_test_rand_int_range (0, n) + 1;
+
+  /* find it */
+  l = -1;
+  while (n--) l += strcspn (type_string + l + 1, "r?*") + 1;
+  g_assert_true (type_string[l] == 'r' ||
+                 type_string[l] == '?' ||
+                 type_string[l] == '*');
+
+  /* store up to that point in a GString */
+  g_string_append_len (result, type_string, l);
+
+  /* then store the replacement in the GString */
+  if (type_string[l] == 'r')
+    replacement = append_tuple_type_string (result, junk, FALSE, 3);
+
+  else if (type_string[l] == '?')
+    replacement = append_type_string (result, junk, FALSE, 0);
+
+  else if (type_string[l] == '*')
+    replacement = append_type_string (result, junk, FALSE, 3);
+
+  else
+    g_assert_not_reached ();
+
+  /* ensure the replacement has the proper type */
+  g_assert_true (g_variant_type_is_subtype_of (replacement,
+                                               (gpointer) &type_string[l]));
+
+  /* store the rest from the original type string */
+  g_string_append (result, type_string + l + 1);
+
+  g_variant_type_free (replacement);
+  g_string_free (junk, TRUE);
+
+  return g_string_free (result, FALSE);
+}
+
+struct typestack
+{
+  const GVariantType *type;
+  struct typestack *parent;
+};
+
+/* given an indefinite type string, replace one of the indefinite
+ * characters in it with a matching type and ensure that the result is a
+ * subtype of the original.  repeat.
+ */
+static void
+subtype_check (const gchar      *type_string,
+               struct typestack *parent_ts)
+{
+  struct typestack ts, *node;
+  gchar *subtype;
+  gint depth = 0;
+
+  subtype = generate_subtype (type_string);
+
+  ts.type = G_VARIANT_TYPE (subtype);
+  ts.parent = parent_ts;
+
+  for (node = &ts; node; node = node->parent)
+    {
+      /* this type should be a subtype of each parent type */
+      g_assert_true (g_variant_type_is_subtype_of (ts.type, node->type));
+
+      /* it should only be a supertype when it is exactly equal */
+      g_assert_true (g_variant_type_is_subtype_of (node->type, ts.type) ==
+                     g_variant_type_equal (ts.type, node->type));
+
+      depth++;
+    }
+
+  if (!g_variant_type_is_definite (ts.type) && depth < 5)
+    {
+      /* the type is still indefinite and we haven't repeated too many
+       * times.  go once more.
+       */
+
+      subtype_check (subtype, &ts);
+    }
+
+  g_free (subtype);
+}
+
+static void
+test_gvarianttype (void)
+{
+  gsize i;
+
+  for (i = 0; i < 2000; i++)
+    {
+      GString *type_string, *description;
+      GVariantType *type, *other_type;
+      const GVariantType *ctype;
+      gchar *invalid;
+      gchar *desc;
+
+      type_string = g_string_new (NULL);
+      description = g_string_new (NULL);
+
+      /* generate a random type, its type string and a description
+       *
+       * exercises type constructor functions and g_variant_type_copy()
+       */
+      type = append_type_string (type_string, description, FALSE, 6);
+
+      /* convert the type string to a type and ensure that it is equal
+       * to the one produced with the type constructor routines
+       */
+      ctype = G_VARIANT_TYPE (type_string->str);
+      g_assert_true (g_variant_type_equal (ctype, type));
+      g_assert_cmpuint (g_variant_type_hash (ctype), ==, g_variant_type_hash (type));
+      g_assert_true (g_variant_type_is_subtype_of (ctype, type));
+      g_assert_true (g_variant_type_is_subtype_of (type, ctype));
+
+      /* check if the type is indefinite */
+      if (!g_variant_type_is_definite (type))
+        {
+          struct typestack ts = { type, NULL };
+
+          /* if it is indefinite, then replace one of the indefinite
+           * characters with a matching type and ensure that the result
+           * is a subtype of the original type.  repeat.
+           */
+          subtype_check (type_string->str, &ts);
+        }
+      else
+        /* ensure that no indefinite characters appear */
+        g_assert_cmpint (strcspn (type_string->str, "r?*"), ==, type_string->len);
+
+
+      /* describe the type.
+       *
+       * exercises the type iterator interface
+       */
+      desc = describe_type (type);
+
+      /* make sure the description matches */
+      g_assert_cmpstr (desc, ==, description->str);
+      g_free (desc);
+
+      /* make an invalid mutation to the type and make sure the type
+       * validation routines catch it */
+      invalid = invalid_mutation (type_string->str);
+      g_assert_true (g_variant_type_string_is_valid (type_string->str));
+      g_assert_false (g_variant_type_string_is_valid (invalid));
+      g_free (invalid);
+
+      /* concatenate another type to the type string and ensure that
+       * the result is recognised as being invalid
+       */
+      other_type = append_type_string (type_string, description, FALSE, 2);
+
+      g_string_free (description, TRUE);
+      g_string_free (type_string, TRUE);
+      g_variant_type_free (other_type);
+      g_variant_type_free (type);
+    }
+}
+
+/* Test that scanning a deeply recursive type string doesn’t exhaust our
+ * stack space (which it would if the type string scanner was recursive). */
+static void
+test_gvarianttype_string_scan_recursion_tuple (void)
+{
+  gchar *type_string = NULL;
+  gsize type_string_len = 1000001;  /* not including nul terminator */
+  gsize i;
+
+  /* Build a long type string of ‘((…u…))’. */
+  type_string = g_new0 (gchar, type_string_len + 1);
+  for (i = 0; i < type_string_len; i++)
+    {
+      if (i < type_string_len / 2)
+        type_string[i] = '(';
+      else if (i == type_string_len / 2)
+        type_string[i] = 'u';
+      else
+        type_string[i] = ')';
+    }
+
+  /* Goes (way) over allowed recursion limit. */
+  g_assert_false (g_variant_type_string_is_valid (type_string));
+
+  g_free (type_string);
+}
+
+/* Same as above, except with an array rather than a tuple. */
+static void
+test_gvarianttype_string_scan_recursion_array (void)
+{
+  gchar *type_string = NULL;
+  gsize type_string_len = 1000001;  /* not including nul terminator */
+  gsize i;
+
+  /* Build a long type string of ‘aaa…aau’. */
+  type_string = g_new0 (gchar, type_string_len + 1);
+  for (i = 0; i < type_string_len; i++)
+    {
+      if (i < type_string_len - 1)
+        type_string[i] = 'a';
+      else
+        type_string[i] = 'u';
+    }
+
+  /* Goes (way) over allowed recursion limit. */
+  g_assert_false (g_variant_type_string_is_valid (type_string));
+
+  g_free (type_string);
+}
+
+#define ALIGNED(x, y)   (((x + (y - 1)) / y) * y)
+
+/* do our own calculation of the fixed_size and alignment of a type
+ * using a simple algorithm to make sure the "fancy" one in the
+ * implementation is correct.
+ */
+static void
+calculate_type_info (const GVariantType *type,
+                     gsize              *fixed_size,
+                     guint              *alignment)
+{
+  if (g_variant_type_is_array (type) ||
+      g_variant_type_is_maybe (type))
+    {
+      calculate_type_info (g_variant_type_element (type), NULL, alignment);
+
+      if (fixed_size)
+        *fixed_size = 0;
+    }
+  else if (g_variant_type_is_tuple (type) ||
+           g_variant_type_is_dict_entry (type))
+    {
+      if (g_variant_type_n_items (type))
+        {
+          const GVariantType *sub;
+          gboolean variable;
+          gsize size;
+          guint al;
+
+          variable = FALSE;
+          size = 0;
+          al = 0;
+
+          sub = g_variant_type_first (type);
+          do
+            {
+              gsize this_fs;
+              guint this_al;
+
+              calculate_type_info (sub, &this_fs, &this_al);
+
+              al = MAX (al, this_al);
+
+              if (!this_fs)
+                {
+                  variable = TRUE;
+                  size = 0;
+                }
+
+              if (!variable)
+                {
+                  size = ALIGNED (size, this_al);
+                  size += this_fs;
+                }
+            }
+          while ((sub = g_variant_type_next (sub)));
+
+          size = ALIGNED (size, al);
+
+          if (alignment)
+            *alignment = al;
+
+          if (fixed_size)
+            *fixed_size = size;
+        }
+      else
+        {
+          if (fixed_size)
+            *fixed_size = 1;
+
+          if (alignment)
+            *alignment = 1;
+        }
+    }
+  else
+    {
+      gint fs, al;
+
+      if (g_variant_type_equal (type, G_VARIANT_TYPE_BOOLEAN) ||
+          g_variant_type_equal (type, G_VARIANT_TYPE_BYTE))
+        {
+          al = fs = 1;
+        }
+
+      else if (g_variant_type_equal (type, G_VARIANT_TYPE_INT16) ||
+               g_variant_type_equal (type, G_VARIANT_TYPE_UINT16))
+        {
+          al = fs = 2;
+        }
+
+      else if (g_variant_type_equal (type, G_VARIANT_TYPE_INT32) ||
+               g_variant_type_equal (type, G_VARIANT_TYPE_UINT32) ||
+               g_variant_type_equal (type, G_VARIANT_TYPE_HANDLE))
+        {
+          al = fs = 4;
+        }
+
+      else if (g_variant_type_equal (type, G_VARIANT_TYPE_INT64) ||
+               g_variant_type_equal (type, G_VARIANT_TYPE_UINT64) ||
+               g_variant_type_equal (type, G_VARIANT_TYPE_DOUBLE))
+        {
+          al = fs = 8;
+        }
+      else if (g_variant_type_equal (type, G_VARIANT_TYPE_STRING) ||
+               g_variant_type_equal (type, G_VARIANT_TYPE_OBJECT_PATH) ||
+               g_variant_type_equal (type, G_VARIANT_TYPE_SIGNATURE))
+        {
+          al = 1;
+          fs = 0;
+        }
+      else if (g_variant_type_equal (type, G_VARIANT_TYPE_VARIANT))
+        {
+          al = 8;
+          fs = 0;
+        }
+      else
+        g_assert_not_reached ();
+
+      if (fixed_size)
+        *fixed_size = fs;
+
+      if (alignment)
+        *alignment = al;
+    }
+}
+
+/* same as the describe_type() function above, but iterates over
+ * typeinfo instead of types.
+ */
+static gchar *
+describe_info (GVariantTypeInfo *info)
+{
+  gchar *result;
+
+  switch (g_variant_type_info_get_type_char (info))
+    {
+    case G_VARIANT_TYPE_INFO_CHAR_MAYBE:
+      {
+        gchar *element;
+
+        element = describe_info (g_variant_type_info_element (info));
+        result = g_strdup_printf ("m of %s", element);
+        g_free (element);
+      }
+      break;
+
+    case G_VARIANT_TYPE_INFO_CHAR_ARRAY:
+      {
+        gchar *element;
+
+        element = describe_info (g_variant_type_info_element (info));
+        result = g_strdup_printf ("a of %s", element);
+        g_free (element);
+      }
+      break;
+
+    case G_VARIANT_TYPE_INFO_CHAR_TUPLE:
+      {
+        const gchar *sep = "";
+        GString *string;
+        gsize i, length;
+
+        string = g_string_new ("t of [");
+        length = g_variant_type_info_n_members (info);
+
+        for (i = 0; i < length; i++)
+          {
+            const GVariantMemberInfo *minfo;
+            gchar *subtype;
+
+            g_string_append (string, sep);
+            sep = ", ";
+
+            minfo = g_variant_type_info_member_info (info, i);
+            subtype = describe_info (minfo->type_info);
+            g_string_append (string, subtype);
+            g_free (subtype);
+          }
+
+        g_string_append_c (string, ']');
+
+        result = g_string_free (string, FALSE);
+      }
+      break;
+
+    case G_VARIANT_TYPE_INFO_CHAR_DICT_ENTRY:
+      {
+        const GVariantMemberInfo *keyinfo, *valueinfo;
+        gchar *key, *value;
+
+        g_assert_cmpint (g_variant_type_info_n_members (info), ==, 2);
+        keyinfo = g_variant_type_info_member_info (info, 0);
+        valueinfo = g_variant_type_info_member_info (info, 1);
+        key = describe_info (keyinfo->type_info);
+        value = describe_info (valueinfo->type_info);
+        result = g_strjoin ("", "e of [", key, ", ", value, "]", NULL);
+        g_free (key);
+        g_free (value);
+      }
+      break;
+
+    case G_VARIANT_TYPE_INFO_CHAR_VARIANT:
+      result = g_strdup ("V");
+      break;
+
+    default:
+      result = g_strdup (g_variant_type_info_get_type_string (info));
+      g_assert_cmpint (strlen (result), ==, 1);
+      break;
+    }
+
+  return result;
+}
+
+/* check that the O(1) method of calculating offsets meshes with the
+ * results of simple iteration.
+ */
+static void
+check_offsets (GVariantTypeInfo   *info,
+               const GVariantType *type)
+{
+  gsize flavour, length;
+
+  length = g_variant_type_info_n_members (info);
+  g_assert_cmpuint (length, ==, g_variant_type_n_items (type));
+
+  /* the 'flavour' is the low order bits of the ending point of
+   * variable-size items in the tuple.  this lets us test that the type
+   * info is correct for various starting alignments.
+   */
+  for (flavour = 0; flavour < 8; flavour++)
+    {
+      const GVariantType *subtype;
+      gsize last_offset_index;
+      gsize last_offset;
+      gsize position;
+      gsize i;
+
+      subtype = g_variant_type_first (type);
+      last_offset_index = -1;
+      last_offset = 0;
+      position = 0;
+
+      /* go through the tuple, keeping track of our position */
+      for (i = 0; i < length; i++)
+        {
+          gsize fixed_size;
+          guint alignment;
+
+          calculate_type_info (subtype, &fixed_size, &alignment);
+
+          position = ALIGNED (position, alignment);
+
+          /* compare our current aligned position (ie: the start of this
+           * item) to the start offset that would be calculated if we
+           * used the type info
+           */
+          {
+            const GVariantMemberInfo *member;
+            gsize start;
+
+            member = g_variant_type_info_member_info (info, i);
+            g_assert_cmpint (member->i, ==, last_offset_index);
+
+            /* do the calculation using the typeinfo */
+            start = last_offset;
+            start += member->a;
+            start &= member->b;
+            start |= member->c;
+
+            /* did we reach the same spot? */
+            g_assert_cmpint (start, ==, position);
+          }
+
+          if (fixed_size)
+            {
+              /* fixed size.  add that size. */
+              position += fixed_size;
+            }
+          else
+            {
+              /* variable size.  do the flavouring. */
+              while ((position & 0x7) != flavour)
+                position++;
+
+              /* and store the offset, just like it would be in the
+               * serialized data.
+               */
+              last_offset = position;
+              last_offset_index++;
+            }
+
+          /* next type */
+          subtype = g_variant_type_next (subtype);
+        }
+
+      /* make sure we used up exactly all the types */
+      g_assert_null (subtype);
+    }
+}
+
+static void
+test_gvarianttypeinfo (void)
+{
+  gsize i;
+
+  for (i = 0; i < 2000; i++)
+    {
+      GString *type_string, *description;
+      gsize fixed_size1, fixed_size2;
+      guint alignment1, alignment2;
+      GVariantTypeInfo *info;
+      GVariantType *type;
+      gchar *desc;
+
+      type_string = g_string_new (NULL);
+      description = g_string_new (NULL);
+
+      /* random type */
+      type = append_type_string (type_string, description, TRUE, 6);
+
+      /* create a typeinfo for it */
+      info = g_variant_type_info_get (type);
+
+      /* make sure the typeinfo has the right type string */
+      g_assert_cmpstr (g_variant_type_info_get_type_string (info), ==,
+                       type_string->str);
+
+      /* calculate the alignment and fixed size, compare to the
+       * typeinfo's calculations
+       */
+      calculate_type_info (type, &fixed_size1, &alignment1);
+      g_variant_type_info_query (info, &alignment2, &fixed_size2);
+      g_assert_cmpint (fixed_size1, ==, fixed_size2);
+      g_assert_cmpint (alignment1, ==, alignment2 + 1);
+
+      /* test the iteration functions over typeinfo structures by
+       * "describing" the typeinfo and verifying equality.
+       */
+      desc = describe_info (info);
+      g_assert_cmpstr (desc, ==, description->str);
+
+      /* do extra checks for containers */
+      if (g_variant_type_is_array (type) ||
+          g_variant_type_is_maybe (type))
+        {
+          const GVariantType *element;
+          gsize efs1, efs2;
+          guint ea1, ea2;
+
+          element = g_variant_type_element (type);
+          calculate_type_info (element, &efs1, &ea1);
+          g_variant_type_info_query_element (info, &ea2, &efs2);
+          g_assert_cmpint (efs1, ==, efs2);
+          g_assert_cmpint (ea1, ==, ea2 + 1);
+
+          g_assert_cmpint (ea1, ==, alignment1);
+          g_assert_cmpint (0, ==, fixed_size1);
+        }
+      else if (g_variant_type_is_tuple (type) ||
+               g_variant_type_is_dict_entry (type))
+        {
+          /* make sure the "magic constants" are working */
+          check_offsets (info, type);
+        }
+
+      g_string_free (type_string, TRUE);
+      g_string_free (description, TRUE);
+      g_variant_type_info_unref (info);
+      g_variant_type_free (type);
+      g_free (desc);
+    }
+
+  g_variant_type_info_assert_no_infos ();
+}
+
+#define MAX_FIXED_MULTIPLIER    256
+#define MAX_INSTANCE_SIZE       1024
+#define MAX_ARRAY_CHILDREN      128
+#define MAX_TUPLE_CHILDREN      128
+
+/* this function generates a random type such that all characteristics
+ * that are "interesting" to the serializer are tested.
+ *
+ * this basically means:
+ *   - test different alignments
+ *   - test variable sized items and fixed sized items
+ *   - test different fixed sizes
+ */
+static gchar *
+random_type_string (void)
+{
+  const guchar base_types[] = "ynix";
+  guchar base_type;
+
+  base_type = base_types[g_test_rand_int_range (0, 4)];
+
+  if (g_test_rand_bit ())
+    /* construct a fixed-sized type */
+    {
+      char type_string[MAX_FIXED_MULTIPLIER];
+      guint multiplier;
+      gsize i = 0;
+
+      multiplier = g_test_rand_int_range (1, sizeof type_string - 1);
+
+      type_string[i++] = '(';
+      while (multiplier--)
+        type_string[i++] = base_type;
+      type_string[i++] = ')';
+
+      return g_strndup (type_string, i);
+    }
+  else
+    /* construct a variable-sized type */
+    {
+      char type_string[2] = { 'a', base_type };
+
+      return g_strndup (type_string, 2);
+    }
+}
+
+typedef struct
+{
+  GVariantTypeInfo *type_info;
+  guint alignment;
+  gsize size;
+  gboolean is_fixed_sized;
+
+  guint32 seed;
+
+#define INSTANCE_MAGIC    1287582829
+  guint magic;
+} RandomInstance;
+
+static RandomInstance *
+random_instance (GVariantTypeInfo *type_info)
+{
+  RandomInstance *instance;
+
+  instance = g_slice_new (RandomInstance);
+
+  if (type_info == NULL)
+    {
+      gchar *str = random_type_string ();
+      instance->type_info = g_variant_type_info_get (G_VARIANT_TYPE (str));
+      g_free (str);
+    }
+  else
+    instance->type_info = g_variant_type_info_ref (type_info);
+
+  instance->seed = g_test_rand_int ();
+
+  g_variant_type_info_query (instance->type_info,
+                             &instance->alignment,
+                             &instance->size);
+
+  instance->is_fixed_sized = instance->size != 0;
+
+  if (!instance->is_fixed_sized)
+    instance->size = g_test_rand_int_range (0, MAX_INSTANCE_SIZE);
+
+  instance->magic = INSTANCE_MAGIC;
+
+  return instance;
+}
+
+static void
+random_instance_free (RandomInstance *instance)
+{
+  g_variant_type_info_unref (instance->type_info);
+  g_slice_free (RandomInstance, instance);
+}
+
+static void
+append_instance_size (RandomInstance *instance,
+                      gsize          *offset)
+{
+  *offset += (-*offset) & instance->alignment;
+  *offset += instance->size;
+}
+
+static void
+random_instance_write (RandomInstance *instance,
+                       guchar         *buffer)
+{
+  GRand *rand;
+  gsize i;
+
+  g_assert_cmpint ((gsize) buffer & ALIGN_BITS & instance->alignment, ==, 0);
+
+  rand = g_rand_new_with_seed (instance->seed);
+  for (i = 0; i < instance->size; i++)
+    buffer[i] = g_rand_int (rand);
+  g_rand_free (rand);
+}
+
+static void
+append_instance_data (RandomInstance  *instance,
+                      guchar         **buffer)
+{
+  while (((gsize) *buffer) & instance->alignment)
+    *(*buffer)++ = '\0';
+
+  random_instance_write (instance, *buffer);
+  *buffer += instance->size;
+}
+
+static gboolean
+random_instance_assert (RandomInstance *instance,
+                        guchar         *buffer,
+                        gsize           size)
+{
+  GRand *rand;
+  gsize i;
+
+  g_assert_cmpint ((gsize) buffer & ALIGN_BITS & instance->alignment, ==, 0);
+  g_assert_cmpint (size, ==, instance->size);
+
+  rand = g_rand_new_with_seed (instance->seed);
+  for (i = 0; i < instance->size; i++)
+    {
+      guchar byte = g_rand_int (rand);
+
+      g_assert_cmpuint (buffer[i], ==, byte);
+    }
+  g_rand_free (rand);
+
+  return i == instance->size;
+}
+
+static gboolean
+random_instance_check (RandomInstance *instance,
+                       guchar         *buffer,
+                       gsize           size)
+{
+  GRand *rand;
+  gsize i;
+
+  g_assert_cmpint ((gsize) buffer & ALIGN_BITS & instance->alignment, ==, 0);
+
+  if (size != instance->size)
+    return FALSE;
+
+  rand = g_rand_new_with_seed (instance->seed);
+  for (i = 0; i < instance->size; i++)
+    if (buffer[i] != (guchar) g_rand_int (rand))
+      break;
+  g_rand_free (rand);
+
+  return i == instance->size;
+}
+
+static void
+random_instance_filler (GVariantSerialised *serialised,
+                        gpointer            data)
+{
+  RandomInstance *instance = data;
+
+  g_assert_cmpuint (instance->magic, ==, INSTANCE_MAGIC);
+
+  if (serialised->type_info == NULL)
+    serialised->type_info = instance->type_info;
+
+  if (serialised->size == 0)
+    serialised->size = instance->size;
+
+  serialised->depth = 0;
+
+  g_assert_true (serialised->type_info == instance->type_info);
+  g_assert_cmpuint (serialised->size, ==, instance->size);
+
+  if (serialised->data)
+    random_instance_write (instance, serialised->data);
+}
+
+static gsize
+calculate_offset_size (gsize body_size,
+                       gsize n_offsets)
+{
+  if (body_size == 0)
+    return 0;
+
+  if (body_size + n_offsets <= G_MAXUINT8)
+    return 1;
+
+  if (body_size + 2 * n_offsets <= G_MAXUINT16)
+    return 2;
+
+  if (body_size + 4 * n_offsets <= G_MAXUINT32)
+    return 4;
+
+  /* the test case won't generate anything bigger */
+  g_assert_not_reached ();
+}
+
+static gpointer
+flavoured_malloc (gsize size, gsize flavour)
+{
+  g_assert_cmpuint (flavour, <, 8);
+
+  if (size == 0)
+    return NULL;
+
+  return ((gchar *) g_malloc (size + flavour)) + flavour;
+}
+
+static void
+flavoured_free (gpointer data,
+                gsize flavour)
+{
+  if (!data)
+    return;
+  g_free (((gchar *) data) - flavour);
+}
+
+static gpointer
+align_malloc (gsize size)
+{
+  gpointer mem;
+
+#ifdef HAVE_POSIX_MEMALIGN
+  if (posix_memalign (&mem, 8, size))
+    g_error ("posix_memalign failed");
+#else
+  /* NOTE: there may be platforms that lack posix_memalign() and also
+   * have malloc() that returns non-8-aligned.  if so, we need to try
+   * harder here.
+   */
+  mem = malloc (size);
+#endif
+
+  return mem;
+}
+
+static void
+align_free (gpointer mem)
+{
+  free (mem);
+}
+
+static void
+append_offset (guchar **offset_ptr,
+               gsize    offset,
+               guint    offset_size)
+{
+  union
+  {
+    guchar bytes[sizeof (gsize)];
+    gsize integer;
+  } tmpvalue;
+
+  tmpvalue.integer = GSIZE_TO_LE (offset);
+  memcpy (*offset_ptr, tmpvalue.bytes, offset_size);
+  *offset_ptr += offset_size;
+}
+
+static void
+prepend_offset (guchar **offset_ptr,
+                gsize    offset,
+                guint    offset_size)
+{
+  union
+  {
+    guchar bytes[sizeof (gsize)];
+    gsize integer;
+  } tmpvalue;
+
+  *offset_ptr -= offset_size;
+  tmpvalue.integer = GSIZE_TO_LE (offset);
+  memcpy (*offset_ptr, tmpvalue.bytes, offset_size);
+}
+
+static void
+test_maybe (void)
+{
+  GVariantTypeInfo *type_info;
+  RandomInstance *instance;
+  gsize needed_size;
+  guchar *data;
+
+  instance = random_instance (NULL);
+
+  {
+    const gchar *element;
+    gchar *tmp;
+
+    element = g_variant_type_info_get_type_string (instance->type_info);
+    tmp = g_strdup_printf ("m%s", element);
+    type_info = g_variant_type_info_get (G_VARIANT_TYPE (tmp));
+    g_free (tmp);
+  }
+
+  needed_size = g_variant_serialiser_needed_size (type_info,
+                                                  random_instance_filler,
+                                                  NULL, 0);
+  g_assert_cmpint (needed_size, ==, 0);
+
+  needed_size = g_variant_serialiser_needed_size (type_info,
+                                                  random_instance_filler,
+                                                  (gpointer *) &instance, 1);
+
+  if (instance->is_fixed_sized)
+    g_assert_cmpint (needed_size, ==, instance->size);
+  else
+    g_assert_cmpint (needed_size, ==, instance->size + 1);
+
+  {
+    guchar *ptr;
+
+    ptr = data = align_malloc (needed_size);
+    append_instance_data (instance, &ptr);
+
+    if (!instance->is_fixed_sized)
+      *ptr++ = '\0';
+
+    g_assert_cmpint (ptr - data, ==, needed_size);
+  }
+
+  {
+    guint alignment;
+    gsize flavour;
+
+    alignment = (instance->alignment & ALIGN_BITS) + 1;
+
+    for (flavour = 0; flavour < 8; flavour += alignment)
+      {
+        GVariantSerialised serialised;
+        GVariantSerialised child;
+
+        serialised.type_info = type_info;
+        serialised.data = flavoured_malloc (needed_size, flavour);
+        serialised.size = needed_size;
+        serialised.depth = 0;
+
+        g_variant_serialiser_serialise (serialised,
+                                        random_instance_filler,
+                                        (gpointer *) &instance, 1);
+        child = g_variant_serialised_get_child (serialised, 0);
+        g_assert_true (child.type_info == instance->type_info);
+        random_instance_assert (instance, child.data, child.size);
+        g_variant_type_info_unref (child.type_info);
+        flavoured_free (serialised.data, flavour);
+      }
+  }
+
+  g_variant_type_info_unref (type_info);
+  random_instance_free (instance);
+  align_free (data);
+}
+
+static void
+test_maybes (void)
+{
+  gsize i;
+
+  for (i = 0; i < 1000; i++)
+    test_maybe ();
+
+  g_variant_type_info_assert_no_infos ();
+}
+
+static void
+test_array (void)
+{
+  GVariantTypeInfo *element_info;
+  GVariantTypeInfo *array_info;
+  RandomInstance **instances;
+  gsize needed_size;
+  gsize offset_size;
+  guint n_children;
+  guchar *data;
+
+  {
+    gchar *element_type, *array_type;
+
+    element_type = random_type_string ();
+    array_type = g_strdup_printf ("a%s", element_type);
+
+    element_info = g_variant_type_info_get (G_VARIANT_TYPE (element_type));
+    array_info = g_variant_type_info_get (G_VARIANT_TYPE (array_type));
+    g_assert_true (g_variant_type_info_element (array_info) == element_info);
+
+    g_free (element_type);
+    g_free (array_type);
+  }
+
+  {
+    gsize i;
+
+    n_children = g_test_rand_int_range (0, MAX_ARRAY_CHILDREN);
+    instances = g_new (RandomInstance *, n_children);
+    for (i = 0; i < n_children; i++)
+      instances[i] = random_instance (element_info);
+  }
+
+  needed_size = g_variant_serialiser_needed_size (array_info,
+                                                  random_instance_filler,
+                                                  (gpointer *) instances,
+                                                  n_children);
+
+  {
+    gsize element_fixed_size;
+    gsize body_size = 0;
+    gsize i;
+
+    for (i = 0; i < n_children; i++)
+      append_instance_size (instances[i], &body_size);
+
+    g_variant_type_info_query (element_info, NULL, &element_fixed_size);
+
+    if (!element_fixed_size)
+      {
+        offset_size = calculate_offset_size (body_size, n_children);
+
+        if (offset_size == 0)
+          offset_size = 1;
+      }
+    else
+      offset_size = 0;
+
+    g_assert_cmpint (needed_size, ==, body_size + n_children * offset_size);
+  }
+
+  {
+    guchar *offset_ptr, *body_ptr;
+    gsize i;
+
+    body_ptr = data = align_malloc (needed_size);
+    offset_ptr = body_ptr + needed_size - offset_size * n_children;
+
+    for (i = 0; i < n_children; i++)
+      {
+        append_instance_data (instances[i], &body_ptr);
+        append_offset (&offset_ptr, body_ptr - data, offset_size);
+      }
+
+    g_assert_true (body_ptr == data + needed_size - offset_size * n_children);
+    g_assert_true (offset_ptr == data + needed_size);
+  }
+
+  {
+    guint alignment;
+    gsize flavour;
+    gsize i;
+
+    g_variant_type_info_query (array_info, &alignment, NULL);
+    alignment = (alignment & ALIGN_BITS) + 1;
+
+    for (flavour = 0; flavour < 8; flavour += alignment)
+      {
+        GVariantSerialised serialised;
+
+        serialised.type_info = array_info;
+        serialised.data = flavoured_malloc (needed_size, flavour);
+        serialised.size = needed_size;
+        serialised.depth = 0;
+
+        g_variant_serialiser_serialise (serialised, random_instance_filler,
+                                        (gpointer *) instances, n_children);
+
+        if (serialised.size)
+          g_assert_cmpint (memcmp (serialised.data, data, serialised.size), ==, 0);
+
+        g_assert_cmpuint (g_variant_serialised_n_children (serialised), ==, n_children);
+
+        for (i = 0; i < n_children; i++)
+          {
+            GVariantSerialised child;
+
+            child = g_variant_serialised_get_child (serialised, i);
+            g_assert_true (child.type_info == instances[i]->type_info);
+            random_instance_assert (instances[i], child.data, child.size);
+            g_variant_type_info_unref (child.type_info);
+          }
+
+        flavoured_free (serialised.data, flavour);
+      }
+  }
+
+  {
+    gsize i;
+
+    for (i = 0; i < n_children; i++)
+      random_instance_free (instances[i]);
+    g_free (instances);
+  }
+
+  g_variant_type_info_unref (element_info);
+  g_variant_type_info_unref (array_info);
+  align_free (data);
+}
+
+static void
+test_arrays (void)
+{
+  gsize i;
+
+  for (i = 0; i < 100; i++)
+    test_array ();
+
+  g_variant_type_info_assert_no_infos ();
+}
+
+static void
+test_tuple (void)
+{
+  GVariantTypeInfo *type_info;
+  RandomInstance **instances;
+  gboolean fixed_size;
+  gsize needed_size;
+  gsize offset_size;
+  guint n_children;
+  guint alignment;
+  guchar *data;
+
+  n_children = g_test_rand_int_range (0, MAX_TUPLE_CHILDREN);
+  instances = g_new (RandomInstance *, n_children);
+
+  {
+    GString *type_string;
+    gsize i;
+
+    fixed_size = TRUE;
+    alignment = 0;
+
+    type_string = g_string_new ("(");
+    for (i = 0; i < n_children; i++)
+      {
+        const gchar *str;
+
+        instances[i] = random_instance (NULL);
+
+        alignment |= instances[i]->alignment;
+        if (!instances[i]->is_fixed_sized)
+          fixed_size = FALSE;
+
+        str = g_variant_type_info_get_type_string (instances[i]->type_info);
+        g_string_append (type_string, str);
+      }
+    g_string_append_c (type_string, ')');
+
+    type_info = g_variant_type_info_get (G_VARIANT_TYPE (type_string->str));
+    g_string_free (type_string, TRUE);
+  }
+
+  needed_size = g_variant_serialiser_needed_size (type_info,
+                                                  random_instance_filler,
+                                                  (gpointer *) instances,
+                                                  n_children);
+  {
+    gsize body_size = 0;
+    gsize offsets = 0;
+    gsize i;
+
+    for (i = 0; i < n_children; i++)
+      {
+        append_instance_size (instances[i], &body_size);
+
+        if (i != n_children - 1 && !instances[i]->is_fixed_sized)
+          offsets++;
+      }
+
+    if (fixed_size)
+      {
+        body_size += (-body_size) & alignment;
+
+        g_assert_true ((body_size == 0) == (n_children == 0));
+        if (n_children == 0)
+          body_size = 1;
+      }
+
+    offset_size = calculate_offset_size (body_size, offsets);
+    g_assert_cmpint (needed_size, ==, body_size + offsets * offset_size);
+  }
+
+  {
+    guchar *body_ptr;
+    guchar *ofs_ptr;
+    gsize i;
+
+    body_ptr = data = align_malloc (needed_size);
+    ofs_ptr = body_ptr + needed_size;
+
+    for (i = 0; i < n_children; i++)
+      {
+        append_instance_data (instances[i], &body_ptr);
+
+        if (i != n_children - 1 && !instances[i]->is_fixed_sized)
+          prepend_offset (&ofs_ptr, body_ptr - data, offset_size);
+      }
+
+    if (fixed_size)
+      {
+        while (((gsize) body_ptr) & alignment)
+          *body_ptr++ = '\0';
+
+        g_assert_true ((body_ptr == data) == (n_children == 0));
+        if (n_children == 0)
+          *body_ptr++ = '\0';
+
+      }
+
+
+    g_assert_true (body_ptr == ofs_ptr);
+  }
+
+  {
+    gsize flavour;
+    gsize i;
+
+    alignment = (alignment & ALIGN_BITS) + 1;
+
+    for (flavour = 0; flavour < 8; flavour += alignment)
+      {
+        GVariantSerialised serialised;
+
+        serialised.type_info = type_info;
+        serialised.data = flavoured_malloc (needed_size, flavour);
+        serialised.size = needed_size;
+        serialised.depth = 0;
+
+        g_variant_serialiser_serialise (serialised, random_instance_filler,
+                                        (gpointer *) instances, n_children);
+
+        if (serialised.size)
+          g_assert_cmpint (memcmp (serialised.data, data, serialised.size), ==, 0);
+
+        g_assert_cmpuint (g_variant_serialised_n_children (serialised), ==, n_children);
+
+        for (i = 0; i < n_children; i++)
+          {
+            GVariantSerialised child;
+
+            child = g_variant_serialised_get_child (serialised, i);
+            g_assert_true (child.type_info == instances[i]->type_info);
+            random_instance_assert (instances[i], child.data, child.size);
+            g_variant_type_info_unref (child.type_info);
+          }
+
+        flavoured_free (serialised.data, flavour);
+      }
+  }
+
+  {
+    gsize i;
+
+    for (i = 0; i < n_children; i++)
+      random_instance_free (instances[i]);
+    g_free (instances);
+  }
+
+  g_variant_type_info_unref (type_info);
+  align_free (data);
+}
+
+static void
+test_tuples (void)
+{
+  gsize i;
+
+  for (i = 0; i < 100; i++)
+    test_tuple ();
+
+  g_variant_type_info_assert_no_infos ();
+}
+
+static void
+test_variant (void)
+{
+  GVariantTypeInfo *type_info;
+  RandomInstance *instance;
+  const gchar *type_string;
+  gsize needed_size;
+  guchar *data;
+  gsize len;
+
+  type_info = g_variant_type_info_get (G_VARIANT_TYPE_VARIANT);
+  instance = random_instance (NULL);
+
+  type_string = g_variant_type_info_get_type_string (instance->type_info);
+  len = strlen (type_string);
+
+  needed_size = g_variant_serialiser_needed_size (type_info,
+                                                  random_instance_filler,
+                                                  (gpointer *) &instance, 1);
+
+  g_assert_cmpint (needed_size, ==, instance->size + 1 + len);
+
+  {
+    guchar *ptr;
+
+    ptr = data = align_malloc (needed_size);
+    append_instance_data (instance, &ptr);
+    *ptr++ = '\0';
+    memcpy (ptr, type_string, len);
+    ptr += len;
+
+    g_assert_true (data + needed_size == ptr);
+  }
+
+  {
+    gsize alignment;
+    gsize flavour;
+
+    /* variants are always 8-aligned */
+    alignment = ALIGN_BITS + 1;
+
+    for (flavour = 0; flavour < 8; flavour += alignment)
+      {
+        GVariantSerialised serialised;
+        GVariantSerialised child;
+
+        serialised.type_info = type_info;
+        serialised.data = flavoured_malloc (needed_size, flavour);
+        serialised.size = needed_size;
+        serialised.depth = 0;
+
+        g_variant_serialiser_serialise (serialised, random_instance_filler,
+                                        (gpointer *) &instance, 1);
+
+        if (serialised.size)
+          g_assert_cmpint (memcmp (serialised.data, data, serialised.size), ==, 0);
+
+        g_assert_cmpuint (g_variant_serialised_n_children (serialised), ==, 1);
+
+        child = g_variant_serialised_get_child (serialised, 0);
+        g_assert_true (child.type_info == instance->type_info);
+        random_instance_check (instance, child.data, child.size);
+
+        g_variant_type_info_unref (child.type_info);
+        flavoured_free (serialised.data, flavour);
+      }
+  }
+
+  g_variant_type_info_unref (type_info);
+  random_instance_free (instance);
+  align_free (data);
+}
+
+static void
+test_variants (void)
+{
+  gsize i;
+
+  for (i = 0; i < 100; i++)
+    test_variant ();
+
+  g_variant_type_info_assert_no_infos ();
+}
+
+static void
+test_strings (void)
+{
+  struct {
+    guint flags;
+    guint size;
+    gconstpointer data;
+  } test_cases[] = {
+#define is_nval           0
+#define is_string         1
+#define is_objpath        is_string | 2
+#define is_sig            is_string | 4
+    { is_sig,       1, "" },
+    { is_nval,      0, NULL },
+    { is_nval,     13, "hello\xffworld!" },
+    { is_string,   13, "hello world!" },
+    { is_nval,     13, "hello world\0" },
+    { is_nval,     13, "hello\0world!" },
+    { is_nval,     12, "hello world!" },
+    { is_nval,     13, "hello world!\xff" },
+
+    { is_objpath,   2, "/" },
+    { is_objpath,   3, "/a" },
+    { is_string,    3, "//" },
+    { is_objpath,  11, "/some/path" },
+    { is_string,   12, "/some/path/" },
+    { is_nval,     11, "/some\0path" },
+    { is_string,   11, "/some\\path" },
+    { is_string,   12, "/some//path" },
+    { is_string,   12, "/some-/path" },
+
+    { is_sig,       2, "i" },
+    { is_sig,       2, "s" },
+    { is_sig,       5, "(si)" },
+    { is_string,    4, "(si" },
+    { is_string,    2, "*" },
+    { is_sig,       3, "ai" },
+    { is_string,    3, "mi" },
+    { is_string,    2, "r" },
+    { is_sig,      15, "(yyy{sv}ssiai)" },
+    { is_string,   16, "(yyy{yv}ssiai))" },
+    { is_string,   15, "(yyy{vv}ssiai)" },
+    { is_string,   15, "(yyy{sv)ssiai}" }
+  };
+  gsize i;
+
+  for (i = 0; i < G_N_ELEMENTS (test_cases); i++)
+    {
+      guint flags;
+
+      flags = g_variant_serialiser_is_string (test_cases[i].data,
+                                              test_cases[i].size)
+        ? 1 : 0;
+
+      flags |= g_variant_serialiser_is_object_path (test_cases[i].data,
+                                                    test_cases[i].size)
+        ? 2 : 0;
+
+      flags |= g_variant_serialiser_is_signature (test_cases[i].data,
+                                                  test_cases[i].size)
+        ? 4 : 0;
+
+      g_assert_cmpuint (flags, ==, test_cases[i].flags);
+    }
+}
+
+typedef struct _TreeInstance TreeInstance;
+struct _TreeInstance
+{
+  GVariantTypeInfo *info;
+
+  TreeInstance **children;
+  gsize n_children;
+
+  union {
+    guint64 integer;
+    gdouble floating;
+    gchar string[200];
+  } data;
+  gsize data_size;
+};
+
+static GVariantType *
+make_random_definite_type (int depth)
+{
+  GString *description;
+  GString *type_string;
+  GVariantType *type;
+
+  description = g_string_new (NULL);
+  type_string = g_string_new (NULL);
+  type = append_type_string (type_string, description, TRUE, depth);
+  g_string_free (description, TRUE);
+  g_string_free (type_string, TRUE);
+
+  return type;
+}
+
+static void
+make_random_string (gchar              *string,
+                    gsize               size,
+                    const GVariantType *type)
+{
+  gsize i;
+
+  /* create strings that are valid signature strings */
+#define good_chars "bynqiuxthdsog"
+
+  for (i = 0; i < size - 1; i++)
+    string[i] = good_chars[g_test_rand_int_range (0, strlen (good_chars))];
+  string[i] = '\0';
+
+  /* in case we need an object path, prefix a '/' */
+  if (*g_variant_type_peek_string (type) == 'o')
+    string[0] = '/';
+
+#undef good_chars
+}
+
+static TreeInstance *
+tree_instance_new (const GVariantType *type,
+                   int                 depth)
+{
+  const GVariantType *child_type = NULL;
+  GVariantType *mytype = NULL;
+  TreeInstance *instance;
+  gboolean is_tuple_type;
+
+  if (type == NULL)
+    type = mytype = make_random_definite_type (depth);
+
+  instance = g_slice_new (TreeInstance);
+  instance->info = g_variant_type_info_get (type);
+  instance->children = NULL;
+  instance->n_children = 0;
+  instance->data_size = 0;
+
+  is_tuple_type = FALSE;
+
+  switch (*g_variant_type_peek_string (type))
+    {
+    case G_VARIANT_TYPE_INFO_CHAR_MAYBE:
+      instance->n_children = g_test_rand_int_range (0, 2);
+      child_type = g_variant_type_element (type);
+      break;
+
+    case G_VARIANT_TYPE_INFO_CHAR_ARRAY:
+      instance->n_children = g_test_rand_int_range (0, MAX_ARRAY_CHILDREN);
+      child_type = g_variant_type_element (type);
+      break;
+
+    case G_VARIANT_TYPE_INFO_CHAR_DICT_ENTRY:
+    case G_VARIANT_TYPE_INFO_CHAR_TUPLE:
+      instance->n_children = g_variant_type_n_items (type);
+      child_type = g_variant_type_first (type);
+      is_tuple_type = TRUE;
+      break;
+
+    case G_VARIANT_TYPE_INFO_CHAR_VARIANT:
+      instance->n_children = 1;
+      child_type = NULL;
+      break;
+
+    case 'b':
+      instance->data.integer = g_test_rand_int_range (0, 2);
+      instance->data_size = 1;
+      break;
+
+    case 'y':
+      instance->data.integer = g_test_rand_int ();
+      instance->data_size = 1;
+      break;
+
+    case 'n': case 'q':
+      instance->data.integer = g_test_rand_int ();
+      instance->data_size = 2;
+      break;
+
+    case 'i': case 'u': case 'h':
+      instance->data.integer = g_test_rand_int ();
+      instance->data_size = 4;
+      break;
+
+    case 'x': case 't':
+      instance->data.integer = g_test_rand_int ();
+      instance->data.integer <<= 32;
+      instance->data.integer |= (guint32) g_test_rand_int ();
+      instance->data_size = 8;
+      break;
+
+    case 'd':
+      instance->data.floating = g_test_rand_double ();
+      instance->data_size = 8;
+      break;
+
+    case 's': case 'o': case 'g':
+      instance->data_size = g_test_rand_int_range (10, 200);
+      make_random_string (instance->data.string, instance->data_size, type);
+      break;
+    }
+
+  if (instance->data_size == 0)
+    /* no data -> it is a container */
+    {
+      gsize i;
+
+      instance->children = g_new (TreeInstance *, instance->n_children);
+
+      for (i = 0; i < instance->n_children; i++)
+        {
+          instance->children[i] = tree_instance_new (child_type, depth - 1);
+
+          if (is_tuple_type)
+            child_type = g_variant_type_next (child_type);
+        }
+
+      g_assert_true (!is_tuple_type || child_type == NULL);
+    }
+
+  g_variant_type_free (mytype);
+
+  return instance;
+}
+
+static void
+tree_instance_free (TreeInstance *instance)
+{
+  gsize i;
+
+  g_variant_type_info_unref (instance->info);
+  for (i = 0; i < instance->n_children; i++)
+    tree_instance_free (instance->children[i]);
+  g_free (instance->children);
+  g_slice_free (TreeInstance, instance);
+}
+
+static gboolean i_am_writing_byteswapped;
+
+static void
+tree_filler (GVariantSerialised *serialised,
+             gpointer            data)
+{
+  TreeInstance *instance = data;
+
+  if (serialised->type_info == NULL)
+    serialised->type_info = instance->info;
+
+  serialised->depth = 0;
+
+  if (instance->data_size == 0)
+    /* is a container */
+    {
+      if (serialised->size == 0)
+        serialised->size =
+          g_variant_serialiser_needed_size (instance->info, tree_filler,
+                                            (gpointer *) instance->children,
+                                            instance->n_children);
+
+      if (serialised->data)
+        g_variant_serialiser_serialise (*serialised, tree_filler,
+                                        (gpointer *) instance->children,
+                                        instance->n_children);
+    }
+  else
+    /* it is a leaf */
+    {
+      if (serialised->size == 0)
+        serialised->size = instance->data_size;
+
+      if (serialised->data)
+        {
+          switch (instance->data_size)
+            {
+            case 1:
+              *serialised->data = instance->data.integer;
+              break;
+
+            case 2:
+              {
+                guint16 value = instance->data.integer;
+
+                if (i_am_writing_byteswapped)
+                  value = GUINT16_SWAP_LE_BE (value);
+
+                *(guint16 *) serialised->data = value;
+              }
+              break;
+
+            case 4:
+              {
+                guint32 value = instance->data.integer;
+
+                if (i_am_writing_byteswapped)
+                  value = GUINT32_SWAP_LE_BE (value);
+
+                *(guint32 *) serialised->data = value;
+              }
+              break;
+
+            case 8:
+              {
+                guint64 value = instance->data.integer;
+
+                if (i_am_writing_byteswapped)
+                  value = GUINT64_SWAP_LE_BE (value);
+
+                *(guint64 *) serialised->data = value;
+              }
+              break;
+
+            default:
+              memcpy (serialised->data,
+                      instance->data.string,
+                      instance->data_size);
+              break;
+            }
+        }
+    }
+}
+
+static gboolean
+check_tree (TreeInstance       *instance,
+            GVariantSerialised  serialised)
+{
+  if (instance->info != serialised.type_info)
+    return FALSE;
+
+  if (instance->data_size == 0)
+    /* is a container */
+    {
+      gsize i;
+
+      if (g_variant_serialised_n_children (serialised) !=
+          instance->n_children)
+        return FALSE;
+
+      for (i = 0; i < instance->n_children; i++)
+        {
+          GVariantSerialised child;
+          gpointer data = NULL;
+          gboolean ok;
+
+          child = g_variant_serialised_get_child (serialised, i);
+          if (child.size && child.data == NULL)
+            child.data = data = g_malloc0 (child.size);
+          ok = check_tree (instance->children[i], child);
+          g_variant_type_info_unref (child.type_info);
+          g_free (data);
+
+          if (!ok)
+            return FALSE;
+        }
+
+      return TRUE;
+    }
+  else
+    /* it is a leaf */
+    {
+      switch (instance->data_size)
+        {
+        case 1:
+          g_assert_cmpuint (serialised.size, ==, 1);
+          return *(guint8 *) serialised.data ==
+                  (guint8) instance->data.integer;
+
+        case 2:
+          g_assert_cmpuint (serialised.size, ==, 2);
+          return *(guint16 *) serialised.data ==
+                  (guint16) instance->data.integer;
+
+        case 4:
+          g_assert_cmpuint (serialised.size, ==, 4);
+          return *(guint32 *) serialised.data ==
+                  (guint32) instance->data.integer;
+
+        case 8:
+          g_assert_cmpuint (serialised.size, ==, 8);
+          return *(guint64 *) serialised.data ==
+                  (guint64) instance->data.integer;
+
+        default:
+          if (serialised.size != instance->data_size)
+            return FALSE;
+
+          return memcmp (serialised.data,
+                         instance->data.string,
+                         instance->data_size) == 0;
+        }
+    }
+}
+
+static void
+serialise_tree (TreeInstance       *tree,
+                GVariantSerialised *serialised)
+{
+  GVariantSerialised empty = {0, };
+
+  *serialised = empty;
+  tree_filler (serialised, tree);
+  serialised->data = g_malloc (serialised->size);
+  tree_filler (serialised, tree);
+}
+
+static void
+test_byteswap (void)
+{
+  GVariantSerialised one, two;
+  TreeInstance *tree;
+
+  tree = tree_instance_new (NULL, 3);
+  serialise_tree (tree, &one);
+
+  i_am_writing_byteswapped = TRUE;
+  serialise_tree (tree, &two);
+  i_am_writing_byteswapped = FALSE;
+
+  g_variant_serialised_byteswap (two);
+
+  g_assert_cmpmem (one.data, one.size, two.data, two.size);
+  g_assert_cmpuint (one.depth, ==, two.depth);
+
+  tree_instance_free (tree);
+  g_free (one.data);
+  g_free (two.data);
+}
+
+static void
+test_byteswaps (void)
+{
+  int i;
+
+  for (i = 0; i < 200; i++)
+    test_byteswap ();
+
+  g_variant_type_info_assert_no_infos ();
+}
+
+static void
+test_serialiser_children (void)
+{
+  GBytes *data1, *data2;
+  GVariant *child1, *child2;
+  GVariantType *mv_type = g_variant_type_new_maybe (G_VARIANT_TYPE_VARIANT);
+  GVariant *variant, *child;
+
+  g_test_bug ("https://gitlab.gnome.org/GNOME/glib/issues/1865");
+  g_test_summary ("Test that getting a child variant before and after "
+                  "serialisation of the parent works");
+
+  /* Construct a variable sized array containing a child which serializes to a
+   * zero-length bytestring. */
+  child = g_variant_new_maybe (G_VARIANT_TYPE_VARIANT, NULL);
+  variant = g_variant_new_array (mv_type, &child, 1);
+
+  /* Get the child before serializing. */
+  child1 = g_variant_get_child_value (variant, 0);
+  data1 = g_variant_get_data_as_bytes (child1);
+
+  /* Serialize the parent variant. */
+  g_variant_get_data (variant);
+
+  /* Get the child again after serializing — this uses a different code path. */
+  child2 = g_variant_get_child_value (variant, 0);
+  data2 = g_variant_get_data_as_bytes (child2);
+
+  /* Check things are equal. */
+  g_assert_cmpvariant (child1, child2);
+  g_assert_true (g_bytes_equal (data1, data2));
+
+  g_variant_unref (child2);
+  g_variant_unref (child1);
+  g_variant_unref (variant);
+  g_bytes_unref (data2);
+  g_bytes_unref (data1);
+  g_variant_type_free (mv_type);
+}
+
+static void
+test_fuzz (gdouble *fuzziness)
+{
+  GVariantSerialised serialised;
+  TreeInstance *tree;
+
+  /* make an instance */
+  tree = tree_instance_new (NULL, 3);
+
+  /* serialize it */
+  serialise_tree (tree, &serialised);
+
+  g_assert_true (g_variant_serialised_is_normal (serialised));
+  g_assert_true (check_tree (tree, serialised));
+
+  if (serialised.size)
+    {
+      gboolean fuzzed = FALSE;
+      gboolean a, b;
+
+      while (!fuzzed)
+        {
+          gsize i;
+
+          for (i = 0; i < serialised.size; i++)
+            if (randomly (*fuzziness))
+              {
+                serialised.data[i] += g_test_rand_int_range (1, 256);
+                fuzzed = TRUE;
+              }
+        }
+
+      /* at least one byte in the serialized data has changed.
+       *
+       * this means that at least one of the following is true:
+       *
+       *    - the serialized data now represents a different value:
+       *        check_tree() will return FALSE
+       *
+       *    - the serialized data is in non-normal form:
+       *        g_variant_serialiser_is_normal() will return FALSE
+       *
+       * we always do both checks to increase exposure of the serializer
+       * to corrupt data.
+       */
+      a = g_variant_serialised_is_normal (serialised);
+      b = check_tree (tree, serialised);
+
+      g_assert_true (!a || !b);
+    }
+
+  tree_instance_free (tree);
+  g_free (serialised.data);
+}
+
+
+static void
+test_fuzzes (gpointer data)
+{
+  gdouble fuzziness;
+  int i;
+
+  fuzziness = GPOINTER_TO_INT (data) / 100.;
+
+  for (i = 0; i < 200; i++)
+    test_fuzz (&fuzziness);
+
+  g_variant_type_info_assert_no_infos ();
+}
+
+static GVariant *
+tree_instance_get_gvariant (TreeInstance *tree)
+{
+  const GVariantType *type;
+  GVariant *result;
+
+  type = (GVariantType *) g_variant_type_info_get_type_string (tree->info);
+
+  switch (g_variant_type_info_get_type_char (tree->info))
+    {
+    case G_VARIANT_TYPE_INFO_CHAR_MAYBE:
+      {
+        const GVariantType *child_type;
+        GVariant *child;
+
+        if (tree->n_children)
+          child = tree_instance_get_gvariant (tree->children[0]);
+        else
+          child = NULL;
+
+        child_type = g_variant_type_element (type);
+
+        if (child != NULL && randomly (0.5))
+          child_type = NULL;
+
+        result = g_variant_new_maybe (child_type, child);
+      }
+      break;
+
+    case G_VARIANT_TYPE_INFO_CHAR_ARRAY:
+      {
+        const GVariantType *child_type;
+        GVariant **children;
+        gsize i;
+
+        children = g_new (GVariant *, tree->n_children);
+        for (i = 0; i < tree->n_children; i++)
+          children[i] = tree_instance_get_gvariant (tree->children[i]);
+
+        child_type = g_variant_type_element (type);
+
+        if (i > 0 && randomly (0.5))
+          child_type = NULL;
+
+        result = g_variant_new_array (child_type, children, tree->n_children);
+        g_free (children);
+      }
+      break;
+
+    case G_VARIANT_TYPE_INFO_CHAR_TUPLE:
+      {
+        GVariant **children;
+        gsize i;
+
+        children = g_new (GVariant *, tree->n_children);
+        for (i = 0; i < tree->n_children; i++)
+          children[i] = tree_instance_get_gvariant (tree->children[i]);
+
+        result = g_variant_new_tuple (children, tree->n_children);
+        g_free (children);
+      }
+      break;
+
+    case G_VARIANT_TYPE_INFO_CHAR_DICT_ENTRY:
+      {
+        GVariant *key, *val;
+
+        g_assert_cmpuint (tree->n_children, ==, 2);
+
+        key = tree_instance_get_gvariant (tree->children[0]);
+        val = tree_instance_get_gvariant (tree->children[1]);
+
+        result = g_variant_new_dict_entry (key, val);
+      }
+      break;
+
+    case G_VARIANT_TYPE_INFO_CHAR_VARIANT:
+      {
+        GVariant *value;
+
+        g_assert_cmpuint (tree->n_children, ==, 1);
+
+        value = tree_instance_get_gvariant (tree->children[0]);
+        result = g_variant_new_variant (value);
+      }
+      break;
+
+    case 'b':
+      result = g_variant_new_boolean (tree->data.integer > 0);
+      break;
+
+    case 'y':
+      result = g_variant_new_byte (tree->data.integer);
+      break;
+
+    case 'n':
+      result = g_variant_new_int16 (tree->data.integer);
+      break;
+
+    case 'q':
+      result = g_variant_new_uint16 (tree->data.integer);
+      break;
+
+    case 'i':
+      result = g_variant_new_int32 (tree->data.integer);
+      break;
+
+    case 'u':
+      result = g_variant_new_uint32 (tree->data.integer);
+      break;
+
+    case 'x':
+      result = g_variant_new_int64 (tree->data.integer);
+      break;
+
+    case 't':
+      result = g_variant_new_uint64 (tree->data.integer);
+      break;
+
+    case 'h':
+      result = g_variant_new_handle (tree->data.integer);
+      break;
+
+    case 'd':
+      result = g_variant_new_double (tree->data.floating);
+      break;
+
+    case 's':
+      result = g_variant_new_string (tree->data.string);
+      break;
+
+    case 'o':
+      result = g_variant_new_object_path (tree->data.string);
+      break;
+
+    case 'g':
+      result = g_variant_new_signature (tree->data.string);
+      break;
+
+    default:
+      g_assert_not_reached ();
+    }
+
+  return result;
+}
+
+static gboolean
+tree_instance_check_gvariant (TreeInstance *tree,
+                              GVariant     *value)
+{
+  const GVariantType *type;
+
+  type = (GVariantType *) g_variant_type_info_get_type_string (tree->info);
+  g_assert_true (g_variant_is_of_type (value, type));
+
+  switch (g_variant_type_info_get_type_char (tree->info))
+    {
+    case G_VARIANT_TYPE_INFO_CHAR_MAYBE:
+      {
+        GVariant *child;
+        gboolean equal;
+
+        child = g_variant_get_maybe (value);
+
+        if (child != NULL && tree->n_children == 1)
+          equal = tree_instance_check_gvariant (tree->children[0], child);
+        else if (child == NULL && tree->n_children == 0)
+          equal = TRUE;
+        else
+          equal = FALSE;
+
+        if (child != NULL)
+          g_variant_unref (child);
+
+        return equal;
+      }
+      break;
+
+    case G_VARIANT_TYPE_INFO_CHAR_ARRAY:
+    case G_VARIANT_TYPE_INFO_CHAR_TUPLE:
+    case G_VARIANT_TYPE_INFO_CHAR_DICT_ENTRY:
+      {
+        gsize i;
+
+        if (g_variant_n_children (value) != tree->n_children)
+          return FALSE;
+
+        for (i = 0; i < tree->n_children; i++)
+          {
+            GVariant *child;
+            gboolean equal;
+
+            child = g_variant_get_child_value (value, i);
+            equal = tree_instance_check_gvariant (tree->children[i], child);
+            g_variant_unref (child);
+
+            if (!equal)
+              return FALSE;
+          }
+
+        return TRUE;
+      }
+      break;
+
+    case G_VARIANT_TYPE_INFO_CHAR_VARIANT:
+      {
+        const gchar *str1, *str2;
+        GVariant *child;
+        gboolean equal;
+
+        child = g_variant_get_variant (value);
+        str1 = g_variant_get_type_string (child);
+        str2 = g_variant_type_info_get_type_string (tree->children[0]->info);
+        /* GVariant only keeps one copy of type strings around */
+        equal = str1 == str2 &&
+                tree_instance_check_gvariant (tree->children[0], child);
+
+        g_variant_unref (child);
+
+        return equal;
+      }
+      break;
+
+    case 'b':
+      return g_variant_get_boolean (value) == (gboolean) tree->data.integer;
+
+    case 'y':
+      return g_variant_get_byte (value) == (guchar) tree->data.integer;
+
+    case 'n':
+      return g_variant_get_int16 (value) == (gint16) tree->data.integer;
+
+    case 'q':
+      return g_variant_get_uint16 (value) == (guint16) tree->data.integer;
+
+    case 'i':
+      return g_variant_get_int32 (value) == (gint32) tree->data.integer;
+
+    case 'u':
+      return g_variant_get_uint32 (value) == (guint32) tree->data.integer;
+
+    case 'x':
+      return g_variant_get_int64 (value) == (gint64) tree->data.integer;
+
+    case 't':
+      return g_variant_get_uint64 (value) == (guint64) tree->data.integer;
+
+    case 'h':
+      return g_variant_get_handle (value) == (gint32) tree->data.integer;
+
+    case 'd':
+      {
+        gdouble floating = g_variant_get_double (value);
+
+        return memcmp (&floating, &tree->data.floating, sizeof floating) == 0;
+      }
+
+    case 's':
+    case 'o':
+    case 'g':
+      return strcmp (g_variant_get_string (value, NULL),
+                     tree->data.string) == 0;
+
+    default:
+      g_assert_not_reached ();
+    }
+}
+
+static void
+tree_instance_build_gvariant (TreeInstance    *tree,
+                              GVariantBuilder *builder,
+                              gboolean         guess_ok)
+{
+  const GVariantType *type;
+
+  type = (GVariantType *) g_variant_type_info_get_type_string (tree->info);
+
+  if (g_variant_type_is_container (type))
+    {
+      gsize i;
+
+      /* force GVariantBuilder to guess the type half the time */
+      if (guess_ok && randomly (0.5))
+        {
+          if (g_variant_type_is_array (type) && tree->n_children)
+            type = G_VARIANT_TYPE_ARRAY;
+
+          if (g_variant_type_is_maybe (type) && tree->n_children)
+            type = G_VARIANT_TYPE_MAYBE;
+
+          if (g_variant_type_is_tuple (type))
+            type = G_VARIANT_TYPE_TUPLE;
+
+          if (g_variant_type_is_dict_entry (type))
+            type = G_VARIANT_TYPE_DICT_ENTRY;
+        }
+      else
+        guess_ok = FALSE;
+
+      g_variant_builder_open (builder, type);
+
+      for (i = 0; i < tree->n_children; i++)
+        tree_instance_build_gvariant (tree->children[i], builder, guess_ok);
+
+      g_variant_builder_close (builder);
+    }
+  else
+    g_variant_builder_add_value (builder, tree_instance_get_gvariant (tree));
+}
+
+
+static gboolean
+tree_instance_check_iter (TreeInstance *tree,
+                          GVariantIter *iter)
+{
+  GVariant *value;
+
+  value = g_variant_iter_next_value (iter);
+
+  if (g_variant_is_container (value))
+    {
+      gsize i;
+
+      iter = g_variant_iter_new (value);
+      g_variant_unref (value);
+
+      if (g_variant_iter_n_children (iter) != tree->n_children)
+        {
+          g_variant_iter_free (iter);
+          return FALSE;
+        }
+
+      for (i = 0; i < tree->n_children; i++)
+        if (!tree_instance_check_iter (tree->children[i], iter))
+          {
+            g_variant_iter_free (iter);
+            return FALSE;
+          }
+
+      g_assert_null (g_variant_iter_next_value (iter));
+      g_variant_iter_free (iter);
+
+      return TRUE;
+    }
+
+  else
+    {
+      gboolean equal;
+
+      equal = tree_instance_check_gvariant (tree, value);
+      g_variant_unref (value);
+
+      return equal;
+    }
+}
+
+static void
+test_container (void)
+{
+  TreeInstance *tree;
+  GVariant *value;
+  gchar *s1, *s2;
+
+  tree = tree_instance_new (NULL, 3);
+  value = g_variant_ref_sink (tree_instance_get_gvariant (tree));
+
+  s1 = g_variant_print (value, TRUE);
+  g_assert_true (tree_instance_check_gvariant (tree, value));
+
+  g_variant_get_data (value);
+
+  s2 = g_variant_print (value, TRUE);
+  g_assert_true (tree_instance_check_gvariant (tree, value));
+
+  g_assert_cmpstr (s1, ==, s2);
+
+  if (g_variant_is_container (value))
+    {
+      GVariantBuilder builder;
+      GVariantIter iter;
+      GVariant *built;
+      GVariant *val;
+      gchar *s3;
+
+      g_variant_builder_init (&builder, G_VARIANT_TYPE_VARIANT);
+      tree_instance_build_gvariant (tree, &builder, TRUE);
+      built = g_variant_builder_end (&builder);
+      g_variant_ref_sink (built);
+      g_variant_get_data (built);
+      val = g_variant_get_variant (built);
+
+      s3 = g_variant_print (val, TRUE);
+      g_assert_cmpstr (s1, ==, s3);
+
+      g_variant_iter_init (&iter, built);
+      g_assert_true (tree_instance_check_iter (tree, &iter));
+      g_assert_null (g_variant_iter_next_value (&iter));
+
+      g_variant_unref (built);
+      g_variant_unref (val);
+      g_free (s3);
+    }
+
+  tree_instance_free (tree);
+  g_variant_unref (value);
+  g_free (s2);
+  g_free (s1);
+}
+
+static void
+test_string (void)
+{
+  /* Test some different methods of creating strings */
+  GVariant *v;
+
+  v = g_variant_new_string ("foo");
+  g_assert_cmpstr (g_variant_get_string (v, NULL), ==, "foo");
+  g_variant_unref (v);
+
+
+  v = g_variant_new_take_string (g_strdup ("foo"));
+  g_assert_cmpstr (g_variant_get_string (v, NULL), ==, "foo");
+  g_variant_unref (v);
+
+  v = g_variant_new_printf ("%s %d", "foo", 123);
+  g_assert_cmpstr (g_variant_get_string (v, NULL), ==, "foo 123");
+  g_variant_unref (v);
+}
+
+static void
+test_utf8 (void)
+{
+  const gchar invalid[] = "hello\xffworld";
+  GVariant *value;
+
+  /* ensure that the test data is not valid utf8... */
+  g_assert_false (g_utf8_validate (invalid, -1, NULL));
+
+  /* load the data untrusted */
+  value = g_variant_new_from_data (G_VARIANT_TYPE_STRING,
+                                   invalid, sizeof invalid,
+                                   FALSE, NULL, NULL);
+
+  /* ensure that the problem is caught and we get valid UTF-8 */
+  g_assert_true (g_utf8_validate (g_variant_get_string (value, NULL), -1, NULL));
+  g_variant_unref (value);
+
+
+  /* now load it trusted */
+  value = g_variant_new_from_data (G_VARIANT_TYPE_STRING,
+                                   invalid, sizeof invalid,
+                                   TRUE, NULL, NULL);
+
+  /* ensure we get the invalid data (ie: make sure that time wasn't
+   * wasted on validating data that was marked as trusted)
+   */
+  g_assert_true (g_variant_get_string (value, NULL) == invalid);
+  g_variant_unref (value);
+}
+
+static void
+test_containers (void)
+{
+  gsize i;
+
+  for (i = 0; i < 100; i++)
+    {
+      test_container ();
+    }
+
+  g_variant_type_info_assert_no_infos ();
+}
+
+static void
+test_format_strings (void)
+{
+  GVariantType *type;
+  const gchar *end;
+
+  g_assert_true (g_variant_format_string_scan ("i", NULL, &end) && *end == '\0');
+  g_assert_true (g_variant_format_string_scan ("@i", NULL, &end) && *end == '\0');
+  g_assert_true (g_variant_format_string_scan ("@ii", NULL, &end) && *end == 'i');
+  g_assert_true (g_variant_format_string_scan ("^a&s", NULL, &end) && *end == '\0');
+  g_assert_true (g_variant_format_string_scan ("(^as)", NULL, &end) &&
+                 *end == '\0');
+  g_assert_false (g_variant_format_string_scan ("(^s)", NULL, &end));
+  g_assert_false (g_variant_format_string_scan ("(^a)", NULL, &end));
+  g_assert_false (g_variant_format_string_scan ("(z)", NULL, &end));
+  g_assert_false (g_variant_format_string_scan ("az", NULL, &end));
+  g_assert_false (g_variant_format_string_scan ("{**}", NULL, &end));
+  g_assert_false (g_variant_format_string_scan ("{@**}", NULL, &end));
+  g_assert_true (g_variant_format_string_scan ("{@y*}", NULL, &end) &&
+                 *end == '\0');
+  g_assert_true (g_variant_format_string_scan ("{yv}", NULL, &end) &&
+                 *end == '\0');
+  g_assert_false (g_variant_format_string_scan ("{&?v}", NULL, &end));
+  g_assert_true (g_variant_format_string_scan ("{@?v}", NULL, &end) &&
+                 *end == '\0');
+  g_assert_false (g_variant_format_string_scan ("{&@sv}", NULL, &end));
+  g_assert_false (g_variant_format_string_scan ("{@&sv}", NULL, &end));
+  g_assert_true (g_variant_format_string_scan ("{&sv}", NULL, &end) &&
+                 *end == '\0');
+  g_assert_false (g_variant_format_string_scan ("{vv}", NULL, &end));
+  g_assert_false (g_variant_format_string_scan ("{y}", NULL, &end));
+  g_assert_false (g_variant_format_string_scan ("{yyy}", NULL, &end));
+  g_assert_false (g_variant_format_string_scan ("{ya}", NULL, &end));
+  g_assert_true (g_variant_format_string_scan ("&s", NULL, &end) && *end == '\0');
+  g_assert_false (g_variant_format_string_scan ("&as", NULL, &end));
+  g_assert_false (g_variant_format_string_scan ("@z", NULL, &end));
+  g_assert_false (g_variant_format_string_scan ("az", NULL, &end));
+  g_assert_false (g_variant_format_string_scan ("a&s", NULL, &end));
+
+  type = g_variant_format_string_scan_type ("mm(@xy^a&s*?@?)", NULL, &end);
+  g_assert_true (type && *end == '\0');
+  g_assert_true (g_variant_type_equal (type, G_VARIANT_TYPE ("mm(xyas*?\?)")));
+  g_variant_type_free (type);
+
+  type = g_variant_format_string_scan_type ("mm(@xy^a&*?@?)", NULL, NULL);
+  g_assert_null (type);
+}
+
+static void
+do_failed_test (const char *test,
+                const gchar *pattern)
+{
+  g_test_trap_subprocess (test, 1000000, 0);
+  g_test_trap_assert_failed ();
+  g_test_trap_assert_stderr (pattern);
+}
+
+static void
+test_invalid_varargs (void)
+{
+  GVariant *value;
+  const gchar *end;
+
+  if (!g_test_undefined ())
+    return;
+
+  g_test_expect_message (G_LOG_DOMAIN, G_LOG_LEVEL_CRITICAL,
+                         "*GVariant format string*");
+  g_test_expect_message (G_LOG_DOMAIN, G_LOG_LEVEL_CRITICAL,
+                         "*valid_format_string*");
+  value = g_variant_new ("z");
+  g_test_assert_expected_messages ();
+  g_assert_null (value);
+
+  g_test_expect_message (G_LOG_DOMAIN, G_LOG_LEVEL_CRITICAL,
+                         "*valid GVariant format string as a prefix*");
+  g_test_expect_message (G_LOG_DOMAIN, G_LOG_LEVEL_CRITICAL,
+                         "*valid_format_string*");
+  value = g_variant_new_va ("z", &end, NULL);
+  g_test_assert_expected_messages ();
+  g_assert_null (value);
+
+  value = g_variant_new ("y", 'a');
+  g_test_expect_message (G_LOG_DOMAIN, G_LOG_LEVEL_CRITICAL,
+                         "*type of 'q' but * has a type of 'y'*");
+  g_test_expect_message (G_LOG_DOMAIN, G_LOG_LEVEL_CRITICAL,
+                         "*valid_format_string*");
+  g_variant_get (value, "q");
+  g_test_assert_expected_messages ();
+  g_variant_unref (value);
+}
+
+static void
+check_and_free (GVariant    *value,
+                const gchar *str)
+{
+  gchar *valstr = g_variant_print (value, FALSE);
+  g_assert_cmpstr (str, ==, valstr);
+  g_variant_unref (value);
+  g_free (valstr);
+}
+
+static void
+test_varargs_empty_array (void)
+{
+  g_variant_new ("(a{s*})", NULL);
+
+  g_assert_not_reached ();
+}
+
+static void
+test_varargs (void)
+{
+  {
+    GVariantBuilder array;
+
+    g_variant_builder_init (&array, G_VARIANT_TYPE_ARRAY);
+    g_variant_builder_add_parsed (&array, "{'size', <(%i, %i)> }", 800, 600);
+    g_variant_builder_add (&array, "{sv}", "title",
+                           g_variant_new_string ("Test case"));
+    g_variant_builder_add_value (&array,
+      g_variant_new_dict_entry (g_variant_new_string ("temperature"),
+                                g_variant_new_variant (
+                                  g_variant_new_double (37.5))));
+    check_and_free (g_variant_new ("(ma{sv}m(a{sv})ma{sv}ii)",
+                                   NULL, FALSE, NULL, &array, 7777, 8888),
+                    "(nothing, nothing, {'size': <(800, 600)>, "
+                                        "'title': <'Test case'>, "
+                                        "'temperature': <37.5>}, "
+                     "7777, 8888)");
+
+    check_and_free (g_variant_new ("(imimimmimmimmi)",
+                                   123,
+                                   FALSE, 321,
+                                   TRUE, 123,
+                                   FALSE, TRUE, 321,
+                                   TRUE, FALSE, 321,
+                                   TRUE, TRUE, 123),
+                    "(123, nothing, 123, nothing, just nothing, 123)");
+
+    check_and_free (g_variant_new ("(ybnixd)",
+                                   'a', 1, 22, 33, (guint64) 44, 5.5),
+                    "(0x61, true, 22, 33, 44, 5.5)");
+
+    check_and_free (g_variant_new ("(@y?*rv)",
+                                   g_variant_new ("y", 'a'),
+                                   g_variant_new ("y", 'b'),
+                                   g_variant_new ("y", 'c'),
+                                   g_variant_new ("(y)", 'd'),
+                                   g_variant_new ("y", 'e')),
+                    "(0x61, 0x62, 0x63, (0x64,), <byte 0x65>)");
+  }
+
+  {
+    GVariantBuilder array;
+    GVariantIter iter;
+    GVariant *value;
+    gchar *number;
+    gboolean just;
+    guint i;
+    gint val;
+
+    g_variant_builder_init (&array, G_VARIANT_TYPE_ARRAY);
+    for (i = 0; i < 100; i++)
+      {
+        number = g_strdup_printf ("%u", i);
+        g_variant_builder_add (&array, "s", number);
+        g_free (number);
+      }
+
+    value = g_variant_builder_end (&array);
+    g_variant_iter_init (&iter, value);
+
+    i = 0;
+    while (g_variant_iter_loop (&iter, "s", &number))
+      {
+        gchar *check = g_strdup_printf ("%u", i++);
+        g_assert_cmpstr (number, ==, check);
+        g_free (check);
+      }
+    g_assert_null (number);
+    g_assert_cmpuint (i, ==, 100);
+
+    g_variant_unref (value);
+
+    g_variant_builder_init (&array, G_VARIANT_TYPE_ARRAY);
+    for (i = 0; i < 100; i++)
+      g_variant_builder_add (&array, "mi", i % 2 == 0, i);
+    value = g_variant_builder_end (&array);
+
+    i = 0;
+    g_variant_iter_init (&iter, value);
+    while (g_variant_iter_loop (&iter, "mi", NULL, &val))
+      g_assert_true (val == (gint) i++ || val == 0);
+    g_assert_cmpuint (i, ==, 100);
+
+    i = 0;
+    g_variant_iter_init (&iter, value);
+    while (g_variant_iter_loop (&iter, "mi", &just, &val))
+      {
+        gint this = i++;
+
+        if (this % 2 == 0)
+          {
+            g_assert_true (just);
+            g_assert_cmpint (val, ==, this);
+          }
+        else
+          {
+            g_assert_false (just);
+            g_assert_cmpint (val, ==, 0);
+          }
+      }
+    g_assert_cmpuint (i, ==, 100);
+
+    g_variant_unref (value);
+  }
+
+  {
+    const gchar *strvector[] = {"/hello", "/world", NULL};
+    const gchar *test_strs[] = {"/foo", "/bar", "/baz" };
+    GVariantBuilder builder;
+    GVariantIter *array;
+    GVariantIter tuple;
+    const gchar **strv;
+    gchar **my_strv;
+    GVariant *value;
+    gchar *str;
+    gsize i;
+
+    g_variant_builder_init (&builder, G_VARIANT_TYPE ("as"));
+    g_variant_builder_add (&builder, "s", test_strs[0]);
+    g_variant_builder_add (&builder, "s", test_strs[1]);
+    g_variant_builder_add (&builder, "s", test_strs[2]);
+    value = g_variant_new ("(as^as^a&s)", &builder, strvector, strvector);
+    g_variant_iter_init (&tuple, value);
+    g_variant_iter_next (&tuple, "as", &array);
+
+    i = 0;
+    while (g_variant_iter_loop (array, "s", &str))
+      g_assert_cmpstr (str, ==, test_strs[i++]);
+    g_assert_cmpuint (i, ==, 3);
+
+    g_variant_iter_free (array);
+
+    /* start over */
+    g_variant_iter_init (&tuple, value);
+    g_variant_iter_next (&tuple, "as", &array);
+
+    i = 0;
+    while (g_variant_iter_loop (array, "&s", &str))
+      g_assert_cmpstr (str, ==, test_strs[i++]);
+    g_assert_cmpuint (i, ==, 3);
+
+    g_variant_iter_free (array);
+
+    g_variant_iter_next (&tuple, "^a&s", &strv);
+    g_variant_iter_next (&tuple, "^as", &my_strv);
+
+    g_assert_cmpstrv (strv, strvector);
+    g_assert_cmpstrv (my_strv, strvector);
+
+    g_variant_unref (value);
+    g_strfreev (my_strv);
+    g_free (strv);
+  }
+
+  {
+    const gchar *strvector[] = {"/hello", "/world", NULL};
+    const gchar *test_strs[] = {"/foo", "/bar", "/baz" };
+    GVariantBuilder builder;
+    GVariantIter *array;
+    GVariantIter tuple;
+    const gchar **strv;
+    gchar **my_strv;
+    GVariant *value;
+    gchar *str;
+    gsize i;
+
+    g_variant_builder_init (&builder, G_VARIANT_TYPE ("aaay"));
+    g_variant_builder_add (&builder, "^aay", strvector);
+    g_variant_builder_add (&builder, "^aay", strvector);
+    g_variant_builder_add (&builder, "^aay", strvector);
+    value = g_variant_new ("aaay", &builder);
+    array = g_variant_iter_new (value);
+    i = 0;
+    while (g_variant_iter_loop (array, "^aay", &my_strv))
+      i++;
+    g_assert_cmpuint (i, ==, 3);
+
+    /* start over */
+    g_variant_iter_init (array, value);
+    i = 0;
+    while (g_variant_iter_loop (array, "^a&ay", &strv))
+      i++;
+    g_assert_cmpuint (i, ==, 3);
+    g_variant_unref (value);
+    g_variant_iter_free (array);
+
+    /* next test */
+    g_variant_builder_init (&builder, G_VARIANT_TYPE ("aay"));
+    g_variant_builder_add (&builder, "^ay", test_strs[0]);
+    g_variant_builder_add (&builder, "^ay", test_strs[1]);
+    g_variant_builder_add (&builder, "^ay", test_strs[2]);
+    value = g_variant_new ("(aay^aay^a&ay)", &builder, strvector, strvector);
+    g_variant_iter_init (&tuple, value);
+    g_variant_iter_next (&tuple, "aay", &array);
+
+    i = 0;
+    while (g_variant_iter_loop (array, "^ay", &str))
+      g_assert_cmpstr (str, ==, test_strs[i++]);
+    g_assert_cmpuint (i, ==, 3);
+
+    g_variant_iter_free (array);
+
+    /* start over */
+    g_variant_iter_init (&tuple, value);
+    g_variant_iter_next (&tuple, "aay", &array);
+
+    i = 0;
+    while (g_variant_iter_loop (array, "^&ay", &str))
+      g_assert_cmpstr (str, ==, test_strs[i++]);
+    g_assert_cmpuint (i, ==, 3);
+
+    g_variant_iter_free (array);
+
+    g_variant_iter_next (&tuple, "^a&ay", &strv);
+    g_variant_iter_next (&tuple, "^aay", &my_strv);
+
+    g_assert_cmpstrv (strv, strvector);
+    g_assert_cmpstrv (my_strv, strvector);
+
+    g_variant_unref (value);
+    g_strfreev (my_strv);
+    g_free (strv);
+  }
+
+  {
+    const gchar *strvector[] = {"/hello", "/world", NULL};
+    const gchar *test_strs[] = {"/foo", "/bar", "/baz" };
+    GVariantBuilder builder;
+    GVariantIter *array;
+    GVariantIter tuple;
+    const gchar **strv;
+    gchar **my_strv;
+    GVariant *value;
+    gchar *str;
+    gsize i;
+
+    g_variant_builder_init (&builder, G_VARIANT_TYPE_OBJECT_PATH_ARRAY);
+    g_variant_builder_add (&builder, "o", test_strs[0]);
+    g_variant_builder_add (&builder, "o", test_strs[1]);
+    g_variant_builder_add (&builder, "o", test_strs[2]);
+    value = g_variant_new ("(ao^ao^a&o)", &builder, strvector, strvector);
+    g_variant_iter_init (&tuple, value);
+    g_variant_iter_next (&tuple, "ao", &array);
+
+    i = 0;
+    while (g_variant_iter_loop (array, "o", &str))
+      g_assert_cmpstr (str, ==, test_strs[i++]);
+    g_assert_cmpuint (i, ==, 3);
+
+    g_variant_iter_free (array);
+
+    /* start over */
+    g_variant_iter_init (&tuple, value);
+    g_variant_iter_next (&tuple, "ao", &array);
+
+    i = 0;
+    while (g_variant_iter_loop (array, "&o", &str))
+      g_assert_cmpstr (str, ==, test_strs[i++]);
+    g_assert_cmpuint (i, ==, 3);
+
+    g_variant_iter_free (array);
+
+    g_variant_iter_next (&tuple, "^a&o", &strv);
+    g_variant_iter_next (&tuple, "^ao", &my_strv);
+
+    g_assert_cmpstrv (strv, strvector);
+    g_assert_cmpstrv (my_strv, strvector);
+
+    g_variant_unref (value);
+    g_strfreev (my_strv);
+    g_free (strv);
+  }
+
+  {
+    const gchar *strvector[] = { "i", "ii", "iii", "iv", "v", "vi", NULL };
+    GVariantBuilder builder;
+    GVariantIter iter;
+    GVariantIter *i2;
+    GVariantIter *i3;
+    GVariant *value;
+    GVariant *sub;
+    gchar **strv;
+    gsize i;
+
+    g_variant_builder_init (&builder, G_VARIANT_TYPE ("aas"));
+    g_variant_builder_open (&builder, G_VARIANT_TYPE ("as"));
+    for (i = 0; i < 6; i++)
+      if (i & 1)
+        g_variant_builder_add (&builder, "s", strvector[i]);
+      else
+        g_variant_builder_add (&builder, "&s", strvector[i]);
+    g_variant_builder_close (&builder);
+    g_variant_builder_add (&builder, "^as", strvector);
+    g_variant_builder_add (&builder, "^as", strvector);
+    value = g_variant_new ("aas", &builder);
+
+    g_variant_iter_init (&iter, value);
+    while (g_variant_iter_loop (&iter, "^as", &strv))
+      for (i = 0; i < 6; i++)
+        g_assert_cmpstr (strv[i], ==, strvector[i]);
+
+    g_variant_iter_init (&iter, value);
+    while (g_variant_iter_loop (&iter, "^a&s", &strv))
+      for (i = 0; i < 6; i++)
+        g_assert_cmpstr (strv[i], ==, strvector[i]);
+
+    g_variant_iter_init (&iter, value);
+    while (g_variant_iter_loop (&iter, "as", &i2))
+      {
+        gchar *str;
+
+        i = 0;
+        while (g_variant_iter_loop (i2, "s", &str))
+          g_assert_cmpstr (str, ==, strvector[i++]);
+        g_assert_cmpuint (i, ==, 6);
+      }
+
+    g_variant_iter_init (&iter, value);
+    i3 = g_variant_iter_copy (&iter);
+    while (g_variant_iter_loop (&iter, "@as", &sub))
+      {
+        gchar *str = g_variant_print (sub, TRUE);
+        g_assert_cmpstr (str, ==,
+                         "['i', 'ii', 'iii', 'iv', 'v', 'vi']");
+        g_free (str);
+      }
+
+    g_test_expect_message (G_LOG_DOMAIN, G_LOG_LEVEL_CRITICAL,
+                           "*NULL has already been returned*");
+    g_variant_iter_next_value (&iter);
+    g_test_assert_expected_messages ();
+
+    while (g_variant_iter_loop (i3, "*", &sub))
+      {
+        gchar *str = g_variant_print (sub, TRUE);
+        g_assert_cmpstr (str, ==,
+                         "['i', 'ii', 'iii', 'iv', 'v', 'vi']");
+        g_free (str);
+      }
+
+    g_variant_iter_free (i3);
+
+    for (i = 0; i < g_variant_n_children (value); i++)
+      {
+        gsize j;
+
+        g_variant_get_child (value, i, "*", &sub);
+
+        for (j = 0; j < g_variant_n_children (sub); j++)
+          {
+            const gchar *str = NULL;
+            GVariant *cval;
+
+            g_variant_get_child (sub, j, "&s", &str);
+            g_assert_cmpstr (str, ==, strvector[j]);
+
+            cval = g_variant_get_child_value (sub, j);
+            g_variant_get (cval, "&s", &str);
+            g_assert_cmpstr (str, ==, strvector[j]);
+            g_variant_unref (cval);
+          }
+
+        g_variant_unref (sub);
+      }
+
+    g_variant_unref (value);
+  }
+
+  {
+    gboolean justs[10];
+    GVariant *value;
+
+    GVariant *vval;
+    guchar byteval;
+    gboolean bval;
+    gint16 i16val;
+    guint16 u16val;
+    gint32 i32val;
+    guint32 u32val;
+    gint64 i64val;
+    guint64 u64val;
+    gdouble dval;
+    gint32 hval;
+
+    /* test all 'nothing' */
+    value = g_variant_new ("(mymbmnmqmimumxmtmhmdmv)",
+                           FALSE, 'a',
+                           FALSE, TRUE,
+                           FALSE, (gint16) 123,
+                           FALSE, (guint16) 123,
+                           FALSE, (gint32) 123,
+                           FALSE, (guint32) 123,
+                           FALSE, (gint64) 123,
+                           FALSE, (guint64) 123,
+                           FALSE, (gint32) -1,
+                           FALSE, (gdouble) 37.5,
+                           NULL);
+
+    /* both NULL */
+    g_variant_get (value, "(mymbmnmqmimumxmtmhmdmv)",
+                   NULL, NULL,
+                   NULL, NULL,
+                   NULL, NULL,
+                   NULL, NULL,
+                   NULL, NULL,
+                   NULL, NULL,
+                   NULL, NULL,
+                   NULL, NULL,
+                   NULL, NULL,
+                   NULL, NULL,
+                   NULL);
+
+    /* NULL values */
+    memset (justs, 1, sizeof justs);
+    g_variant_get (value, "(mymbmnmqmimumxmtmhmdmv)",
+                   &justs[0], NULL,
+                   &justs[1], NULL,
+                   &justs[2], NULL,
+                   &justs[3], NULL,
+                   &justs[4], NULL,
+                   &justs[5], NULL,
+                   &justs[6], NULL,
+                   &justs[7], NULL,
+                   &justs[8], NULL,
+                   &justs[9], NULL,
+                   NULL);
+    g_assert_true (!(justs[0] || justs[1] || justs[2] || justs[3] || justs[4] ||
+                     justs[5] || justs[6] || justs[7] || justs[8] || justs[9]));
+
+    /* both non-NULL */
+    memset (justs, 1, sizeof justs);
+    byteval = i16val = u16val = i32val = u32val = i64val = u64val = hval = 88;
+    vval = (void *) 1;
+    bval = TRUE;
+    dval = 88.88;
+    g_variant_get (value, "(mymbmnmqmimumxmtmhmdmv)",
+                   &justs[0], &byteval,
+                   &justs[1], &bval,
+                   &justs[2], &i16val,
+                   &justs[3], &u16val,
+                   &justs[4], &i32val,
+                   &justs[5], &u32val,
+                   &justs[6], &i64val,
+                   &justs[7], &u64val,
+                   &justs[8], &hval,
+                   &justs[9], &dval,
+                   &vval);
+    g_assert_true (!(justs[0] || justs[1] || justs[2] || justs[3] || justs[4] ||
+                     justs[5] || justs[6] || justs[7] || justs[8] || justs[9]));
+    g_assert_true (byteval == '\0' && bval == FALSE);
+    g_assert_true (i16val == 0 && u16val == 0 && i32val == 0 &&
+                   u32val == 0 && i64val == 0 && u64val == 0 &&
+                   hval == 0 && dval == 0.0);
+    g_assert_null (vval);
+
+    /* NULL justs */
+    byteval = i16val = u16val = i32val = u32val = i64val = u64val = hval = 88;
+    vval = (void *) 1;
+    bval = TRUE;
+    dval = 88.88;
+    g_variant_get (value, "(mymbmnmqmimumxmtmhmdmv)",
+                   NULL, &byteval,
+                   NULL, &bval,
+                   NULL, &i16val,
+                   NULL, &u16val,
+                   NULL, &i32val,
+                   NULL, &u32val,
+                   NULL, &i64val,
+                   NULL, &u64val,
+                   NULL, &hval,
+                   NULL, &dval,
+                   &vval);
+    g_assert_true (byteval == '\0' && bval == FALSE);
+    g_assert_true (i16val == 0 && u16val == 0 && i32val == 0 &&
+                   u32val == 0 && i64val == 0 && u64val == 0 &&
+                   hval == 0 && dval == 0.0);
+    g_assert_null (vval);
+
+    g_variant_unref (value);
+
+
+    /* test all 'just' */
+    value = g_variant_new ("(mymbmnmqmimumxmtmhmdmv)",
+                           TRUE, 'a',
+                           TRUE, TRUE,
+                           TRUE, (gint16) 123,
+                           TRUE, (guint16) 123,
+                           TRUE, (gint32) 123,
+                           TRUE, (guint32) 123,
+                           TRUE, (gint64) 123,
+                           TRUE, (guint64) 123,
+                           TRUE, (gint32) -1,
+                           TRUE, (gdouble) 37.5,
+                           g_variant_new ("()"));
+
+    /* both NULL */
+    g_variant_get (value, "(mymbmnmqmimumxmtmhmdmv)",
+                   NULL, NULL,
+                   NULL, NULL,
+                   NULL, NULL,
+                   NULL, NULL,
+                   NULL, NULL,
+                   NULL, NULL,
+                   NULL, NULL,
+                   NULL, NULL,
+                   NULL, NULL,
+                   NULL, NULL,
+                   NULL);
+
+    /* NULL values */
+    memset (justs, 0, sizeof justs);
+    g_variant_get (value, "(mymbmnmqmimumxmtmhmdmv)",
+                   &justs[0], NULL,
+                   &justs[1], NULL,
+                   &justs[2], NULL,
+                   &justs[3], NULL,
+                   &justs[4], NULL,
+                   &justs[5], NULL,
+                   &justs[6], NULL,
+                   &justs[7], NULL,
+                   &justs[8], NULL,
+                   &justs[9], NULL,
+                   NULL);
+    g_assert_true (justs[0] && justs[1] && justs[2] && justs[3] && justs[4] &&
+                   justs[5] && justs[6] && justs[7] && justs[8] && justs[9]);
+
+    /* both non-NULL */
+    memset (justs, 0, sizeof justs);
+    byteval = i16val = u16val = i32val = u32val = i64val = u64val = hval = 88;
+    vval = (void *) 1;
+    bval = FALSE;
+    dval = 88.88;
+    g_variant_get (value, "(mymbmnmqmimumxmtmhmdmv)",
+                   &justs[0], &byteval,
+                   &justs[1], &bval,
+                   &justs[2], &i16val,
+                   &justs[3], &u16val,
+                   &justs[4], &i32val,
+                   &justs[5], &u32val,
+                   &justs[6], &i64val,
+                   &justs[7], &u64val,
+                   &justs[8], &hval,
+                   &justs[9], &dval,
+                   &vval);
+    g_assert_true (justs[0] && justs[1] && justs[2] && justs[3] && justs[4] &&
+                   justs[5] && justs[6] && justs[7] && justs[8] && justs[9]);
+    g_assert_true (byteval == 'a' && bval == TRUE);
+    g_assert_true (i16val == 123 && u16val == 123 && i32val == 123 &&
+                   u32val == 123 && i64val == 123 && u64val == 123 &&
+                   hval == -1 && dval == 37.5);
+    g_assert_true (g_variant_is_of_type (vval, G_VARIANT_TYPE_UNIT));
+    g_variant_unref (vval);
+
+    /* NULL justs */
+    byteval = i16val = u16val = i32val = u32val = i64val = u64val = hval = 88;
+    vval = (void *) 1;
+    bval = TRUE;
+    dval = 88.88;
+    g_variant_get (value, "(mymbmnmqmimumxmtmhmdmv)",
+                   NULL, &byteval,
+                   NULL, &bval,
+                   NULL, &i16val,
+                   NULL, &u16val,
+                   NULL, &i32val,
+                   NULL, &u32val,
+                   NULL, &i64val,
+                   NULL, &u64val,
+                   NULL, &hval,
+                   NULL, &dval,
+                   &vval);
+    g_assert_true (byteval == 'a' && bval == TRUE);
+    g_assert_true (i16val == 123 && u16val == 123 && i32val == 123 &&
+                   u32val == 123 && i64val == 123 && u64val == 123 &&
+                   hval == -1 && dval == 37.5);
+    g_assert_true (g_variant_is_of_type (vval, G_VARIANT_TYPE_UNIT));
+    g_variant_unref (vval);
+
+    g_variant_unref (value);
+  }
+
+  {
+    GVariant *value;
+    gchar *str;
+
+    value = g_variant_new ("(masas)", NULL, NULL);
+    g_variant_ref_sink (value);
+
+    str = g_variant_print (value, TRUE);
+    g_assert_cmpstr (str, ==, "(@mas nothing, @as [])");
+    g_variant_unref (value);
+    g_free (str);
+
+    do_failed_test ("/gvariant/varargs/subprocess/empty-array",
+                    "*which type of empty array*");
+  }
+
+  g_variant_type_info_assert_no_infos ();
+}
+
+static void
+hash_get (GVariant    *value,
+          const gchar *format,
+          ...)
+{
+  const gchar *endptr = NULL;
+  gboolean hash;
+  va_list ap;
+
+  hash = g_str_has_suffix (format, "#");
+
+  va_start (ap, format);
+  g_variant_get_va (value, format, hash ? &endptr : NULL, &ap);
+  va_end (ap);
+
+  if (hash)
+    g_assert_cmpint (*endptr, ==, '#');
+}
+
+static GVariant *
+hash_new (const gchar *format,
+          ...)
+{
+  const gchar *endptr = NULL;
+  GVariant *value;
+  gboolean hash;
+  va_list ap;
+
+  hash = g_str_has_suffix (format, "#");
+
+  va_start (ap, format);
+  value = g_variant_new_va (format, hash ? &endptr : NULL, &ap);
+  va_end (ap);
+
+  if (hash)
+    g_assert_cmpint (*endptr, ==, '#');
+
+  return value;
+}
+
+static void
+test_valist (void)
+{
+  GVariant *value;
+  gint32 x;
+
+  x = 0;
+  value = hash_new ("i", 234);
+  hash_get (value, "i", &x);
+  g_assert_cmpint (x, ==, 234);
+  g_variant_unref (value);
+
+  x = 0;
+  value = hash_new ("i#", 234);
+  hash_get (value, "i#", &x);
+  g_assert_cmpint (x, ==, 234);
+  g_variant_unref (value);
+
+  g_variant_type_info_assert_no_infos ();
+}
+
+static void
+test_builder_memory (void)
+{
+  GVariantBuilder *hb;
+  GVariantBuilder sb;
+
+  hb = g_variant_builder_new  (G_VARIANT_TYPE_ARRAY);
+  g_variant_builder_open (hb, G_VARIANT_TYPE_ARRAY);
+  g_variant_builder_open (hb, G_VARIANT_TYPE_ARRAY);
+  g_variant_builder_open (hb, G_VARIANT_TYPE_ARRAY);
+  g_variant_builder_add (hb, "s", "some value");
+  g_variant_builder_ref (hb);
+  g_variant_builder_unref (hb);
+  g_variant_builder_unref (hb);
+
+  hb = g_variant_builder_new (G_VARIANT_TYPE_ARRAY);
+  g_variant_builder_unref (hb);
+
+  hb = g_variant_builder_new (G_VARIANT_TYPE_ARRAY);
+  g_variant_builder_clear (hb);
+  g_variant_builder_unref (hb);
+
+  g_variant_builder_init (&sb, G_VARIANT_TYPE_ARRAY);
+  g_variant_builder_open (&sb, G_VARIANT_TYPE_ARRAY);
+  g_variant_builder_open (&sb, G_VARIANT_TYPE_ARRAY);
+  g_variant_builder_add (&sb, "s", "some value");
+  g_variant_builder_clear (&sb);
+
+  g_variant_type_info_assert_no_infos ();
+}
+
+static void
+test_hashing (void)
+{
+  GVariant *items[4096];
+  GHashTable *table;
+  gsize i;
+
+  table = g_hash_table_new_full (g_variant_hash, g_variant_equal,
+                                 (GDestroyNotify ) g_variant_unref,
+                                 NULL);
+
+  for (i = 0; i < G_N_ELEMENTS (items); i++)
+    {
+      TreeInstance *tree;
+      gsize j;
+
+ again:
+      tree = tree_instance_new (NULL, 0);
+      items[i] = tree_instance_get_gvariant (tree);
+      tree_instance_free (tree);
+
+      for (j = 0; j < i; j++)
+        if (g_variant_equal (items[i], items[j]))
+          {
+            g_variant_unref (items[i]);
+            goto again;
+          }
+
+      g_hash_table_insert (table,
+                           g_variant_ref_sink (items[i]),
+                           GINT_TO_POINTER (i));
+    }
+
+  for (i = 0; i < G_N_ELEMENTS (items); i++)
+    {
+      gpointer result;
+
+      result = g_hash_table_lookup (table, items[i]);
+      g_assert_cmpint (GPOINTER_TO_INT (result), ==, i);
+    }
+
+  g_hash_table_unref (table);
+
+  g_variant_type_info_assert_no_infos ();
+}
+
+static void
+test_gv_byteswap (void)
+{
+#if G_BYTE_ORDER == G_LITTLE_ENDIAN
+# define native16(x)  x, 0
+# define swapped16(x) 0, x
+#else
+# define native16(x)  0, x
+# define swapped16(x) x, 0
+#endif
+  /* all kinds of of crazy randomised testing already performed on the
+   * byteswapper in the /gvariant/serializer/byteswap test and all kinds
+   * of crazy randomised testing performed against the serializer
+   * normalisation functions in the /gvariant/serializer/fuzz/ tests.
+   *
+   * just test a few simple cases here to make sure they each work
+   */
+  guchar validbytes[] = { 'a', '\0', swapped16(66), 2,
+                          0,
+                          'b', '\0', swapped16(77), 2,
+                          5, 11 };
+  guchar corruptbytes[] = { 'a', '\0', swapped16(66), 2,
+                            0,
+                            'b', '\0', swapped16(77), 2,
+                            6, 11 };
+  guint valid_data[4], corrupt_data[4];
+  GVariant *value, *swapped;
+  gchar *string, *string2;
+
+  memcpy (valid_data, validbytes, sizeof validbytes);
+  memcpy (corrupt_data, corruptbytes, sizeof corruptbytes);
+
+  /* trusted */
+  value = g_variant_new_from_data (G_VARIANT_TYPE ("a(sn)"),
+                                   valid_data, sizeof validbytes, TRUE,
+                                   NULL, NULL);
+  swapped = g_variant_byteswap (value);
+  g_variant_unref (value);
+  g_assert_cmpuint (g_variant_get_size (swapped), ==, 13);
+  string = g_variant_print (swapped, FALSE);
+  g_variant_unref (swapped);
+  g_assert_cmpstr (string, ==, "[('a', 66), ('b', 77)]");
+  g_free (string);
+
+  /* untrusted but valid */
+  value = g_variant_new_from_data (G_VARIANT_TYPE ("a(sn)"),
+                                   valid_data, sizeof validbytes, FALSE,
+                                   NULL, NULL);
+  swapped = g_variant_byteswap (value);
+  g_variant_unref (value);
+  g_assert_cmpuint (g_variant_get_size (swapped), ==, 13);
+  string = g_variant_print (swapped, FALSE);
+  g_variant_unref (swapped);
+  g_assert_cmpstr (string, ==, "[('a', 66), ('b', 77)]");
+  g_free (string);
+
+  /* untrusted, invalid */
+  value = g_variant_new_from_data (G_VARIANT_TYPE ("a(sn)"),
+                                   corrupt_data, sizeof corruptbytes, FALSE,
+                                   NULL, NULL);
+  string = g_variant_print (value, FALSE);
+  swapped = g_variant_byteswap (value);
+  g_variant_unref (value);
+  g_assert_cmpuint (g_variant_get_size (swapped), ==, 13);
+  value = g_variant_byteswap (swapped);
+  g_variant_unref (swapped);
+  string2 = g_variant_print (value, FALSE);
+  g_assert_cmpuint (g_variant_get_size (value), ==, 13);
+  g_variant_unref (value);
+  g_assert_cmpstr (string, ==, string2);
+  g_free (string2);
+  g_free (string);
+}
+
+static void
+test_parser (void)
+{
+  TreeInstance *tree;
+  GVariant *parsed;
+  GVariant *value;
+  gchar *pt, *p;
+  gchar *res;
+
+  tree = tree_instance_new (NULL, 3);
+  value = tree_instance_get_gvariant (tree);
+  tree_instance_free (tree);
+
+  pt = g_variant_print (value, TRUE);
+  p = g_variant_print (value, FALSE);
+
+  parsed = g_variant_parse (NULL, pt, NULL, NULL, NULL);
+  res = g_variant_print (parsed, FALSE);
+  g_assert_cmpstr (p, ==, res);
+  g_variant_unref (parsed);
+  g_free (res);
+
+  parsed = g_variant_parse (g_variant_get_type (value), p,
+                            NULL, NULL, NULL);
+  res = g_variant_print (parsed, TRUE);
+  g_assert_cmpstr (pt, ==, res);
+  g_variant_unref (parsed);
+  g_free (res);
+
+  g_variant_unref (value);
+  g_free (pt);
+  g_free (p);
+}
+
+static void
+test_parses (void)
+{
+  gsize i;
+
+  for (i = 0; i < 100; i++)
+    {
+      test_parser ();
+    }
+
+  /* mini test */
+  {
+    GError *error = NULL;
+    gchar str[128];
+    GVariant *val;
+    gchar *p, *p2;
+
+    for (i = 0; i < 127; i++)
+      str[i] = i + 1;
+    str[i] = 0;
+
+    val = g_variant_new_string (str);
+    p = g_variant_print (val, FALSE);
+    g_variant_unref (val);
+
+    val = g_variant_parse (NULL, p, NULL, NULL, &error);
+    p2 = g_variant_print (val, FALSE);
+
+    g_assert_cmpstr (str, ==, g_variant_get_string (val, NULL));
+    g_assert_cmpstr (p, ==, p2);
+
+    g_variant_unref (val);
+    g_free (p2);
+    g_free (p);
+  }
+
+  /* another mini test */
+  {
+    const gchar *end;
+    GVariant *value;
+
+    value = g_variant_parse (G_VARIANT_TYPE_INT32, "1 2 3", NULL, &end, NULL);
+    g_assert_cmpint (g_variant_get_int32 (value), ==, 1);
+    /* make sure endptr returning works */
+    g_assert_cmpstr (end, ==, " 2 3");
+    g_variant_unref (value);
+  }
+
+  /* unicode mini test */
+  {
+    /* ał𝄞 */
+    const gchar orig[] = "a\xc5\x82\xf0\x9d\x84\x9e \t\n";
+    GVariant *value;
+    gchar *printed;
+
+    value = g_variant_new_string (orig);
+    printed = g_variant_print (value, FALSE);
+    g_variant_unref (value);
+
+    g_assert_cmpstr (printed, ==, "'a\xc5\x82\xf0\x9d\x84\x9e \\t\\n'");
+    value = g_variant_parse (NULL, printed, NULL, NULL, NULL);
+    g_assert_cmpstr (g_variant_get_string (value, NULL), ==, orig);
+    g_variant_unref (value);
+    g_free (printed);
+  }
+
+  /* escapes */
+  {
+    const gchar orig[] = " \342\200\254 \360\220\210\240 \a \b \f \n \r \t \v ";
+    GVariant *value;
+    gchar *printed;
+
+    value = g_variant_new_string (orig);
+    printed = g_variant_print (value, FALSE);
+    g_variant_unref (value);
+
+    g_assert_cmpstr (printed, ==, "' \\u202c \\U00010220 \\a \\b \\f \\n \\r \\t \\v '");
+    value = g_variant_parse (NULL, printed, NULL, NULL, NULL);
+    g_assert_cmpstr (g_variant_get_string (value, NULL), ==, orig);
+    g_variant_unref (value);
+    g_free (printed);
+  }
+
+  /* pattern coalese of `MN` and `*` is `MN` */
+  {
+    GVariant *value = NULL;
+    GError *error = NULL;
+
+    value = g_variant_parse (NULL, "[[0], [], [nothing]]", NULL, NULL, &error);
+    g_assert_no_error (error);
+    g_assert_cmpstr (g_variant_get_type_string (value), ==, "aami");
+    g_variant_unref (value);
+  }
+
+#ifndef _MSC_VER
+  /* inf/nan strings are C99 features which Visual C++ does not support */
+  /* inf/nan mini test */
+  {
+    const gchar *tests[] = { "inf", "-inf", "nan" };
+    GVariant *value;
+    gchar *printed;
+    gchar *printed_down;
+    gsize i;
+
+    for (i = 0; i < G_N_ELEMENTS (tests); i++)
+      {
+        GError *error = NULL;
+        value = g_variant_parse (NULL, tests[i], NULL, NULL, &error);
+        printed = g_variant_print (value, FALSE);
+        /* Canonicalize to lowercase; https://bugzilla.gnome.org/show_bug.cgi?id=704585 */
+        printed_down = g_ascii_strdown (printed, -1);
+        g_assert_true (g_str_has_prefix (printed_down, tests[i]));
+        g_free (printed);
+        g_free (printed_down);
+        g_variant_unref (value);
+      }
+  }
+#endif
+
+  g_variant_type_info_assert_no_infos ();
+}
+
+static void
+test_parse_failures (void)
+{
+  const gchar *test[] = {
+    "[1, 2,",                   "6:",              "expected value",
+    "",                         "0:",              "expected value",
+    "(1, 2,",                   "6:",              "expected value",
+    "<1",                       "2:",              "expected '>'",
+    "[]",                       "0-2:",            "unable to infer",
+    "(,",                       "1:",              "expected value",
+    "[4,'']",                   "1-2,3-5:",        "common type",
+    "[4, '', 5]",               "1-2,4-6:",        "common type",
+    "['', 4, 5]",               "1-3,5-6:",        "common type",
+    "[4, 5, '']",               "1-2,7-9:",        "common type",
+    "[[4], [], ['']]",          "1-4,10-14:",      "common type",
+    "[[], [4], ['']]",          "5-8,10-14:",      "common type",
+    "just",                     "4:",              "expected value",
+    "nothing",                  "0-7:",            "unable to infer",
+    "just [4, '']",             "6-7,9-11:",       "common type",
+    "[[4,'']]",                 "2-3,4-6:",        "common type",
+    "([4,''],)",                "2-3,4-6:",        "common type",
+    "(4)",                      "2:",              "','",
+    "{}",                       "0-2:",            "unable to infer",
+    "{[1,2],[3,4]}",            "0-13:",           "basic types",
+    "{[1,2]:[3,4]}",            "0-13:",           "basic types",
+    "justt",                    "0-5:",            "unknown keyword",
+    "nothng",                   "0-6:",            "unknown keyword",
+    "uint33",                   "0-6:",            "unknown keyword",
+    "@mi just ''",              "9-11:",           "can not parse as",
+    "@ai ['']",                 "5-7:",            "can not parse as",
+    "@(i) ('',)",               "6-8:",            "can not parse as",
+    "[[], 5]",                  "1-3,5-6:",        "common type",
+    "[[5], 5]",                 "1-4,6-7:",        "common type",
+    "5 5",                      "2:",              "expected end of input",
+    "[5, [5, '']]",             "5-6,8-10:",       "common type",
+    "@i just 5",                "3-9:",            "can not parse as",
+    "@i nothing",               "3-10:",           "can not parse as",
+    "@i []",                    "3-5:",            "can not parse as",
+    "@i ()",                    "3-5:",            "can not parse as",
+    "@ai (4,)",                 "4-8:",            "can not parse as",
+    "@(i) []",                  "5-7:",            "can not parse as",
+    "(5 5)",                    "3:",              "expected ','",
+    "[5 5]",                    "3:",              "expected ',' or ']'",
+    "(5, 5 5)",                 "6:",              "expected ',' or ')'",
+    "[5, 5 5]",                 "6:",              "expected ',' or ']'",
+    "<@i []>",                  "4-6:",            "can not parse as",
+    "<[5 5]>",                  "4:",              "expected ',' or ']'",
+    "{[4,''],5}",               "2-3,4-6:",        "common type",
+    "{5,[4,'']}",               "4-5,6-8:",        "common type",
+    "@i {1,2}",                 "3-8:",            "can not parse as",
+    "{@i '', 5}",               "4-6:",            "can not parse as",
+    "{5, @i ''}",               "7-9:",            "can not parse as",
+    "@ai {}",                   "4-6:",            "can not parse as",
+    "{@i '': 5}",               "4-6:",            "can not parse as",
+    "{5: @i ''}",               "7-9:",            "can not parse as",
+    "{<4,5}",                   "3:",              "expected '>'",
+    "{4,<5}",                   "5:",              "expected '>'",
+    "{4,5,6}",                  "4:",              "expected '}'",
+    "{5 5}",                    "3:",              "expected ':' or ','",
+    "{4: 5: 6}",                "5:",              "expected ',' or '}'",
+    "{4:5,<6:7}",               "7:",              "expected '>'",
+    "{4:5,6:<7}",               "9:",              "expected '>'",
+    "{4:5,6 7}",                "7:",              "expected ':'",
+    "@o 'foo'",                 "3-8:",            "object path",
+    "@g 'zzz'",                 "3-8:",            "signature",
+    "@i true",                  "3-7:",            "can not parse as",
+    "@z 4",                     "0-2:",            "invalid type",
+    "@a* []",                   "0-3:",            "definite",
+    "@ai [3 3]",                "7:",              "expected ',' or ']'",
+    "18446744073709551616",     "0-20:",           "too big for any type",
+    "-18446744073709551616",    "0-21:",           "too big for any type",
+    "byte 256",                 "5-8:",            "out of range for type",
+    "byte -1",                  "5-7:",            "out of range for type",
+    "int16 32768",              "6-11:",           "out of range for type",
+    "int16 -32769",             "6-12:",           "out of range for type",
+    "uint16 -1",                "7-9:",            "out of range for type",
+    "uint16 65536",             "7-12:",           "out of range for type",
+    "2147483648",               "0-10:",           "out of range for type",
+    "-2147483649",              "0-11:",           "out of range for type",
+    "uint32 -1",                "7-9:",            "out of range for type",
+    "uint32 4294967296",        "7-17:",           "out of range for type",
+    "@x 9223372036854775808",   "3-22:",           "out of range for type",
+    "@x -9223372036854775809",  "3-23:",           "out of range for type",
+    "@t -1",                    "3-5:",            "out of range for type",
+    "@t 18446744073709551616",  "3-23:",           "too big for any type",
+    "handle 2147483648",        "7-17:",           "out of range for type",
+    "handle -2147483649",       "7-18:",           "out of range for type",
+    "1.798e308",                "0-9:",            "too big for any type",
+    "37.5a488",                 "4-5:",            "invalid character",
+    "0x7ffgf",                  "5-6:",            "invalid character",
+    "07758",                    "4-5:",            "invalid character",
+    "123a5",                    "3-4:",            "invalid character",
+    "@ai 123",                  "4-7:",            "can not parse as",
+    "'\"\\'",                   "0-4:",            "unterminated string",
+    "'\"\\'\\",                 "0-5:",            "unterminated string",
+    "boolean 4",                "8-9:",            "can not parse as",
+    "int32 true",               "6-10:",           "can not parse as",
+    "[double 5, int32 5]",      "1-9,11-18:",      "common type",
+    "string 4",                 "7-8:",            "can not parse as",
+    "\x0a",                     "1:",              "expected value",
+    "((",                       "2:",              "expected value",
+    "(b",                       "1:",              "expected value",
+    "b'",                       "0-2:",            "unterminated string constant",
+    "b\"",                      "0-2:",            "unterminated string constant",
+    "b'a",                      "0-3:",            "unterminated string constant",
+    "b\"a",                     "0-3:",            "unterminated string constant",
+    "b'\\",                     "0-3:",            "unterminated string constant",
+    "b\"\\",                    "0-3:",            "unterminated string constant",
+    "b'\\'",                    "0-4:",            "unterminated string constant",
+    "b\"\\\"",                  "0-4:",            "unterminated string constant",
+    "b'\\'a",                   "0-5:",            "unterminated string constant",
+    "b\"\\\"a",                 "0-5:",            "unterminated string constant",
+    "'\\u-ff4'",                "3:",              "invalid 4-character unicode escape",
+    "'\\u+ff4'",                "3:",              "invalid 4-character unicode escape",
+    "'\\u'",                    "3:",              "invalid 4-character unicode escape",
+    "'\\u0'",                   "3-4:",            "invalid 4-character unicode escape",
+    "'\\uHELLO'",               "3:",              "invalid 4-character unicode escape",
+    "'\\u ff4'",                "3:",              "invalid 4-character unicode escape",
+    "'\\u012'",                 "3-6:",            "invalid 4-character unicode escape",
+    "'\\u0xff4'",               "3-4:",            "invalid 4-character unicode escape",
+    "'\\U-ff4'",                "3:",              "invalid 8-character unicode escape",
+    "'\\U+ff4'",                "3:",              "invalid 8-character unicode escape",
+    "'\\U'",                    "3:",              "invalid 8-character unicode escape",
+    "'\\U0'",                   "3-4:",            "invalid 8-character unicode escape",
+    "'\\UHELLO'",               "3:",              "invalid 8-character unicode escape",
+    "'\\U ff4'",                "3:",              "invalid 8-character unicode escape",
+    "'\\U0123456'",             "3-10:",           "invalid 8-character unicode escape",
+    "'\\U0xff4'",               "3-4:",            "invalid 8-character unicode escape",
+  };
+  guint i;
+
+  for (i = 0; i < G_N_ELEMENTS (test); i += 3)
+    {
+      GError *error1 = NULL, *error2 = NULL;
+      GVariant *value;
+
+      /* Copy the test string and drop its nul terminator, then use the @limit
+       * parameter of g_variant_parse() to set the length. This allows valgrind
+       * to catch 1-byte heap buffer overflows. */
+      gsize test_len = MAX (strlen (test[i]), 1);
+      gchar *test_blob = g_malloc0 (test_len);  /* no nul terminator */
+
+      memcpy (test_blob, test[i], test_len);
+      value = g_variant_parse (NULL, test_blob, test_blob + test_len, NULL, &error1);
+      g_assert_null (value);
+
+      g_free (test_blob);
+
+      if (!strstr (error1->message, test[i+2]))
+        g_error ("test %u: Can't find '%s' in '%s'", i / 3,
+                 test[i+2], error1->message);
+
+      if (!g_str_has_prefix (error1->message, test[i+1]))
+        g_error ("test %u: Expected location '%s' in '%s'", i / 3,
+                 test[i+1], error1->message);
+
+      /* Test again with the nul terminator this time. The behaviour should be
+       * the same. */
+      value = g_variant_parse (NULL, test[i], NULL, NULL, &error2);
+      g_assert_null (value);
+
+      g_assert_cmpint (error1->domain, ==, error2->domain);
+      g_assert_cmpint (error1->code, ==, error2->code);
+      g_assert_cmpstr (error1->message, ==, error2->message);
+
+      g_clear_error (&error1);
+      g_clear_error (&error2);
+    }
+}
+
+/* Test that parsing GVariant text format integers works at the boundaries of
+ * those integer types. We’re especially interested in the handling of the most
+ * negative numbers, since those can’t be represented in sign + absolute value
+ * form. */
+static void
+test_parser_integer_bounds (void)
+{
+  GVariant *value = NULL;
+  GError *local_error = NULL;
+
+#define test_bound(TYPE, type, text, expected_value) \
+  value = g_variant_parse (G_VARIANT_TYPE_##TYPE, text, NULL, NULL, &local_error); \
+  g_assert_no_error (local_error); \
+  g_assert_nonnull (value); \
+  g_assert_true (g_variant_is_of_type (value, G_VARIANT_TYPE_##TYPE)); \
+  g_assert_cmpint (g_variant_get_##type (value), ==, expected_value); \
+  g_variant_unref (value)
+
+  test_bound (BYTE, byte, "0", 0);
+  test_bound (BYTE, byte, "255", G_MAXUINT8);
+  test_bound (INT16, int16, "-32768", G_MININT16);
+  test_bound (INT16, int16, "32767", G_MAXINT16);
+  test_bound (INT32, int32, "-2147483648", G_MININT32);
+  test_bound (INT32, int32, "2147483647", G_MAXINT32);
+  test_bound (INT64, int64, "-9223372036854775808", G_MININT64);
+  test_bound (INT64, int64, "9223372036854775807", G_MAXINT64);
+  test_bound (HANDLE, handle, "-2147483648", G_MININT32);
+  test_bound (HANDLE, handle, "2147483647", G_MAXINT32);
+
+#undef test_bound
+}
+
+/* Test that #GVariants which recurse too deeply are rejected. */
+static void
+test_parser_recursion (void)
+{
+  GVariant *value = NULL;
+  GError *local_error = NULL;
+  const guint recursion_depth = G_VARIANT_MAX_RECURSION_DEPTH + 1;
+  gchar *silly_dict = g_malloc0 (recursion_depth * 2 + 1);
+  gsize i;
+
+  for (i = 0; i < recursion_depth; i++)
+    {
+      silly_dict[i] = '{';
+      silly_dict[recursion_depth * 2 - i - 1] = '}';
+    }
+
+  value = g_variant_parse (NULL, silly_dict, NULL, NULL, &local_error);
+  g_assert_error (local_error, G_VARIANT_PARSE_ERROR, G_VARIANT_PARSE_ERROR_RECURSION);
+  g_assert_null (value);
+  g_error_free (local_error);
+  g_free (silly_dict);
+}
+
+static void
+test_parse_bad_format_char (void)
+{
+  g_variant_new_parsed ("%z");
+
+  g_assert_not_reached ();
+}
+
+static void
+test_parse_bad_format_string (void)
+{
+  g_variant_new_parsed ("uint32 %i", 2);
+
+  g_assert_not_reached ();
+}
+
+static void
+test_parse_bad_args (void)
+{
+  g_variant_new_parsed ("%@i", g_variant_new_uint32 (2));
+
+  g_assert_not_reached ();
+}
+
+static void
+test_parse_positional (void)
+{
+  GVariant *value;
+  check_and_free (g_variant_new_parsed ("[('one', 1), (%s, 2),"
+                                        " ('three', %i)]", "two", 3),
+                  "[('one', 1), ('two', 2), ('three', 3)]");
+  value = g_variant_new_parsed ("[('one', 1), (%s, 2),"
+                                " ('three', %u)]", "two", 3);
+  g_assert_true (g_variant_is_of_type (value, G_VARIANT_TYPE ("a(su)")));
+  check_and_free (value, "[('one', 1), ('two', 2), ('three', 3)]");
+  check_and_free (g_variant_new_parsed ("{%s:%i}", "one", 1), "{'one': 1}");
+
+  if (g_test_undefined ())
+    {
+      do_failed_test ("/gvariant/parse/subprocess/bad-format-char",
+                      "*GVariant format string*");
+
+      do_failed_test ("/gvariant/parse/subprocess/bad-format-string",
+                      "*can not parse as*");
+
+      do_failed_test ("/gvariant/parse/subprocess/bad-args",
+                      "*expected GVariant of type 'i'*");
+    }
+}
+
+static void
+test_floating (void)
+{
+  GVariant *value;
+
+  value = g_variant_new_int32 (42);
+  g_assert_true (g_variant_is_floating (value));
+  g_variant_ref_sink (value);
+  g_assert_true (!g_variant_is_floating (value));
+  g_variant_unref (value);
+}
+
+static void
+test_bytestring (void)
+{
+  const gchar *test_string = "foo,bar,baz,quux,\xffoooo";
+  GVariant *value;
+  gchar **strv;
+  gchar *str;
+  const gchar *const_str;
+  GVariant *untrusted_empty;
+
+  strv = g_strsplit (test_string, ",", 0);
+
+  value = g_variant_new_bytestring_array ((const gchar **) strv, -1);
+  g_assert_true (g_variant_is_floating (value));
+  g_strfreev (strv);
+
+  str = g_variant_print (value, FALSE);
+  g_variant_unref (value);
+
+  value = g_variant_parse (NULL, str, NULL, NULL, NULL);
+  g_free (str);
+
+  strv = g_variant_dup_bytestring_array (value, NULL);
+  g_variant_unref (value);
+
+  str = g_strjoinv (",", strv);
+  g_strfreev (strv);
+
+  g_assert_cmpstr (str, ==, test_string);
+  g_free (str);
+
+  strv = g_strsplit (test_string, ",", 0);
+  value = g_variant_new ("(^aay^a&ay^ay^&ay)",
+                         strv, strv, strv[0], strv[0]);
+  g_strfreev (strv);
+
+  g_variant_get_child (value, 0, "^a&ay", &strv);
+  str = g_strjoinv (",", strv);
+  g_free (strv);
+  g_assert_cmpstr (str, ==, test_string);
+  g_free (str);
+
+  g_variant_get_child (value, 0, "^aay", &strv);
+  str = g_strjoinv (",", strv);
+  g_strfreev (strv);
+  g_assert_cmpstr (str, ==, test_string);
+  g_free (str);
+
+  g_variant_get_child (value, 1, "^a&ay", &strv);
+  str = g_strjoinv (",", strv);
+  g_free (strv);
+  g_assert_cmpstr (str, ==, test_string);
+  g_free (str);
+
+  g_variant_get_child (value, 1, "^aay", &strv);
+  str = g_strjoinv (",", strv);
+  g_strfreev (strv);
+  g_assert_cmpstr (str, ==, test_string);
+  g_free (str);
+
+  g_variant_get_child (value, 2, "^ay", &str);
+  g_assert_cmpstr (str, ==, "foo");
+  g_free (str);
+
+  g_variant_get_child (value, 2, "^&ay", &str);
+  g_assert_cmpstr (str, ==, "foo");
+
+  g_variant_get_child (value, 3, "^ay", &str);
+  g_assert_cmpstr (str, ==, "foo");
+  g_free (str);
+
+  g_variant_get_child (value, 3, "^&ay", &str);
+  g_assert_cmpstr (str, ==, "foo");
+  g_variant_unref (value);
+
+  untrusted_empty = g_variant_new_from_data (G_VARIANT_TYPE ("ay"), NULL, 0, FALSE, NULL, NULL);
+  value = g_variant_get_normal_form (untrusted_empty);
+  const_str = g_variant_get_bytestring (value);
+  (void) const_str;
+  g_variant_unref (value);
+  g_variant_unref (untrusted_empty);
+}
+
+static void
+test_lookup_value (void)
+{
+  struct {
+    const gchar *dict, *key, *value;
+  } cases[] = {
+    { "@a{ss} {'x':  'y'}",   "x",  "'y'" },
+    { "@a{ss} {'x':  'y'}",   "y",  NULL  },
+    { "@a{os} {'/x': 'y'}",   "/x", "'y'" },
+    { "@a{os} {'/x': 'y'}",   "/y", NULL  },
+    { "@a{sv} {'x':  <'y'>}", "x",  "'y'" },
+    { "@a{sv} {'x':  <5>}",   "x",  "5"   },
+    { "@a{sv} {'x':  <'y'>}", "y",  NULL  }
+  };
+  gsize i;
+
+  for (i = 0; i < G_N_ELEMENTS (cases); i++)
+    {
+      GVariant *dictionary;
+      GVariant *value;
+      gchar *p;
+      
+      dictionary = g_variant_parse (NULL, cases[i].dict, NULL, NULL, NULL);
+      value = g_variant_lookup_value (dictionary, cases[i].key, NULL);
+      g_variant_unref (dictionary);
+
+      if (value == NULL && cases[i].value == NULL)
+        continue;
+
+      g_assert_true (value && cases[i].value);
+      p = g_variant_print (value, FALSE);
+      g_assert_cmpstr (cases[i].value, ==, p);
+      g_variant_unref (value);
+      g_free (p);
+    }
+}
+
+static void
+test_lookup (void)
+{
+  const gchar *str;
+  GVariant *dict;
+  gboolean ok;
+  gint num;
+
+  dict = g_variant_parse (NULL,
+                          "{'a': <5>, 'b': <'c'>}",
+                          NULL, NULL, NULL);
+
+  ok = g_variant_lookup (dict, "a", "i", &num);
+  g_assert_true (ok);
+  g_assert_cmpint (num, ==, 5);
+
+  ok = g_variant_lookup (dict, "a", "&s", &str);
+  g_assert_false (ok);
+
+  ok = g_variant_lookup (dict, "q", "&s", &str);
+  g_assert_false (ok);
+
+  ok = g_variant_lookup (dict, "b", "i", &num);
+  g_assert_false (ok);
+
+  ok = g_variant_lookup (dict, "b", "&s", &str);
+  g_assert_true (ok);
+  g_assert_cmpstr (str, ==, "c");
+
+  ok = g_variant_lookup (dict, "q", "&s", &str);
+  g_assert_false (ok);
+
+  g_variant_unref (dict);
+}
+
+static GVariant *
+untrusted (GVariant *a)
+{
+  GVariant *b;
+  const GVariantType *type;
+  GBytes *bytes;
+
+  type = g_variant_get_type (a);
+  bytes = g_variant_get_data_as_bytes (a);
+  b = g_variant_new_from_bytes (type, bytes, FALSE);
+  g_bytes_unref (bytes);
+  g_variant_unref (a);
+
+  return b;
+}
+
+static void
+test_compare (void)
+{
+  GVariant *a;
+  GVariant *b;
+
+  a = untrusted (g_variant_new_byte (5));
+  b = g_variant_new_byte (6);
+  g_assert_cmpint (g_variant_compare (a, b), <, 0);
+  g_variant_unref (a);
+  g_variant_unref (b);
+  a = untrusted (g_variant_new_int16 (G_MININT16));
+  b = g_variant_new_int16 (G_MAXINT16);
+  g_assert_cmpint (g_variant_compare (a, b), <, 0);
+  g_variant_unref (a);
+  g_variant_unref (b);
+  a = untrusted (g_variant_new_uint16 (0));
+  b = g_variant_new_uint16 (G_MAXUINT16);
+  g_assert_cmpint (g_variant_compare (a, b), <, 0);
+  g_variant_unref (a);
+  g_variant_unref (b);
+  a = untrusted (g_variant_new_int32 (G_MININT32));
+  b = g_variant_new_int32 (G_MAXINT32);
+  g_assert_cmpint (g_variant_compare (a, b), <, 0);
+  g_variant_unref (a);
+  g_variant_unref (b);
+  a = untrusted (g_variant_new_uint32 (0));
+  b = g_variant_new_uint32 (G_MAXUINT32);
+  g_assert_cmpint (g_variant_compare (a, b), <, 0);
+  g_variant_unref (a);
+  g_variant_unref (b);
+  a = untrusted (g_variant_new_int64 (G_MININT64));
+  b = g_variant_new_int64 (G_MAXINT64);
+  g_assert_cmpint (g_variant_compare (a, b), <, 0);
+  g_variant_unref (a);
+  g_variant_unref (b);
+  a = untrusted (g_variant_new_uint64 (0));
+  b = g_variant_new_uint64 (G_MAXUINT64);
+  g_assert_cmpint (g_variant_compare (a, b), <, 0);
+  g_variant_unref (a);
+  g_variant_unref (b);
+  a = untrusted (g_variant_new_double (G_MINDOUBLE));
+  b = g_variant_new_double (G_MAXDOUBLE);
+  g_assert_cmpint (g_variant_compare (a, b), <, 0);
+  g_variant_unref (a);
+  g_variant_unref (b);
+  a = untrusted (g_variant_new_string ("abc"));
+  b = g_variant_new_string ("abd");
+  g_assert_cmpint (g_variant_compare (a, b), <, 0);
+  g_variant_unref (a);
+  g_variant_unref (b);
+  a = untrusted (g_variant_new_object_path ("/abc"));
+  b = g_variant_new_object_path ("/abd");
+  g_assert_cmpint (g_variant_compare (a, b), <, 0);
+  g_variant_unref (a);
+  g_variant_unref (b);
+  a = untrusted (g_variant_new_signature ("g"));
+  b = g_variant_new_signature ("o");
+  g_assert_cmpint (g_variant_compare (a, b), <, 0);
+  g_variant_unref (a);
+  g_variant_unref (b);
+  a = untrusted (g_variant_new_boolean (FALSE));
+  b = g_variant_new_boolean (TRUE);
+  g_assert_cmpint (g_variant_compare (a, b), <, 0);
+  g_variant_unref (a);
+  g_variant_unref (b);
+}
+
+static void
+test_equal (void)
+{
+  GVariant *a;
+  GVariant *b;
+
+  a = untrusted (g_variant_new_byte (5));
+  b = g_variant_get_normal_form (a);
+  g_assert_cmpvariant (a, b);
+  g_variant_unref (a);
+  g_variant_unref (b);
+  a = untrusted (g_variant_new_int16 (G_MININT16));
+  b = g_variant_get_normal_form (a);
+  g_assert_cmpvariant (a, b);
+  g_variant_unref (a);
+  g_variant_unref (b);
+  a = untrusted (g_variant_new_uint16 (0));
+  b = g_variant_get_normal_form (a);
+  g_assert_cmpvariant (a, b);
+  g_variant_unref (a);
+  g_variant_unref (b);
+  a = untrusted (g_variant_new_int32 (G_MININT32));
+  b = g_variant_get_normal_form (a);
+  g_assert_cmpvariant (a, b);
+  g_variant_unref (a);
+  g_variant_unref (b);
+  a = untrusted (g_variant_new_uint32 (0));
+  b = g_variant_get_normal_form (a);
+  g_assert_cmpvariant (a, b);
+  g_variant_unref (a);
+  g_variant_unref (b);
+  a = untrusted (g_variant_new_int64 (G_MININT64));
+  b = g_variant_get_normal_form (a);
+  g_assert_cmpvariant (a, b);
+  g_variant_unref (a);
+  g_variant_unref (b);
+  a = untrusted (g_variant_new_uint64 (0));
+  b = g_variant_get_normal_form (a);
+  g_assert_cmpvariant (a, b);
+  g_variant_unref (a);
+  g_variant_unref (b);
+  a = untrusted (g_variant_new_double (G_MINDOUBLE));
+  b = g_variant_get_normal_form (a);
+  g_assert_cmpvariant (a, b);
+  g_variant_unref (a);
+  g_variant_unref (b);
+  a = untrusted (g_variant_new_string ("abc"));
+  g_assert_cmpvariant (a, a);
+  b = g_variant_get_normal_form (a);
+  g_assert_cmpvariant (a, b);
+  g_variant_unref (a);
+  g_variant_unref (b);
+  a = untrusted (g_variant_new_object_path ("/abc"));
+  g_assert_cmpvariant (a, a);
+  b = g_variant_get_normal_form (a);
+  a = untrusted (a);
+  g_assert_cmpvariant (a, b);
+  g_variant_unref (a);
+  g_variant_unref (b);
+  a = untrusted (g_variant_new_signature ("g"));
+  g_assert_cmpvariant (a, a);
+  b = g_variant_get_normal_form (a);
+  a = untrusted (a);
+  g_assert_cmpvariant (a, b);
+  g_variant_unref (a);
+  g_variant_unref (b);
+  a = untrusted (g_variant_new_boolean (FALSE));
+  b = g_variant_get_normal_form (a);
+  g_assert_cmpvariant (a, b);
+  g_variant_unref (a);
+  g_variant_unref (b);
+}
+
+static void
+test_fixed_array (void)
+{
+  GVariant *a;
+  gint32 values[5];
+  const gint32 *elts;
+  gsize n_elts;
+  gsize i;
+
+  n_elts = 0;
+  a = g_variant_new_parsed ("[1,2,3,4,5]");
+  elts = g_variant_get_fixed_array (a, &n_elts, sizeof (gint32));
+  g_assert_cmpuint (n_elts, ==, 5);
+  for (i = 0; i < 5; i++)
+    g_assert_cmpint (elts[i], ==, i + 1);
+  g_variant_unref (a);
+
+  n_elts = 0;
+  for (i = 0; i < 5; i++)
+    values[i] = i + 1;
+  a = g_variant_new_fixed_array (G_VARIANT_TYPE_INT32, values,
+                                 G_N_ELEMENTS (values), sizeof (values[0]));
+  g_assert_cmpstr (g_variant_get_type_string (a), ==, "ai");
+  elts = g_variant_get_fixed_array (a, &n_elts, sizeof (gint32));
+  g_assert_cmpuint (n_elts, ==, 5);
+  for (i = 0; i < 5; i++)
+    g_assert_cmpint (elts[i], ==, i + 1);
+  g_variant_unref (a);
+}
+
+static void
+test_check_format_string (void)
+{
+  GVariant *value;
+
+  value = g_variant_new ("(sas)", "foo", NULL);
+  g_variant_ref_sink (value);
+
+  g_assert_true (g_variant_check_format_string (value, "(s*)", TRUE));
+  g_assert_true (g_variant_check_format_string (value, "(s*)", FALSE));
+  g_assert_false (g_variant_check_format_string (value, "(u*)", TRUE));
+  g_assert_false (g_variant_check_format_string (value, "(u*)", FALSE));
+
+  g_assert_true (g_variant_check_format_string (value, "(&s*)", FALSE));
+  g_test_expect_message ("GLib", G_LOG_LEVEL_CRITICAL, "*contains a '&' character*");
+  g_assert_false (g_variant_check_format_string (value, "(&s*)", TRUE));
+  g_test_assert_expected_messages ();
+
+  g_assert_true (g_variant_check_format_string (value, "(s^as)", TRUE));
+  g_assert_true (g_variant_check_format_string (value, "(s^as)", FALSE));
+
+  g_test_expect_message ("GLib", G_LOG_LEVEL_CRITICAL, "*contains a '&' character*");
+  g_assert_false (g_variant_check_format_string (value, "(s^a&s)", TRUE));
+  g_test_assert_expected_messages ();
+  g_assert_true (g_variant_check_format_string (value, "(s^a&s)", FALSE));
+
+  g_variant_unref (value);
+
+  /* Do it again with a type that will let us put a '&' after a '^' */
+  value = g_variant_new ("(say)", "foo", NULL);
+  g_variant_ref_sink (value);
+
+  g_assert_true (g_variant_check_format_string (value, "(s*)", TRUE));
+  g_assert_true (g_variant_check_format_string (value, "(s*)", FALSE));
+  g_assert_false (g_variant_check_format_string (value, "(u*)", TRUE));
+  g_assert_false (g_variant_check_format_string (value, "(u*)", FALSE));
+
+  g_assert_true (g_variant_check_format_string (value, "(&s*)", FALSE));
+  g_test_expect_message ("GLib", G_LOG_LEVEL_CRITICAL, "*contains a '&' character*");
+  g_assert_false (g_variant_check_format_string (value, "(&s*)", TRUE));
+  g_test_assert_expected_messages ();
+
+  g_assert_true (g_variant_check_format_string (value, "(s^ay)", TRUE));
+  g_assert_true (g_variant_check_format_string (value, "(s^ay)", FALSE));
+
+  g_test_expect_message ("GLib", G_LOG_LEVEL_CRITICAL, "*contains a '&' character*");
+  g_assert_false (g_variant_check_format_string (value, "(s^&ay)", TRUE));
+  g_test_assert_expected_messages ();
+  g_assert_true (g_variant_check_format_string (value, "(s^&ay)", FALSE));
+
+  g_assert_true (g_variant_check_format_string (value, "r", FALSE));
+  g_assert_true (g_variant_check_format_string (value, "(?a?)", FALSE));
+
+  g_variant_unref (value);
+}
+
+static void
+verify_gvariant_checksum (const gchar  *sha256,
+			  GVariant     *v)
+	     
+{
+  gchar *checksum;
+  checksum = g_compute_checksum_for_data (G_CHECKSUM_SHA256,
+					  g_variant_get_data (v),
+					  g_variant_get_size (v));
+  g_assert_cmpstr (sha256, ==, checksum);
+  g_free (checksum);
+}
+
+static void
+verify_gvariant_checksum_va (const gchar *sha256,
+			     const gchar *fmt,
+			     ...)
+{
+  va_list args;
+  GVariant *v;
+
+  va_start (args, fmt);
+
+  v = g_variant_new_va (fmt, NULL, &args);
+  g_variant_ref_sink (v);
+#if G_BYTE_ORDER == G_BIG_ENDIAN
+  {
+    GVariant *byteswapped = g_variant_byteswap (v);
+    g_variant_unref (v);
+    v = byteswapped;
+  }
+#endif
+
+  va_end (args);
+
+  verify_gvariant_checksum (sha256, v);
+
+  g_variant_unref (v);
+}
+
+static void
+test_checksum_basic (void)
+{
+  verify_gvariant_checksum_va ("e8a4b2ee7ede79a3afb332b5b6cc3d952a65fd8cffb897f5d18016577c33d7cc",
+			       "u", 42);
+  verify_gvariant_checksum_va ("c53e363c33b00cfce298229ee83856b8a98c2e6126cab13f65899f62473b0df5",
+			       "s", "moocow");
+  verify_gvariant_checksum_va ("2b4c342f5433ebe591a1da77e013d1b72475562d48578dca8b84bac6651c3cb9",
+			       "y", 9);
+  verify_gvariant_checksum_va ("12a3ae445661ce5dee78d0650d33362dec29c4f82af05e7e57fb595bbbacf0ca",
+			       "t", G_MAXUINT64);
+  verify_gvariant_checksum_va ("e25a59b24440eb6c833aa79c93b9840e6eab6966add0dacf31df7e9e7000f5b3",
+			       "d", 3.14159);
+  verify_gvariant_checksum_va ("4bf5122f344554c53bde2ebb8cd2b7e3d1600ad631c385a5d7cce23c7785459a",
+			       "b", TRUE);
+  verify_gvariant_checksum_va ("ca2fd00fa001190744c15c317643ab092e7048ce086a243e2be9437c898de1bb",
+			       "q", G_MAXUINT16);
+}
+
+static void
+test_checksum_nested (void)
+{
+  static const char* const strv[] = {"foo", "bar", "baz", NULL};
+
+  verify_gvariant_checksum_va ("31fbc92f08fddaca716188fe4b5d44ae122fc6306fd3c6925af53cfa47ea596d",
+			       "(uu)", 41, 43);
+  verify_gvariant_checksum_va ("01759d683cead856d1d386d59af0578841698a424a265345ad5413122f220de8",
+			       "(su)", "moocow", 79);
+  verify_gvariant_checksum_va ("52b3ae95f19b3e642ea1d01185aea14a09004c1d1712672644427403a8a0afe6",
+			       "(qyst)", G_MAXUINT16, 9, "moocow", G_MAXUINT64);
+  verify_gvariant_checksum_va ("6fc6f4524161c3ae0d316812d7088e3fcd372023edaea2d7821093be40ae1060",
+			       "(@ay)", g_variant_new_bytestring ("\xFF\xFF\xFF"));
+  verify_gvariant_checksum_va ("572aca386e1a983dd23bb6eb6e3dfa72eef9ca7c7744581aa800e18d7d9d0b0b",
+			       "(^as)", strv);
+  verify_gvariant_checksum_va ("4bddf6174c791bb44fc6a4106573031690064df34b741033a0122ed8dc05bcf3",
+			       "(yvu)", 254, g_variant_new ("(^as)", strv), 42);
+}
+
+static void
+test_gbytes (void)
+{
+  GVariant *a;
+  GVariant *tuple;
+  GBytes *bytes;
+  GBytes *bytes2;
+  const guint8 values[5] = { 1, 2, 3, 4, 5 };
+  const guint8 *elts;
+  gsize n_elts;
+  gsize i;
+
+  bytes = g_bytes_new (&values, 5);
+  a = g_variant_new_from_bytes (G_VARIANT_TYPE_BYTESTRING, bytes, TRUE);
+  g_bytes_unref (bytes);
+  n_elts = 0;
+  elts = g_variant_get_fixed_array (a, &n_elts, sizeof (guint8));
+  g_assert_cmpuint (n_elts, ==, 5);
+  for (i = 0; i < 5; i++)
+    g_assert_cmpuint (elts[i], ==, i + 1);
+
+  bytes2 = g_variant_get_data_as_bytes (a);
+  g_variant_unref (a);
+
+  bytes = g_bytes_new (&values, 5);
+  g_assert_true (g_bytes_equal (bytes, bytes2));
+  g_bytes_unref (bytes);
+  g_bytes_unref (bytes2);
+
+  tuple = g_variant_new_parsed ("['foo', 'bar']");
+  bytes = g_variant_get_data_as_bytes (tuple); /* force serialization */
+  a = g_variant_get_child_value (tuple, 1);
+  bytes2 = g_variant_get_data_as_bytes (a);
+  g_assert_false (g_bytes_equal (bytes, bytes2));
+
+  g_bytes_unref (bytes);
+  g_bytes_unref (bytes2);
+  g_variant_unref (a);
+  g_variant_unref (tuple);
+}
+
+typedef struct {
+  const GVariantType *type;
+  const gchar *in;
+  const gchar *out;
+} ContextTest;
+
+static void
+test_print_context (void)
+{
+  ContextTest tests[] = {
+    { NULL, "(1, 2, 3, 'abc", "          ^^^^" },
+    { NULL, "[1, 2, 3, 'str']", " ^        ^^^^^" },
+    { G_VARIANT_TYPE_UINT16, "{ 'abc':'def' }", "  ^^^^^^^^^^^^^^^" },
+    { NULL, "<5", "    ^" },
+    { NULL, "'ab\\ux'", "       ^ " },
+    { NULL, "'ab\\U00efx'", "       ^^^^  " }
+  };
+  GVariant *v;
+  gchar *s;
+  gsize i;
+  GError *error = NULL;
+
+  for (i = 0; i < G_N_ELEMENTS (tests); i++)
+    {
+      v = g_variant_parse (tests[i].type, tests[i].in, NULL, NULL, &error);
+      g_assert_null (v);
+      s = g_variant_parse_error_print_context (error, tests[i].in);
+      g_assert_nonnull (strstr (s, tests[i].out));
+      g_free (s);
+      g_clear_error (&error);
+    }
+}
+
+static void
+test_error_quark (void)
+{
+G_GNUC_BEGIN_IGNORE_DEPRECATIONS
+  g_assert_cmpuint (g_variant_parser_get_error_quark (), ==, g_variant_parse_error_quark ());
+G_GNUC_END_IGNORE_DEPRECATIONS
+}
+
+static void
+test_stack_builder_init (void)
+{
+  GVariantBuilder builder = G_VARIANT_BUILDER_INIT (G_VARIANT_TYPE_BYTESTRING);
+  GVariant *variant;
+
+  g_variant_builder_add_value (&builder, g_variant_new_byte ('g'));
+  g_variant_builder_add_value (&builder, g_variant_new_byte ('l'));
+  g_variant_builder_add_value (&builder, g_variant_new_byte ('i'));
+  g_variant_builder_add_value (&builder, g_variant_new_byte ('b'));
+  g_variant_builder_add_value (&builder, g_variant_new_byte ('\0'));
+
+  variant = g_variant_ref_sink (g_variant_builder_end (&builder));
+  g_assert_nonnull (variant);
+  g_assert_true (g_variant_type_equal (g_variant_get_type (variant),
+                                       G_VARIANT_TYPE_BYTESTRING));
+  g_assert_cmpuint (g_variant_n_children (variant), ==, 5);
+  g_assert_cmpstr (g_variant_get_bytestring (variant), ==, "glib");
+  g_variant_unref (variant);
+}
+
+static GVariant *
+get_asv (void)
+{
+  GVariantBuilder builder = G_VARIANT_BUILDER_INIT (G_VARIANT_TYPE_VARDICT);
+
+  g_variant_builder_add (&builder, "{s@v}", "foo", g_variant_new_variant (g_variant_new_string ("FOO")));
+  g_variant_builder_add (&builder, "{s@v}", "bar", g_variant_new_variant (g_variant_new_string ("BAR")));
+
+  return g_variant_ref_sink (g_variant_builder_end (&builder));
+}
+
+static void
+test_stack_dict_init (void)
+{
+  GVariant *asv = get_asv ();
+  GVariantDict dict = G_VARIANT_DICT_INIT (asv);
+  GVariant *variant;
+  GVariantIter iter;
+  gchar *key;
+  GVariant *value;
+
+  g_variant_dict_insert_value (&dict, "baz", g_variant_new_string ("BAZ"));
+  g_variant_dict_insert_value (&dict, "quux", g_variant_new_string ("QUUX"));
+
+  variant = g_variant_ref_sink (g_variant_dict_end (&dict));
+  g_assert_nonnull (variant);
+  g_assert_true (g_variant_type_equal (g_variant_get_type (variant),
+                                       G_VARIANT_TYPE_VARDICT));
+  g_assert_cmpuint (g_variant_n_children (variant), ==, 4);
+
+  g_variant_iter_init (&iter, variant);
+  while (g_variant_iter_next (&iter, "{sv}", &key, &value))
+    {
+      gchar *strup = g_ascii_strup (key, -1);
+
+      g_assert_cmpstr (strup, ==, g_variant_get_string (value, NULL));
+      g_free (key);
+      g_free (strup);
+      g_variant_unref (value);
+    }
+
+  g_variant_unref (asv);
+  g_variant_unref (variant);
+}
+
+/* Test checking arbitrary binary data for normal form. This time, it’s a tuple
+ * with invalid element ends. */
+static void
+test_normal_checking_tuples (void)
+{
+  const guint8 data[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
+    'a', '(', 'a', 'o', 'a', 'o', 'a', 'a', 'o', 'a', 'a', 'o', ')'
+  };
+  gsize size = sizeof (data);
+  GVariant *variant = NULL;
+  GVariant *normal_variant = NULL;
+
+  variant = g_variant_new_from_data (G_VARIANT_TYPE_VARIANT, data, size,
+                                     FALSE, NULL, NULL);
+  g_assert_nonnull (variant);
+
+  normal_variant = g_variant_get_normal_form (variant);
+  g_assert_nonnull (normal_variant);
+
+  g_variant_unref (normal_variant);
+  g_variant_unref (variant);
+}
+
+/* Check that deeply nested variants are not considered in normal form when
+ * deserialized from untrusted data.*/
+static void
+test_recursion_limits_variant_in_variant (void)
+{
+  GVariant *wrapper_variant = NULL;
+  gsize i;
+  GBytes *bytes = NULL;
+  GVariant *deserialised_variant = NULL;
+
+  /* Construct a hierarchy of variants, containing a single string. This is just
+   * below the maximum recursion level, as a series of nested variant types. */
+  wrapper_variant = g_variant_new_string ("hello");
+
+  for (i = 0; i < G_VARIANT_MAX_RECURSION_DEPTH - 1; i++)
+    wrapper_variant = g_variant_new_variant (g_steal_pointer (&wrapper_variant));
+
+  /* Serialize and deserialize it as untrusted data, to force normalisation. */
+  bytes = g_variant_get_data_as_bytes (wrapper_variant);
+  deserialised_variant = g_variant_new_from_bytes (G_VARIANT_TYPE_VARIANT,
+                                                   bytes, FALSE);
+  g_assert_nonnull (deserialised_variant);
+  g_assert_true (g_variant_is_normal_form (deserialised_variant));
+
+  g_bytes_unref (bytes);
+  g_variant_unref (deserialised_variant);
+
+  /* Wrap it once more. Normalisation should now fail. */
+  wrapper_variant = g_variant_new_variant (g_steal_pointer (&wrapper_variant));
+
+  bytes = g_variant_get_data_as_bytes (wrapper_variant);
+  deserialised_variant = g_variant_new_from_bytes (G_VARIANT_TYPE_VARIANT,
+                                                   bytes, FALSE);
+  g_assert_nonnull (deserialised_variant);
+  g_assert_false (g_variant_is_normal_form (deserialised_variant));
+
+  g_variant_unref (deserialised_variant);
+
+  /* Deserialize it again, but trusted this time. This should succeed. */
+  deserialised_variant = g_variant_new_from_bytes (G_VARIANT_TYPE_VARIANT,
+                                                   bytes, TRUE);
+  g_assert_nonnull (deserialised_variant);
+  g_assert_true (g_variant_is_normal_form (deserialised_variant));
+
+  g_bytes_unref (bytes);
+  g_variant_unref (deserialised_variant);
+  g_variant_unref (wrapper_variant);
+}
+
+/* Check that deeply nested arrays are not considered in normal form when
+ * deserialized from untrusted data after being wrapped in a variant. This is
+ * worth testing, because neither the deeply nested array, nor the variant,
+ * have a static #GVariantType which is too deep — only when nested together do
+ * they become too deep. */
+static void
+test_recursion_limits_array_in_variant (void)
+{
+  GVariant *child_variant = NULL;
+  GVariant *wrapper_variant = NULL;
+  gsize i;
+  GBytes *bytes = NULL;
+  GVariant *deserialised_variant = NULL;
+
+  /* Construct a hierarchy of arrays, containing a single string. This is just
+   * below the maximum recursion level, all in a single definite type. */
+  child_variant = g_variant_new_string ("hello");
+
+  for (i = 0; i < G_VARIANT_MAX_RECURSION_DEPTH - 1; i++)
+    child_variant = g_variant_new_array (NULL, &child_variant, 1);
+
+  /* Serialize and deserialize it as untrusted data, to force normalisation. */
+  bytes = g_variant_get_data_as_bytes (child_variant);
+  deserialised_variant = g_variant_new_from_bytes (g_variant_get_type (child_variant),
+                                                   bytes, FALSE);
+  g_assert_nonnull (deserialised_variant);
+  g_assert_true (g_variant_is_normal_form (deserialised_variant));
+
+  g_bytes_unref (bytes);
+  g_variant_unref (deserialised_variant);
+
+  /* Wrap it in a variant. Normalisation should now fail. */
+  wrapper_variant = g_variant_new_variant (g_steal_pointer (&child_variant));
+
+  bytes = g_variant_get_data_as_bytes (wrapper_variant);
+  deserialised_variant = g_variant_new_from_bytes (G_VARIANT_TYPE_VARIANT,
+                                                   bytes, FALSE);
+  g_assert_nonnull (deserialised_variant);
+  g_assert_false (g_variant_is_normal_form (deserialised_variant));
+
+  g_variant_unref (deserialised_variant);
+
+  /* Deserialize it again, but trusted this time. This should succeed. */
+  deserialised_variant = g_variant_new_from_bytes (G_VARIANT_TYPE_VARIANT,
+                                                   bytes, TRUE);
+  g_assert_nonnull (deserialised_variant);
+  g_assert_true (g_variant_is_normal_form (deserialised_variant));
+
+  g_bytes_unref (bytes);
+  g_variant_unref (deserialised_variant);
+  g_variant_unref (wrapper_variant);
+}
+
+/* Test that an array with invalidly large values in its offset table is
+ * normalised successfully without looping infinitely. */
+static void
+test_normal_checking_array_offsets (void)
+{
+  const guint8 data[] = {
+    0x07, 0xe5, 0x00, 0x07, 0x00, 0x07, 0x00, 0x00,
+    'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'g',
+  };
+  gsize size = sizeof (data);
+  GVariant *variant = NULL;
+  GVariant *normal_variant = NULL;
+
+  variant = g_variant_new_from_data (G_VARIANT_TYPE_VARIANT, data, size,
+                                     FALSE, NULL, NULL);
+  g_assert_nonnull (variant);
+
+  normal_variant = g_variant_get_normal_form (variant);
+  g_assert_nonnull (normal_variant);
+
+  g_variant_unref (normal_variant);
+  g_variant_unref (variant);
+}
+
+/* Test that a tuple with invalidly large values in its offset table is
+ * normalised successfully without looping infinitely. */
+static void
+test_normal_checking_tuple_offsets (void)
+{
+  const guint8 data[] = {
+    0x07, 0xe5, 0x00, 0x07, 0x00, 0x07,
+    '(', 'a', 's', 'a', 's', 'a', 's', 'a', 's', 'a', 's', 'a', 's', ')',
+  };
+  gsize size = sizeof (data);
+  GVariant *variant = NULL;
+  GVariant *normal_variant = NULL;
+
+  variant = g_variant_new_from_data (G_VARIANT_TYPE_VARIANT, data, size,
+                                     FALSE, NULL, NULL);
+  g_assert_nonnull (variant);
+
+  normal_variant = g_variant_get_normal_form (variant);
+  g_assert_nonnull (normal_variant);
+
+  g_variant_unref (normal_variant);
+  g_variant_unref (variant);
+}
+
+/* Test that an empty object path is normalised successfully to the base object
+ * path, ‘/’. */
+static void
+test_normal_checking_empty_object_path (void)
+{
+  const guint8 data[] = {
+    0x20, 0x20, 0x00, 0x00, 0x00, 0x00,
+    '(', 'h', '(', 'a', 'i', 'a', 'b', 'i', 'o', ')', ')',
+  };
+  gsize size = sizeof (data);
+  GVariant *variant = NULL;
+  GVariant *normal_variant = NULL;
+
+  variant = g_variant_new_from_data (G_VARIANT_TYPE_VARIANT, data, size,
+                                     FALSE, NULL, NULL);
+  g_assert_nonnull (variant);
+
+  normal_variant = g_variant_get_normal_form (variant);
+  g_assert_nonnull (normal_variant);
+
+  g_variant_unref (normal_variant);
+  g_variant_unref (variant);
+}
+
+/* Test that constructing a #GVariant from data which is not correctly aligned
+ * for the variant type is OK, by loading a variant from data at various offsets
+ * which are aligned and unaligned. When unaligned, a slow construction path
+ * should be taken. */
+static void
+test_unaligned_construction (void)
+{
+  const guint8 data[] = {
+    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+  };
+  GVariant *variant = NULL;
+  GVariant *normal_variant = NULL;
+  gsize i, offset;
+  const struct {
+    const GVariantType *type;
+    gsize size;
+    gsize max_offset;
+  } vectors[] = {
+    { G_VARIANT_TYPE_UINT64, sizeof (guint64), sizeof (guint64) },
+    { G_VARIANT_TYPE_UINT32, sizeof (guint32), sizeof (guint32) },
+    { G_VARIANT_TYPE_UINT16, sizeof (guint16), sizeof (guint16) },
+    { G_VARIANT_TYPE_BYTE, sizeof (guint8), 3 },
+  };
+
+  G_STATIC_ASSERT (sizeof (guint64) * 2 <= sizeof (data));
+
+  for (i = 0; i < G_N_ELEMENTS (vectors); i++)
+    {
+      for (offset = 0; offset < vectors[i].max_offset; offset++)
+        {
+          variant = g_variant_new_from_data (vectors[i].type, data + offset,
+                                             vectors[i].size,
+                                             FALSE, NULL, NULL);
+          g_assert_nonnull (variant);
+
+          normal_variant = g_variant_get_normal_form (variant);
+          g_assert_nonnull (normal_variant);
+
+          g_variant_unref (normal_variant);
+          g_variant_unref (variant);
+        }
+    }
+}
+
+int
+main (int argc, char **argv)
+{
+  guint i;
+
+  g_test_init (&argc, &argv, NULL);
+
+  g_test_add_func ("/gvariant/type", test_gvarianttype);
+  g_test_add_func ("/gvariant/type/string-scan/recursion/tuple",
+                   test_gvarianttype_string_scan_recursion_tuple);
+  g_test_add_func ("/gvariant/type/string-scan/recursion/array",
+                   test_gvarianttype_string_scan_recursion_array);
+  g_test_add_func ("/gvariant/typeinfo", test_gvarianttypeinfo);
+  g_test_add_func ("/gvariant/serialiser/maybe", test_maybes);
+  g_test_add_func ("/gvariant/serialiser/array", test_arrays);
+  g_test_add_func ("/gvariant/serialiser/tuple", test_tuples);
+  g_test_add_func ("/gvariant/serialiser/variant", test_variants);
+  g_test_add_func ("/gvariant/serialiser/strings", test_strings);
+  g_test_add_func ("/gvariant/serialiser/byteswap", test_byteswaps);
+  g_test_add_func ("/gvariant/serialiser/children", test_serialiser_children);
+
+  for (i = 1; i <= 20; i += 4)
+    {
+      char *testname;
+
+      testname = g_strdup_printf ("/gvariant/serialiser/fuzz/%u%%", i);
+      g_test_add_data_func (testname, GINT_TO_POINTER (i),
+                            (gpointer) test_fuzzes);
+      g_free (testname);
+    }
+
+  g_test_add_func ("/gvariant/string", test_string);
+  g_test_add_func ("/gvariant/utf8", test_utf8);
+  g_test_add_func ("/gvariant/containers", test_containers);
+  g_test_add_func ("/gvariant/format-strings", test_format_strings);
+  g_test_add_func ("/gvariant/invalid-varargs", test_invalid_varargs);
+  g_test_add_func ("/gvariant/varargs", test_varargs);
+  g_test_add_func ("/gvariant/varargs/subprocess/empty-array", test_varargs_empty_array);
+  g_test_add_func ("/gvariant/valist", test_valist);
+  g_test_add_func ("/gvariant/builder-memory", test_builder_memory);
+  g_test_add_func ("/gvariant/hashing", test_hashing);
+  g_test_add_func ("/gvariant/byteswap", test_gv_byteswap);
+  g_test_add_func ("/gvariant/parser", test_parses);
+  g_test_add_func ("/gvariant/parser/integer-bounds", test_parser_integer_bounds);
+  g_test_add_func ("/gvariant/parser/recursion", test_parser_recursion);
+  g_test_add_func ("/gvariant/parse-failures", test_parse_failures);
+  g_test_add_func ("/gvariant/parse-positional", test_parse_positional);
+  g_test_add_func ("/gvariant/parse/subprocess/bad-format-char", test_parse_bad_format_char);
+  g_test_add_func ("/gvariant/parse/subprocess/bad-format-string", test_parse_bad_format_string);
+  g_test_add_func ("/gvariant/parse/subprocess/bad-args", test_parse_bad_args);
+  g_test_add_func ("/gvariant/floating", test_floating);
+  g_test_add_func ("/gvariant/bytestring", test_bytestring);
+  g_test_add_func ("/gvariant/lookup-value", test_lookup_value);
+  g_test_add_func ("/gvariant/lookup", test_lookup);
+  g_test_add_func ("/gvariant/compare", test_compare);
+  g_test_add_func ("/gvariant/equal", test_equal);
+  g_test_add_func ("/gvariant/fixed-array", test_fixed_array);
+  g_test_add_func ("/gvariant/check-format-string", test_check_format_string);
+
+  g_test_add_func ("/gvariant/checksum-basic", test_checksum_basic);
+  g_test_add_func ("/gvariant/checksum-nested", test_checksum_nested);
+
+  g_test_add_func ("/gvariant/gbytes", test_gbytes);
+  g_test_add_func ("/gvariant/print-context", test_print_context);
+  g_test_add_func ("/gvariant/error-quark", test_error_quark);
+
+  g_test_add_func ("/gvariant/stack-builder-init", test_stack_builder_init);
+  g_test_add_func ("/gvariant/stack-dict-init", test_stack_dict_init);
+
+  g_test_add_func ("/gvariant/normal-checking/tuples",
+                   test_normal_checking_tuples);
+  g_test_add_func ("/gvariant/normal-checking/array-offsets",
+                   test_normal_checking_array_offsets);
+  g_test_add_func ("/gvariant/normal-checking/tuple-offsets",
+                   test_normal_checking_tuple_offsets);
+  g_test_add_func ("/gvariant/normal-checking/empty-object-path",
+                   test_normal_checking_empty_object_path);
+
+  g_test_add_func ("/gvariant/recursion-limits/variant-in-variant",
+                   test_recursion_limits_variant_in_variant);
+  g_test_add_func ("/gvariant/recursion-limits/array-in-variant",
+                   test_recursion_limits_array_in_variant);
+
+  g_test_add_func ("/gvariant/unaligned-construction",
+                   test_unaligned_construction);
+
+  return g_test_run ();
+}
-- 
2.34.1

