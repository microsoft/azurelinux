From ec78ea01c197d46ed44c226613536490a6b0c87f Mon Sep 17 00:00:00 2001
From: Kshitiz Godara <kgodara@microsoft.com>
Date: Mon, 16 Jun 2025 14:01:28 +0000
Subject: [PATCH] Fix for CVE-2019-13627

Upstream reference:
https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libgcrypt.git;a=commit;h=db4e9976cc31b314aafad6626b2894e86ee44d60
---
 grub-core/lib/libgcrypt/cipher/dsa.c | 14 ++++++++++++--
 grub-core/lib/libgcrypt/mpi/ec.c     |  6 +++++-
 2 files changed, 17 insertions(+), 3 deletions(-)

diff --git a/grub-core/lib/libgcrypt/cipher/dsa.c b/grub-core/lib/libgcrypt/cipher/dsa.c
index 883a815..1d77305 100644
--- a/grub-core/lib/libgcrypt/cipher/dsa.c
+++ b/grub-core/lib/libgcrypt/cipher/dsa.c
@@ -600,8 +600,6 @@ check_secret_key( DSA_secret_key *sk )
   return rc;
 }
 
-
-
 /*
    Make a DSA signature from HASH and put it into r and s.
  */
@@ -611,10 +609,22 @@ sign(gcry_mpi_t r, gcry_mpi_t s, gcry_mpi_t hash, DSA_secret_key *skey )
   gcry_mpi_t k;
   gcry_mpi_t kinv;
   gcry_mpi_t tmp;
+  unsigned int qbits = mpi_get_nbits (skey->q);
 
   /* Select a random k with 0 < k < q */
   k = gen_k( skey->q );
 
+  /* Originally, ECDSA computation requires k where 0 < k < n.
+   * Here, we add n (the order of curve), to keep k in a
+   * range: n < k < 2*n, or, addming more n, keep k in a range:
+   * 2*n < k < 3*n, so that timing difference of the EC
+   * multiply operation can be small.  The result is same.
+   */
+  mpi_add (k, k, skey->E.n);
+  if (!mpi_test_bit (k, qbits))
+    mpi_add (k, k, skey->E.n);
+
+
   /* r = (a^k mod p) mod q */
   gcry_mpi_powm( r, skey->g, k, skey->p );
   mpi_fdiv_r( r, r, skey->q );
diff --git a/grub-core/lib/libgcrypt/mpi/ec.c b/grub-core/lib/libgcrypt/mpi/ec.c
index fa00818..0089347 100644
--- a/grub-core/lib/libgcrypt/mpi/ec.c
+++ b/grub-core/lib/libgcrypt/mpi/ec.c
@@ -617,7 +617,11 @@ _gcry_mpi_ec_mul_point (mpi_point_t *result,
   unsigned int nbits;
   int i;
 
-  nbits = mpi_get_nbits (scalar);
+  if (mpi_cmp (scalar, ctx->p) >= 0)
+    nbits = mpi_get_nbits (scalar);
+  else
+    nbits = mpi_get_nbits (ctx->p);
+
   mpi_set_ui (result->x, 1);
   mpi_set_ui (result->y, 1);
   mpi_set_ui (result->z, 0);
-- 
2.45.3

