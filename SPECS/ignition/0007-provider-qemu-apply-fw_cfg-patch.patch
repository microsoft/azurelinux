From 35265ad5c3948399b9ca85ddb8675cf67961a644 Mon Sep 17 00:00:00 2001
From: Mathieu Tortuyaux <mtortuyaux@microsoft.com>
Date: Tue, 20 Feb 2024 10:02:28 +0100
Subject: [PATCH 07/19] provider/qemu: apply fw_cfg patch

we support both CoreOS and Flatcar fw_cfg path to ensure compatiblity

Signed-off-by: Mathieu Tortuyaux <mtortuyaux@microsoft.com>
---
 internal/providers/qemu/qemu_fwcfg.go | 133 ++++++++++++++------------
 1 file changed, 70 insertions(+), 63 deletions(-)

diff --git a/internal/providers/qemu/qemu_fwcfg.go b/internal/providers/qemu/qemu_fwcfg.go
index 863c9601..e8d4fec7 100644
--- a/internal/providers/qemu/qemu_fwcfg.go
+++ b/internal/providers/qemu/qemu_fwcfg.go
@@ -29,6 +29,7 @@ import (
 	"strings"
 	"time"
 
+	iErrors "github.com/flatcar/ignition/v2/config/shared/errors"
 	"github.com/flatcar/ignition/v2/config/v3_6_experimental/types"
 	"github.com/flatcar/ignition/v2/internal/distro"
 	"github.com/flatcar/ignition/v2/internal/platform"
@@ -38,9 +39,11 @@ import (
 	"github.com/coreos/vcontext/report"
 )
 
-const (
-	firmwareConfigPath     = "/sys/firmware/qemu_fw_cfg/by_name/opt/com.coreos/config/raw"
-	firmwareConfigSizePath = "/sys/firmware/qemu_fw_cfg/by_name/opt/com.coreos/config/size"
+var (
+	firmwareConfigPaths = map[string]string{
+		"/sys/firmware/qemu_fw_cfg/by_name/opt/org.flatcar-linux/config/raw": "/sys/firmware/qemu_fw_cfg/by_name/opt/org.flatcar-linux/config/size",
+		"/sys/firmware/qemu_fw_cfg/by_name/opt/com.coreos/config/raw":        "/sys/firmware/qemu_fw_cfg/by_name/opt/com.coreos/config/size",
+	}
 )
 
 func init() {
@@ -56,72 +59,76 @@ func fetchConfig(f *resource.Fetcher) (cfg types.Config, rpt report.Report, err
 		return
 	}
 
-	// get size of firmware blob, if it exists
-	var sizeBytes []byte
-	sizeBytes, err = os.ReadFile(firmwareConfigSizePath)
-	if os.IsNotExist(err) {
-		f.Logger.Info("QEMU firmware config was not found. Ignoring...")
-		cfg, rpt, err = util.ParseConfig(f.Logger, []byte{})
-		return
-	} else if err != nil {
-		f.Logger.Err("couldn't read QEMU firmware config size: %v", err)
-		return
-	}
-	var size int
-	size, err = strconv.Atoi(strings.TrimSpace(string(sizeBytes)))
-	if err != nil {
-		f.Logger.Err("couldn't parse QEMU firmware config size: %v", err)
-		return
-	}
+	for cfgPath, sizePath := range firmwareConfigPaths {
+		// get size of firmware blob, if it exists
+		var sizeBytes []byte
+		sizeBytes, err = os.ReadFile(sizePath)
+		if os.IsNotExist(err) {
+			f.Logger.Info("QEMU firmware config was not found. Ignoring...")
+			continue
+		} else if err != nil {
+			f.Logger.Err("couldn't read QEMU firmware config size: %v", err)
+			return
+		}
+		var size int
+		size, err = strconv.Atoi(strings.TrimSpace(string(sizeBytes)))
+		if err != nil {
+			f.Logger.Err("couldn't parse QEMU firmware config size: %v", err)
+			return
+		}
 
-	// Read firmware blob.  We need to make as few, large read() calls as
-	// possible, since the qemu_fw_cfg kernel module takes O(offset)
-	// time for each read syscall.  os.ReadFile() would eventually
-	// converge on the correct read size (one page) but we can do
-	// better, and without reallocating.
-	// Leave an extra guard byte to check for EOF
-	data := make([]byte, 0, size+1)
-	var fh *os.File
-	fh, err = os.Open(firmwareConfigPath)
-	if err != nil {
-		f.Logger.Err("couldn't open QEMU firmware config: %v", err)
-		return
-	}
-	defer func() {
-		_ = fh.Close()
-	}()
-	lastReport := time.Now()
-	reporting := false
-	for len(data) < size {
-		// if size is correct, we will never call this at an offset
-		// where it would return io.EOF
-		var n int
-		n, err = fh.Read(data[len(data):cap(data)])
+		// Read firmware blob.  We need to make as few, large read() calls as
+		// possible, since the qemu_fw_cfg kernel module takes O(offset)
+		// time for each read syscall.  os.ReadFile() would eventually
+		// converge on the correct read size (one page) but we can do
+		// better, and without reallocating.
+		// Leave an extra guard byte to check for EOF
+		data := make([]byte, 0, size+1)
+		var fh *os.File
+		fh, err = os.Open(cfgPath)
 		if err != nil {
-			f.Logger.Err("couldn't read QEMU firmware config: %v", err)
+			f.Logger.Err("couldn't open QEMU firmware config: %v", err)
 			return
 		}
-		data = data[:len(data)+n]
-		if !reporting && time.Since(lastReport).Seconds() >= 10 {
-			f.Logger.Warning("Reading QEMU fw_cfg takes quadratic time. Consider moving large files or config fragments to a remote URL.")
-			reporting = true
+		defer func() {
+			fh.Close()
+		}()
+		lastReport := time.Now()
+		reporting := false
+		for len(data) < size {
+			// if size is correct, we will never call this at an offset
+			// where it would return io.EOF
+			var n int
+			n, err = fh.Read(data[len(data):cap(data)])
+			if err != nil {
+				f.Logger.Err("couldn't read QEMU firmware config: %v", err)
+				return
+			}
+			data = data[:len(data)+n]
+			if !reporting && time.Since(lastReport).Seconds() >= 10 {
+				f.Logger.Warning("Reading QEMU fw_cfg takes quadratic time. Consider moving large files or config fragments to a remote URL.")
+				reporting = true
+			}
+			if reporting && (time.Since(lastReport).Seconds() >= 5 || len(data) >= size) {
+				f.Logger.Info("Reading config from QEMU fw_cfg: %d/%d KB", len(data)/1024, size/1024)
+				lastReport = time.Now()
+			}
 		}
-		if reporting && (time.Since(lastReport).Seconds() >= 5 || len(data) >= size) {
-			f.Logger.Info("Reading config from QEMU fw_cfg: %d/%d KB", len(data)/1024, size/1024)
-			lastReport = time.Now()
+		if len(data) > size {
+			// overflowed into guard byte
+			f.Logger.Err("missing EOF reading QEMU firmware config")
+			err = errors.New("missing EOF")
+			return
 		}
-	}
-	if len(data) > size {
-		// overflowed into guard byte
-		f.Logger.Err("missing EOF reading QEMU firmware config")
-		err = errors.New("missing EOF")
+		// If size is not at a page boundary, we know we're at EOF because
+		// the guard byte was not filled.  If size is at a page boundary,
+		// trust that firmwareConfigSizePath was telling the truth to avoid
+		// incurring an extra read call to check for EOF.  We're at the end
+		// of the file so the extra read would be maximally expensive.
+		cfg, rpt, err = util.ParseConfig(f.Logger, data)
 		return
+
 	}
-	// If size is not at a page boundary, we know we're at EOF because
-	// the guard byte was not filled.  If size is at a page boundary,
-	// trust that firmwareConfigSizePath was telling the truth to avoid
-	// incurring an extra read call to check for EOF.  We're at the end
-	// of the file so the extra read would be maximally expensive.
-	cfg, rpt, err = util.ParseConfig(f.Logger, data)
-	return
+	return types.Config{}, report.Report{}, iErrors.ErrEmpty
+
 }
-- 
2.51.0

