From a06550ff7294cde7367802b22f45b147a11d0324 Mon Sep 17 00:00:00 2001
From: Mathieu Tortuyaux <mtortuyaux@microsoft.com>
Date: Mon, 26 Sep 2022 12:12:04 +0200
Subject: [PATCH 02/20] config: add ignition translation

it's a merge from flatcar/ign-converter

Signed-off-by: Mathieu Tortuyaux <mtortuyaux@microsoft.com>
---
 config/util/translate.go         |  166 +++
 config/v24tov31/v24tov31.go      |  729 +++++++++++++
 config/v24tov31/v24tov31_test.go | 1692 ++++++++++++++++++++++++++++++
 3 files changed, 2587 insertions(+)
 create mode 100644 config/util/translate.go
 create mode 100644 config/v24tov31/v24tov31.go
 create mode 100644 config/v24tov31/v24tov31_test.go

diff --git a/config/util/translate.go b/config/util/translate.go
new file mode 100644
index 00000000..347d148c
--- /dev/null
+++ b/config/util/translate.go
@@ -0,0 +1,166 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package util
+
+import (
+	"fmt"
+	"strconv"
+	"strings"
+	"sync"
+)
+
+// Error definitions
+
+// NoFilesystemError type for when a filesystem is referenced in a config but there's no mapping to where
+// it should be mounted (i.e. `path` in v3+ configs)
+type NoFilesystemError string
+
+func (e NoFilesystemError) Error() string {
+	return fmt.Sprintf("Config defined filesystem %q but no mapping was defined."+
+		"Please specify a path to be used as the filesystem mountpoint.", string(e))
+}
+
+// DuplicateInodeError is for when files, directories, or links both specify the same path
+type DuplicateInodeError struct {
+	Old string // first occurance of the path
+	New string // second occurance of the path
+}
+
+func (e DuplicateInodeError) Error() string {
+	return fmt.Sprintf("Config has conflicting inodes: %q and %q.  All files, directories and links must specify a unique `path`.", e.Old, e.New)
+}
+
+// UsesOwnLinkError is for when files, directories, or links use symlinks defined in the config
+// in their own path. This is disallowed in v3+ configs.
+type UsesOwnLinkError struct {
+	LinkPath string
+	Name     string
+}
+
+func (e UsesOwnLinkError) Error() string {
+	return fmt.Sprintf("%s uses link defined in config %q. Please use a link not defined in Storage:Links", e.Name, e.LinkPath)
+}
+
+// DuplicateUnitError is for when a unit name is used twice
+type DuplicateUnitError struct {
+	Name string
+}
+
+func (e DuplicateUnitError) Error() string {
+	return fmt.Sprintf("Config has duplicate unit name %q.  All units must specify a unique `name`.", e.Name)
+}
+
+// DuplicateDropinError is for when a unit has multiple dropins with the same name
+type DuplicateDropinError struct {
+	Unit string
+	Name string
+}
+
+func (e DuplicateDropinError) Error() string {
+	return fmt.Sprintf("Config has duplicate dropin name %q in unit %q.  All dropins must specify a unique `name`.", e.Name, e.Unit)
+}
+
+func CheckPathUsesLink(links []string, path string) string {
+	for _, l := range links {
+		linkdir := l
+		if !strings.HasSuffix(l, "/") {
+			linkdir += "/"
+		}
+		if strings.HasPrefix(path, linkdir) && path != l {
+			return l
+		}
+	}
+	return ""
+}
+
+func StrP(in string) *string {
+	if in == "" {
+		return nil
+	}
+	return &in
+}
+
+func StrPStrict(in string) *string {
+	return &in
+}
+
+func BoolP(in bool) *bool {
+	if !in {
+		return nil
+	}
+	return &in
+}
+
+func BoolPStrict(in bool) *bool {
+	return &in
+}
+
+func IntP(in int) *int {
+	if in == 0 {
+		return nil
+	}
+	return &in
+}
+
+func StrV(in *string) string {
+	if in == nil {
+		return ""
+	}
+	return *in
+}
+
+func BoolV(in *bool) bool {
+	if in == nil {
+		return false
+	}
+	return *in
+}
+
+func IntV(in *int) int {
+	if in == nil {
+		return 0
+	}
+	return *in
+}
+
+var (
+	generatedNameCounter uint64
+	addedSuffixCounter   uint64
+	counterMutex         sync.Mutex
+)
+
+// FSGeneration generates a name and a path that will be used to feed
+// the `fsMap` in case consumer provided no entry for it in the map.
+// FSMap is required to link the filesystem from v2 to v3 with the rest of the configuration.
+func FSGeneration(name string, fsMap map[string]string) (string, error) {
+	counterMutex.Lock()
+	if len(name) == 0 {
+		generatedNameCounter += 1
+		name = "ignition" + strconv.FormatUint(generatedNameCounter, 10)
+	}
+
+	if _, ok := fsMap[name]; !ok {
+		addedSuffixCounter += 1
+		if name == "oem" {
+			fsMap[name] = "/usr/share/oem"
+		} else {
+			// generate a new path
+			fsMap[name] = "/tmp/" + name + "-ign" + strconv.FormatUint(addedSuffixCounter, 10)
+		}
+	}
+
+	counterMutex.Unlock()
+	return name, nil
+}
diff --git a/config/v24tov31/v24tov31.go b/config/v24tov31/v24tov31.go
new file mode 100644
index 00000000..46749385
--- /dev/null
+++ b/config/v24tov31/v24tov31.go
@@ -0,0 +1,729 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v24tov31
+
+import (
+	"errors"
+	"fmt"
+	"net/url"
+	"path"
+	"path/filepath"
+	"reflect"
+
+	old "github.com/flatcar/ignition/config/v2_4/types"
+	oldValidate "github.com/flatcar/ignition/config/validate"
+	"github.com/flatcar/ignition/v2/config/merge"
+	"github.com/flatcar/ignition/v2/config/v3_1/types"
+	"github.com/flatcar/ignition/v2/config/validate"
+	"github.com/flatcar/ignition/v2/config/util"
+
+)
+
+// Check2_4 returns if the config is translatable but does not do any translation.
+// fsMap is a map from v2 filesystem names to the paths under which they should
+// be mounted in v3.
+func Check2_4(cfg old.Config, fsMap map[string]string) error {
+	rpt := oldValidate.ValidateWithoutSource(reflect.ValueOf(cfg))
+	if rpt.IsFatal() || rpt.IsDeprecated() {
+		// disallow any deprecated fields
+		return fmt.Errorf("Invalid input config:\n%s", rpt.String())
+	}
+
+	// check that all filesystems have a path
+	if fsMap == nil {
+		fsMap = map[string]string{}
+	}
+	fsMap["root"] = "/"
+	for _, fs := range cfg.Storage.Filesystems {
+		name, err := util.FSGeneration(fs.Name, fsMap)
+		if err != nil {
+			return fmt.Errorf("generating filesystem path and name: %w", err)
+		}
+
+		fs.Name = name
+
+		if fs.Mount.Create != nil && !fs.Mount.Create.Force {
+			return fmt.Errorf("Config must force filesystem creation in case `mount.create` object is defined.")
+		}
+	}
+
+	// check that there are no duplicates with files, links, or directories
+	// from path to a pretty-printing description of the entry
+	entryMap := map[string]string{}
+	links := make([]string, 0, len(cfg.Storage.Links))
+	// build up a list of all the links we write. We're not allow to use links
+	// that we write
+	for _, link := range cfg.Storage.Links {
+		pathString := path.Join("/", fsMap[link.Filesystem], link.Path)
+		links = append(links, pathString)
+	}
+
+	for _, file := range cfg.Storage.Files {
+		pathString := path.Join("/", fsMap[file.Filesystem], file.Path)
+		name := fmt.Sprintf("File: %s", pathString)
+		if duplicate, isDup := entryMap[pathString]; isDup {
+			return util.DuplicateInodeError{Old: duplicate, New: name}
+		}
+		if l := util.CheckPathUsesLink(links, pathString); l != "" {
+			return &util.UsesOwnLinkError{
+				LinkPath: l,
+				Name:     name,
+			}
+		}
+		entryMap[pathString] = name
+	}
+	for _, dir := range cfg.Storage.Directories {
+		pathString := path.Join("/", fsMap[dir.Filesystem], dir.Path)
+		name := fmt.Sprintf("Directory: %s", pathString)
+		if duplicate, isDup := entryMap[pathString]; isDup {
+			return util.DuplicateInodeError{Old: duplicate, New: name}
+		}
+		if l := util.CheckPathUsesLink(links, pathString); l != "" {
+			return &util.UsesOwnLinkError{
+				LinkPath: l,
+				Name:     name,
+			}
+		}
+		entryMap[pathString] = name
+	}
+	for _, link := range cfg.Storage.Links {
+		pathString := path.Join("/", fsMap[link.Filesystem], link.Path)
+		name := fmt.Sprintf("Link: %s", pathString)
+		if duplicate, isDup := entryMap[pathString]; isDup {
+			return &util.DuplicateInodeError{Old: duplicate, New: name}
+		}
+		entryMap[pathString] = name
+		if l := util.CheckPathUsesLink(links, pathString); l != "" {
+			return &util.UsesOwnLinkError{
+				LinkPath: l,
+				Name:     name,
+			}
+		}
+	}
+
+	for _, unit := range cfg.Systemd.Units {
+		dropinMap := map[string]struct{}{} // dropin name -> struct{}
+		for _, dropin := range unit.Dropins {
+			if _, isDup := dropinMap[dropin.Name]; isDup {
+				return util.DuplicateDropinError{Unit: unit.Name, Name: dropin.Name}
+			}
+			dropinMap[dropin.Name] = struct{}{}
+		}
+	}
+
+	return nil
+}
+
+// Translate translates an Ignition spec v2.4 config to v3.1
+func Translate(cfg old.Config, fsMap map[string]string) (types.Config, error) {
+	if err := Check2_4(cfg, fsMap); err != nil {
+		return types.Config{}, err
+	}
+
+	files := translateFiles(cfg.Storage.Files, fsMap)
+	files = append(files, translateNetworkd(cfg.Networkd.Units, fsMap)...)
+
+	res := types.Config{
+		// Ignition section
+		Ignition: types.Ignition{
+			Version: "3.1.0",
+			Config: types.IgnitionConfig{
+				Replace: translateCfgRef(cfg.Ignition.Config.Replace),
+				Merge:   translateCfgRefs(cfg.Ignition.Config.Append),
+			},
+			Security: types.Security{
+				TLS: types.TLS{
+					CertificateAuthorities: translateCAs(cfg.Ignition.Security.TLS.CertificateAuthorities),
+				},
+			},
+			Timeouts: types.Timeouts{
+				HTTPResponseHeaders: cfg.Ignition.Timeouts.HTTPResponseHeaders,
+				HTTPTotal:           cfg.Ignition.Timeouts.HTTPTotal,
+			},
+			Proxy: types.Proxy{
+				HTTPProxy:  util.StrP(cfg.Ignition.Proxy.HTTPProxy),
+				HTTPSProxy: util.StrP(cfg.Ignition.Proxy.HTTPSProxy),
+				NoProxy:    translateNoProxy(cfg.Ignition.Proxy.NoProxy),
+			},
+		},
+		// Passwd section
+		Passwd: types.Passwd{
+			Users:  translateUsers(cfg.Passwd.Users),
+			Groups: translateGroups(cfg.Passwd.Groups),
+		},
+		Systemd: types.Systemd{
+			Units: translateUnits(cfg.Systemd.Units),
+		},
+		Storage: types.Storage{
+			Disks:       translateDisks(cfg.Storage.Disks),
+			Raid:        translateRaid(cfg.Storage.Raid),
+			Filesystems: translateFilesystems(cfg.Storage.Filesystems, fsMap),
+			Files:       files,
+			Directories: translateDirectories(cfg.Storage.Directories, fsMap),
+			Links:       translateLinks(cfg.Storage.Links, fsMap),
+		},
+	}
+	r := validate.ValidateWithContext(res, nil)
+	if r.IsFatal() {
+		return types.Config{}, errors.New(r.String())
+	}
+	return res, nil
+}
+
+func translateNoProxy(noproxy []old.NoProxyItem) (ret []types.NoProxyItem) {
+	for _, d := range noproxy {
+		ret = append(ret, types.NoProxyItem(d))
+	}
+	return
+}
+
+func translateCfgRef(ref *old.ConfigReference) (ret types.Resource) {
+	if ref == nil {
+		return
+	}
+	ret.Source = &ref.Source
+	ret.Verification.Hash = ref.Verification.Hash
+	ret.HTTPHeaders = translateHTTPHeaders(ref.HTTPHeaders)
+
+	return
+}
+
+func translateHTTPHeaders(headers []old.HTTPHeader) (ret []types.HTTPHeader) {
+	for _, o := range headers {
+		ret = append(ret, types.HTTPHeader{
+			Name:  o.Name,
+			Value: util.StrP(o.Value),
+		})
+	}
+	return
+}
+
+func translateCfgRefs(refs []old.ConfigReference) (ret []types.Resource) {
+	for _, ref := range refs {
+		ret = append(ret, translateCfgRef(&ref))
+	}
+	return
+}
+
+func translateCAs(refs []old.CaReference) (ret []types.Resource) {
+	for _, ref := range refs {
+		ret = append(ret, types.Resource{
+			Source: &ref.Source,
+			Verification: types.Verification{
+				Hash: ref.Verification.Hash,
+			},
+			HTTPHeaders: translateHTTPHeaders(ref.HTTPHeaders),
+		})
+	}
+	return
+}
+
+func translateUsers(users []old.PasswdUser) (ret []types.PasswdUser) {
+	for _, u := range users {
+		uid := u.UID
+		gecos := u.Gecos
+		homeDir := u.HomeDir
+		noCreateHome := u.NoCreateHome
+		primaryGroup := u.PrimaryGroup
+		groups := translateUserGroups(u.Groups)
+		noUserGroup := u.NoUserGroup
+		noLogInit := u.NoLogInit
+		shell := u.Shell
+		system := u.System
+
+		// support deprecated `create` object
+		if u.Create != nil {
+			create := u.Create
+			uid = create.UID
+			gecos = create.Gecos
+			homeDir = create.HomeDir
+			noCreateHome = create.NoCreateHome
+			primaryGroup = create.PrimaryGroup
+			noUserGroup = create.NoUserGroup
+			noLogInit = create.NoLogInit
+			shell = create.Shell
+			system = create.System
+
+			// convert group type
+			g := make([]types.Group, len(create.Groups))
+			for i, group := range create.Groups {
+				g[i] = types.Group(group)
+			}
+
+			groups = g
+		}
+
+		ret = append(ret, types.PasswdUser{
+			Name:              u.Name,
+			PasswordHash:      u.PasswordHash,
+			SSHAuthorizedKeys: translateUserSSH(u.SSHAuthorizedKeys),
+			UID:               uid,
+			Gecos:             util.StrP(gecos),
+			HomeDir:           util.StrP(homeDir),
+			NoCreateHome:      util.BoolP(noCreateHome),
+			PrimaryGroup:      util.StrP(primaryGroup),
+			Groups:            groups,
+			NoUserGroup:       util.BoolP(noUserGroup),
+			NoLogInit:         util.BoolP(noLogInit),
+			Shell:             util.StrP(shell),
+			System:            util.BoolP(system),
+		})
+	}
+	return
+}
+
+func translateUserSSH(in []old.SSHAuthorizedKey) (ret []types.SSHAuthorizedKey) {
+	for _, k := range in {
+		ret = append(ret, types.SSHAuthorizedKey(k))
+	}
+	return
+}
+
+func translateUserGroups(in []old.Group) (ret []types.Group) {
+	for _, g := range in {
+		ret = append(ret, types.Group(g))
+	}
+	return
+}
+
+func translateGroups(groups []old.PasswdGroup) (ret []types.PasswdGroup) {
+	for _, g := range groups {
+		ret = append(ret, types.PasswdGroup{
+			Name:         g.Name,
+			Gid:          g.Gid,
+			PasswordHash: util.StrP(g.PasswordHash),
+			System:       util.BoolP(g.System),
+		})
+	}
+	return
+}
+
+func translateUnits(units []old.Unit) (ret []types.Unit) {
+	unitsMap := map[string]types.Unit{}
+
+	for _, u := range units {
+		var enabled *bool
+		// The Enabled field wins over Enable, since Enable is deprecated in spec v2 and removed in v3.
+		// It does so following the apparent intent of the upstream code [1]
+		// which actually does the opposite for Enable=true Enabled=false
+		// because the first matching line in a systemd preset wins.
+		// [1] https://github.com/flatcar-linux/ignition/blob/b4d18ad3fcb278a890327f858c1c10256ab6ee9d/internal/exec/stages/files/units.go#L32
+		if (u.Enabled != nil && *u.Enabled) || u.Enable {
+			enabled = util.BoolP(true)
+		}
+		if u.Enabled != nil && !*u.Enabled {
+			enabled = util.BoolPStrict(false)
+		}
+
+		// 'trUnit' is the translated unit, a candidate for insertion.
+		trUnit := types.Unit{
+			Name:     u.Name,
+			Enabled:  enabled,
+			Mask:     util.BoolP(u.Mask),
+			Contents: util.StrP(u.Contents),
+			Dropins:  translateDropins(u.Dropins),
+		}
+
+		// We check for an already added unit with the same name (it should be unique).
+		// 'prUnit' for previous unit.
+		if prUnit, ok := unitsMap[trUnit.Name]; ok {
+			// We prepare the merging of the two units. For this, we need to
+			// wrap them into an actual Ignition Config.
+			parent := types.Config{
+				Systemd: types.Systemd{
+					Units: []types.Unit{
+						prUnit,
+					},
+				},
+			}
+
+			child := types.Config{
+				Systemd: types.Systemd{
+					Units: []types.Unit{
+						trUnit,
+					},
+				},
+			}
+
+			// We actually merge the two configurations, it should not raise any error.
+			res, _ := merge.MergeStructTranscribe(parent, child)
+			mergedConfig := res.(types.Config)
+
+			mergedUnits := mergedConfig.Systemd.Units
+
+			// We should only get one new unit from the merge.
+			if len(mergedUnits) == 1 {
+				// We override the previous unit with the new one for the next round.
+				unitsMap[u.Name] = mergedUnits[0]
+				continue
+			}
+		}
+
+		// We track the unit as added.
+		unitsMap[u.Name] = trUnit
+	}
+
+	for _, value := range unitsMap {
+		ret = append(ret, value)
+	}
+
+	return
+}
+
+func translateDropins(dropins []old.SystemdDropin) (ret []types.Dropin) {
+	for _, d := range dropins {
+		ret = append(ret, types.Dropin{
+			Name:     d.Name,
+			Contents: util.StrP(d.Contents),
+		})
+	}
+	return
+}
+
+func translateDisks(disks []old.Disk) (ret []types.Disk) {
+	for _, d := range disks {
+		ret = append(ret, types.Disk{
+			Device:     d.Device,
+			WipeTable:  util.BoolP(d.WipeTable),
+			Partitions: translatePartitions(d.Partitions),
+		})
+	}
+	return
+}
+
+func translatePartitions(parts []old.Partition) (ret []types.Partition) {
+	for _, p := range parts {
+		ret = append(ret, types.Partition{
+			Label:              p.Label,
+			Number:             p.Number,
+			SizeMiB:            p.SizeMiB,
+			StartMiB:           p.StartMiB,
+			TypeGUID:           util.StrP(p.TypeGUID),
+			GUID:               util.StrP(p.GUID),
+			WipePartitionEntry: util.BoolP(p.WipePartitionEntry),
+			ShouldExist:        p.ShouldExist,
+		})
+	}
+	return
+}
+
+func translateRaid(raids []old.Raid) (ret []types.Raid) {
+	for _, r := range raids {
+		ret = append(ret, types.Raid{
+			Name:    r.Name,
+			Level:   r.Level,
+			Devices: translateDevices(r.Devices),
+			Spares:  util.IntP(r.Spares),
+			Options: translateRaidOptions(r.Options),
+		})
+	}
+	return
+}
+
+func translateDevices(devices []old.Device) (ret []types.Device) {
+	for _, d := range devices {
+		ret = append(ret, types.Device(d))
+	}
+	return
+}
+
+func translateRaidOptions(options []old.RaidOption) (ret []types.RaidOption) {
+	for _, o := range options {
+		ret = append(ret, types.RaidOption(o))
+	}
+	return
+}
+
+func translateFilesystems(fss []old.Filesystem, m map[string]string) (ret []types.Filesystem) {
+	for _, f := range fss {
+		if f.Name == "root" {
+			// root is implied
+			continue
+		}
+		if f.Mount == nil {
+			f.Mount = &old.Mount{}
+		}
+
+		wipe := util.BoolP(f.Mount.WipeFilesystem)
+		options := translateFilesystemOptions(f.Mount.Options)
+
+		// If we have a `"create": {...}` section, we try
+		// to convert it.
+		if f.Mount.Create != nil {
+			// `wipe` should always be set to `true` - there is a config check
+			// in the beginning of the translation to ensure that we don't try to
+			// use this `create` section without forcing the exising filesystem to be
+			// wiped.
+			wipe = util.BoolP(f.Mount.Create.Force)
+
+			for _, opt := range f.Mount.Create.Options {
+				options = append(options, types.FilesystemOption(opt))
+			}
+		}
+
+		format := f.Mount.Format
+		if f.Name == "oem" && (wipe == nil || !*wipe) {
+			format = "btrfs"
+		}
+
+		ret = append(ret, types.Filesystem{
+			Device:         f.Mount.Device,
+			Format:         util.StrP(format),
+			WipeFilesystem: wipe,
+			Label:          f.Mount.Label,
+			UUID:           f.Mount.UUID,
+			Options:        options,
+			Path:           util.StrP(m[f.Name]),
+		})
+	}
+	return
+}
+
+func translateFilesystemOptions(options []old.MountOption) (ret []types.FilesystemOption) {
+	for _, o := range options {
+		ret = append(ret, types.FilesystemOption(o))
+	}
+	return
+}
+
+func translateNode(n old.Node, m map[string]string) types.Node {
+	if n.User == nil {
+		n.User = &old.NodeUser{}
+	}
+	if n.Group == nil {
+		n.Group = &old.NodeGroup{}
+	}
+	return types.Node{
+		Path: path.Join(m[n.Filesystem], n.Path),
+		User: types.NodeUser{
+			ID:   n.User.ID,
+			Name: util.StrP(n.User.Name),
+		},
+		Group: types.NodeGroup{
+			ID:   n.Group.ID,
+			Name: util.StrP(n.Group.Name),
+		},
+		Overwrite: n.Overwrite,
+	}
+}
+
+func translateFiles(files []old.File, m map[string]string) (ret []types.File) {
+	for _, f := range files {
+		// 2.x files are overwrite by default
+		if f.Node.Overwrite == nil {
+			f.Node.Overwrite = util.BoolP(true)
+		}
+
+		// In spec 3, overwrite must be false if append is true
+		// i.e. spec 2 files with append true must be translated to spec 3 files with overwrite false
+		if f.FileEmbedded1.Append {
+			f.Node.Overwrite = util.BoolPStrict(false)
+		}
+
+		file := types.File{
+			Node: translateNode(f.Node, m),
+			FileEmbedded1: types.FileEmbedded1{
+				Mode: f.Mode,
+			},
+		}
+		c := types.Resource{
+			Compression: util.StrP(f.Contents.Compression),
+			Source:      util.StrPStrict(f.Contents.Source),
+			HTTPHeaders: translateHTTPHeaders(f.Contents.HTTPHeaders),
+		}
+		c.Verification.Hash = f.FileEmbedded1.Contents.Verification.Hash
+
+		if f.Append {
+			file.Append = []types.Resource{c}
+		} else {
+			file.Contents = c
+		}
+		ret = append(ret, file)
+	}
+	return
+}
+
+func translateNetworkd(units []old.Networkdunit, m map[string]string) []types.File {
+	var ret []types.File
+
+	for _, u := range units {
+		if u.Contents != "" {
+			file := types.File{
+				Node: types.Node{
+					// 2.x files are overwrite by default
+					Overwrite: util.BoolP(true),
+				},
+				FileEmbedded1: types.FileEmbedded1{
+					// Ignition default file permission
+					Mode: util.IntP(int(0644)),
+				},
+			}
+			// path /etc/systemd/network is hardcoded in Ignition2.x codebase.
+			// TODO: customize this path at compilation time.
+			file.Node.Path = filepath.Join(m["root"], "/etc/systemd/network", u.Name)
+
+			// URL encoding unit content to follow 'data' format - we could use base64 also.
+			file.FileEmbedded1.Contents.Source = util.StrPStrict("data:," + url.PathEscape(u.Contents))
+
+			ret = append(ret, file)
+		}
+
+		for _, d := range u.Dropins {
+			file := types.File{
+				Node: types.Node{
+					// 2.x files are overwrite by default
+					Overwrite: util.BoolP(true),
+				},
+				FileEmbedded1: types.FileEmbedded1{
+					// Ignition default file permission
+					Mode: util.IntP(int(0644)),
+				},
+			}
+
+			file.Node.Path = filepath.Join(m["root"], "/etc/systemd/network", string(u.Name)+".d", d.Name)
+			file.FileEmbedded1.Contents.Source = util.StrPStrict("data:," + url.PathEscape(d.Contents))
+
+			ret = append(ret, file)
+		}
+	}
+
+	return ret
+}
+
+func translateLinks(links []old.Link, m map[string]string) (ret []types.Link) {
+	for _, l := range links {
+		ret = append(ret, types.Link{
+			Node: translateNode(l.Node, m),
+			LinkEmbedded1: types.LinkEmbedded1{
+				Hard:   util.BoolP(l.Hard),
+				Target: l.Target,
+			},
+		})
+	}
+	return
+}
+
+func translateDirectories(dirs []old.Directory, m map[string]string) (ret []types.Directory) {
+	for _, d := range dirs {
+		ret = append(ret, types.Directory{
+			Node: translateNode(d.Node, m),
+			DirectoryEmbedded1: types.DirectoryEmbedded1{
+				Mode: d.Mode,
+			},
+		})
+	}
+	return
+}
+
+// RemoveDuplicateFilesUnitsUsers is a helper function that removes duplicated files/units/users
+// from spec v2 config, since neither spec v3 nor the translator function allow for duplicate
+// file entries in the config.
+// This functionality is not included in the Translate function and has some limitations, but
+// may be useful in cases where configuration has to be sanitized before translation.
+// For duplicates, it takes ordering into consideration by taking the file/unit contents from
+// the slice with the highest index value, which is assumed to be the latest revision.
+// Unit dropins are concat'ed, i.e. if no duplicate dropin of the same name exists it is added
+// to the list of dropins of the deduplicated unit definition.
+// The function will fail if a non-root filesystem is declared on any file.
+// It will also fail if file appendices are encountered.
+func RemoveDuplicateFilesUnitsUsers(cfg old.Config) (old.Config, error) {
+	files := cfg.Storage.Files
+	units := cfg.Systemd.Units
+	users := cfg.Passwd.Users
+
+	filePathMap := map[string]bool{}
+	var outFiles []old.File
+	// range from highest to lowest index
+	for i := len(files) - 1; i >= 0; i-- {
+		if files[i].Filesystem != "root" {
+			return old.Config{}, errors.New("cannot dedupe set of files on non-root filesystem")
+		}
+		if files[i].Append {
+			return old.Config{}, errors.New("cannot dedupe set of files that contains appendices")
+		}
+		path := files[i].Path
+		if _, isDup := filePathMap[path]; isDup {
+			// dupes are ignored
+			continue
+		}
+		// append unique file
+		outFiles = append(outFiles, files[i])
+		filePathMap[path] = true
+	}
+
+	unitNameMap := map[string]bool{}
+	var outUnits []old.Unit
+	// range from highest to lowest index
+	for i := len(units) - 1; i >= 0; i-- {
+		unitName := units[i].Name
+		if _, isDup := unitNameMap[unitName]; isDup {
+			// this is a duplicated unit by name
+			if len(units[i].Dropins) > 0 {
+				for j := range outUnits {
+					if outUnits[j].Name == unitName {
+						// outUnits[j] is the highest priority entry with this unit name
+						// now loop over the new unit's dropins and append it if the name
+						// isn't duplicated in the existing unit's dropins
+						for _, newDropin := range units[i].Dropins {
+							hasExistingDropin := false
+							for _, existingDropin := range outUnits[j].Dropins {
+								if existingDropin.Name == newDropin.Name {
+									hasExistingDropin = true
+									break
+								}
+							}
+							if !hasExistingDropin {
+								outUnits[j].Dropins = append(outUnits[j].Dropins, newDropin)
+							}
+						}
+					}
+				}
+			}
+		} else {
+			// append unique unit
+			outUnits = append(outUnits, units[i])
+			unitNameMap[unitName] = true
+		}
+	}
+
+	// Concat sshkey sections into the newest passwdUser in the list
+	// Only the SSHAuthorizedKeys of a duplicate user are considered,
+	// all other fields are ignored.
+	userNameMap := map[string]bool{}
+	var outUsers []old.PasswdUser
+	// range from highest to lowest index
+	for i := len(users) - 1; i >= 0; i-- {
+		userName := users[i].Name
+		if _, isDup := userNameMap[userName]; isDup {
+			// this is a duplicated user by name, append keys to existing user
+			for j := range outUsers {
+				if outUsers[j].Name == userName {
+					outUsers[j].SSHAuthorizedKeys = append(outUsers[j].SSHAuthorizedKeys, users[i].SSHAuthorizedKeys...)
+				}
+			}
+		} else {
+			// append unique users
+			outUsers = append(outUsers, users[i])
+			userNameMap[userName] = true
+		}
+	}
+
+	// outFiles, outUnits, and outUsers should now have all duplication removed
+	cfg.Storage.Files = outFiles
+	cfg.Systemd.Units = outUnits
+	cfg.Passwd.Users = outUsers
+
+	return cfg, nil
+}
diff --git a/config/v24tov31/v24tov31_test.go b/config/v24tov31/v24tov31_test.go
new file mode 100644
index 00000000..e81f6bed
--- /dev/null
+++ b/config/v24tov31/v24tov31_test.go
@@ -0,0 +1,1692 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v24tov31_test
+
+import (
+	"fmt"
+	"testing"
+
+	types2_4 "github.com/flatcar/ignition/config/v2_4/types"
+	types3_1 "github.com/flatcar/ignition/v2/config/v3_1/types"
+
+	"github.com/stretchr/testify/assert"
+
+	"github.com/flatcar/ignition/v2/config/util"
+	"github.com/flatcar/ignition/v2/config/v24tov31"
+)
+
+// Configs using _all_ the (undeprecated) fields
+var (
+	userID        = 1010
+	aSha512Hash   = "sha512-c6100de5624cfb3c109909948ecb8d703bbddcd3725b8bd43dcf2cee6d2f5dc990a757575e0306a8e8eea354bcd7cfac354da911719766225668fe5430477fa8"
+	aUUID         = "9d6e42cd-dcef-4177-b4c6-2a0c979e3d82"
+	exhaustiveMap = map[string]string{
+		"var":  "/var",
+		"/var": "/var",
+	}
+
+	wrongDeprecatedConfig2_4 = types2_4.Config{
+		Ignition: types2_4.Ignition{
+			Version: "2.4.0",
+			Config: types2_4.IgnitionConfig{
+				Append: []types2_4.ConfigReference{
+					{
+						Source: "https://example.com",
+						Verification: types2_4.Verification{
+							Hash: &aSha512Hash,
+						},
+					},
+				},
+				Replace: &types2_4.ConfigReference{
+					Source: "https://example.com",
+					Verification: types2_4.Verification{
+						Hash: &aSha512Hash,
+					},
+				},
+			},
+			Timeouts: types2_4.Timeouts{
+				HTTPResponseHeaders: util.IntP(5),
+				HTTPTotal:           util.IntP(10),
+			},
+			Security: types2_4.Security{
+				TLS: types2_4.TLS{
+					CertificateAuthorities: []types2_4.CaReference{
+						{
+							Source: "https://example.com",
+							Verification: types2_4.Verification{
+								Hash: &aSha512Hash,
+							},
+						},
+					},
+				},
+			},
+			Proxy: types2_4.Proxy{
+				HTTPProxy:  "https://proxy.example.net/",
+				HTTPSProxy: "https://secure.proxy.example.net/",
+				NoProxy: []types2_4.NoProxyItem{
+					"www.example.net",
+					"www.example2.net",
+				},
+			},
+		},
+		Storage: types2_4.Storage{
+			Disks: []types2_4.Disk{
+				{
+					Device:    "/dev/sda",
+					WipeTable: true,
+					Partitions: []types2_4.Partition{
+						{
+							Label:              util.StrP("var"),
+							Number:             1,
+							SizeMiB:            util.IntP(5000),
+							StartMiB:           util.IntP(2048),
+							TypeGUID:           aUUID,
+							GUID:               aUUID,
+							WipePartitionEntry: true,
+							ShouldExist:        util.BoolP(true),
+						},
+					},
+				},
+			},
+			Raid: []types2_4.Raid{
+				{
+					Name:    "array",
+					Level:   "raid10",
+					Devices: []types2_4.Device{"/dev/sdb", "/dev/sdc"},
+					Spares:  1,
+					Options: []types2_4.RaidOption{"foobar"},
+				},
+			},
+			Filesystems: []types2_4.Filesystem{
+				{
+					Name: "/var",
+					Mount: &types2_4.Mount{
+						Device: "/dev/disk/by-partlabel/var",
+						Format: "xfs",
+						Create: &types2_4.Create{
+							Force: true,
+							Options: []types2_4.CreateOption{
+								"--labl=ROOT",
+								types2_4.CreateOption(fmt.Sprintf("--uuid=%s", aUUID)),
+							},
+						},
+						UUID: &aUUID,
+					},
+				},
+			},
+			Files: []types2_4.File{
+				{
+					Node: types2_4.Node{
+						Filesystem: "/var",
+						Path:       "/varfile",
+						Overwrite:  util.BoolPStrict(false),
+						User: &types2_4.NodeUser{
+							ID: util.IntP(1000),
+						},
+						Group: &types2_4.NodeGroup{
+							Name: "groupname",
+						},
+					},
+					FileEmbedded1: types2_4.FileEmbedded1{
+						Append: true,
+						Mode:   util.IntP(420),
+						Contents: types2_4.FileContents{
+							Compression: "gzip",
+							Source:      "https://example.com",
+							Verification: types2_4.Verification{
+								Hash: &aSha512Hash,
+							},
+							HTTPHeaders: types2_4.HTTPHeaders{
+								types2_4.HTTPHeader{
+									Name:  "Authorization",
+									Value: "Basic YWxhZGRpbjpvcGVuc2VzYW1l",
+								},
+								types2_4.HTTPHeader{
+									Name:  "User-Agent",
+									Value: "Mozilla/5.0 (compatible; MSIE 6.0; Windows NT 5.1)",
+								},
+							},
+						},
+					},
+				},
+				{
+					Node: types2_4.Node{
+						Filesystem: "root",
+						Path:       "/empty",
+						Overwrite:  util.BoolPStrict(false),
+					},
+					FileEmbedded1: types2_4.FileEmbedded1{
+						Mode: util.IntP(420),
+					},
+				},
+			},
+			Directories: []types2_4.Directory{
+				{
+					Node: types2_4.Node{
+						Filesystem: "root",
+						Path:       "/rootdir",
+						Overwrite:  util.BoolP(true),
+						User: &types2_4.NodeUser{
+							ID: util.IntP(1000),
+						},
+						Group: &types2_4.NodeGroup{
+							Name: "groupname",
+						},
+					},
+					DirectoryEmbedded1: types2_4.DirectoryEmbedded1{
+						Mode: util.IntP(420),
+					},
+				},
+			},
+			Links: []types2_4.Link{
+				{
+					Node: types2_4.Node{
+						Filesystem: "root",
+						Path:       "/rootlink",
+						Overwrite:  util.BoolP(true),
+						User: &types2_4.NodeUser{
+							ID: util.IntP(1000),
+						},
+						Group: &types2_4.NodeGroup{
+							Name: "groupname",
+						},
+					},
+					LinkEmbedded1: types2_4.LinkEmbedded1{
+						Hard:   false,
+						Target: "/foobar",
+					},
+				},
+			},
+		},
+	}
+
+	deprecatedConfig2_4 = types2_4.Config{
+		Ignition: types2_4.Ignition{
+			Version: "2.4.0",
+			Config: types2_4.IgnitionConfig{
+				Append: []types2_4.ConfigReference{
+					{
+						Source: "https://example.com",
+						Verification: types2_4.Verification{
+							Hash: &aSha512Hash,
+						},
+					},
+				},
+				Replace: &types2_4.ConfigReference{
+					Source: "https://example.com",
+					Verification: types2_4.Verification{
+						Hash: &aSha512Hash,
+					},
+				},
+			},
+			Timeouts: types2_4.Timeouts{
+				HTTPResponseHeaders: util.IntP(5),
+				HTTPTotal:           util.IntP(10),
+			},
+			Security: types2_4.Security{
+				TLS: types2_4.TLS{
+					CertificateAuthorities: []types2_4.CaReference{
+						{
+							Source: "https://example.com",
+							Verification: types2_4.Verification{
+								Hash: &aSha512Hash,
+							},
+						},
+					},
+				},
+			},
+			Proxy: types2_4.Proxy{
+				HTTPProxy:  "https://proxy.example.net/",
+				HTTPSProxy: "https://secure.proxy.example.net/",
+				NoProxy: []types2_4.NoProxyItem{
+					"www.example.net",
+					"www.example2.net",
+				},
+			},
+		},
+		Passwd: types2_4.Passwd{
+			Users: []types2_4.PasswdUser{
+				{
+					Name: "user",
+					Create: &types2_4.Usercreate{
+						UID: &userID,
+						Groups: []types2_4.UsercreateGroup{
+							types2_4.UsercreateGroup("docker"),
+						},
+					},
+				},
+			},
+		},
+		Networkd: types2_4.Networkd{
+			Units: []types2_4.Networkdunit{
+				{
+					Contents: "[Match]\nType=!vlan bond bridge\nName=eth*\n\n[Network]\nBond=bond0",
+					Dropins: []types2_4.NetworkdDropin{
+						{
+							Contents: "[Match]\nName=bond0\n\n[Network]\nDHCP=true",
+							Name:     "dropin-1.conf",
+						},
+					},
+					Name: "00-eth.network",
+				},
+				{
+					Contents: "[Match]\nName=eth12\n\n[Network]\nBond=bond0",
+					Name:     "99-eth.network",
+				},
+			},
+		},
+		Storage: types2_4.Storage{
+			Disks: []types2_4.Disk{
+				{
+					Device:    "/dev/sda",
+					WipeTable: true,
+					Partitions: []types2_4.Partition{
+						{
+							Label:              util.StrP("var"),
+							Number:             1,
+							SizeMiB:            util.IntP(5000),
+							StartMiB:           util.IntP(2048),
+							TypeGUID:           aUUID,
+							GUID:               aUUID,
+							WipePartitionEntry: true,
+							ShouldExist:        util.BoolP(true),
+						},
+					},
+				},
+			},
+			Raid: []types2_4.Raid{
+				{
+					Name:    "array",
+					Level:   "raid10",
+					Devices: []types2_4.Device{"/dev/sdb", "/dev/sdc"},
+					Spares:  1,
+					Options: []types2_4.RaidOption{"foobar"},
+				},
+			},
+			Filesystems: []types2_4.Filesystem{
+				{
+					Name: "/var",
+					Mount: &types2_4.Mount{
+						Device: "/dev/disk/by-partlabel/var",
+						Format: "xfs",
+						Label:  util.StrP("var"),
+						UUID:   &aUUID,
+						Create: &types2_4.Create{
+							Force: true,
+							Options: []types2_4.CreateOption{
+								"--label=var",
+								types2_4.CreateOption(fmt.Sprintf("--uuid=%s", aUUID)),
+							},
+						},
+					},
+				},
+			},
+			Files: []types2_4.File{
+				{
+					Node: types2_4.Node{
+						Filesystem: "/var",
+						Path:       "/varfile",
+						Overwrite:  util.BoolPStrict(false),
+						User: &types2_4.NodeUser{
+							ID: util.IntP(1000),
+						},
+						Group: &types2_4.NodeGroup{
+							Name: "groupname",
+						},
+					},
+					FileEmbedded1: types2_4.FileEmbedded1{
+						Append: true,
+						Mode:   util.IntP(420),
+						Contents: types2_4.FileContents{
+							Compression: "gzip",
+							Source:      "https://example.com",
+							Verification: types2_4.Verification{
+								Hash: &aSha512Hash,
+							},
+							HTTPHeaders: types2_4.HTTPHeaders{
+								types2_4.HTTPHeader{
+									Name:  "Authorization",
+									Value: "Basic YWxhZGRpbjpvcGVuc2VzYW1l",
+								},
+								types2_4.HTTPHeader{
+									Name:  "User-Agent",
+									Value: "Mozilla/5.0 (compatible; MSIE 6.0; Windows NT 5.1)",
+								},
+							},
+						},
+					},
+				},
+				{
+					Node: types2_4.Node{
+						Filesystem: "root",
+						Path:       "/empty",
+						Overwrite:  util.BoolPStrict(false),
+					},
+					FileEmbedded1: types2_4.FileEmbedded1{
+						Mode: util.IntP(420),
+					},
+				},
+			},
+			Directories: []types2_4.Directory{
+				{
+					Node: types2_4.Node{
+						Filesystem: "root",
+						Path:       "/rootdir",
+						Overwrite:  util.BoolP(true),
+						User: &types2_4.NodeUser{
+							ID: util.IntP(1000),
+						},
+						Group: &types2_4.NodeGroup{
+							Name: "groupname",
+						},
+					},
+					DirectoryEmbedded1: types2_4.DirectoryEmbedded1{
+						Mode: util.IntP(420),
+					},
+				},
+			},
+			Links: []types2_4.Link{
+				{
+					Node: types2_4.Node{
+						Filesystem: "root",
+						Path:       "/rootlink",
+						Overwrite:  util.BoolP(true),
+						User: &types2_4.NodeUser{
+							ID: util.IntP(1000),
+						},
+						Group: &types2_4.NodeGroup{
+							Name: "groupname",
+						},
+					},
+					LinkEmbedded1: types2_4.LinkEmbedded1{
+						Hard:   false,
+						Target: "/foobar",
+					},
+				},
+			},
+		},
+	}
+
+	badDeprecatedConfig2_4 = types2_4.Config{
+		Ignition: types2_4.Ignition{
+			Version: "2.4.0",
+			Config: types2_4.IgnitionConfig{
+				Append: []types2_4.ConfigReference{
+					{
+						Source: "https://example.com",
+						Verification: types2_4.Verification{
+							Hash: &aSha512Hash,
+						},
+					},
+				},
+				Replace: &types2_4.ConfigReference{
+					Source: "https://example.com",
+					Verification: types2_4.Verification{
+						Hash: &aSha512Hash,
+					},
+				},
+			},
+			Timeouts: types2_4.Timeouts{
+				HTTPResponseHeaders: util.IntP(5),
+				HTTPTotal:           util.IntP(10),
+			},
+			Security: types2_4.Security{
+				TLS: types2_4.TLS{
+					CertificateAuthorities: []types2_4.CaReference{
+						{
+							Source: "https://example.com",
+							Verification: types2_4.Verification{
+								Hash: &aSha512Hash,
+							},
+						},
+					},
+				},
+			},
+			Proxy: types2_4.Proxy{
+				HTTPProxy:  "https://proxy.example.net/",
+				HTTPSProxy: "https://secure.proxy.example.net/",
+				NoProxy: []types2_4.NoProxyItem{
+					"www.example.net",
+					"www.example2.net",
+				},
+			},
+		},
+		Storage: types2_4.Storage{
+			Filesystems: []types2_4.Filesystem{
+				{
+					Name: "/var",
+					Mount: &types2_4.Mount{
+						Device: "/dev/disk/by-partlabel/var",
+						Format: "xfs",
+						Label:  util.StrP("var"),
+						UUID:   &aUUID,
+						Create: &types2_4.Create{
+							Force: false,
+							Options: []types2_4.CreateOption{
+								"--label=var",
+								types2_4.CreateOption(fmt.Sprintf("--uuid=%s", aUUID)),
+							},
+						},
+					},
+				},
+			},
+		},
+	}
+
+	exhaustiveConfig2_4 = types2_4.Config{
+		Ignition: types2_4.Ignition{
+			Version: "2.4.0",
+			Config: types2_4.IgnitionConfig{
+				Append: []types2_4.ConfigReference{
+					{
+						Source: "https://example.com",
+						Verification: types2_4.Verification{
+							Hash: &aSha512Hash,
+						},
+					},
+				},
+				Replace: &types2_4.ConfigReference{
+					Source: "https://example.com",
+					Verification: types2_4.Verification{
+						Hash: &aSha512Hash,
+					},
+				},
+			},
+			Timeouts: types2_4.Timeouts{
+				HTTPResponseHeaders: util.IntP(5),
+				HTTPTotal:           util.IntP(10),
+			},
+			Security: types2_4.Security{
+				TLS: types2_4.TLS{
+					CertificateAuthorities: []types2_4.CaReference{
+						{
+							Source: "https://example.com",
+							Verification: types2_4.Verification{
+								Hash: &aSha512Hash,
+							},
+						},
+					},
+				},
+			},
+			Proxy: types2_4.Proxy{
+				HTTPProxy:  "https://proxy.example.net/",
+				HTTPSProxy: "https://secure.proxy.example.net/",
+				NoProxy: []types2_4.NoProxyItem{
+					"www.example.net",
+					"www.example2.net",
+				},
+			},
+		},
+		Storage: types2_4.Storage{
+			Disks: []types2_4.Disk{
+				{
+					Device:    "/dev/sda",
+					WipeTable: true,
+					Partitions: []types2_4.Partition{
+						{
+							Label:              util.StrP("var"),
+							Number:             1,
+							SizeMiB:            util.IntP(5000),
+							StartMiB:           util.IntP(2048),
+							TypeGUID:           aUUID,
+							GUID:               aUUID,
+							WipePartitionEntry: true,
+							ShouldExist:        util.BoolP(true),
+						},
+					},
+				},
+			},
+			Raid: []types2_4.Raid{
+				{
+					Name:    "array",
+					Level:   "raid10",
+					Devices: []types2_4.Device{"/dev/sdb", "/dev/sdc"},
+					Spares:  1,
+					Options: []types2_4.RaidOption{"foobar"},
+				},
+			},
+			Filesystems: []types2_4.Filesystem{
+				{
+					Name: "/var",
+					Mount: &types2_4.Mount{
+						Device:         "/dev/disk/by-partlabel/var",
+						Format:         "xfs",
+						WipeFilesystem: true,
+						Label:          util.StrP("var"),
+						UUID:           &aUUID,
+						Options:        []types2_4.MountOption{"rw"},
+					},
+				},
+			},
+			Files: []types2_4.File{
+				{
+					Node: types2_4.Node{
+						Filesystem: "/var",
+						Path:       "/varfile",
+						Overwrite:  util.BoolPStrict(false),
+						User: &types2_4.NodeUser{
+							ID: util.IntP(1000),
+						},
+						Group: &types2_4.NodeGroup{
+							Name: "groupname",
+						},
+					},
+					FileEmbedded1: types2_4.FileEmbedded1{
+						Append: true,
+						Mode:   util.IntP(420),
+						Contents: types2_4.FileContents{
+							Compression: "gzip",
+							Source:      "https://example.com",
+							Verification: types2_4.Verification{
+								Hash: &aSha512Hash,
+							},
+							HTTPHeaders: types2_4.HTTPHeaders{
+								types2_4.HTTPHeader{
+									Name:  "Authorization",
+									Value: "Basic YWxhZGRpbjpvcGVuc2VzYW1l",
+								},
+								types2_4.HTTPHeader{
+									Name:  "User-Agent",
+									Value: "Mozilla/5.0 (compatible; MSIE 6.0; Windows NT 5.1)",
+								},
+							},
+						},
+					},
+				},
+				{
+					Node: types2_4.Node{
+						Filesystem: "root",
+						Path:       "/empty",
+						Overwrite:  util.BoolPStrict(false),
+					},
+					FileEmbedded1: types2_4.FileEmbedded1{
+						Mode: util.IntP(420),
+					},
+				},
+			},
+			Directories: []types2_4.Directory{
+				{
+					Node: types2_4.Node{
+						Filesystem: "root",
+						Path:       "/rootdir",
+						Overwrite:  util.BoolP(true),
+						User: &types2_4.NodeUser{
+							ID: util.IntP(1000),
+						},
+						Group: &types2_4.NodeGroup{
+							Name: "groupname",
+						},
+					},
+					DirectoryEmbedded1: types2_4.DirectoryEmbedded1{
+						Mode: util.IntP(420),
+					},
+				},
+			},
+			Links: []types2_4.Link{
+				{
+					Node: types2_4.Node{
+						Filesystem: "root",
+						Path:       "/rootlink",
+						Overwrite:  util.BoolP(true),
+						User: &types2_4.NodeUser{
+							ID: util.IntP(1000),
+						},
+						Group: &types2_4.NodeGroup{
+							Name: "groupname",
+						},
+					},
+					LinkEmbedded1: types2_4.LinkEmbedded1{
+						Hard:   false,
+						Target: "/foobar",
+					},
+				},
+			},
+		},
+	}
+
+	config3_1WithNoFSOptions = types3_1.Config{
+		Ignition: types3_1.Ignition{
+			Version: "3.1.0",
+			Config: types3_1.IgnitionConfig{
+				Merge: []types3_1.Resource{
+					{
+						Source: util.StrP("https://example.com"),
+						Verification: types3_1.Verification{
+							Hash: &aSha512Hash,
+						},
+					},
+				},
+				Replace: types3_1.Resource{
+					Source: util.StrP("https://example.com"),
+					Verification: types3_1.Verification{
+						Hash: &aSha512Hash,
+					},
+				},
+			},
+			Timeouts: types3_1.Timeouts{
+				HTTPResponseHeaders: util.IntP(5),
+				HTTPTotal:           util.IntP(10),
+			},
+			Security: types3_1.Security{
+				TLS: types3_1.TLS{
+					CertificateAuthorities: []types3_1.Resource{
+						{
+							Source: util.StrP("https://example.com"),
+							Verification: types3_1.Verification{
+								Hash: &aSha512Hash,
+							},
+						},
+					},
+				},
+			},
+			Proxy: types3_1.Proxy{
+				HTTPProxy:  util.StrP("https://proxy.example.net/"),
+				HTTPSProxy: util.StrP("https://secure.proxy.example.net/"),
+				NoProxy: []types3_1.NoProxyItem{
+					"www.example.net",
+					"www.example2.net",
+				},
+			},
+		},
+		Storage: types3_1.Storage{
+			Disks: []types3_1.Disk{
+				{
+					Device:    "/dev/sda",
+					WipeTable: util.BoolP(true),
+					Partitions: []types3_1.Partition{
+						{
+							Label:              util.StrP("var"),
+							Number:             1,
+							SizeMiB:            util.IntP(5000),
+							StartMiB:           util.IntP(2048),
+							TypeGUID:           &aUUID,
+							GUID:               &aUUID,
+							WipePartitionEntry: util.BoolP(true),
+							ShouldExist:        util.BoolP(true),
+						},
+					},
+				},
+			},
+			Raid: []types3_1.Raid{
+				{
+					Name:    "array",
+					Level:   "raid10",
+					Devices: []types3_1.Device{"/dev/sdb", "/dev/sdc"},
+					Spares:  util.IntP(1),
+					Options: []types3_1.RaidOption{"foobar"},
+				},
+			},
+			Filesystems: []types3_1.Filesystem{
+				{
+					Path:           util.StrP("/var"),
+					Device:         "/dev/disk/by-partlabel/var",
+					Format:         util.StrP("xfs"),
+					WipeFilesystem: util.BoolP(true),
+					Label:          util.StrP("var"),
+					UUID:           &aUUID,
+					Options: []types3_1.FilesystemOption{
+						types3_1.FilesystemOption("--label=var"),
+						types3_1.FilesystemOption("--uuid=9d6e42cd-dcef-4177-b4c6-2a0c979e3d82"),
+					},
+				},
+			},
+			Files: []types3_1.File{
+				{
+					Node: types3_1.Node{
+						Path:      "/var/varfile",
+						Overwrite: util.BoolPStrict(false),
+						User: types3_1.NodeUser{
+							ID: util.IntP(1000),
+						},
+						Group: types3_1.NodeGroup{
+							Name: util.StrP("groupname"),
+						},
+					},
+					FileEmbedded1: types3_1.FileEmbedded1{
+						Mode: util.IntP(420),
+						Append: []types3_1.Resource{
+							{
+								Compression: util.StrP("gzip"),
+								Source:      util.StrP("https://example.com"),
+								Verification: types3_1.Verification{
+									Hash: &aSha512Hash,
+								},
+								HTTPHeaders: types3_1.HTTPHeaders{
+									types3_1.HTTPHeader{
+										Name:  "Authorization",
+										Value: util.StrP("Basic YWxhZGRpbjpvcGVuc2VzYW1l"),
+									},
+									types3_1.HTTPHeader{
+										Name:  "User-Agent",
+										Value: util.StrP("Mozilla/5.0 (compatible; MSIE 6.0; Windows NT 5.1)"),
+									},
+								},
+							},
+						},
+					},
+				},
+				{
+					Node: types3_1.Node{
+						Path:      "/empty",
+						Overwrite: util.BoolPStrict(false),
+					},
+					FileEmbedded1: types3_1.FileEmbedded1{
+						Mode: util.IntP(420),
+						Contents: types3_1.Resource{
+							Source: util.StrPStrict(""),
+						},
+					},
+				},
+				{
+					Node: types3_1.Node{
+						Path:      "/etc/systemd/network/00-eth.network",
+						Overwrite: util.BoolPStrict(true),
+					},
+					FileEmbedded1: types3_1.FileEmbedded1{
+						Mode: util.IntP(420),
+						Contents: types3_1.Resource{
+							Source: util.StrPStrict("data:,%5BMatch%5D%0AType=%21vlan%20bond%20bridge%0AName=eth%2A%0A%0A%5BNetwork%5D%0ABond=bond0"),
+						},
+					},
+				},
+				{
+					Node: types3_1.Node{
+						Path:      "/etc/systemd/network/00-eth.network.d/dropin-1.conf",
+						Overwrite: util.BoolPStrict(true),
+					},
+					FileEmbedded1: types3_1.FileEmbedded1{
+						Mode: util.IntP(420),
+						Contents: types3_1.Resource{
+							Source: util.StrPStrict("data:,%5BMatch%5D%0AName=bond0%0A%0A%5BNetwork%5D%0ADHCP=true"),
+						},
+					},
+				},
+				{
+					Node: types3_1.Node{
+						Path:      "/etc/systemd/network/99-eth.network",
+						Overwrite: util.BoolPStrict(true),
+					},
+					FileEmbedded1: types3_1.FileEmbedded1{
+						Mode: util.IntP(420),
+						Contents: types3_1.Resource{
+							Source: util.StrPStrict("data:,%5BMatch%5D%0AName=eth12%0A%0A%5BNetwork%5D%0ABond=bond0"),
+						},
+					},
+				},
+			},
+			Directories: []types3_1.Directory{
+				{
+					Node: types3_1.Node{
+						Path:      "/rootdir",
+						Overwrite: util.BoolP(true),
+						User: types3_1.NodeUser{
+							ID: util.IntP(1000),
+						},
+						Group: types3_1.NodeGroup{
+							Name: util.StrP("groupname"),
+						},
+					},
+					DirectoryEmbedded1: types3_1.DirectoryEmbedded1{
+						Mode: util.IntP(420),
+					},
+				},
+			},
+			Links: []types3_1.Link{
+				{
+					Node: types3_1.Node{
+						Path:      "/rootlink",
+						Overwrite: util.BoolP(true),
+						User: types3_1.NodeUser{
+							ID: util.IntP(1000),
+						},
+						Group: types3_1.NodeGroup{
+							Name: util.StrP("groupname"),
+						},
+					},
+					LinkEmbedded1: types3_1.LinkEmbedded1{
+						Hard:   util.BoolP(false),
+						Target: "/foobar",
+					},
+				},
+			},
+		},
+		Passwd: types3_1.Passwd{
+			Users: []types3_1.PasswdUser{
+				{
+					Name: "user",
+					UID:  &userID,
+					Groups: []types3_1.Group{
+						"docker",
+					},
+				},
+			},
+		},
+	}
+
+	config3_1WithNoFSOptionsAndNoLabel = types3_1.Config{
+		Ignition: types3_1.Ignition{
+			Version: "3.1.0",
+			Config: types3_1.IgnitionConfig{
+				Merge: []types3_1.Resource{
+					{
+						Source: util.StrP("https://example.com"),
+						Verification: types3_1.Verification{
+							Hash: &aSha512Hash,
+						},
+					},
+				},
+				Replace: types3_1.Resource{
+					Source: util.StrP("https://example.com"),
+					Verification: types3_1.Verification{
+						Hash: &aSha512Hash,
+					},
+				},
+			},
+			Timeouts: types3_1.Timeouts{
+				HTTPResponseHeaders: util.IntP(5),
+				HTTPTotal:           util.IntP(10),
+			},
+			Security: types3_1.Security{
+				TLS: types3_1.TLS{
+					CertificateAuthorities: []types3_1.Resource{
+						{
+							Source: util.StrP("https://example.com"),
+							Verification: types3_1.Verification{
+								Hash: &aSha512Hash,
+							},
+						},
+					},
+				},
+			},
+			Proxy: types3_1.Proxy{
+				HTTPProxy:  util.StrP("https://proxy.example.net/"),
+				HTTPSProxy: util.StrP("https://secure.proxy.example.net/"),
+				NoProxy: []types3_1.NoProxyItem{
+					"www.example.net",
+					"www.example2.net",
+				},
+			},
+		},
+		Storage: types3_1.Storage{
+			Disks: []types3_1.Disk{
+				{
+					Device:    "/dev/sda",
+					WipeTable: util.BoolP(true),
+					Partitions: []types3_1.Partition{
+						{
+							Label:              util.StrP("var"),
+							Number:             1,
+							SizeMiB:            util.IntP(5000),
+							StartMiB:           util.IntP(2048),
+							TypeGUID:           &aUUID,
+							GUID:               &aUUID,
+							WipePartitionEntry: util.BoolP(true),
+							ShouldExist:        util.BoolP(true),
+						},
+					},
+				},
+			},
+			Raid: []types3_1.Raid{
+				{
+					Name:    "array",
+					Level:   "raid10",
+					Devices: []types3_1.Device{"/dev/sdb", "/dev/sdc"},
+					Spares:  util.IntP(1),
+					Options: []types3_1.RaidOption{"foobar"},
+				},
+			},
+			Filesystems: []types3_1.Filesystem{
+				{
+					Path:           util.StrP("/var"),
+					Device:         "/dev/disk/by-partlabel/var",
+					Format:         util.StrP("xfs"),
+					WipeFilesystem: util.BoolP(true),
+					UUID:           &aUUID,
+					Options: []types3_1.FilesystemOption{
+						types3_1.FilesystemOption("--labl=ROOT"),
+						types3_1.FilesystemOption("--uuid=9d6e42cd-dcef-4177-b4c6-2a0c979e3d82"),
+					},
+				},
+			},
+			Files: []types3_1.File{
+				{
+					Node: types3_1.Node{
+						Path:      "/var/varfile",
+						Overwrite: util.BoolPStrict(false),
+						User: types3_1.NodeUser{
+							ID: util.IntP(1000),
+						},
+						Group: types3_1.NodeGroup{
+							Name: util.StrP("groupname"),
+						},
+					},
+					FileEmbedded1: types3_1.FileEmbedded1{
+						Mode: util.IntP(420),
+						Append: []types3_1.Resource{
+							{
+								Compression: util.StrP("gzip"),
+								Source:      util.StrP("https://example.com"),
+								Verification: types3_1.Verification{
+									Hash: &aSha512Hash,
+								},
+								HTTPHeaders: types3_1.HTTPHeaders{
+									types3_1.HTTPHeader{
+										Name:  "Authorization",
+										Value: util.StrP("Basic YWxhZGRpbjpvcGVuc2VzYW1l"),
+									},
+									types3_1.HTTPHeader{
+										Name:  "User-Agent",
+										Value: util.StrP("Mozilla/5.0 (compatible; MSIE 6.0; Windows NT 5.1)"),
+									},
+								},
+							},
+						},
+					},
+				},
+				{
+					Node: types3_1.Node{
+						Path:      "/empty",
+						Overwrite: util.BoolPStrict(false),
+					},
+					FileEmbedded1: types3_1.FileEmbedded1{
+						Mode: util.IntP(420),
+						Contents: types3_1.Resource{
+							Source: util.StrPStrict(""),
+						},
+					},
+				},
+			},
+			Directories: []types3_1.Directory{
+				{
+					Node: types3_1.Node{
+						Path:      "/rootdir",
+						Overwrite: util.BoolP(true),
+						User: types3_1.NodeUser{
+							ID: util.IntP(1000),
+						},
+						Group: types3_1.NodeGroup{
+							Name: util.StrP("groupname"),
+						},
+					},
+					DirectoryEmbedded1: types3_1.DirectoryEmbedded1{
+						Mode: util.IntP(420),
+					},
+				},
+			},
+			Links: []types3_1.Link{
+				{
+					Node: types3_1.Node{
+						Path:      "/rootlink",
+						Overwrite: util.BoolP(true),
+						User: types3_1.NodeUser{
+							ID: util.IntP(1000),
+						},
+						Group: types3_1.NodeGroup{
+							Name: util.StrP("groupname"),
+						},
+					},
+					LinkEmbedded1: types3_1.LinkEmbedded1{
+						Hard:   util.BoolP(false),
+						Target: "/foobar",
+					},
+				},
+			},
+		},
+	}
+
+	nonexhaustiveConfig3_1 = types3_1.Config{
+		Ignition: types3_1.Ignition{
+			Version: "3.1.0",
+			Config: types3_1.IgnitionConfig{
+				Merge: []types3_1.Resource{
+					{
+						Source: util.StrP("https://example.com"),
+						Verification: types3_1.Verification{
+							Hash: &aSha512Hash,
+						},
+					},
+				},
+				Replace: types3_1.Resource{
+					Source: util.StrP("https://example.com"),
+					Verification: types3_1.Verification{
+						Hash: &aSha512Hash,
+					},
+				},
+			},
+			Timeouts: types3_1.Timeouts{
+				HTTPResponseHeaders: util.IntP(5),
+				HTTPTotal:           util.IntP(10),
+			},
+			Security: types3_1.Security{
+				TLS: types3_1.TLS{
+					CertificateAuthorities: []types3_1.Resource{
+						{
+							Source: util.StrP("https://example.com"),
+							Verification: types3_1.Verification{
+								Hash: &aSha512Hash,
+							},
+						},
+					},
+				},
+			},
+			Proxy: types3_1.Proxy{
+				HTTPProxy:  util.StrP("https://proxy.example.net/"),
+				HTTPSProxy: util.StrP("https://secure.proxy.example.net/"),
+				NoProxy: []types3_1.NoProxyItem{
+					"www.example.net",
+					"www.example2.net",
+				},
+			},
+		},
+		Storage: types3_1.Storage{
+			Disks: []types3_1.Disk{
+				{
+					Device:    "/dev/sda",
+					WipeTable: util.BoolP(true),
+					Partitions: []types3_1.Partition{
+						{
+							Label:              util.StrP("var"),
+							Number:             1,
+							SizeMiB:            util.IntP(5000),
+							StartMiB:           util.IntP(2048),
+							TypeGUID:           &aUUID,
+							GUID:               &aUUID,
+							WipePartitionEntry: util.BoolP(true),
+							ShouldExist:        util.BoolP(true),
+						},
+					},
+				},
+			},
+			Raid: []types3_1.Raid{
+				{
+					Name:    "array",
+					Level:   "raid10",
+					Devices: []types3_1.Device{"/dev/sdb", "/dev/sdc"},
+					Spares:  util.IntP(1),
+					Options: []types3_1.RaidOption{"foobar"},
+				},
+			},
+			Filesystems: []types3_1.Filesystem{
+				{
+					Path:           util.StrP("/var"),
+					Device:         "/dev/disk/by-partlabel/var",
+					Format:         util.StrP("xfs"),
+					WipeFilesystem: util.BoolP(true),
+					Label:          util.StrP("var"),
+					UUID:           &aUUID,
+					Options:        []types3_1.FilesystemOption{"rw"},
+				},
+			},
+			Files: []types3_1.File{
+				{
+					Node: types3_1.Node{
+						Path:      "/var/varfile",
+						Overwrite: util.BoolPStrict(false),
+						User: types3_1.NodeUser{
+							ID: util.IntP(1000),
+						},
+						Group: types3_1.NodeGroup{
+							Name: util.StrP("groupname"),
+						},
+					},
+					FileEmbedded1: types3_1.FileEmbedded1{
+						Mode: util.IntP(420),
+						Append: []types3_1.Resource{
+							{
+								Compression: util.StrP("gzip"),
+								Source:      util.StrP("https://example.com"),
+								Verification: types3_1.Verification{
+									Hash: &aSha512Hash,
+								},
+								HTTPHeaders: types3_1.HTTPHeaders{
+									types3_1.HTTPHeader{
+										Name:  "Authorization",
+										Value: util.StrP("Basic YWxhZGRpbjpvcGVuc2VzYW1l"),
+									},
+									types3_1.HTTPHeader{
+										Name:  "User-Agent",
+										Value: util.StrP("Mozilla/5.0 (compatible; MSIE 6.0; Windows NT 5.1)"),
+									},
+								},
+							},
+						},
+					},
+				},
+				{
+					Node: types3_1.Node{
+						Path:      "/empty",
+						Overwrite: util.BoolPStrict(false),
+					},
+					FileEmbedded1: types3_1.FileEmbedded1{
+						Mode: util.IntP(420),
+						Contents: types3_1.Resource{
+							Source: util.StrPStrict(""),
+						},
+					},
+				},
+			},
+			Directories: []types3_1.Directory{
+				{
+					Node: types3_1.Node{
+						Path:      "/rootdir",
+						Overwrite: util.BoolP(true),
+						User: types3_1.NodeUser{
+							ID: util.IntP(1000),
+						},
+						Group: types3_1.NodeGroup{
+							Name: util.StrP("groupname"),
+						},
+					},
+					DirectoryEmbedded1: types3_1.DirectoryEmbedded1{
+						Mode: util.IntP(420),
+					},
+				},
+			},
+			Links: []types3_1.Link{
+				{
+					Node: types3_1.Node{
+						Path:      "/rootlink",
+						Overwrite: util.BoolP(true),
+						User: types3_1.NodeUser{
+							ID: util.IntP(1000),
+						},
+						Group: types3_1.NodeGroup{
+							Name: util.StrP("groupname"),
+						},
+					},
+					LinkEmbedded1: types3_1.LinkEmbedded1{
+						Hard:   util.BoolP(false),
+						Target: "/foobar",
+					},
+				},
+			},
+		},
+	}
+)
+
+type input2_4 struct {
+	cfg   types2_4.Config
+	fsMap map[string]string
+}
+
+func TestCheck2_4WithGeneratedFSMap(t *testing.T) {
+	// in this config, Filesystem Name is not passed
+	// to verify the FS generation mechanism.
+	cfg := types2_4.Config{
+		Ignition: types2_4.Ignition{
+			Version: "2.4.0",
+		},
+		Storage: types2_4.Storage{
+			Filesystems: []types2_4.Filesystem{
+				{
+					Mount: &types2_4.Mount{
+						Device: "/dev/disk/by-partlabel/var",
+						Format: "xfs",
+						Create: &types2_4.Create{
+							Force: true,
+						},
+					},
+				},
+			},
+		},
+	}
+	fsMap := make(map[string]string)
+
+	if err := v24tov31.Check2_4(cfg, fsMap); err != nil {
+		t.Errorf("error should be nil got: %v", err)
+	}
+
+	if len(fsMap) != 2 {
+		t.Errorf("fsMap should have 2 keys: 'root' and a generated one. Got: %d", len(fsMap))
+	}
+}
+
+func TestCheck2_4(t *testing.T) {
+	goodConfigs := []input2_4{
+		{
+			exhaustiveConfig2_4,
+			exhaustiveMap,
+		},
+	}
+	badConfigs := []input2_4{
+		{}, // empty config has no version, fails validation
+		{
+			// use `mount.create` with `mount.create.force` set to false.
+			badDeprecatedConfig2_4,
+			exhaustiveMap,
+		},
+	}
+	for i, e := range goodConfigs {
+		if err := v24tov31.Check2_4(e.cfg, e.fsMap); err != nil {
+			t.Errorf("Good config test %d: got %v, expected nil", i, err)
+		}
+	}
+	for i, e := range badConfigs {
+		if err := v24tov31.Check2_4(e.cfg, e.fsMap); err == nil {
+			t.Errorf("Bad config test %d: got ok, expected: %v", i, err)
+		}
+	}
+}
+
+func TestTranslate2_4to3_1(t *testing.T) {
+	res, err := v24tov31.Translate(exhaustiveConfig2_4, exhaustiveMap)
+	if err != nil {
+		t.Fatalf("Failed translation: %v", err)
+	}
+	assert.Equal(t, nonexhaustiveConfig3_1, res)
+}
+
+func TestTranslateDeprecated2_4to3_1(t *testing.T) {
+	res, err := v24tov31.Translate(deprecatedConfig2_4, exhaustiveMap)
+	if err != nil {
+		t.Fatalf("Failed translation: %v", err)
+	}
+	assert.Equal(t, config3_1WithNoFSOptions, res)
+}
+
+func TestTranslateWrongDeprecated2_4to3_1(t *testing.T) {
+	res, err := v24tov31.Translate(wrongDeprecatedConfig2_4, exhaustiveMap)
+	if err != nil {
+		t.Fatalf("Failed translation: %v", err)
+	}
+	assert.Equal(t, config3_1WithNoFSOptionsAndNoLabel, res)
+}
+
+func TestRemoveDuplicateFilesUnitsUsers2_4(t *testing.T) {
+	mode := 420
+	testDataOld := "data:,old"
+	testDataNew := "data:,new"
+	testIgn2Config := types2_4.Config{}
+
+	// file test, add a duplicate file and see if the newest one is preserved
+	fileOld := types2_4.File{
+		Node: types2_4.Node{
+			Filesystem: "root", Path: "/etc/testfileconfig",
+		},
+		FileEmbedded1: types2_4.FileEmbedded1{
+			Contents: types2_4.FileContents{
+				Source: testDataOld,
+			},
+			Mode: &mode,
+		},
+	}
+	testIgn2Config.Storage.Files = append(testIgn2Config.Storage.Files, fileOld)
+
+	fileNew := types2_4.File{
+		Node: types2_4.Node{
+			Filesystem: "root", Path: "/etc/testfileconfig",
+		},
+		FileEmbedded1: types2_4.FileEmbedded1{
+			Contents: types2_4.FileContents{
+				Source: testDataNew,
+			},
+			Mode: &mode,
+		},
+	}
+	testIgn2Config.Storage.Files = append(testIgn2Config.Storage.Files, fileNew)
+
+	// unit test, add three units and three dropins with the same name as follows:
+	// unitOne:
+	//    contents: old
+	//    dropin:
+	//        name: one
+	//        contents: old
+	// unitTwo:
+	//    dropin:
+	//        name: one
+	//        contents: new
+	// unitThree:
+	//    contents: new
+	//    dropin:
+	//        name: two
+	//        contents: new
+	// Which should result in:
+	// unitFinal:
+	//    contents: new
+	//    dropin:
+	//      - name: one
+	//        contents: new
+	//      - name: two
+	//        contents: new
+	//
+	unitName := "testUnit"
+	dropinNameOne := "one"
+	dropinNameTwo := "two"
+	dropinOne := types2_4.SystemdDropin{
+		Contents: testDataOld,
+		Name:     dropinNameOne,
+	}
+	dropinTwo := types2_4.SystemdDropin{
+		Contents: testDataNew,
+		Name:     dropinNameOne,
+	}
+	dropinThree := types2_4.SystemdDropin{
+		Contents: testDataNew,
+		Name:     dropinNameTwo,
+	}
+
+	unitOne := types2_4.Unit{
+		Contents: testDataOld,
+		Name:     unitName,
+	}
+	unitOne.Dropins = append(unitOne.Dropins, dropinOne)
+	testIgn2Config.Systemd.Units = append(testIgn2Config.Systemd.Units, unitOne)
+
+	unitTwo := types2_4.Unit{
+		Name: unitName,
+	}
+	unitTwo.Dropins = append(unitTwo.Dropins, dropinTwo)
+	testIgn2Config.Systemd.Units = append(testIgn2Config.Systemd.Units, unitTwo)
+
+	unitThree := types2_4.Unit{
+		Contents: testDataNew,
+		Name:     unitName,
+	}
+	unitThree.Dropins = append(unitThree.Dropins, dropinThree)
+	testIgn2Config.Systemd.Units = append(testIgn2Config.Systemd.Units, unitThree)
+
+	// user test, add a duplicate user and see if it is deduplicated but ssh keys from both are preserved
+	userName := "testUser"
+	userOne := types2_4.PasswdUser{
+		Name: userName,
+		SSHAuthorizedKeys: []types2_4.SSHAuthorizedKey{
+			"one",
+			"two",
+		},
+	}
+	userTwo := types2_4.PasswdUser{
+		Name: userName,
+		SSHAuthorizedKeys: []types2_4.SSHAuthorizedKey{
+			"three",
+		},
+	}
+	userThree := types2_4.PasswdUser{
+		Name: "userThree",
+		SSHAuthorizedKeys: []types2_4.SSHAuthorizedKey{
+			"four",
+		},
+	}
+	testIgn2Config.Passwd.Users = append(testIgn2Config.Passwd.Users, userOne, userTwo, userThree)
+
+	convertedIgn2Config, err := v24tov31.RemoveDuplicateFilesUnitsUsers(testIgn2Config)
+	assert.NoError(t, err)
+
+	expectedIgn2Config := types2_4.Config{}
+	expectedIgn2Config.Storage.Files = append(expectedIgn2Config.Storage.Files, fileNew)
+	unitExpected := types2_4.Unit{
+		Contents: testDataNew,
+		Name:     unitName,
+	}
+	unitExpected.Dropins = append(unitExpected.Dropins, dropinThree)
+	unitExpected.Dropins = append(unitExpected.Dropins, dropinTwo)
+	expectedIgn2Config.Systemd.Units = append(expectedIgn2Config.Systemd.Units, unitExpected)
+	expectedMergedUser := types2_4.PasswdUser{
+		Name: userName,
+		SSHAuthorizedKeys: []types2_4.SSHAuthorizedKey{
+			"three",
+			"one",
+			"two",
+		},
+	}
+	expectedIgn2Config.Passwd.Users = append(expectedIgn2Config.Passwd.Users, userThree, expectedMergedUser)
+	assert.Equal(t, expectedIgn2Config, convertedIgn2Config)
+}
+
+func TestDuplicateUnits(t *testing.T) {
+	tests := []struct {
+		ign2 types2_4.Config
+		ign3 types3_1.Config
+		err  error
+	}{
+		{
+			ign2: types2_4.Config{
+				Ignition: types2_4.Ignition{
+					Version:  "2.4.0",
+					Config:   types2_4.IgnitionConfig{},
+					Timeouts: types2_4.Timeouts{},
+					Security: types2_4.Security{},
+					Proxy:    types2_4.Proxy{},
+				},
+				Systemd: types2_4.Systemd{
+					Units: []types2_4.Unit{
+						{
+							Name:   "kubeadm.service",
+							Enable: true,
+							Dropins: []types2_4.SystemdDropin{
+								{
+									Name:     "10-flatcar.conf",
+									Contents: "[Service]\nExecStart=",
+								},
+							},
+						},
+						{
+							Name:   "kubeadm.service",
+							Enable: true,
+							Dropins: []types2_4.SystemdDropin{
+								{
+									Name:     "20-flatcar.conf",
+									Contents: "[Service]\nExecStart=",
+								},
+							},
+						},
+						{
+							Name:   "kubeadm.service",
+							Enable: true,
+						},
+					},
+				},
+			},
+			ign3: types3_1.Config{
+				Ignition: types3_1.Ignition{
+					Version:  "3.1.0",
+					Config:   types3_1.IgnitionConfig{},
+					Timeouts: types3_1.Timeouts{},
+					Security: types3_1.Security{},
+					Proxy:    types3_1.Proxy{},
+				},
+				Systemd: types3_1.Systemd{
+					Units: []types3_1.Unit{
+						{
+							Name:    "kubeadm.service",
+							Enabled: util.BoolP(true),
+							Dropins: []types3_1.Dropin{
+								{
+									Name:     "10-flatcar.conf",
+									Contents: util.StrP("[Service]\nExecStart="),
+								},
+								{
+									Name:     "20-flatcar.conf",
+									Contents: util.StrP("[Service]\nExecStart="),
+								},
+							},
+						},
+					},
+				},
+			},
+			err: nil,
+		},
+		{
+			ign2: types2_4.Config{
+				Ignition: types2_4.Ignition{
+					Version:  "2.4.0",
+					Config:   types2_4.IgnitionConfig{},
+					Timeouts: types2_4.Timeouts{},
+					Security: types2_4.Security{},
+					Proxy:    types2_4.Proxy{},
+				},
+				Systemd: types2_4.Systemd{
+					Units: []types2_4.Unit{
+						{
+							Name:   "kubeadm.service",
+							Enable: true,
+							Dropins: []types2_4.SystemdDropin{
+								{
+									Name:     "10-flatcar.conf",
+									Contents: "[Service]\nExecStart=",
+								},
+							},
+						},
+						{
+							Name:   "kubeadm.service",
+							Enable: true,
+							Dropins: []types2_4.SystemdDropin{
+								{
+									Name:     "20-flatcar.conf",
+									Contents: "[Service]\nExecStart=",
+								},
+							},
+						},
+					},
+				},
+			},
+			ign3: types3_1.Config{
+				Ignition: types3_1.Ignition{
+					Version:  "3.1.0",
+					Config:   types3_1.IgnitionConfig{},
+					Timeouts: types3_1.Timeouts{},
+					Security: types3_1.Security{},
+					Proxy:    types3_1.Proxy{},
+				},
+				Systemd: types3_1.Systemd{
+					Units: []types3_1.Unit{
+						{
+							Name:    "kubeadm.service",
+							Enabled: util.BoolP(true),
+							Dropins: []types3_1.Dropin{
+								{
+									Name:     "10-flatcar.conf",
+									Contents: util.StrP("[Service]\nExecStart="),
+								},
+								{
+									Name:     "20-flatcar.conf",
+									Contents: util.StrP("[Service]\nExecStart="),
+								},
+							},
+						},
+					},
+				},
+			},
+			err: nil,
+		},
+		{
+			ign2: types2_4.Config{
+				Ignition: types2_4.Ignition{
+					Version:  "2.4.0",
+					Config:   types2_4.IgnitionConfig{},
+					Timeouts: types2_4.Timeouts{},
+					Security: types2_4.Security{},
+					Proxy:    types2_4.Proxy{},
+				},
+				Systemd: types2_4.Systemd{
+					Units: []types2_4.Unit{
+						{
+							Name:   "kubeadm.service",
+							Enable: true,
+						},
+						{
+							Name:   "kubeadm.service",
+							Enable: true,
+							Dropins: []types2_4.SystemdDropin{
+								{
+									Name:     "10-flatcar.conf",
+									Contents: "[Service]\nExecStart=",
+								},
+								{
+									Name:     "20-flatcar.conf",
+									Contents: "[Service]\nExecStart=",
+								},
+							},
+						},
+					},
+				},
+			},
+			ign3: types3_1.Config{
+				Ignition: types3_1.Ignition{
+					Version:  "3.1.0",
+					Config:   types3_1.IgnitionConfig{},
+					Timeouts: types3_1.Timeouts{},
+					Security: types3_1.Security{},
+					Proxy:    types3_1.Proxy{},
+				},
+				Systemd: types3_1.Systemd{
+					Units: []types3_1.Unit{
+						{
+							Name:    "kubeadm.service",
+							Enabled: util.BoolP(true),
+							Dropins: []types3_1.Dropin{
+								{
+									Name:     "10-flatcar.conf",
+									Contents: util.StrP("[Service]\nExecStart="),
+								},
+								{
+									Name:     "20-flatcar.conf",
+									Contents: util.StrP("[Service]\nExecStart="),
+								},
+							},
+						},
+					},
+				},
+			},
+			err: nil,
+		},
+		{
+			ign2: types2_4.Config{
+				Ignition: types2_4.Ignition{
+					Version:  "2.4.0",
+					Config:   types2_4.IgnitionConfig{},
+					Timeouts: types2_4.Timeouts{},
+					Security: types2_4.Security{},
+					Proxy:    types2_4.Proxy{},
+				},
+				Systemd: types2_4.Systemd{
+					Units: []types2_4.Unit{
+						{
+							Name:   "kubeadm.service",
+							Enable: true,
+						},
+						{
+							Name:   "kubeadm.service",
+							Enable: true,
+						},
+					},
+				},
+			},
+			ign3: types3_1.Config{
+				Ignition: types3_1.Ignition{
+					Version:  "3.1.0",
+					Config:   types3_1.IgnitionConfig{},
+					Timeouts: types3_1.Timeouts{},
+					Security: types3_1.Security{},
+					Proxy:    types3_1.Proxy{},
+				},
+				Systemd: types3_1.Systemd{
+					Units: []types3_1.Unit{
+						{
+							Name:    "kubeadm.service",
+							Enabled: util.BoolP(true),
+						},
+					},
+				},
+			},
+			err: nil,
+		},
+	}
+	for _, test := range tests {
+		res, err := v24tov31.Translate(test.ign2, nil)
+
+		assert.Equal(t, test.err, err)
+		assert.Equal(t, test.ign3, res)
+	}
+}
-- 
2.49.1

