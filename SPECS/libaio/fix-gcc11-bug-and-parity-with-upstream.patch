From 6507d3f7a2b1985a33d06f280b9388aa34054889 Mon Sep 17 00:00:00 2001
From: Jeff Moyer <jmoyer@redhat.com>
Date: Mon, 29 Jul 2019 10:07:23 -0400
Subject: [PATCH 01/33] harness: allow running tests against the installed
 library

A user can now specify "LIBAIO=/path/to/libaio.so" in order to run
the test harness against the installed library.

Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 harness/Makefile | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/harness/Makefile b/harness/Makefile
index f477737..87b33f6 100644
--- a/harness/Makefile
+++ b/harness/Makefile
@@ -9,10 +9,14 @@ HARNESS_SRCS:=main.c
 CFLAGS+=-Wall -Werror -I../src -g -O2 -DPAGE_SIZE=$(shell getconf PAGESIZE)
 #-lpthread -lrt
 
+# Change this on the build line to run tests against the installed libraries:
+# make LIBAIO=-laio partcheck
+LIBAIO?=../src/libaio.a
+
 all: $(PROGS)
 
 $(PROGS): %.p: %.t $(HARNESS_SRCS)
-	$(CC) $(CFLAGS) -DTEST_NAME=\"$<\" -o $@ main.c ../src/libaio.a -lpthread
+	$(CC) $(CFLAGS) -DTEST_NAME=\"$<\" -o $@ main.c $(LIBAIO) -lpthread
 
 clean:
 	rm -f $(PROGS) *.o runtests.out rofile wofile rwfile
-- 
2.17.1


From aef192335a7f16384c4b95a2cc2ce9c46fa72e02 Mon Sep 17 00:00:00 2001
From: Guillem Jover <guillem@hadrons.org>
Date: Sat, 20 Jul 2019 21:18:00 +0200
Subject: [PATCH 02/33] man: Add missing space in man page references

Signed-off-by: Guillem Jover <guillem@hadrons.org>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 man/io.3               | 26 +++++++++++++-------------
 man/io_cancel.3        | 26 +++++++++++++-------------
 man/io_fsync.3         | 24 ++++++++++++------------
 man/io_getevents.3     | 28 ++++++++++++++--------------
 man/io_prep_fsync.3    | 26 +++++++++++++-------------
 man/io_prep_pread.3    | 26 +++++++++++++-------------
 man/io_prep_pwrite.3   | 26 +++++++++++++-------------
 man/io_queue_init.3    | 26 +++++++++++++-------------
 man/io_queue_release.3 | 24 ++++++++++++------------
 man/io_queue_run.3     | 26 +++++++++++++-------------
 man/io_queue_wait.3    | 26 +++++++++++++-------------
 man/io_set_callback.3  | 26 +++++++++++++-------------
 man/io_submit.3        | 26 +++++++++++++-------------
 13 files changed, 168 insertions(+), 168 deletions(-)

diff --git a/man/io.3 b/man/io.3
index d910a68..968b1f9 100644
--- a/man/io.3
+++ b/man/io.3
@@ -336,16 +336,16 @@ int main(int argc, char *const *argv)
  */
 .fi
 .SH "SEE ALSO"
-.BR io_cancel(3),
-.BR io_fsync(3),
-.BR io_getevents(3),
-.BR io_prep_fsync(3),
-.BR io_prep_pread(3),
-.BR io_prep_pwrite(3),
-.BR io_queue_init(3),
-.BR io_queue_release(3),
-.BR io_queue_run(3),
-.BR io_queue_wait(3),
-.BR io_set_callback(3),
-.BR io_submit(3),
-.BR errno(3)
+.BR io_cancel (3),
+.BR io_fsync (3),
+.BR io_getevents (3),
+.BR io_prep_fsync (3),
+.BR io_prep_pread (3),
+.BR io_prep_pwrite (3),
+.BR io_queue_init (3),
+.BR io_queue_release (3),
+.BR io_queue_run (3),
+.BR io_queue_wait (3),
+.BR io_set_callback (3),
+.BR io_submit (3),
+.BR errno (3).
diff --git a/man/io_cancel.3 b/man/io_cancel.3
index 9a16084..3cf1bc6 100644
--- a/man/io_cancel.3
+++ b/man/io_cancel.3
@@ -50,16 +50,16 @@ cancelled.
 .B ENOSYS 
 if not implemented.
 .SH "SEE ALSO"
-.BR io(3),
-.BR io_fsync(3),
-.BR io_getevents(3),
-.BR io_prep_fsync(3),
-.BR io_prep_pread(3),
-.BR io_prep_pwrite(3),
-.BR io_queue_init(3),
-.BR io_queue_release(3),
-.BR io_queue_run(3),
-.BR io_queue_wait(3),
-.BR io_set_callback(3),
-.BR io_submit(3),
-.BR errno(3)
+.BR io (3),
+.BR io_fsync (3),
+.BR io_getevents (3),
+.BR io_prep_fsync (3),
+.BR io_prep_pread (3),
+.BR io_prep_pwrite (3),
+.BR io_queue_init (3),
+.BR io_queue_release (3),
+.BR io_queue_run (3),
+.BR io_queue_wait (3),
+.BR io_set_callback (3),
+.BR io_submit (3),
+.BR errno (3).
diff --git a/man/io_fsync.3 b/man/io_fsync.3
index 53eb63d..859de1b 100644
--- a/man/io_fsync.3
+++ b/man/io_fsync.3
@@ -68,15 +68,15 @@ The iocb contains a file descriptor that does not exist.
 .B EINVAL
 The file specified in the iocb does not support the given io operation.
 .SH "SEE ALSO"
-.BR io(3),
-.BR io_cancel(3),
-.BR io_getevents(3),
-.BR io_prep_pread(3),
-.BR io_prep_pwrite(3),
-.BR io_queue_init(3),
-.BR io_queue_release(3),
-.BR io_queue_run(3),
-.BR io_queue_wait(3),
-.BR io_set_callback(3),
-.BR io_submit(3),
-.BR errno(3)
+.BR io (3),
+.BR io_cancel (3),
+.BR io_getevents (3),
+.BR io_prep_pread (3),
+.BR io_prep_pwrite (3),
+.BR io_queue_init (3),
+.BR io_queue_release (3),
+.BR io_queue_run (3),
+.BR io_queue_wait (3),
+.BR io_set_callback (3),
+.BR io_submit (3),
+.BR errno (3).
diff --git a/man/io_getevents.3 b/man/io_getevents.3
index 5062daa..a4f8b57 100644
--- a/man/io_getevents.3
+++ b/man/io_getevents.3
@@ -118,17 +118,17 @@ if nr is out of range, if when is out of range.
 .B EFAULT 
 if any of the memory specified to is invalid.  
 .SH "SEE ALSO"
-.BR io(3),
-.BR io_cancel(3),
-.BR io_fsync(3),
-.BR io_prep_fsync(3),
-.BR io_prep_pread(3),
-.BR io_prep_pwrite(3),
-.BR io_queue_init(3),
-.BR io_queue_release(3),
-.BR io_queue_run(3),
-.BR io_queue_wait(3),
-.BR io_set_callback(3),
-.BR io_submit(3),
-.BR errno(3),
-.BR pselect(2)
+.BR io (3),
+.BR io_cancel (3),
+.BR io_fsync (3),
+.BR io_prep_fsync (3),
+.BR io_prep_pread (3),
+.BR io_prep_pwrite (3),
+.BR io_queue_init (3),
+.BR io_queue_release (3),
+.BR io_queue_run (3),
+.BR io_queue_wait (3),
+.BR io_set_callback (3),
+.BR io_submit (3),
+.BR errno (3),
+.BR pselect (2).
diff --git a/man/io_prep_fsync.3 b/man/io_prep_fsync.3
index 4cf935a..1173e2a 100644
--- a/man/io_prep_fsync.3
+++ b/man/io_prep_fsync.3
@@ -74,16 +74,16 @@ None
 .SH ERRORS
 None
 .SH "SEE ALSO"
-.BR io(3),
-.BR io_cancel(3),
-.BR io_fsync(3),
-.BR io_getevents(3),
-.BR io_prep_pread(3),
-.BR io_prep_pwrite(3),
-.BR io_queue_init(3),
-.BR io_queue_release(3),
-.BR io_queue_run(3),
-.BR io_queue_wait(3),
-.BR io_set_callback(3),
-.BR io_submit(3),
-.BR errno(3)
+.BR io (3),
+.BR io_cancel (3),
+.BR io_fsync (3),
+.BR io_getevents (3),
+.BR io_prep_pread (3),
+.BR io_prep_pwrite (3),
+.BR io_queue_init (3),
+.BR io_queue_release (3),
+.BR io_queue_run (3),
+.BR io_queue_wait (3),
+.BR io_set_callback (3),
+.BR io_submit (3),
+.BR errno (3).
diff --git a/man/io_prep_pread.3 b/man/io_prep_pread.3
index 5938aec..2c3b314 100644
--- a/man/io_prep_pread.3
+++ b/man/io_prep_pread.3
@@ -64,16 +64,16 @@ None
 .SH ERRORS
 None
 .SH "SEE ALSO"
-.BR io(3),
-.BR io_cancel(3),
-.BR io_fsync(3),
-.BR io_getevents(3),
-.BR io_prep_fsync(3),
-.BR io_prep_pwrite(3),
-.BR io_queue_init(3),
-.BR io_queue_release(3),
-.BR io_queue_run(3),
-.BR io_queue_wait(3),
-.BR io_set_callback(3),
-.BR io_submit(3),
-.BR errno(3)
+.BR io (3),
+.BR io_cancel (3),
+.BR io_fsync (3),
+.BR io_getevents (3),
+.BR io_prep_fsync (3),
+.BR io_prep_pwrite (3),
+.BR io_queue_init (3),
+.BR io_queue_release (3),
+.BR io_queue_run (3),
+.BR io_queue_wait (3),
+.BR io_set_callback (3),
+.BR io_submit (3),
+.BR errno (3).
diff --git a/man/io_prep_pwrite.3 b/man/io_prep_pwrite.3
index 68b3500..669b8c2 100644
--- a/man/io_prep_pwrite.3
+++ b/man/io_prep_pwrite.3
@@ -62,16 +62,16 @@ None
 .SH ERRORS
 None
 .SH "SEE ALSO"
-.BR io(3),
-.BR io_cancel(3),
-.BR io_fsync(3),
-.BR io_getevents(3),
-.BR io_prep_fsync(3),
-.BR io_prep_pread(3),
-.BR io_queue_init(3),
-.BR io_queue_release(3),
-.BR io_queue_run(3),
-.BR io_queue_wait(3),
-.BR io_set_callback(3),
-.BR io_submit(3),
-.BR errno(3)
+.BR io (3),
+.BR io_cancel (3),
+.BR io_fsync (3),
+.BR io_getevents (3),
+.BR io_prep_fsync (3),
+.BR io_prep_pread (3),
+.BR io_queue_init (3),
+.BR io_queue_release (3),
+.BR io_queue_run (3),
+.BR io_queue_wait (3),
+.BR io_set_callback (3),
+.BR io_submit (3),
+.BR errno (3).
diff --git a/man/io_queue_init.3 b/man/io_queue_init.3
index 317f631..7531f51 100644
--- a/man/io_queue_init.3
+++ b/man/io_queue_init.3
@@ -48,16 +48,16 @@ Not implemented
 .IR "maxevents > max_aio_reqs"
 where max_aio_reqs is a tunable value.
 .SH "SEE ALSO"
-.BR io(3),
-.BR io_cancel(3),
-.BR io_fsync(3),
-.BR io_getevents(3),
-.BR io_prep_fsync(3),
-.BR io_prep_pread(3),
-.BR io_prep_pwrite(3),
-.BR io_queue_release(3),
-.BR io_queue_run(3),
-.BR io_queue_wait(3),
-.BR io_set_callback(3),
-.BR io_submit(3),
-.BR errno(3)
+.BR io (3),
+.BR io_cancel (3),
+.BR io_fsync (3),
+.BR io_getevents (3),
+.BR io_prep_fsync (3),
+.BR io_prep_pread (3),
+.BR io_prep_pwrite (3),
+.BR io_queue_release (3),
+.BR io_queue_run (3),
+.BR io_queue_wait (3),
+.BR io_set_callback (3),
+.BR io_submit (3),
+.BR errno (3).
diff --git a/man/io_queue_release.3 b/man/io_queue_release.3
index 06b9ec0..9df39a0 100644
--- a/man/io_queue_release.3
+++ b/man/io_queue_release.3
@@ -32,17 +32,17 @@ contains an improperly initialized iocb,
 .B ENOSYS 
 Not implemented
 .SH "SEE ALSO"
-.BR io(3),
-.BR io_cancel(3),
-.BR io_fsync(3),
-.BR io_getevents(3),
-.BR io_prep_fsync(3),
-.BR io_prep_pread(3),
-.BR io_prep_pwrite(3),
-.BR io_queue_init(3),
-.BR io_queue_run(3),
+.BR io (3),
+.BR io_cancel (3),
+.BR io_fsync (3),
+.BR io_getevents (3),
+.BR io_prep_fsync (3),
+.BR io_prep_pread (3),
+.BR io_prep_pwrite (3),
+.BR io_queue_init (3),
+.BR io_queue_run (3),
 .BR io_queue_wait(3),
-.BR io_set_callback(3),
-.BR io_submit(3),
-.BR errno(3)
+.BR io_set_callback (3),
+.BR io_submit (3),
+.BR errno (3).
 
diff --git a/man/io_queue_run.3 b/man/io_queue_run.3
index 57dd417..45762f5 100644
--- a/man/io_queue_run.3
+++ b/man/io_queue_run.3
@@ -35,16 +35,16 @@ contains an improperly initialized iocb,
 .B ENOSYS 
 Not implemented
 .SH "SEE ALSO"
-.BR io(3),
-.BR io_cancel(3),
-.BR io_fsync(3),
-.BR io_getevents(3),
-.BR io_prep_fsync(3),
-.BR io_prep_pread(3),
-.BR io_prep_pwrite(3),
-.BR io_queue_init(3),
-.BR io_queue_release(3),
-.BR io_queue_wait(3),
-.BR io_set_callback(3),
-.BR io_submit(3),
-.BR errno(3)
+.BR io (3),
+.BR io_cancel (3),
+.BR io_fsync (3),
+.BR io_getevents (3),
+.BR io_prep_fsync (3),
+.BR io_prep_pread (3),
+.BR io_prep_pwrite (3),
+.BR io_queue_init (3),
+.BR io_queue_release (3),
+.BR io_queue_wait (3),
+.BR io_set_callback (3),
+.BR io_submit (3),
+.BR errno (3).
diff --git a/man/io_queue_wait.3 b/man/io_queue_wait.3
index 2306663..2c7fc2c 100644
--- a/man/io_queue_wait.3
+++ b/man/io_queue_wait.3
@@ -41,16 +41,16 @@ contains an improperly initialized iocb,
 .B ENOSYS 
 Not implemented
 .SH "SEE ALSO"
-.BR io(3),
-.BR io_cancel(3),
-.BR io_fsync(3),
-.BR io_getevents(3),
-.BR io_prep_fsync(3),
-.BR io_prep_pread(3),
-.BR io_prep_pwrite(3),
-.BR io_queue_init(3),
-.BR io_queue_release(3),
-.BR io_queue_run(3),
-.BR io_set_callback(3),
-.BR io_submit(3),
-.BR errno(3)
+.BR io (3),
+.BR io_cancel (3),
+.BR io_fsync (3),
+.BR io_getevents (3),
+.BR io_prep_fsync (3),
+.BR io_prep_pread (3),
+.BR io_prep_pwrite (3),
+.BR io_queue_init (3),
+.BR io_queue_release (3),
+.BR io_queue_run (3),
+.BR io_set_callback (3),
+.BR io_submit (3),
+.BR errno (3).
diff --git a/man/io_set_callback.3 b/man/io_set_callback.3
index a8ca789..3c7e43f 100644
--- a/man/io_set_callback.3
+++ b/man/io_set_callback.3
@@ -29,16 +29,16 @@ io_getevents, only with the library helpers
 .SH "RETURN VALUES"
 .SH ERRORS
 .SH "SEE ALSO"
-.BR io(3),
-.BR io_cancel(3),
-.BR io_fsync(3),
-.BR io_getevents(3),
-.BR io_prep_fsync(3),
-.BR io_prep_pread(3),
-.BR io_prep_pwrite(3),
-.BR io_queue_init(3),
-.BR io_queue_release(3),
-.BR io_queue_run(3),
-.BR io_queue_wait(3),
-.BR io_submit(3),
-.BR errno(3)
+.BR io (3),
+.BR io_cancel (3),
+.BR io_fsync (3),
+.BR io_getevents (3),
+.BR io_prep_fsync (3),
+.BR io_prep_pread (3),
+.BR io_prep_pwrite (3),
+.BR io_queue_init (3),
+.BR io_queue_release (3),
+.BR io_queue_run (3),
+.BR io_queue_wait (3),
+.BR io_submit (3),
+.BR errno (3).
diff --git a/man/io_submit.3 b/man/io_submit.3
index b6966ef..7281147 100644
--- a/man/io_submit.3
+++ b/man/io_submit.3
@@ -120,16 +120,16 @@ The iocb contains a file descriptor that does not exist.
 .B EINVAL
 The file specified in the iocb does not support the given io operation.
 .SH "SEE ALSO"
-.BR io(3),
-.BR io_cancel(3),
-.BR io_fsync(3),
-.BR io_getevents(3),
-.BR io_prep_fsync(3),
-.BR io_prep_pread(3),
-.BR io_prep_pwrite(3),
-.BR io_queue_init(3),
-.BR io_queue_release(3),
-.BR io_queue_run(3),
-.BR io_queue_wait(3),
-.BR io_set_callback(3),
-.BR errno(3)
+.BR io (3),
+.BR io_cancel (3),
+.BR io_fsync (3),
+.BR io_getevents (3),
+.BR io_prep_fsync (3),
+.BR io_prep_pread (3),
+.BR io_prep_pwrite (3),
+.BR io_queue_init (3),
+.BR io_queue_release (3),
+.BR io_queue_run (3),
+.BR io_queue_wait (3),
+.BR io_set_callback (3),
+.BR errno (3).
-- 
2.17.1


From 0cd5b9ea20e8bc315d43ba1e38ed113804e3c759 Mon Sep 17 00:00:00 2001
From: Guillem Jover <guillem@hadrons.org>
Date: Sat, 20 Jul 2019 21:18:01 +0200
Subject: [PATCH 03/33] man: Use the correct troff macro for comments

Signed-off-by: Guillem Jover <guillem@hadrons.org>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 man/io_fsync.3        | 12 ++++++------
 man/io_getevents.3    | 36 ++++++++++++++++++------------------
 man/io_prep_fsync.3   | 14 +++++++-------
 man/io_prep_pread.3   | 20 ++++++++++----------
 man/io_prep_pwrite.3  | 20 ++++++++++----------
 man/io_set_callback.3 |  2 +-
 man/io_submit.3       | 24 ++++++++++++------------
 7 files changed, 64 insertions(+), 64 deletions(-)

diff --git a/man/io_fsync.3 b/man/io_fsync.3
index 859de1b..77a62ff 100644
--- a/man/io_fsync.3
+++ b/man/io_fsync.3
@@ -1,9 +1,9 @@
-./" static inline int io_fsync(io_context_t ctx, struct iocb *iocb, io_callback_t cb, int fd)
-./" {
-./" 	io_prep_fsync(iocb, fd);
-./" 	io_set_callback(iocb, cb);
-./" 	return io_submit(ctx, 1, &iocb);
-./" }
+.\" static inline int io_fsync(io_context_t ctx, struct iocb *iocb, io_callback_t cb, int fd)
+.\" {
+.\" 	io_prep_fsync(iocb, fd);
+.\" 	io_set_callback(iocb, cb);
+.\" 	return io_submit(ctx, 1, &iocb);
+.\" }
 .TH io_fsync 3 2002-09-12 "Linux 2.4" Linux AIO"
 .SH NAME
 io_fsync \- Synchronize a file's complete in-core state with that on disk
diff --git a/man/io_getevents.3 b/man/io_getevents.3
index a4f8b57..1e643ac 100644
--- a/man/io_getevents.3
+++ b/man/io_getevents.3
@@ -1,21 +1,21 @@
-./"/* io_getevents:
-./" *      Attempts to read at least min_nr events and up to nr events from
-./" *      the completion queue for the aio_context specified by ctx_id.  May
-./" *      fail with -EINVAL if ctx_id is invalid, if min_nr is out of range,
-./" *      if nr is out of range, if when is out of range.  May fail with
-./" *      -EFAULT if any of the memory specified to is invalid.  May return
-./" *      0 or < min_nr if no events are available and the timeout specified
-./" *      by when has elapsed, where when == NULL specifies an infinite
-./" *      timeout.  Note that the timeout pointed to by when is relative and
-./" *      will be updated if not NULL and the operation blocks.  Will fail
-./" *      with -ENOSYS if not implemented.
-./" */
-./"asmlinkage long sys_io_getevents(io_context_t ctx_id,
-./"                                 long min_nr,
-./"                                 long nr,
-./"                                 struct io_event *events,
-./"                                 struct timespec *timeout)
-./"
+.\"/* io_getevents:
+.\" *      Attempts to read at least min_nr events and up to nr events from
+.\" *      the completion queue for the aio_context specified by ctx_id.  May
+.\" *      fail with -EINVAL if ctx_id is invalid, if min_nr is out of range,
+.\" *      if nr is out of range, if when is out of range.  May fail with
+.\" *      -EFAULT if any of the memory specified to is invalid.  May return
+.\" *      0 or < min_nr if no events are available and the timeout specified
+.\" *      by when has elapsed, where when == NULL specifies an infinite
+.\" *      timeout.  Note that the timeout pointed to by when is relative and
+.\" *      will be updated if not NULL and the operation blocks.  Will fail
+.\" *      with -ENOSYS if not implemented.
+.\" */
+.\"asmlinkage long sys_io_getevents(io_context_t ctx_id,
+.\"                                 long min_nr,
+.\"                                 long nr,
+.\"                                 struct io_event *events,
+.\"                                 struct timespec *timeout)
+.\"
 .TH io_getevents 2 2002-09-03 "Linux 2.4" "Linux AIO"
 .SH NAME
 io_getevents, aio_pgetevents \- Read resulting events from io requests
diff --git a/man/io_prep_fsync.3 b/man/io_prep_fsync.3
index 1173e2a..2daddee 100644
--- a/man/io_prep_fsync.3
+++ b/man/io_prep_fsync.3
@@ -1,10 +1,10 @@
-./" static inline void io_prep_fsync(struct iocb *iocb, int fd)
-./" {
-./" 	memset(iocb, 0, sizeof(*iocb));
-./" 	iocb->aio_fildes = fd;
-./" 	iocb->aio_lio_opcode = IO_CMD_FSYNC;
-./" 	iocb->aio_reqprio = 0;
-./" }
+.\" static inline void io_prep_fsync(struct iocb *iocb, int fd)
+.\" {
+.\" 	memset(iocb, 0, sizeof(*iocb));
+.\" 	iocb->aio_fildes = fd;
+.\" 	iocb->aio_lio_opcode = IO_CMD_FSYNC;
+.\" 	iocb->aio_reqprio = 0;
+.\" }
 .TH io_prep_fsync 3 2002-09-12 "Linux 2.4" Linux AIO"
 .SH NAME
 io_prep_fsync \- Synchronize a file's complete in-core state with that on disk
diff --git a/man/io_prep_pread.3 b/man/io_prep_pread.3
index 2c3b314..1ab28f5 100644
--- a/man/io_prep_pread.3
+++ b/man/io_prep_pread.3
@@ -1,13 +1,13 @@
-./" static inline void io_prep_pread(struct iocb *iocb, int fd, void *buf, size_t count, long long offset)
-./" {
-./" 	memset(iocb, 0, sizeof(*iocb));
-./" 	iocb->aio_fildes = fd;
-./" 	iocb->aio_lio_opcode = IO_CMD_PREAD;
-./" 	iocb->aio_reqprio = 0;
-./" 	iocb->u.c.buf = buf;
-./" 	iocb->u.c.nbytes = count;
-./" 	iocb->u.c.offset = offset;
-./" }
+.\" static inline void io_prep_pread(struct iocb *iocb, int fd, void *buf, size_t count, long long offset)
+.\" {
+.\" 	memset(iocb, 0, sizeof(*iocb));
+.\" 	iocb->aio_fildes = fd;
+.\" 	iocb->aio_lio_opcode = IO_CMD_PREAD;
+.\" 	iocb->aio_reqprio = 0;
+.\" 	iocb->u.c.buf = buf;
+.\" 	iocb->u.c.nbytes = count;
+.\" 	iocb->u.c.offset = offset;
+.\" }
 .TH io_prep_pread 3 2002-09-12 "Linux 2.4" Linux AIO"
 .SH NAME
 io_prep_pread \- Set up asynchronous read
diff --git a/man/io_prep_pwrite.3 b/man/io_prep_pwrite.3
index 669b8c2..f8d7fac 100644
--- a/man/io_prep_pwrite.3
+++ b/man/io_prep_pwrite.3
@@ -1,13 +1,13 @@
-./" static inline void io_prep_pwrite(struct iocb *iocb, int fd, void *buf, size_t count, long long offset)
-./" {
-./" 	memset(iocb, 0, sizeof(*iocb));
-./" 	iocb->aio_fildes = fd;
-./" 	iocb->aio_lio_opcode = IO_CMD_PWRITE;
-./" 	iocb->aio_reqprio = 0;
-./" 	iocb->u.c.buf = buf;
-./" 	iocb->u.c.nbytes = count;
-./" 	iocb->u.c.offset = offset;
-./" }
+.\" static inline void io_prep_pwrite(struct iocb *iocb, int fd, void *buf, size_t count, long long offset)
+.\" {
+.\" 	memset(iocb, 0, sizeof(*iocb));
+.\" 	iocb->aio_fildes = fd;
+.\" 	iocb->aio_lio_opcode = IO_CMD_PWRITE;
+.\" 	iocb->aio_reqprio = 0;
+.\" 	iocb->u.c.buf = buf;
+.\" 	iocb->u.c.nbytes = count;
+.\" 	iocb->u.c.offset = offset;
+.\" }
 .TH io_prep_pwrite 3 2002-09-12 "Linux 2.4" Linux AIO"
 .SH NAME
 io_prep_pwrite \- Set up iocb for asynchronous writes
diff --git a/man/io_set_callback.3 b/man/io_set_callback.3
index 3c7e43f..cc842f7 100644
--- a/man/io_set_callback.3
+++ b/man/io_set_callback.3
@@ -1,4 +1,4 @@
-./"static inline void io_set_callback(struct iocb *iocb, io_callback_t cb)
+.\"static inline void io_set_callback(struct iocb *iocb, io_callback_t cb)
 .TH io_set_callback 3 2002-09-12 "Linux 2.4" Linux AIO"
 .SH NAME
 io_set_callback \- Set up io completion callback function
diff --git a/man/io_submit.3 b/man/io_submit.3
index 7281147..a810b3f 100644
--- a/man/io_submit.3
+++ b/man/io_submit.3
@@ -1,15 +1,15 @@
-./"/* sys_io_submit:
-./" *      Queue the nr iocbs pointed to by iocbpp for processing.  Returns
-./" *      the number of iocbs queued.  May return -EINVAL if the aio_context
-./" *      specified by ctx_id is invalid, if nr is < 0, if the iocb at
-./" *      *iocbpp[0] is not properly initialized, if the operation specified
-./" *      is invalid for the file descriptor in the iocb.  May fail with
-./" *      -EFAULT if any of the data structures point to invalid data.  May
-./" *      fail with -EBADF if the file descriptor specified in the first
-./" *      iocb is invalid.  May fail with -EAGAIN if insufficient resources
-./" *      are available to queue any iocbs.  Will return 0 if nr is 0.  Will
-./" *      fail with -ENOSYS if not implemented.
-./" */
+.\"/* sys_io_submit:
+.\" *      Queue the nr iocbs pointed to by iocbpp for processing.  Returns
+.\" *      the number of iocbs queued.  May return -EINVAL if the aio_context
+.\" *      specified by ctx_id is invalid, if nr is < 0, if the iocb at
+.\" *      *iocbpp[0] is not properly initialized, if the operation specified
+.\" *      is invalid for the file descriptor in the iocb.  May fail with
+.\" *      -EFAULT if any of the data structures point to invalid data.  May
+.\" *      fail with -EBADF if the file descriptor specified in the first
+.\" *      iocb is invalid.  May fail with -EAGAIN if insufficient resources
+.\" *      are available to queue any iocbs.  Will return 0 if nr is 0.  Will
+.\" *      fail with -ENOSYS if not implemented.
+.\" */
 .TH io_submit 2 2002-09-02 "Linux 2.4" "Linux AIO"
 .SH NAME
 io_submit \- Submit io requests
-- 
2.17.1


From e9dce27ad722dc2f17f913e56432107bc3c1229f Mon Sep 17 00:00:00 2001
From: Guillem Jover <guillem@hadrons.org>
Date: Sat, 20 Jul 2019 21:18:02 +0200
Subject: [PATCH 04/33] man: Refer to libaio.h instead of libio.h

Signed-off-by: Guillem Jover <guillem@hadrons.org>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 man/io.3 | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/man/io.3 b/man/io.3
index 968b1f9..e4fe108 100644
--- a/man/io.3
+++ b/man/io.3
@@ -6,7 +6,7 @@ io \- Asynchronous IO
 .B #include <errno.h>
 .sp
 .br 
-.B #include <libio.h>
+.B #include <libaio.h>
 .sp
 .fi
 .SH DESCRIPTION
@@ -29,7 +29,7 @@ might be arbitrarily many operations running for one file.  The
 asynchronous I/O operations are controlled using a data structure named
 .IR "struct iocb"
 It is defined in
-.IR "libio.h"
+.IR "libaio.h"
 as follows.
 
 .nf
-- 
2.17.1


From d868db4f2c993ebb2895ca77c32b5a5d000355d7 Mon Sep 17 00:00:00 2001
From: Guillem Jover <guillem@hadrons.org>
Date: Sat, 20 Jul 2019 21:18:03 +0200
Subject: [PATCH 05/33] man: End sentences with a period

Signed-off-by: Guillem Jover <guillem@hadrons.org>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 man/io_prep_fsync.3    | 4 ++--
 man/io_prep_pread.3    | 4 ++--
 man/io_prep_pwrite.3   | 4 ++--
 man/io_queue_init.3    | 2 +-
 man/io_queue_release.3 | 2 +-
 man/io_queue_run.3     | 2 +-
 man/io_queue_wait.3    | 2 +-
 man/io_set_callback.3  | 2 +-
 8 files changed, 11 insertions(+), 11 deletions(-)

diff --git a/man/io_prep_fsync.3 b/man/io_prep_fsync.3
index 2daddee..3a5f952 100644
--- a/man/io_prep_fsync.3
+++ b/man/io_prep_fsync.3
@@ -70,9 +70,9 @@ must be called.
 Simultaneous asynchronous operations using the same iocb produce
 undefined results.
 .SH "RETURN VALUES"
-None
+None.
 .SH ERRORS
-None
+None.
 .SH "SEE ALSO"
 .BR io (3),
 .BR io_cancel (3),
diff --git a/man/io_prep_pread.3 b/man/io_prep_pread.3
index 1ab28f5..a4df182 100644
--- a/man/io_prep_pread.3
+++ b/man/io_prep_pread.3
@@ -60,9 +60,9 @@ must be called.
 Simultaneous asynchronous operations using the same iocb produce
 undefined results.
 .SH "RETURN VALUES"
-None
+None.
 .SH ERRORS
-None
+None.
 .SH "SEE ALSO"
 .BR io (3),
 .BR io_cancel (3),
diff --git a/man/io_prep_pwrite.3 b/man/io_prep_pwrite.3
index f8d7fac..73c62c7 100644
--- a/man/io_prep_pwrite.3
+++ b/man/io_prep_pwrite.3
@@ -58,9 +58,9 @@ must be called.
 Simultaneous asynchronous operations using the same iocb produce
 undefined results.
 .SH "RETURN VALUES"
-None
+None.
 .SH ERRORS
-None
+None.
 .SH "SEE ALSO"
 .BR io (3),
 .BR io_cancel (3),
diff --git a/man/io_queue_init.3 b/man/io_queue_init.3
index 7531f51..666dfae 100644
--- a/man/io_queue_init.3
+++ b/man/io_queue_init.3
@@ -42,7 +42,7 @@ is <= 0 or
 is an invalid memory locattion.
 .TP
 .B ENOSYS 
-Not implemented
+Not implemented.
 .TP
 .B EAGAIN
 .IR "maxevents > max_aio_reqs"
diff --git a/man/io_queue_release.3 b/man/io_queue_release.3
index 9df39a0..f927562 100644
--- a/man/io_queue_release.3
+++ b/man/io_queue_release.3
@@ -30,7 +30,7 @@ refers to an unitialized aio context, the iocb pointed to by
 contains an improperly initialized iocb,
 .TP
 .B ENOSYS 
-Not implemented
+Not implemented.
 .SH "SEE ALSO"
 .BR io (3),
 .BR io_cancel (3),
diff --git a/man/io_queue_run.3 b/man/io_queue_run.3
index 45762f5..35f385b 100644
--- a/man/io_queue_run.3
+++ b/man/io_queue_run.3
@@ -33,7 +33,7 @@ refers to an unitialized aio context, the iocb pointed to by
 contains an improperly initialized iocb,
 .TP
 .B ENOSYS 
-Not implemented
+Not implemented.
 .SH "SEE ALSO"
 .BR io (3),
 .BR io_cancel (3),
diff --git a/man/io_queue_wait.3 b/man/io_queue_wait.3
index 2c7fc2c..eb6db83 100644
--- a/man/io_queue_wait.3
+++ b/man/io_queue_wait.3
@@ -39,7 +39,7 @@ refers to an unitialized aio context, the iocb pointed to by
 contains an improperly initialized iocb,
 .TP
 .B ENOSYS 
-Not implemented
+Not implemented.
 .SH "SEE ALSO"
 .BR io (3),
 .BR io_cancel (3),
diff --git a/man/io_set_callback.3 b/man/io_set_callback.3
index cc842f7..71efd2f 100644
--- a/man/io_set_callback.3
+++ b/man/io_set_callback.3
@@ -25,7 +25,7 @@ typedef void (*io_callback_t)(io_context_t ctx, struct iocb *iocb, long res, lon
 .fi
 .SH DESCRIPTION
 The callback is not done if the caller uses raw events from 
-io_getevents, only with the library helpers
+io_getevents, only with the library helpers.
 .SH "RETURN VALUES"
 .SH ERRORS
 .SH "SEE ALSO"
-- 
2.17.1


From 19a7217fe0a4dafd5f171b99bc27b7d8a29df9a0 Mon Sep 17 00:00:00 2001
From: Guillem Jover <guillem@hadrons.org>
Date: Sat, 20 Jul 2019 21:18:04 +0200
Subject: [PATCH 06/33] man: Fix casing

Signed-off-by: Guillem Jover <guillem@hadrons.org>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 man/io_cancel.3    | 4 ++--
 man/io_getevents.3 | 4 ++--
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/man/io_cancel.3 b/man/io_cancel.3
index 3cf1bc6..9ac1b40 100644
--- a/man/io_cancel.3
+++ b/man/io_cancel.3
@@ -33,7 +33,7 @@ have to be overwritten soon.  As an example, assume an application, which
 writes data in files in a situation where new incoming data would have
 to be written in a file which will be updated by an enqueued request.
 .SH "RETURN VALUES"
-0 is returned on success , otherwise returns Errno.
+0 is returned on success , otherwise returns errno.
 .SH ERRORS
 .TP
 .B EFAULT 
@@ -48,7 +48,7 @@ If the iocb specified was not
 cancelled.  
 .TP
 .B ENOSYS 
-if not implemented.
+If not implemented.
 .SH "SEE ALSO"
 .BR io (3),
 .BR io_fsync (3),
diff --git a/man/io_getevents.3 b/man/io_getevents.3
index 1e643ac..c8f2676 100644
--- a/man/io_getevents.3
+++ b/man/io_getevents.3
@@ -112,11 +112,11 @@ behaves the same as
 .SH ERRORS
 .TP
 .B EINVAL 
-if ctx_id is invalid, if min_nr is out of range,
+If ctx_id is invalid, if min_nr is out of range,
 if nr is out of range, if when is out of range.  
 .TP
 .B EFAULT 
-if any of the memory specified to is invalid.  
+If any of the memory specified to is invalid.
 .SH "SEE ALSO"
 .BR io (3),
 .BR io_cancel (3),
-- 
2.17.1


From 0319efeeea3dbd4b53b81934b4f24bba96d77959 Mon Sep 17 00:00:00 2001
From: Guillem Jover <guillem@hadrons.org>
Date: Sat, 20 Jul 2019 21:18:05 +0200
Subject: [PATCH 07/33] man: Fix period formatting

Signed-off-by: Guillem Jover <guillem@hadrons.org>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 man/io.3               | 13 +++++--------
 man/io_fsync.3         |  2 +-
 man/io_getevents.3     |  3 +--
 man/io_prep_fsync.3    |  2 +-
 man/io_prep_pread.3    |  5 ++---
 man/io_prep_pwrite.3   |  5 ++---
 man/io_queue_release.3 |  2 +-
 man/io_queue_run.3     |  2 +-
 man/io_queue_wait.3    |  2 +-
 man/io_submit.3        |  8 ++++----
 10 files changed, 19 insertions(+), 25 deletions(-)

diff --git a/man/io.3 b/man/io.3
index e4fe108..7b8ab5e 100644
--- a/man/io.3
+++ b/man/io.3
@@ -17,8 +17,8 @@ then immediately resume normal work while the I/O operations are
 executed in parallel.  
 
 These functions are part of the library with realtime functions named
-.IR "libaio"
-.  They are not actually part of the 
+.IR libaio .
+They are not actually part of the
 .IR "libc" 
 binary.
 The implementation of these functions can be done using support in the
@@ -98,8 +98,7 @@ where the read data is stored.
 .TP
 .IR "long u.c.nbytes"
 This element specifies the length of the buffer pointed to by 
-.IR "io_buf"
-.
+.IR io_buf .
 .TP
 .IR "int aio_reqprio"
 Is not currently used.
@@ -111,8 +110,7 @@ and store the next
 .IR "u.c.nbytes"
 bytes in the
 buffer pointed to by 
-.IR "buf"
-.
+.IR buf .
 .TP
 .B "IO_CMD_PWRITE"
 Start a write operation.  Write 
@@ -120,8 +118,7 @@ Start a write operation.  Write
 bytes starting at
 .IR "buf"
 into the file starting at position 
-.IR "u.c.offset"
-.
+.IR u.c.offset .
 .TP
 .B "IO_CMD_NOP"
 Do nothing for this control block.  This value is useful sometimes when
diff --git a/man/io_fsync.3 b/man/io_fsync.3
index 77a62ff..03c81bc 100644
--- a/man/io_fsync.3
+++ b/man/io_fsync.3
@@ -39,7 +39,7 @@ resources (mainly computation time).
 Calling this function forces all I/O operations operating queued at the
 time of the function call operating on the file descriptor
 .IR "iocb->io_fildes"
-into the synchronized I/O completion state .  The 
+into the synchronized I/O completion state.  The
 .IR "io_fsync"
 function returns
 immediately but the notification through the method described in
diff --git a/man/io_getevents.3 b/man/io_getevents.3
index c8f2676..24c07c3 100644
--- a/man/io_getevents.3
+++ b/man/io_getevents.3
@@ -107,8 +107,7 @@ argument is specified as NULL, then no signal mask manipulation is
 performed (and thus
 .BR io_pgetevents ()
 behaves the same as
-.BR io_getevents()
-) .
+.BR io_getevents() ).
 .SH ERRORS
 .TP
 .B EINVAL 
diff --git a/man/io_prep_fsync.3 b/man/io_prep_fsync.3
index 3a5f952..cf4ecff 100644
--- a/man/io_prep_fsync.3
+++ b/man/io_prep_fsync.3
@@ -62,7 +62,7 @@ forced to the relevant completion state. The completion of
 subsequent I/O on the file descriptor is not guaranteed to be
 completed in a synchronized fashion.
 .PP
-This function returns immediately . To schedule the operation, the
+This function returns immediately. To schedule the operation, the
 function
 .IR io_submit
 must be called.
diff --git a/man/io_prep_pread.3 b/man/io_prep_pread.3
index a4df182..6d66c0f 100644
--- a/man/io_prep_pread.3
+++ b/man/io_prep_pread.3
@@ -44,15 +44,14 @@ bytes of the file for which
 is a descriptor are written to the buffer
 starting at
 .TP
-.IR "iocb->u.c.buf = buf"
-.
+.IR "iocb->u.c.buf = buf" .
 .br
 Reading starts at the absolute position
 .TP
 .IR "ioc->u.c.offset = offset"
 in the file.
 .PP
-This function returns immediately . To schedule the operation, the
+This function returns immediately. To schedule the operation, the
 function 
 .IR io_submit
 must be called.
diff --git a/man/io_prep_pwrite.3 b/man/io_prep_pwrite.3
index 73c62c7..98b3a65 100644
--- a/man/io_prep_pwrite.3
+++ b/man/io_prep_pwrite.3
@@ -42,15 +42,14 @@ bytes of the file for which
 is a descriptor are written from the buffer
 starting at
 .TP
-.IR "iocb->u.c.buf = buf"
-.
+.IR "iocb->u.c.buf = buf" .
 .br
 Writing starts at the absolute position
 .TP
 .IR "ioc->u.c.offset = offset"
 in the file.
 .PP
-This function returns immediately . To schedule the operation, the
+This function returns immediately. To schedule the operation, the
 function
 .IR io_submit
 must be called.
diff --git a/man/io_queue_release.3 b/man/io_queue_release.3
index f927562..db91bad 100644
--- a/man/io_queue_release.3
+++ b/man/io_queue_release.3
@@ -12,7 +12,7 @@ io_queue_release \- Release the context associated with the userspace handle
 .sp
 .SH DESCRIPTION
 .B io_queue_release
-destroys the context associated with the userspace handle.    May cancel any outstanding
+destroys the context associated with the userspace handle. May cancel any outstanding
 AIOs and block on completion.
 
 .B cts.
diff --git a/man/io_queue_run.3 b/man/io_queue_run.3
index 35f385b..018257f 100644
--- a/man/io_queue_run.3
+++ b/man/io_queue_run.3
@@ -30,7 +30,7 @@ referenced data outside of the program's accessible address space.
 .I ctx 
 refers to an unitialized aio context, the iocb pointed to by
 .I iocbs 
-contains an improperly initialized iocb,
+contains an improperly initialized iocb.
 .TP
 .B ENOSYS 
 Not implemented.
diff --git a/man/io_queue_wait.3 b/man/io_queue_wait.3
index eb6db83..e3598d9 100644
--- a/man/io_queue_wait.3
+++ b/man/io_queue_wait.3
@@ -36,7 +36,7 @@ referenced data outside of the program's accessible address space.
 .I ctx 
 refers to an unitialized aio context, the iocb pointed to by
 .I iocbs 
-contains an improperly initialized iocb,
+contains an improperly initialized iocb.
 .TP
 .B ENOSYS 
 Not implemented.
diff --git a/man/io_submit.3 b/man/io_submit.3
index a810b3f..76e68d1 100644
--- a/man/io_submit.3
+++ b/man/io_submit.3
@@ -49,12 +49,12 @@ gets the
 .IR "nr"
 requests from the array pointed to
 by 
-.IR "iocbs"
-.  The operation to be performed is determined by the
+.IR "iocbs" .
+The operation to be performed is determined by the
 .IR "aio_lio_opcode"
 member in each element of 
-.IR "iocbs"
-.  If this
+.IR "iocbs" .
+If this
 field is 
 .B "IO_CMD_PREAD"
 a read operation is enqueued, similar to a call
-- 
2.17.1


From 767c68f7ea77f46fe9a227c2dc64a48f8eaa06f5 Mon Sep 17 00:00:00 2001
From: Guillem Jover <guillem@hadrons.org>
Date: Sat, 20 Jul 2019 21:18:06 +0200
Subject: [PATCH 08/33] man: Remove spurious spaces

Signed-off-by: Guillem Jover <guillem@hadrons.org>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 man/io_cancel.3     | 2 +-
 man/io_queue_run.3  | 2 +-
 man/io_queue_wait.3 | 2 +-
 3 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/man/io_cancel.3 b/man/io_cancel.3
index 9ac1b40..261a407 100644
--- a/man/io_cancel.3
+++ b/man/io_cancel.3
@@ -33,7 +33,7 @@ have to be overwritten soon.  As an example, assume an application, which
 writes data in files in a situation where new incoming data would have
 to be written in a file which will be updated by an enqueued request.
 .SH "RETURN VALUES"
-0 is returned on success , otherwise returns errno.
+0 is returned on success, otherwise returns errno.
 .SH ERRORS
 .TP
 .B EFAULT 
diff --git a/man/io_queue_run.3 b/man/io_queue_run.3
index 018257f..b05851c 100644
--- a/man/io_queue_run.3
+++ b/man/io_queue_run.3
@@ -14,7 +14,7 @@ io_queue_run \- Handle completed io requests
 .fi
 .SH DESCRIPTION
 .B io_queue_run
-Attempts to read  all the events events from
+Attempts to read all the events events from
 the completion queue for the aio_context specified by ctx_id.
 .SH "RETURN VALUES"
 May return
diff --git a/man/io_queue_wait.3 b/man/io_queue_wait.3
index e3598d9..fff8141 100644
--- a/man/io_queue_wait.3
+++ b/man/io_queue_wait.3
@@ -12,7 +12,7 @@ io_queue_wait \- Wait for io requests to complete
 .BI "int io_queue_wait(io_context_t ctx, const struct timespec *timeout);"
 .fi
 .SH DESCRIPTION
-Attempts to read  an event from
+Attempts to read an event from
 the completion queue for the aio_context specified by ctx_id.
 .SH "RETURN VALUES"
 May return
-- 
2.17.1


From 5f0e08fda606b960eb1652f5e6743dc031e595f1 Mon Sep 17 00:00:00 2001
From: Guillem Jover <guillem@hadrons.org>
Date: Sat, 20 Jul 2019 21:18:07 +0200
Subject: [PATCH 09/33] man: Remove spurious text

Signed-off-by: Guillem Jover <guillem@hadrons.org>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 man/io_getevents.3     | 1 -
 man/io_prep_pread.3    | 2 +-
 man/io_queue_release.3 | 3 +--
 3 files changed, 2 insertions(+), 4 deletions(-)

diff --git a/man/io_getevents.3 b/man/io_getevents.3
index 24c07c3..37e9f7a 100644
--- a/man/io_getevents.3
+++ b/man/io_getevents.3
@@ -73,7 +73,6 @@ events happens or until a signal is caught.
 The following
 .BR io_pgetevents ()
 call:
-call:
 .PP
 .in +4n
 .EX
diff --git a/man/io_prep_pread.3 b/man/io_prep_pread.3
index 6d66c0f..b32fe4c 100644
--- a/man/io_prep_pread.3
+++ b/man/io_prep_pread.3
@@ -20,7 +20,7 @@ io_prep_pread \- Set up asynchronous read
 .br
 .sp
 .BI "inline void io_prep_pread(struct iocb *iocb, int fd, void *buf, size_t count, long long offset)
-"
+.
 .sp
 struct iocb {
 	void		*data;
diff --git a/man/io_queue_release.3 b/man/io_queue_release.3
index db91bad..6444aff 100644
--- a/man/io_queue_release.3
+++ b/man/io_queue_release.3
@@ -14,8 +14,7 @@ io_queue_release \- Release the context associated with the userspace handle
 .B io_queue_release
 destroys the context associated with the userspace handle. May cancel any outstanding
 AIOs and block on completion.
-
-.B cts.
+.
 .SH "RETURN VALUES"
 On success,
 .B io_queue_release
-- 
2.17.1


From 69874fec6fef24564302b2efa9af53af07851058 Mon Sep 17 00:00:00 2001
From: Guillem Jover <guillem@hadrons.org>
Date: Sat, 20 Jul 2019 21:18:08 +0200
Subject: [PATCH 10/33] man: Add "None" to empty sections

Signed-off-by: Guillem Jover <guillem@hadrons.org>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 man/io_set_callback.3 | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/man/io_set_callback.3 b/man/io_set_callback.3
index 71efd2f..4ee4b05 100644
--- a/man/io_set_callback.3
+++ b/man/io_set_callback.3
@@ -27,7 +27,9 @@ typedef void (*io_callback_t)(io_context_t ctx, struct iocb *iocb, long res, lon
 The callback is not done if the caller uses raw events from 
 io_getevents, only with the library helpers.
 .SH "RETURN VALUES"
+None.
 .SH ERRORS
+None.
 .SH "SEE ALSO"
 .BR io (3),
 .BR io_cancel (3),
-- 
2.17.1


From 716fe28caeefd07235413c309d316e9a92587e0c Mon Sep 17 00:00:00 2001
From: Guillem Jover <guillem@hadrons.org>
Date: Sat, 20 Jul 2019 21:18:09 +0200
Subject: [PATCH 11/33] man: Fix typos

Signed-off-by: Guillem Jover <guillem@hadrons.org>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 man/io.3               | 2 +-
 man/io_fsync.3         | 4 ++--
 man/io_getevents.3     | 4 ++--
 man/io_prep_fsync.3    | 2 +-
 man/io_prep_pread.3    | 2 +-
 man/io_prep_pwrite.3   | 4 ++--
 man/io_queue_init.3    | 2 +-
 man/io_queue_release.3 | 2 +-
 man/io_queue_run.3     | 4 ++--
 man/io_queue_wait.3    | 2 +-
 man/io_set_callback.3  | 2 +-
 man/io_submit.3        | 2 +-
 12 files changed, 16 insertions(+), 16 deletions(-)

diff --git a/man/io.3 b/man/io.3
index 7b8ab5e..bc529ea 100644
--- a/man/io.3
+++ b/man/io.3
@@ -1,7 +1,7 @@
 .TH io 3 2002-09-12 "Linux 2.4" Linux IO"
 .SH NAME
 io \- Asynchronous IO
-.SH SYNOPSYS
+.SH SYNOPSIS
 .nf
 .B #include <errno.h>
 .sp
diff --git a/man/io_fsync.3 b/man/io_fsync.3
index 03c81bc..5400d41 100644
--- a/man/io_fsync.3
+++ b/man/io_fsync.3
@@ -7,7 +7,7 @@
 .TH io_fsync 3 2002-09-12 "Linux 2.4" Linux AIO"
 .SH NAME
 io_fsync \- Synchronize a file's complete in-core state with that on disk
-.SH SYNOPSYS
+.SH SYNOPSIS
 .nf
 .B #include <errno.h>
 .sp
@@ -58,7 +58,7 @@ referenced data outside of the program's accessible address space.
 .TP
 .B EINVAL
 .I ctx
-refers to an unitialized aio context, the iocb pointed to by 
+refers to an uninitialized aio context, the iocb pointed to by
 .I iocbs
 contains an improperly initialized iocb, 
 .TP
diff --git a/man/io_getevents.3 b/man/io_getevents.3
index 37e9f7a..95fa86e 100644
--- a/man/io_getevents.3
+++ b/man/io_getevents.3
@@ -64,11 +64,11 @@ is analogous to the relationship between
 .BR select (2)
 and
 .BR pselect (2):
-similar
+similar to
 .BR pselect (2),
 .BR pgetevents ()
 allows an application to safely wait until either an aio completion
-events happens or until a signal is caught.
+event happens or until a signal is caught.
 .PP
 The following
 .BR io_pgetevents ()
diff --git a/man/io_prep_fsync.3 b/man/io_prep_fsync.3
index cf4ecff..0397172 100644
--- a/man/io_prep_fsync.3
+++ b/man/io_prep_fsync.3
@@ -8,7 +8,7 @@
 .TH io_prep_fsync 3 2002-09-12 "Linux 2.4" Linux AIO"
 .SH NAME
 io_prep_fsync \- Synchronize a file's complete in-core state with that on disk
-.SH SYNOPSYS
+.SH SYNOPSIS
 .nf
 .B #include <errno.h>
 .br
diff --git a/man/io_prep_pread.3 b/man/io_prep_pread.3
index b32fe4c..3c28f61 100644
--- a/man/io_prep_pread.3
+++ b/man/io_prep_pread.3
@@ -11,7 +11,7 @@
 .TH io_prep_pread 3 2002-09-12 "Linux 2.4" Linux AIO"
 .SH NAME
 io_prep_pread \- Set up asynchronous read
-.SH SYNOPSYS
+.SH SYNOPSIS
 .nf
 .B #include <errno.h>
 .sp
diff --git a/man/io_prep_pwrite.3 b/man/io_prep_pwrite.3
index 98b3a65..69479c2 100644
--- a/man/io_prep_pwrite.3
+++ b/man/io_prep_pwrite.3
@@ -11,7 +11,7 @@
 .TH io_prep_pwrite 3 2002-09-12 "Linux 2.4" Linux AIO"
 .SH NAME
 io_prep_pwrite \- Set up iocb for asynchronous writes
-.SH SYNOPSYS
+.SH SYNOPSIS
 .nf
 .B #include <errno.h>
 .br
@@ -31,7 +31,7 @@ struct iocb {
 };
 .fi
 .SH DESCRIPTION
-io_prep_write is a convenicence function for setting up parallel writes.
+io_prep_write is a convenience function for setting up parallel writes.
 
 The first
 .TP
diff --git a/man/io_queue_init.3 b/man/io_queue_init.3
index 666dfae..9c04b3f 100644
--- a/man/io_queue_init.3
+++ b/man/io_queue_init.3
@@ -39,7 +39,7 @@ referenced data outside of the program's accessible address space.
 .I maxevents
 is <= 0 or 
 .IR ctx
-is an invalid memory locattion.
+is an invalid memory location.
 .TP
 .B ENOSYS 
 Not implemented.
diff --git a/man/io_queue_release.3 b/man/io_queue_release.3
index 6444aff..5c9ded1 100644
--- a/man/io_queue_release.3
+++ b/man/io_queue_release.3
@@ -24,7 +24,7 @@ error is one of the Exxx values defined in the Errors section.
 .TP
 .B EINVAL
 .I ctx 
-refers to an unitialized aio context, the iocb pointed to by
+refers to an uninitialized aio context, the iocb pointed to by
 .I iocbs 
 contains an improperly initialized iocb,
 .TP
diff --git a/man/io_queue_run.3 b/man/io_queue_run.3
index b05851c..8e0691c 100644
--- a/man/io_queue_run.3
+++ b/man/io_queue_run.3
@@ -14,7 +14,7 @@ io_queue_run \- Handle completed io requests
 .fi
 .SH DESCRIPTION
 .B io_queue_run
-Attempts to read all the events events from
+Attempts to read all the events from
 the completion queue for the aio_context specified by ctx_id.
 .SH "RETURN VALUES"
 May return
@@ -28,7 +28,7 @@ referenced data outside of the program's accessible address space.
 .TP
 .B EINVAL
 .I ctx 
-refers to an unitialized aio context, the iocb pointed to by
+refers to an uninitialized aio context, the iocb pointed to by
 .I iocbs 
 contains an improperly initialized iocb.
 .TP
diff --git a/man/io_queue_wait.3 b/man/io_queue_wait.3
index fff8141..0cf0497 100644
--- a/man/io_queue_wait.3
+++ b/man/io_queue_wait.3
@@ -34,7 +34,7 @@ referenced data outside of the program's accessible address space.
 .TP
 .B EINVAL
 .I ctx 
-refers to an unitialized aio context, the iocb pointed to by
+refers to an uninitialized aio context, the iocb pointed to by
 .I iocbs 
 contains an improperly initialized iocb.
 .TP
diff --git a/man/io_set_callback.3 b/man/io_set_callback.3
index 4ee4b05..3599e8c 100644
--- a/man/io_set_callback.3
+++ b/man/io_set_callback.3
@@ -2,7 +2,7 @@
 .TH io_set_callback 3 2002-09-12 "Linux 2.4" Linux AIO"
 .SH NAME
 io_set_callback \- Set up io completion callback function
-.SH SYNOPSYS
+.SH SYNOPSIS
 .nf
 .B #include <errno.h>
 .br
diff --git a/man/io_submit.3 b/man/io_submit.3
index 76e68d1..3ae8721 100644
--- a/man/io_submit.3
+++ b/man/io_submit.3
@@ -110,7 +110,7 @@ referenced data outside of the program's accessible address space.
 .TP
 .B EINVAL
 .I ctx
-refers to an unitialized aio context, the iocb pointed to by 
+refers to an uninitialized aio context, the iocb pointed to by
 .I iocbs
 contains an improperly initialized iocb, 
 .TP
-- 
2.17.1


From ed25b0e63b2bedecc9c181a620422627f27064ef Mon Sep 17 00:00:00 2001
From: Guillem Jover <guillem@hadrons.org>
Date: Tue, 23 Jul 2019 01:28:10 +0200
Subject: [PATCH 12/33] man: Fix title header

- Update year.
- Balance double quotes.
- Remove version from source argument as recommended in man-pages(7).
- Fix all sections numbers to 3.

Signed-off-by: Guillem Jover <guillem@hadrons.org>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 man/io.3               | 2 +-
 man/io_cancel.3        | 2 +-
 man/io_fsync.3         | 2 +-
 man/io_getevents.3     | 2 +-
 man/io_prep_fsync.3    | 2 +-
 man/io_prep_pread.3    | 2 +-
 man/io_prep_pwrite.3   | 2 +-
 man/io_queue_init.3    | 2 +-
 man/io_queue_release.3 | 2 +-
 man/io_queue_run.3     | 2 +-
 man/io_queue_wait.3    | 2 +-
 man/io_set_callback.3  | 2 +-
 man/io_submit.3        | 2 +-
 13 files changed, 13 insertions(+), 13 deletions(-)

diff --git a/man/io.3 b/man/io.3
index bc529ea..922fbca 100644
--- a/man/io.3
+++ b/man/io.3
@@ -1,4 +1,4 @@
-.TH io 3 2002-09-12 "Linux 2.4" Linux IO"
+.TH io 3 2019-07-23 "Linux" "Linux AIO"
 .SH NAME
 io \- Asynchronous IO
 .SH SYNOPSIS
diff --git a/man/io_cancel.3 b/man/io_cancel.3
index 261a407..a4683be 100644
--- a/man/io_cancel.3
+++ b/man/io_cancel.3
@@ -1,4 +1,4 @@
-.TH io_cancel 2 2002-09-03 "Linux 2.4" "Linux AIO"
+.TH io_cancel 3 2019-07-23 "Linux" "Linux AIO"
 .SH NAME
 io_cancel \- Cancel io requests
 .SH SYNOPSIS
diff --git a/man/io_fsync.3 b/man/io_fsync.3
index 5400d41..bc6778a 100644
--- a/man/io_fsync.3
+++ b/man/io_fsync.3
@@ -4,7 +4,7 @@
 .\" 	io_set_callback(iocb, cb);
 .\" 	return io_submit(ctx, 1, &iocb);
 .\" }
-.TH io_fsync 3 2002-09-12 "Linux 2.4" Linux AIO"
+.TH io_fsync 3 2019-07-23 "Linux" "Linux AIO"
 .SH NAME
 io_fsync \- Synchronize a file's complete in-core state with that on disk
 .SH SYNOPSIS
diff --git a/man/io_getevents.3 b/man/io_getevents.3
index 95fa86e..05b2507 100644
--- a/man/io_getevents.3
+++ b/man/io_getevents.3
@@ -16,7 +16,7 @@
 .\"                                 struct io_event *events,
 .\"                                 struct timespec *timeout)
 .\"
-.TH io_getevents 2 2002-09-03 "Linux 2.4" "Linux AIO"
+.TH io_getevents 3 2019-07-23 "Linux" "Linux AIO"
 .SH NAME
 io_getevents, aio_pgetevents \- Read resulting events from io requests
 .SH SYNOPSIS
diff --git a/man/io_prep_fsync.3 b/man/io_prep_fsync.3
index 0397172..bc0c43b 100644
--- a/man/io_prep_fsync.3
+++ b/man/io_prep_fsync.3
@@ -5,7 +5,7 @@
 .\" 	iocb->aio_lio_opcode = IO_CMD_FSYNC;
 .\" 	iocb->aio_reqprio = 0;
 .\" }
-.TH io_prep_fsync 3 2002-09-12 "Linux 2.4" Linux AIO"
+.TH io_prep_fsync 3 2019-07-23 "Linux" "Linux AIO"
 .SH NAME
 io_prep_fsync \- Synchronize a file's complete in-core state with that on disk
 .SH SYNOPSIS
diff --git a/man/io_prep_pread.3 b/man/io_prep_pread.3
index 3c28f61..e981e41 100644
--- a/man/io_prep_pread.3
+++ b/man/io_prep_pread.3
@@ -8,7 +8,7 @@
 .\" 	iocb->u.c.nbytes = count;
 .\" 	iocb->u.c.offset = offset;
 .\" }
-.TH io_prep_pread 3 2002-09-12 "Linux 2.4" Linux AIO"
+.TH io_prep_pread 3 2019-07-23 "Linux" "Linux AIO"
 .SH NAME
 io_prep_pread \- Set up asynchronous read
 .SH SYNOPSIS
diff --git a/man/io_prep_pwrite.3 b/man/io_prep_pwrite.3
index 69479c2..f2837b6 100644
--- a/man/io_prep_pwrite.3
+++ b/man/io_prep_pwrite.3
@@ -8,7 +8,7 @@
 .\" 	iocb->u.c.nbytes = count;
 .\" 	iocb->u.c.offset = offset;
 .\" }
-.TH io_prep_pwrite 3 2002-09-12 "Linux 2.4" Linux AIO"
+.TH io_prep_pwrite 3 2019-07-23 "Linux" "Linux AIO"
 .SH NAME
 io_prep_pwrite \- Set up iocb for asynchronous writes
 .SH SYNOPSIS
diff --git a/man/io_queue_init.3 b/man/io_queue_init.3
index 9c04b3f..d8753a7 100644
--- a/man/io_queue_init.3
+++ b/man/io_queue_init.3
@@ -1,4 +1,4 @@
-.TH io_queue_init 2 2002-09-03 "Linux 2.4" "Linux AIO"
+.TH io_queue_init 3 2019-07-23 "Linux" "Linux AIO"
 .SH NAME
 io_queue_init \- Initialize asynchronous io state machine
 
diff --git a/man/io_queue_release.3 b/man/io_queue_release.3
index 5c9ded1..392a478 100644
--- a/man/io_queue_release.3
+++ b/man/io_queue_release.3
@@ -1,4 +1,4 @@
-.TH io_queue_release 2 2002-09-03 "Linux 2.4" "Linux AIO"
+.TH io_queue_release 3 2019-07-23 "Linux" "Linux AIO"
 .SH NAME
 io_queue_release \- Release the context associated with the userspace handle
 .SH SYNOPSIS
diff --git a/man/io_queue_run.3 b/man/io_queue_run.3
index 8e0691c..dc54acd 100644
--- a/man/io_queue_run.3
+++ b/man/io_queue_run.3
@@ -1,4 +1,4 @@
-.TH io_queue_run 2 2002-09-03 "Linux 2.4" "Linux AIO"
+.TH io_queue_run 3 2019-07-23 "Linux" "Linux AIO"
 .SH NAME
 io_queue_run \- Handle completed io requests
 .SH SYNOPSIS
diff --git a/man/io_queue_wait.3 b/man/io_queue_wait.3
index 0cf0497..356c3b2 100644
--- a/man/io_queue_wait.3
+++ b/man/io_queue_wait.3
@@ -1,4 +1,4 @@
-.TH io_queue_wait 2 2002-09-03 "Linux 2.4" "Linux AIO"
+.TH io_queue_wait 3 2019-07-23 "Linux" "Linux AIO"
 .SH NAME
 io_queue_wait \- Wait for io requests to complete
 .SH SYNOPSIS
diff --git a/man/io_set_callback.3 b/man/io_set_callback.3
index 3599e8c..25b9a7f 100644
--- a/man/io_set_callback.3
+++ b/man/io_set_callback.3
@@ -1,5 +1,5 @@
 .\"static inline void io_set_callback(struct iocb *iocb, io_callback_t cb)
-.TH io_set_callback 3 2002-09-12 "Linux 2.4" Linux AIO"
+.TH io_set_callback 3 2019-07-23 "Linux" "Linux AIO"
 .SH NAME
 io_set_callback \- Set up io completion callback function
 .SH SYNOPSIS
diff --git a/man/io_submit.3 b/man/io_submit.3
index 3ae8721..01c25cd 100644
--- a/man/io_submit.3
+++ b/man/io_submit.3
@@ -10,7 +10,7 @@
 .\" *      are available to queue any iocbs.  Will return 0 if nr is 0.  Will
 .\" *      fail with -ENOSYS if not implemented.
 .\" */
-.TH io_submit 2 2002-09-02 "Linux 2.4" "Linux AIO"
+.TH io_submit 3 2019-07-23 "Linux" "Linux AIO"
 .SH NAME
 io_submit \- Submit io requests
 .SH SYNOPSIS
-- 
2.17.1


From a311701ea7eebff003e88694a391d810485f36e0 Mon Sep 17 00:00:00 2001
From: Guillem Jover <guillem@hadrons.org>
Date: Sat, 20 Jul 2019 21:18:11 +0200
Subject: [PATCH 13/33] man: Fix markup

- Remove unnecessary macro argument quoting.
- Variables, pathnames in italics.
- Keywords in bold.
- Man page references in bold, followed by the man page number.
- Fix TP/TQ macro usage.

Signed-off-by: Guillem Jover <guillem@hadrons.org>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 man/io.3               | 38 ++++++++++++++-------------
 man/io_cancel.3        | 23 ++++++++++------
 man/io_fsync.3         |  9 ++++---
 man/io_getevents.3     | 33 ++++++++++++++++-------
 man/io_prep_fsync.3    | 59 ++++++++++++++++++++++++++++++------------
 man/io_prep_pread.3    | 19 +++++---------
 man/io_prep_pwrite.3   | 14 ++++------
 man/io_queue_init.3    | 34 +++++++++++++++---------
 man/io_queue_release.3 | 16 +++++++-----
 man/io_queue_run.3     | 18 ++++++++-----
 man/io_queue_wait.3    | 25 +++++++++++-------
 man/io_set_callback.3  |  5 ++--
 man/io_submit.3        | 26 +++++++++++--------
 13 files changed, 195 insertions(+), 124 deletions(-)

diff --git a/man/io.3 b/man/io.3
index 922fbca..f40da41 100644
--- a/man/io.3
+++ b/man/io.3
@@ -10,16 +10,18 @@ io \- Asynchronous IO
 .sp
 .fi
 .SH DESCRIPTION
-The libaio library defines a new set of I/O operations which can
+The
+.B libaio
+library defines a new set of I/O operations which can
 significantly reduce the time an application spends waiting at I/O.  The
 new functions allow a program to initiate one or more I/O operations and
 then immediately resume normal work while the I/O operations are
 executed in parallel.  
 
 These functions are part of the library with realtime functions named
-.IR libaio .
+.BR libaio .
 They are not actually part of the
-.IR "libc" 
+.B libc
 binary.
 The implementation of these functions can be done using support in the
 kernel.
@@ -27,9 +29,9 @@ kernel.
 All IO operations operate on files which were opened previously.  There
 might be arbitrarily many operations running for one file.  The
 asynchronous I/O operations are controlled using a data structure named
-.IR "struct iocb"
+.B struct iocb
 It is defined in
-.IR "libaio.h"
+.I libaio.h
 as follows.
 
 .nf
@@ -74,7 +76,7 @@ struct iocb {
 
 .fi
 .TP
-.IR "int aio_fildes"
+.BI int " aio_fildes"
 This element specifies the file descriptor to be used for the
 operation.  It must be a legal descriptor, otherwise the operation will
 fail.
@@ -82,55 +84,55 @@ fail.
 The device on which the file is opened must allow the seek operation.
 I.e., it is not possible to use any of the IO operations on devices
 like terminals where an 
-.IR "lseek"
+.BR lseek (2)
 call would lead to an error.
 .TP
-.IR "long u.c.offset"
+.BI long " u.c.offset"
 This element specifies the offset in the file at which the operation (input
 or output) is performed.  Since the operations are carried out in arbitrary
 order and more than one operation for one file descriptor can be
 started, one cannot expect a current read/write position of the file
 descriptor.
 .TP
-.IR "void *buf"
+.BI "void *" buf
 This is a pointer to the buffer with the data to be written or the place
 where the read data is stored.
 .TP
-.IR "long u.c.nbytes"
+.BI long " u.c.nbytes"
 This element specifies the length of the buffer pointed to by 
 .IR io_buf .
 .TP
-.IR "int aio_reqprio"
+.BI int " aio_reqprio"
 Is not currently used.
 .TP
 .B "IO_CMD_PREAD"
 Start a read operation.  Read from the file at position
-.IR "u.c.offset"
+.I u.c.offset
 and store the next 
-.IR "u.c.nbytes"
+.I u.c.nbytes
 bytes in the
 buffer pointed to by 
 .IR buf .
 .TP
 .B "IO_CMD_PWRITE"
 Start a write operation.  Write 
-.IR "u.c.nbytes" 
+.I u.c.nbytes
 bytes starting at
-.IR "buf"
+.I buf
 into the file starting at position 
 .IR u.c.offset .
 .TP
 .B "IO_CMD_NOP"
 Do nothing for this control block.  This value is useful sometimes when
 an array of 
-.IR "struct iocb"
+.B struct iocb
 values contains holes, i.e., some of the
 values must not be handled although the whole array is presented to the
-.IR "io_submit"
+.BR io_submit (3)
 function.
 .TP 
 .B "IO_CMD_FSYNC"
-.TP
+.TQ
 .B "IO_CMD_POLL"
 This is experimental.
 .SH EXAMPLE
diff --git a/man/io_cancel.3 b/man/io_cancel.3
index a4683be..3ca629b 100644
--- a/man/io_cancel.3
+++ b/man/io_cancel.3
@@ -9,7 +9,7 @@ io_cancel \- Cancel io requests
 .B #include <libaio.h>
 .sp
 .br
-.BI "int io_cancel(io_context_t ctx, struct iocb *iocb)"
+.BI "int io_cancel(io_context_t " ctx ", struct iocb *" iocb ");"
 .br
 .sp
 struct iocb {
@@ -21,8 +21,11 @@ struct iocb {
 };
 .fi
 .SH DESCRIPTION
-Attempts to cancel an iocb previously passed to io_submit.  If
-the operation is successfully cancelled, the resulting event is
+Attempts to cancel an
+.I iocb
+previously passed to
+.BR io_submit (3).
+If the operation is successfully cancelled, the resulting event is
 copied into the memory pointed to by result without being placed
 into the completion queue.
 .PP
@@ -33,19 +36,23 @@ have to be overwritten soon.  As an example, assume an application, which
 writes data in files in a situation where new incoming data would have
 to be written in a file which will be updated by an enqueued request.
 .SH "RETURN VALUES"
-0 is returned on success, otherwise returns errno.
+\fI0\fP is returned on success, otherwise returns \fIerrno\fP.
 .SH ERRORS
 .TP
 .B EFAULT 
 If any of the data structures pointed to are invalid.
 .TP
 .B EINVAL 
-If aio_context specified by ctx_id is
-invalid.  
+If
+.I aio_context
+specified by
+.I ctx_id
+is invalid.
 .TP
 .B EAGAIN
-If the iocb specified was not
-cancelled.  
+If the
+.I iocb
+specified was not cancelled.
 .TP
 .B ENOSYS 
 If not implemented.
diff --git a/man/io_fsync.3 b/man/io_fsync.3
index bc6778a..06538c4 100644
--- a/man/io_fsync.3
+++ b/man/io_fsync.3
@@ -15,7 +15,7 @@ io_fsync \- Synchronize a file's complete in-core state with that on disk
 .B #include <libaio.h>
 .sp
 .br
-.BI "int io_fsync(io_context_t ctx, struct iocb *iocb, io_callback_t cb, int fd)"
+.BI "int io_fsync(io_context_t " ctx ", struct iocb *" iocb ", io_callback_t " cb ", int " fd ");"
 .sp
 struct iocb {
 	void		*data;
@@ -40,7 +40,7 @@ Calling this function forces all I/O operations operating queued at the
 time of the function call operating on the file descriptor
 .IR "iocb->io_fildes"
 into the synchronized I/O completion state.  The
-.IR "io_fsync"
+.BR io_fsync ()
 function returns
 immediately but the notification through the method described in
 .IR "io_callback"
@@ -49,7 +49,10 @@ file descriptor have terminated and the file is synchronized.  This also
 means that requests for this very same file descriptor which are queued
 after the synchronization request are not affected.
 .SH "RETURN VALUES"
-Returns 0, otherwise returns errno.
+Returns
+.BR 0 ,
+otherwise returns
+.IR errno .
 .SH ERRORS
 .TP
 .B EFAULT
diff --git a/man/io_getevents.3 b/man/io_getevents.3
index 05b2507..6fbcc24 100644
--- a/man/io_getevents.3
+++ b/man/io_getevents.3
@@ -42,19 +42,25 @@ struct io_event {
         unsigned        PADDED(res2, __pad4);
 };
 .sp
-.BI "int io_getevents(io_context_t " ctx ",  long " nr ", struct io_event *" events "[], struct timespec *" timeout ");"
-.BI "int io_pgetevents(io_context_t " ctx ",  long " nr ", struct io_event *" events "[], struct timespec *" timeout ", sigset_t *" sigmask ");"
+.BI "int io_getevents(io_context_t " ctx ", long " nr ", struct io_event *" events "[], struct timespec *" timeout ");"
+.BI "int io_pgetevents(io_context_t " ctx ", long " nr ", struct io_event *" events "[], struct timespec *" timeout ", sigset_t *" sigmask ");"
 .fi
 .SH DESCRIPTION
-Attempts to read  up to nr events from
-the completion queue for the aio_context specified by ctx.  
+Attempts to read up to
+.I nr
+events from the completion queue for the aio_context specified by
+.IR ctx .
 .SH "RETURN VALUES"
 May return
-0 if no events are available and the timeout specified
-by when has elapsed, where when == NULL specifies an infinite
+.B 0
+if no events are available and the timeout specified
+by when has elapsed, where
+.I when
+== NULL specifies an infinite
 timeout.  Note that the timeout pointed to by when is relative and
-will be updated if not NULL and the operation blocks.  Will fail
-with ENOSYS if not implemented.
+will be updated if not NULL and the operation blocks.  Will fail with
+.B ENOSYS
+if not implemented.
 .SS io_pgetevents()
 The relationship between
 .BR io_getevents ()
@@ -110,8 +116,15 @@ behaves the same as
 .SH ERRORS
 .TP
 .B EINVAL 
-If ctx_id is invalid, if min_nr is out of range,
-if nr is out of range, if when is out of range.  
+If
+.I ctx_id
+is invalid, if
+.I min_nr
+is out of range, if
+.I nr
+is out of range, if
+.I when
+is out of range.
 .TP
 .B EFAULT 
 If any of the memory specified to is invalid.
diff --git a/man/io_prep_fsync.3 b/man/io_prep_fsync.3
index bc0c43b..d332709 100644
--- a/man/io_prep_fsync.3
+++ b/man/io_prep_fsync.3
@@ -16,7 +16,7 @@ io_prep_fsync \- Synchronize a file's complete in-core state with that on disk
 .B #include <libaio.h>
 .br
 .sp
-.BI "static inline void io_prep_fsync(struct iocb *iocb, int fd)"
+.BI "static inline void io_prep_fsync(struct iocb *" iocb ", int " fd ");"
 .sp
 struct iocb {
 	void		*data;
@@ -28,47 +28,72 @@ struct iocb {
 .sp
 .fi
 .SH DESCRIPTION
-This is an inline convenience function for setting up an iocbv for a FSYNC request.
-.br
+This is an inline convenience function for setting up an
+.I iocbv
+for a
+.B FSYNC
+request.
+.
+.PP
 The file for which
-.TP 
+.nf
 .IR "iocb->aio_fildes = fd" 
+.fi
 is a descriptor is set up with
 the command
-.TP 
-.IR "iocb->aio_lio_opcode = IO_CMD_FSYNC:
+.nf
+.IR "iocb->aio_lio_opcode = IO_CMD_FSYNC"
+.fi
 .
 .PP
-The io_prep_fsync() function shall set up an IO_CMD_FSYNC operation
-to asynchronously force all I/O
+The
+.BR io_prep_fsync ()
+function shall set up an
+.B IO_CMD_FSYNC
+operation to asynchronously force all I/O
 operations associated with the file indicated by the file
-descriptor aio_fildes member of the iocb structure referenced by
+descriptor
+.I aio_fildes
+member of the
+.I iocb
+structure referenced by
 the iocb argument and queued at the time of the call to
-io_submit() to the synchronized I/O completion state. The function
+.BR io_submit ()
+to the synchronized I/O completion state. The function
 call shall return when the synchronization request has been
 initiated or queued to the file or device (even when the data
 cannot be synchronized immediately).
 
 All currently queued I/O operations shall be completed as if by a call
-to fsync(); that is, as defined for synchronized I/O file
+to
+.BR fsync (2);
+that is, as defined for synchronized I/O file
 integrity completion. If the
-operation queued by io_prep_fsync() fails, then, as for fsync(),
+operation queued by
+.BR io_prep_fsync ()
+fails, then, as for
+.BR fsync (2),
 outstanding I/O operations are not guaranteed to have
 been completed.
 
-If io_prep_fsync() succeeds, then it is only the I/O that was queued
-at the time of the call to io_submit() that is guaranteed to be
+If
+.BR io_prep_fsync ()
+succeeds, then it is only the I/O that was queued
+at the time of the call to
+.BR io_submit (3)
+that is guaranteed to be
 forced to the relevant completion state. The completion of
 subsequent I/O on the file descriptor is not guaranteed to be
 completed in a synchronized fashion.
 .PP
 This function returns immediately. To schedule the operation, the
 function
-.IR io_submit
+.BR io_submit (3)
 must be called.
 .PP
-Simultaneous asynchronous operations using the same iocb produce
-undefined results.
+Simultaneous asynchronous operations using the same
+.I iocb
+produce undefined results.
 .SH "RETURN VALUES"
 None.
 .SH ERRORS
diff --git a/man/io_prep_pread.3 b/man/io_prep_pread.3
index e981e41..e0756a7 100644
--- a/man/io_prep_pread.3
+++ b/man/io_prep_pread.3
@@ -19,7 +19,7 @@ io_prep_pread \- Set up asynchronous read
 .B #include <libaio.h>
 .br
 .sp
-.BI "inline void io_prep_pread(struct iocb *iocb, int fd, void *buf, size_t count, long long offset)
+.BI "inline void io_prep_pread(struct iocb *" iocb ", int " fd ", void *" buf ", size_t " count ", long long " offset ");"
 .
 .sp
 struct iocb {
@@ -31,32 +31,27 @@ struct iocb {
 };
 .fi
 .SH DESCRIPTION
-.IR io_prep_pread 
+.BR io_prep_pread ()
 is an inline convenience function designed to facilitate the initialization of
 the iocb for an asynchronous read operation.
 
 The first
-.TP
-.IR "iocb->u.c.nbytes = count"
+.I iocb->u.c.nbytes = count
 bytes of the file for which
-.TP
-.IR "iocb->aio_fildes = fd"
+.I iocb->aio_fildes = fd
 is a descriptor are written to the buffer
 starting at
-.TP
 .IR "iocb->u.c.buf = buf" .
-.br
 Reading starts at the absolute position
-.TP
-.IR "ioc->u.c.offset = offset"
+.I ioc->u.c.offset = offset
 in the file.
 .PP
 This function returns immediately. To schedule the operation, the
 function 
-.IR io_submit
+.BR io_submit (3)
 must be called.
 .PP
-Simultaneous asynchronous operations using the same iocb produce
+Simultaneous asynchronous operations using the same \fIiocb\fP produce
 undefined results.
 .SH "RETURN VALUES"
 None.
diff --git a/man/io_prep_pwrite.3 b/man/io_prep_pwrite.3
index f2837b6..b3770b4 100644
--- a/man/io_prep_pwrite.3
+++ b/man/io_prep_pwrite.3
@@ -19,8 +19,8 @@ io_prep_pwrite \- Set up iocb for asynchronous writes
 .B #include <libaio.h>
 .br
 .sp
-.BI "inline void io_prep_pwrite(struct iocb *iocb, int fd, void *buf, size_t count, long long offset)
-"
+.BI "inline void io_prep_pwrite(struct iocb *" iocb ", int " fd ", void *" buf ", size_t " count ", long long " offset ");"
+.
 .sp
 struct iocb {
 	void		*data;
@@ -31,27 +31,23 @@ struct iocb {
 };
 .fi
 .SH DESCRIPTION
-io_prep_write is a convenience function for setting up parallel writes.
+.BR io_prep_write ()
+is a convenience function for setting up parallel writes.
 
 The first
-.TP
 .IR "iocb->u.c.nbytes = count"
 bytes of the file for which
-.TP
 .IR "iocb->aio_fildes = fd"
 is a descriptor are written from the buffer
 starting at
-.TP
 .IR "iocb->u.c.buf = buf" .
-.br
 Writing starts at the absolute position
-.TP
 .IR "ioc->u.c.offset = offset"
 in the file.
 .PP
 This function returns immediately. To schedule the operation, the
 function
-.IR io_submit
+.BR io_submit (3)
 must be called.
 .PP
 Simultaneous asynchronous operations using the same iocb produce
diff --git a/man/io_queue_init.3 b/man/io_queue_init.3
index d8753a7..661f377 100644
--- a/man/io_queue_init.3
+++ b/man/io_queue_init.3
@@ -10,25 +10,31 @@ io_queue_init \- Initialize asynchronous io state machine
 .B #include <libaio.h>
 .br
 .sp
-.BI "int io_queue_init(int maxevents, io_context_t  *ctx );"
+.BI "int io_queue_init(int " maxevents ", io_context_t *" ctx ");"
 .sp
 .fi
 .SH DESCRIPTION
-.B io_queue_init
-Attempts to create an aio context capable of receiving at least 
-.IR maxevents
+.BR io_queue_init ()
+attempts to create an aio context capable of receiving at least
+.I maxevents
 events. 
-.IR ctx
+.I ctx
 must point to an aio context that already exists and must be initialized
 to 
-.IR 0
+.B 0
 before the call.
-If the operation is successful, *cxtp is filled with the resulting handle.
+If the operation is successful,
+.I *cxtp
+is filled with the resulting handle.
 .SH "RETURN VALUES"
 On success,
-.B io_queue_init
-returns 0.  Otherwise, -error is return, where
-error is one of the Exxx values defined in the Errors section.
+.BR io_queue_init ()
+returns
+.BR 0 .
+Otherwise, -error is return, where
+error is one of the Exxx values defined in the
+.B ERRORS
+section.
 .SH ERRORS
 .TP
 .B EFAULT
@@ -37,7 +43,9 @@ referenced data outside of the program's accessible address space.
 .TP
 .B EINVAL
 .I maxevents
-is <= 0 or 
+is <=
+.B 0
+or
 .IR ctx
 is an invalid memory location.
 .TP
@@ -46,7 +54,9 @@ Not implemented.
 .TP
 .B EAGAIN
 .IR "maxevents > max_aio_reqs"
-where max_aio_reqs is a tunable value.
+where
+.I max_aio_reqs
+is a tunable value.
 .SH "SEE ALSO"
 .BR io (3),
 .BR io_cancel (3),
diff --git a/man/io_queue_release.3 b/man/io_queue_release.3
index 392a478..7a67141 100644
--- a/man/io_queue_release.3
+++ b/man/io_queue_release.3
@@ -8,7 +8,7 @@ io_queue_release \- Release the context associated with the userspace handle
 .B #include <libaio.h>
 .br
 .sp
-.BI "int io_queue_release(io_context_t ctx)"
+.BI "int io_queue_release(io_context_t " ctx ");"
 .sp
 .SH DESCRIPTION
 .B io_queue_release
@@ -17,16 +17,21 @@ AIOs and block on completion.
 .
 .SH "RETURN VALUES"
 On success,
-.B io_queue_release
-returns 0.  Otherwise, -error is return, where
+.BR io_queue_release ()
+returns
+.BR 0 .
+Otherwise, -error is return, where
 error is one of the Exxx values defined in the Errors section.
 .SH ERRORS
 .TP
 .B EINVAL
 .I ctx 
-refers to an uninitialized aio context, the iocb pointed to by
+refers to an uninitialized aio context, the
+.I iocb
+pointed to by
 .I iocbs 
-contains an improperly initialized iocb,
+contains an improperly initialized
+.IR iocb .
 .TP
 .B ENOSYS 
 Not implemented.
@@ -44,4 +49,3 @@ Not implemented.
 .BR io_set_callback (3),
 .BR io_submit (3),
 .BR errno (3).
-
diff --git a/man/io_queue_run.3 b/man/io_queue_run.3
index dc54acd..93e322b 100644
--- a/man/io_queue_run.3
+++ b/man/io_queue_run.3
@@ -9,17 +9,19 @@ io_queue_run \- Handle completed io requests
 .B #include <libaio.h>
 .br
 .sp
-.BI "int io_queue_run(io_context_t  ctx );"
+.BI "int io_queue_run(io_context_t " ctx ");"
 .sp
 .fi
 .SH DESCRIPTION
-.B io_queue_run
-Attempts to read all the events from
-the completion queue for the aio_context specified by ctx_id.
+.BR io_queue_run ()
+attempts to read all the events from
+the completion queue for the aio_context specified by
+.IR ctx_id .
 .SH "RETURN VALUES"
 May return
-0 if no events are available.
-Will fail with -ENOSYS if not implemented.
+.B 0
+if no events are available.
+Will fail with -\fBENOSYS\fP if not implemented.
 .SH ERRORS
 .TP
 .B EFAULT
@@ -28,7 +30,9 @@ referenced data outside of the program's accessible address space.
 .TP
 .B EINVAL
 .I ctx 
-refers to an uninitialized aio context, the iocb pointed to by
+refers to an uninitialized aio context, the
+.I iocb
+pointed to by
 .I iocbs 
 contains an improperly initialized iocb.
 .TP
diff --git a/man/io_queue_wait.3 b/man/io_queue_wait.3
index 356c3b2..ad5e7f4 100644
--- a/man/io_queue_wait.3
+++ b/man/io_queue_wait.3
@@ -9,22 +9,27 @@ io_queue_wait \- Wait for io requests to complete
 .B #include <libaio.h>
 .br
 .sp
-.BI "int io_queue_wait(io_context_t ctx, const struct timespec *timeout);"
+.BI "int io_queue_wait(io_context_t " ctx ", const struct timespec *" timeout ");"
 .fi
 .SH DESCRIPTION
-Attempts to read an event from
-the completion queue for the aio_context specified by ctx_id.
+.BR io_queue_wait ()
+attempts to read an event from
+the completion queue for the aio_context specified by
+.IR ctx_id .
 .SH "RETURN VALUES"
 May return
-0 if no events are available and the timeout specified
+.B 0
+if no events are available and the timeout specified
 by when has elapsed, where when == NULL specifies an infinite
-timeout.  Note that the timeout pointed to by when is relative and
+\fItimeout\fP.  Note that the \fItimeout\fP pointed to by when is relative and
 will be updated if not NULL and the operation blocks.  Will fail
-with -ENOSYS if not implemented.
+with -\fBENOSYS\fP if not implemented.
 .SH "RETURN VALUES"
 On success,
-.B io_queue_wait
-returns 0.  Otherwise, -error is return, where
+.BR io_queue_wait ()
+returns
+.BR 0 .
+Otherwise, -error is return, where
 error is one of the Exxx values defined in the Errors section.
 .SH ERRORS
 .TP
@@ -34,7 +39,9 @@ referenced data outside of the program's accessible address space.
 .TP
 .B EINVAL
 .I ctx 
-refers to an uninitialized aio context, the iocb pointed to by
+refers to an uninitialized aio context, the
+.I iocb
+pointed to by
 .I iocbs 
 contains an improperly initialized iocb.
 .TP
diff --git a/man/io_set_callback.3 b/man/io_set_callback.3
index 25b9a7f..855f4b9 100644
--- a/man/io_set_callback.3
+++ b/man/io_set_callback.3
@@ -10,7 +10,7 @@ io_set_callback \- Set up io completion callback function
 .B #include <libaio.h>
 .br
 .sp
-.BI "static inline void io_set_callback(struct iocb *iocb, io_callback_t cb)"
+.BI "static inline void io_set_callback(struct iocb *" iocb ", io_callback_t " cb ");"
 .sp
 struct iocb {
 	void		*data;
@@ -25,7 +25,8 @@ typedef void (*io_callback_t)(io_context_t ctx, struct iocb *iocb, long res, lon
 .fi
 .SH DESCRIPTION
 The callback is not done if the caller uses raw events from 
-io_getevents, only with the library helpers.
+.BR io_getevents (3),
+only with the library helpers.
 .SH "RETURN VALUES"
 None.
 .SH ERRORS
diff --git a/man/io_submit.3 b/man/io_submit.3
index 01c25cd..a195653 100644
--- a/man/io_submit.3
+++ b/man/io_submit.3
@@ -32,21 +32,21 @@ struct iocb {
 };
 .fi
 .SH DESCRIPTION
-.B io_submit
+.BR io_submit ()
 submits
 .I nr
 iocbs for processing for a given io context ctx.
 
 The 
-.IR "io_submit"
+.BR io_submit ()
 function can be used to enqueue an arbitrary
 number of read and write requests at one time.  The requests can all be
 meant for the same file, all for different files or every solution in
 between.
 
-.IR "io_submit"
+.BR io_submit ()
 gets the 
-.IR "nr"
+.I nr
 requests from the array pointed to
 by 
 .IR "iocbs" .
@@ -75,10 +75,10 @@ in which case this element of
 .IR "iocbs"
 is simply ignored.  This
 ``operation'' is useful in situations where one has a fixed array of
-.IR "struct iocb"
+.B struct iocb
 elements from which only a few need to be handled at
 a time.  Another situation is where the 
-.IR "io_submit"
+.BR io_submit (3)
 call was
 canceled before all requests are processed  and the remaining requests have to be reissued.
 
@@ -86,15 +86,15 @@ The other members of each element of the array pointed to by
 .IR "iocbs"
 must have values suitable for the operation as described in
 the documentation for 
-.IR "io_prep_pread"
+.BR io_prep_pread (3)
 and 
-.IR "io_prep_pwrite"
+.BR io_prep_pwrite (3)
 above.
 
 The function returns immediately after
 having enqueued all the requests.  
 On success,
-.B io_submit
+.BR io_submit ()
 returns the number of iocbs submitted successfully.  Otherwise, -error is return, where 
 error is one of the Exxx values defined in the Errors section.
 .PP
@@ -115,10 +115,14 @@ refers to an uninitialized aio context, the iocb pointed to by
 contains an improperly initialized iocb, 
 .TP
 .B EBADF
-The iocb contains a file descriptor that does not exist.
+The
+.I iocb
+contains a file descriptor that does not exist.
 .TP
 .B EINVAL
-The file specified in the iocb does not support the given io operation.
+The file specified in the
+.I iocb
+does not support the given io operation.
 .SH "SEE ALSO"
 .BR io (3),
 .BR io_cancel (3),
-- 
2.17.1


From 96fe0e8a3efb8bb058852a46c0273125dd54ba49 Mon Sep 17 00:00:00 2001
From: Guillem Jover <guillem@hadrons.org>
Date: Sat, 20 Jul 2019 21:18:12 +0200
Subject: [PATCH 14/33] man: Fold short lines

Signed-off-by: Guillem Jover <guillem@hadrons.org>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 man/io_prep_fsync.3 | 3 +--
 man/io_submit.3     | 9 +++------
 2 files changed, 4 insertions(+), 8 deletions(-)

diff --git a/man/io_prep_fsync.3 b/man/io_prep_fsync.3
index d332709..419dfeb 100644
--- a/man/io_prep_fsync.3
+++ b/man/io_prep_fsync.3
@@ -39,8 +39,7 @@ The file for which
 .nf
 .IR "iocb->aio_fildes = fd" 
 .fi
-is a descriptor is set up with
-the command
+is a descriptor is set up with the command
 .nf
 .IR "iocb->aio_lio_opcode = IO_CMD_FSYNC"
 .fi
diff --git a/man/io_submit.3 b/man/io_submit.3
index a195653..c0791ed 100644
--- a/man/io_submit.3
+++ b/man/io_submit.3
@@ -47,18 +47,15 @@ between.
 .BR io_submit ()
 gets the 
 .I nr
-requests from the array pointed to
-by 
+requests from the array pointed to by
 .IR "iocbs" .
 The operation to be performed is determined by the
 .IR "aio_lio_opcode"
 member in each element of 
 .IR "iocbs" .
-If this
-field is 
+If this field is
 .B "IO_CMD_PREAD"
-a read operation is enqueued, similar to a call
-of 
+a read operation is enqueued, similar to a call of
 .IR "io_prep_pread"
 for this element of the array (except that the way
 the termination is signalled is different, as we will see below).  If
-- 
2.17.1


From 6f0b6fb5bb3ac118cb56848e52d40ff7e1ece3d1 Mon Sep 17 00:00:00 2001
From: Stephan Springl <springl-libaio@bfw-online.de>
Date: Sat, 20 Jul 2019 21:18:13 +0200
Subject: [PATCH 15/33] man: Escape verbatim \n in order to make it through
 roff

Signed-off-by: Guillem Jover <guillem@hadrons.org>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 man/io.3 | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/man/io.3 b/man/io.3
index f40da41..bfa9836 100644
--- a/man/io.3
+++ b/man/io.3
@@ -174,11 +174,11 @@ static const char *srcname = NULL;
 static void io_error(const char *func, int rc)
 {
     if (rc == -ENOSYS)
-	fprintf(stderr, "AIO not in this kernel\n");
+	fprintf(stderr, "AIO not in this kernel\\n");
     else if (rc < 0 && -rc < sys_nerr)
-	fprintf(stderr, "%s: %s\n", func, sys_errlist[-rc]);
+	fprintf(stderr, "%s: %s\\n", func, sys_errlist[-rc]);
     else
-	fprintf(stderr, "%s: error %d\n", func, rc);
+	fprintf(stderr, "%s: error %d\\n", func, rc);
 
     if (dstfd > 0)
 	close(dstfd);
@@ -197,7 +197,7 @@ static void wr_done(io_context_t ctx, struct iocb *iocb, long res, long res2)
 	io_error("aio write", res2);
     }
     if (res != iocb->u.c.nbytes) {
-	fprintf(stderr, "write missed bytes expect %d got %d\n", iocb->u.c.nbytes, res2);
+	fprintf(stderr, "write missed bytes expect %d got %d\\n", iocb->u.c.nbytes, res2);
 	exit(1);
     }
     --tocopy;
@@ -223,7 +223,7 @@ static void rd_done(io_context_t ctx, struct iocb *iocb, long res, long res2)
     if (res2 != 0)
 	io_error("aio read", res2);
     if (res != iosize) {
-	fprintf(stderr, "read missing bytes expect %d got %d\n", iocb->u.c.nbytes, res);
+	fprintf(stderr, "read missing bytes expect %d got %d\\n", iocb->u.c.nbytes, res);
 	exit(1);
     }
 
@@ -283,7 +283,7 @@ int main(int argc, char *const *argv)
 		char *buf = (char *) malloc(iosize);
 
 		if (NULL == buf || NULL == io) {
-		    fprintf(stderr, "out of memory\n");
+		    fprintf(stderr, "out of memory\\n");
 		    exit(1);
 		}
 
-- 
2.17.1


From e2175569737a2905d3c7a6e6ff664f0febcf5a28 Mon Sep 17 00:00:00 2001
From: Guillem Jover <guillem@hadrons.org>
Date: Sat, 20 Jul 2019 21:18:14 +0200
Subject: [PATCH 16/33] Use ctx consistently for io_context_t instead of ctx_id

Signed-off-by: Guillem Jover <guillem@hadrons.org>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 man/io_cancel.3     | 2 +-
 man/io_getevents.3  | 8 ++++----
 man/io_queue_run.3  | 2 +-
 man/io_queue_wait.3 | 2 +-
 man/io_submit.3     | 2 +-
 src/compat-0_1.c    | 4 ++--
 src/libaio.h        | 4 ++--
 src/vsys_def.h      | 2 +-
 8 files changed, 13 insertions(+), 13 deletions(-)

diff --git a/man/io_cancel.3 b/man/io_cancel.3
index 3ca629b..8c6910e 100644
--- a/man/io_cancel.3
+++ b/man/io_cancel.3
@@ -46,7 +46,7 @@ If any of the data structures pointed to are invalid.
 If
 .I aio_context
 specified by
-.I ctx_id
+.I ctx
 is invalid.
 .TP
 .B EAGAIN
diff --git a/man/io_getevents.3 b/man/io_getevents.3
index 6fbcc24..6ff686d 100644
--- a/man/io_getevents.3
+++ b/man/io_getevents.3
@@ -1,7 +1,7 @@
 .\"/* io_getevents:
 .\" *      Attempts to read at least min_nr events and up to nr events from
-.\" *      the completion queue for the aio_context specified by ctx_id.  May
-.\" *      fail with -EINVAL if ctx_id is invalid, if min_nr is out of range,
+.\" *      the completion queue for the aio_context specified by ctx.  May
+.\" *      fail with -EINVAL if ctx is invalid, if min_nr is out of range,
 .\" *      if nr is out of range, if when is out of range.  May fail with
 .\" *      -EFAULT if any of the memory specified to is invalid.  May return
 .\" *      0 or < min_nr if no events are available and the timeout specified
@@ -10,7 +10,7 @@
 .\" *      will be updated if not NULL and the operation blocks.  Will fail
 .\" *      with -ENOSYS if not implemented.
 .\" */
-.\"asmlinkage long sys_io_getevents(io_context_t ctx_id,
+.\"asmlinkage long sys_io_getevents(io_context_t ctx,
 .\"                                 long min_nr,
 .\"                                 long nr,
 .\"                                 struct io_event *events,
@@ -117,7 +117,7 @@ behaves the same as
 .TP
 .B EINVAL 
 If
-.I ctx_id
+.I ctx
 is invalid, if
 .I min_nr
 is out of range, if
diff --git a/man/io_queue_run.3 b/man/io_queue_run.3
index 93e322b..2bb9701 100644
--- a/man/io_queue_run.3
+++ b/man/io_queue_run.3
@@ -16,7 +16,7 @@ io_queue_run \- Handle completed io requests
 .BR io_queue_run ()
 attempts to read all the events from
 the completion queue for the aio_context specified by
-.IR ctx_id .
+.IR ctx .
 .SH "RETURN VALUES"
 May return
 .B 0
diff --git a/man/io_queue_wait.3 b/man/io_queue_wait.3
index ad5e7f4..1cf4f0b 100644
--- a/man/io_queue_wait.3
+++ b/man/io_queue_wait.3
@@ -15,7 +15,7 @@ io_queue_wait \- Wait for io requests to complete
 .BR io_queue_wait ()
 attempts to read an event from
 the completion queue for the aio_context specified by
-.IR ctx_id .
+.IR ctx .
 .SH "RETURN VALUES"
 May return
 .B 0
diff --git a/man/io_submit.3 b/man/io_submit.3
index c0791ed..c15134f 100644
--- a/man/io_submit.3
+++ b/man/io_submit.3
@@ -1,7 +1,7 @@
 .\"/* sys_io_submit:
 .\" *      Queue the nr iocbs pointed to by iocbpp for processing.  Returns
 .\" *      the number of iocbs queued.  May return -EINVAL if the aio_context
-.\" *      specified by ctx_id is invalid, if nr is < 0, if the iocb at
+.\" *      specified by ctx is invalid, if nr is < 0, if the iocb at
 .\" *      *iocbpp[0] is not properly initialized, if the operation specified
 .\" *      is invalid for the file descriptor in the iocb.  May fail with
 .\" *      -EFAULT if any of the data structures point to invalid data.  May
diff --git a/src/compat-0_1.c b/src/compat-0_1.c
index 136396f..722e107 100644
--- a/src/compat-0_1.c
+++ b/src/compat-0_1.c
@@ -49,14 +49,14 @@ int compat0_1_io_queue_wait(io_context_t ctx, struct timespec *when)
 
 /* ABI change.  Provide backwards compatibility for this one. */
 SYMVER(compat0_1_io_getevents, io_getevents, 0.1);
-int compat0_1_io_getevents(io_context_t ctx_id, long nr,
+int compat0_1_io_getevents(io_context_t ctx, long nr,
 		       struct io_event *events,
 		       const struct timespec *const_timeout)
 {
 	struct timespec timeout;
 	if (const_timeout)
 		timeout = *const_timeout;
-	return io_getevents(ctx_id, 1, nr, events,
+	return io_getevents(ctx, 1, nr, events,
 			const_timeout ? &timeout : NULL);
 }
 
diff --git a/src/libaio.h b/src/libaio.h
index 2bc24e0..8b33382 100644
--- a/src/libaio.h
+++ b/src/libaio.h
@@ -162,8 +162,8 @@ extern int io_setup(int maxevents, io_context_t *ctxp);
 extern int io_destroy(io_context_t ctx);
 extern int io_submit(io_context_t ctx, long nr, struct iocb *ios[]);
 extern int io_cancel(io_context_t ctx, struct iocb *iocb, struct io_event *evt);
-extern int io_getevents(io_context_t ctx_id, long min_nr, long nr, struct io_event *events, struct timespec *timeout);
-extern int io_pgetevents(io_context_t ctx_id, long min_nr, long nr,
+extern int io_getevents(io_context_t ctx, long min_nr, long nr, struct io_event *events, struct timespec *timeout);
+extern int io_pgetevents(io_context_t ctx, long min_nr, long nr,
 		struct io_event *events, struct timespec *timeout,
 		sigset_t *sigmask);
 
diff --git a/src/vsys_def.h b/src/vsys_def.h
index 13d032e..dd711dc 100644
--- a/src/vsys_def.h
+++ b/src/vsys_def.h
@@ -20,5 +20,5 @@ extern int vsys_io_destroy(io_context_t ctx);
 extern int vsys_io_submit(io_context_t ctx, long nr, struct iocb *iocbs[]);
 extern int vsys_io_cancel(io_context_t ctx, struct iocb *iocb);
 extern int vsys_io_wait(io_context_t ctx, struct iocb *iocb, const struct timespec *when);
-extern int vsys_io_getevents(io_context_t ctx_id, long nr, struct io_event *events, const struct timespec *timeout);
+extern int vsys_io_getevents(io_context_t ctx, long nr, struct io_event *events, const struct timespec *timeout);
 
-- 
2.17.1


From b9e17f6afdc4d0e81b1598aecea7b80d0c54b13a Mon Sep 17 00:00:00 2001
From: Guillem Jover <guillem@hadrons.org>
Date: Sat, 20 Jul 2019 21:20:58 +0200
Subject: [PATCH 17/33] harness: Use destination strncpy() expression for
 sizeof() argument
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Even though this is the same size, as the sizeof() is derived from the
source expression, recent gcc versions will emit a warning, which is
turned into an error by -Werror:

  error: argument to sizeof in strncpy call is the same expression
    as the source; did you mean to use the size of the destination?
    [-Werror=sizeof-pointer-memaccess]

Signed-off-by: Guillem Jover <guillem@hadrons.org>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 harness/cases/19.t | 2 +-
 harness/cases/21.t | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/harness/cases/19.t b/harness/cases/19.t
index 4989510..5c3e0d6 100644
--- a/harness/cases/19.t
+++ b/harness/cases/19.t
@@ -41,7 +41,7 @@ open_temp_file(void)
 	int fd;
 	char template[sizeof(TEMPLATE)];
 
-	strncpy(template, TEMPLATE, sizeof(TEMPLATE));
+	strncpy(template, TEMPLATE, sizeof(template));
 	fd = mkostemp(template, O_DIRECT);
 	if (fd < 0) {
 		perror("mkstemp");
diff --git a/harness/cases/21.t b/harness/cases/21.t
index 441eaa8..fe33a9d 100644
--- a/harness/cases/21.t
+++ b/harness/cases/21.t
@@ -43,7 +43,7 @@ open_temp_file()
 	int fd;
 	char temp_file[sizeof(TEMPLATE)];
 
-	strncpy(temp_file, TEMPLATE, sizeof(TEMPLATE));
+	strncpy(temp_file, TEMPLATE, sizeof(temp_file));
 	fd = mkstemp(temp_file);
 	if (fd < 0) {
 		perror("mkstemp");
-- 
2.17.1


From fca5217d524635bed70532aa68baff065d22d790 Mon Sep 17 00:00:00 2001
From: Guillem Jover <guillem@hadrons.org>
Date: Sat, 20 Jul 2019 21:20:59 +0200
Subject: [PATCH 18/33] harness: Use run-time _SC_PAGE_SIZE instead of
 build-time PAGESIZE

The getconf(1) command is inherently not cross-compilation friendly.
In addition PAGESIZE depends on the specific system, even within a
specific arch, so using a hard-coded value is never safe.

Signed-off-by: Guillem Jover <guillem@hadrons.org>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 harness/Makefile   |  2 +-
 harness/cases/18.t | 34 ++++++++++++++++++++++++----------
 2 files changed, 25 insertions(+), 11 deletions(-)

diff --git a/harness/Makefile b/harness/Makefile
index 87b33f6..5cc2b25 100644
--- a/harness/Makefile
+++ b/harness/Makefile
@@ -6,7 +6,7 @@ PROGS:=$(PARTPROGS) $(EXTRAPROGS)
 HARNESS_SRCS:=main.c
 # io_queue.c
 
-CFLAGS+=-Wall -Werror -I../src -g -O2 -DPAGE_SIZE=$(shell getconf PAGESIZE)
+CFLAGS+=-Wall -Werror -I../src -g -O2
 #-lpthread -lrt
 
 # Change this on the build line to run tests against the installed libraries:
diff --git a/harness/cases/18.t b/harness/cases/18.t
index 5587ceb..daa1d26 100644
--- a/harness/cases/18.t
+++ b/harness/cases/18.t
@@ -40,11 +40,17 @@
 
 #define THREADS_NUM 100
 
+static size_t page_size;
+
 void
 aio_worker(void *ptr)
 {
-	int i, j, fd;
-	char buffer[PAGE_SIZE] __attribute__((aligned(PAGE_SIZE)));
+	int i, j, fd, ret;
+	char *buffer = NULL;
+
+	ret = posix_memalign((void **)&buffer, page_size, page_size);
+	assert(ret == 0);
+	assert(buffer != NULL);
 
 	fd = open(FILENAME, O_DIRECT|O_RDONLY);
 	assert(fd >= 0);
@@ -55,19 +61,19 @@ aio_worker(void *ptr)
 		struct iocb *cbs[1];
 
 		assert(!io_queue_init(1, &ctx));
-		io_prep_pread(&cb, fd, buffer, PAGE_SIZE, 0);
+		io_prep_pread(&cb, fd, buffer, page_size, 0);
 		cbs[0] = &cb;
 
-		memset(buffer, '0', PAGE_SIZE);
+		memset(buffer, '0', page_size);
 		assert(io_submit(ctx, 1, &cbs[0]) == 1);
 		// wait random time (0-500ms) ?
 
 		io_destroy(ctx);
-		memset(buffer, DESTROY_PATTERN, PAGE_SIZE);
+		memset(buffer, DESTROY_PATTERN, page_size);
 		// wait random for (0-500ms) ?
 
 		// check it is still DESTROY_PATTERN
-		for (j = 0; j < PAGE_SIZE; j++) {
+		for (j = 0; j < page_size; j++) {
 			if (buffer[j] != DESTROY_PATTERN) {
 				fprintf(stderr,
 					"Buffer has unexpected character: %c\n",
@@ -77,6 +83,7 @@ aio_worker(void *ptr)
 		}
 	}
 
+	free(buffer);
 	close(fd);
 }
 
@@ -84,15 +91,22 @@ int
 test_main(void)
 {
 	int i, fd, ret;
-	char buffer[PAGE_SIZE];
+	char *buffer = NULL;
 	pthread_t threads[THREADS_NUM];
 
+	page_size = sysconf(_SC_PAGESIZE);
+	assert(page_size >= 1);
+
+	ret = posix_memalign((void **)&buffer, page_size, page_size);
+	assert(ret == 0);
+	assert(buffer != NULL);
+
 	fd = open(FILENAME, O_CREAT|O_TRUNC|O_APPEND|O_RDWR, S_IRUSR|S_IWUSR);
 	assert(fd != -1);
 
-	memset(buffer, FILEPATTERN, PAGE_SIZE);
-	ret = write(fd, buffer, PAGE_SIZE);
-	assert(ret == PAGE_SIZE);
+	memset(buffer, FILEPATTERN, page_size);
+	ret = write(fd, buffer, page_size);
+	assert(ret == page_size);
 	close(fd);
 
 	for (i = 0; i < THREADS_NUM; i++) {
-- 
2.17.1


From f322f467c3cd2ac4d8d08a19bd281eabb65433b1 Mon Sep 17 00:00:00 2001
From: Guillem Jover <guillem@hadrons.org>
Date: Sat, 20 Jul 2019 21:21:00 +0200
Subject: [PATCH 19/33] harness: Make RISC-V use SYS_eventfd2 instead of
 unavailable SYS_eventfd

This is a recent architecture and as such does not provide legacy
support for SYS_eventfd. Declare that we need to use the new syscall.

Signed-off-by: Guillem Jover <guillem@hadrons.org>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 harness/cases/16.t | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/harness/cases/16.t b/harness/cases/16.t
index 5a546ff..b36bbd2 100644
--- a/harness/cases/16.t
+++ b/harness/cases/16.t
@@ -18,12 +18,12 @@
 #define SYS_eventfd 318
 #elif defined(__alpha__)
 #define SYS_eventfd 478
-#elif defined(__aarch64__)
-/* arm64 does not implement eventfd, only eventfd2 */
+#elif defined(__aarch64__) || defined(__riscv)
+/* arm64 and riscv do not implement eventfd, only eventfd2 */
 #define USE_EVENTFD2
 #ifndef SYS_eventfd2
 #define SYS_eventfd2 19
-#endif /* __aarch64__ */
+#endif /* __aarch64__ || __riscv */
 #else
 #error define SYS_eventfd for your arch!
 #endif
-- 
2.17.1


From abcb9eeacc2f12c3d77b66c274ace9bffecf68e3 Mon Sep 17 00:00:00 2001
From: Guillem Jover <guillem@hadrons.org>
Date: Tue, 23 Jul 2019 02:48:43 +0200
Subject: [PATCH 20/33] harness: Make the test exit with a code matching the
 pass/fail state

This way we can use the exit code to check whether the tests passed or
failed, and fail the package build.

Signed-off-by: Guillem Jover <guillem@hadrons.org>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 harness/runtests.sh | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/harness/runtests.sh b/harness/runtests.sh
index 717c72a..ef269a7 100755
--- a/harness/runtests.sh
+++ b/harness/runtests.sh
@@ -17,3 +17,5 @@ done
 
 echo "Pass: $passes  Fail: $fails"
 echo "Test run complete at" `date`
+
+exit $fails
-- 
2.17.1


From 90ec55ab2675bc2b6b4d256f78a3db26adf75900 Mon Sep 17 00:00:00 2001
From: Jeff Moyer <jmoyer@redhat.com>
Date: Mon, 29 Jul 2019 13:16:18 -0400
Subject: [PATCH 21/33] harness: add support for skipping tests

Skipped tests will not cause the test harness to return failure.  An
exit status of "3" was chosen for skipped tests.  This doesn't
conflict with any of the current tests.

Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 harness/main.c      | 20 ++++++++++++++++----
 harness/runtests.sh | 14 ++++++++++++--
 2 files changed, 28 insertions(+), 6 deletions(-)

diff --git a/harness/main.c b/harness/main.c
index 9ecd5da..82e9c69 100644
--- a/harness/main.c
+++ b/harness/main.c
@@ -26,15 +26,27 @@ char test_name[] = TEST_NAME;
 int main(void)
 {
 	int res;
+	const char *test_result;
 
 #if defined(SETUP)
 	SETUP;
 #endif
 
 	res = test_main();
-	printf("test %s completed %s.\n", test_name, 
-		res ? "FAILED" : "PASSED"
-		);
+	switch(res) {
+	case 0:
+		test_result = "PASSED";
+		break;
+	case 3:
+		test_result = "SKIPPED";
+		break;
+	default:
+		test_result = "FAILED";
+		res = 1;
+		break;
+	}
+
+	printf("test %s completed %s.\n", test_name, test_result);
 	fflush(stdout);
-	return res ? 1 : 0;
+	return res;
 }
diff --git a/harness/runtests.sh b/harness/runtests.sh
index ef269a7..e9ceec8 100755
--- a/harness/runtests.sh
+++ b/harness/runtests.sh
@@ -2,6 +2,7 @@
 
 passes=0
 fails=0
+skips=0
 
 echo "Test run starting at" `date`
 
@@ -11,11 +12,20 @@ while [ $# -ge 1 ] ; do
 	echo "Starting $this_test"
 	$this_test 2>&1
 	res=$?
-	if [ $res -eq 0 ] ; then str="" ; passes=$[passes + 1] ; else str=" -- FAILED" ; fails=$[fails + 1] ; fi
+	if [ $res -eq 0 ]; then
+		str="";
+		passes=$((passes + 1));
+	elif [ $res -eq 3 ]; then
+		str=" -- SKIPPED";
+		skips=$((skips + 1));
+	else
+		str=" -- FAILED"
+		fails=$((fails + 1));
+	fi
 	echo "Completed $this_test with $res$str".
 done
 
-echo "Pass: $passes  Fail: $fails"
+echo "Pass: $passes  Fail: $fails  Skip: $skips"
 echo "Test run complete at" `date`
 
 exit $fails
-- 
2.17.1


From ac60a850d5ce22ae21e3746f72a9ebb2623d17f8 Mon Sep 17 00:00:00 2001
From: Guillem Jover <guillem@hadrons.org>
Date: Sat, 20 Jul 2019 21:21:01 +0200
Subject: [PATCH 22/33] harness: Add fallback code for filesystems not
 supporting O_DIRECT

When running the harness on a filesystem such as a tmpfs, which do not
support O_DIRECT, fallback to calls without the flag.

Signed-off-by: Guillem Jover <guillem@hadrons.org>
[JEM: change from duplicating the open call to using F_SETFL]
[JEM: 18 and 21 require O_DIRECT-skip if not present]
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 harness/cases/17.t | 11 +++++++++--
 harness/cases/18.t |  2 ++
 harness/cases/19.t | 10 ++++++++--
 harness/cases/21.t |  5 ++++-
 4 files changed, 23 insertions(+), 5 deletions(-)

diff --git a/harness/cases/17.t b/harness/cases/17.t
index 38ada4d..b4b6660 100644
--- a/harness/cases/17.t
+++ b/harness/cases/17.t
@@ -119,7 +119,7 @@ void prune(io_context_t io_ctx, int max_ios, int getevents_type)
 
 void run_test(int max_ios, int getevents_type)
 {
-	int fd, ret;
+	int fd, ret, flags;
 	long i, to_submit;
 	struct iocb **iocb_sub;
 	io_context_t io_ctx;
@@ -137,9 +137,16 @@ void run_test(int max_ios, int getevents_type)
 	events = calloc(max_ios, sizeof(*events));
 
 	unlink(filename);
-	fd = open(filename, O_CREAT | O_RDWR | O_DIRECT, 0644);
+	fd = open(filename, O_CREAT | O_RDWR, 0644);
 	assert(fd >= 0);
 
+	/*
+	 * Use O_DIRECT if it's available.  If it's not, the test code
+	 * will still operate correctly, just potentially slower.
+	 */
+	flags = fcntl(fd, F_GETFL, 0);
+	fcntl(fd, F_SETFL, flags | O_DIRECT);
+
 	ret = ftruncate(fd, max_ios * io_size);
 	assert(!ret);
 
diff --git a/harness/cases/18.t b/harness/cases/18.t
index daa1d26..e8dbcd1 100644
--- a/harness/cases/18.t
+++ b/harness/cases/18.t
@@ -53,6 +53,8 @@ aio_worker(void *ptr)
 	assert(buffer != NULL);
 
 	fd = open(FILENAME, O_DIRECT|O_RDONLY);
+	if (fd < 0 && errno == EINVAL)
+		exit(3); /* skip this test, O_DIRECT is unavailable */
 	assert(fd >= 0);
 
 	for (i = 0; i < 1000; i++) {
diff --git a/harness/cases/19.t b/harness/cases/19.t
index 5c3e0d6..ba1c620 100644
--- a/harness/cases/19.t
+++ b/harness/cases/19.t
@@ -38,15 +38,21 @@ struct aio_ring {
 int
 open_temp_file(void)
 {
-	int fd;
+	int fd, flags;
 	char template[sizeof(TEMPLATE)];
 
 	strncpy(template, TEMPLATE, sizeof(template));
-	fd = mkostemp(template, O_DIRECT);
+	fd = mkstemp(template);
 	if (fd < 0) {
 		perror("mkstemp");
 		exit(1);
 	}
+	/*
+	 * O_DIRECT is desirable, but not required for this test.
+	 */
+	flags = fcntl(F_GETFL, 0);
+	fcntl(F_SETFL, flags | O_DIRECT);
+
 	unlink(template);
 	return fd;
 }
diff --git a/harness/cases/21.t b/harness/cases/21.t
index fe33a9d..ba988ed 100644
--- a/harness/cases/21.t
+++ b/harness/cases/21.t
@@ -92,7 +92,10 @@ test_main()
 	 */
 	flags = fcntl(fd, F_GETFL);
 	ret = fcntl(fd, F_SETFL, flags | O_DIRECT);
-	if (ret != 0) {
+	if (ret < 0) {
+		/* SKIP this test if O_DIRECT is not available on this fs */
+		if (errno == EINVAL)
+			return 3;
 		perror("fcntl");
 		return 1;
 	}
-- 
2.17.1


From 5d2c97e89a896636572ea4375550bc79154482ec Mon Sep 17 00:00:00 2001
From: Guillem Jover <guillem@hadrons.org>
Date: Sat, 20 Jul 2019 21:21:02 +0200
Subject: [PATCH 23/33] harness: Handle -ENOTSUP from io_submit() with
 RWF_NOWAIT

On filesystems such as tmpfs the syscall might return -ENOTSUP instead
of EINVAL when it does not support the RWF_NOWAIT flag.

Signed-off-by: Guillem Jover <guillem@hadrons.org>
[JEM: skip the test instead of returning success]
[JEM: make the error message differentiate between kernel and fs support]
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 harness/cases/21.t | 14 ++++++++------
 1 file changed, 8 insertions(+), 6 deletions(-)

diff --git a/harness/cases/21.t b/harness/cases/21.t
index ba988ed..cdff4ff 100644
--- a/harness/cases/21.t
+++ b/harness/cases/21.t
@@ -108,13 +108,15 @@ test_main()
 	ret = io_submit(ctx, 1, &iocbp);
 
 	/*
-	 * io_submit will return -EINVAL if RWF_NOWAIT is not supported.
+	 * io_submit will return -EINVAL if RWF_NOWAIT is not supported by
+	 * the kernel, and EOPNOTSUPP if it's not supported by the fs.
 	 */
 	if (ret != 1) {
-		if (ret == -EINVAL) {
-			fprintf(stderr, "RWF_NOWAIT not supported by kernel.\n");
-			/* just return success */
-			return 0;
+		if (ret == -EINVAL || ret == -ENOTSUP) {
+			fprintf(stderr, "RWF_NOWAIT not supported by %s.\n",
+				ret == -EINVAL ? "kernel" : "file system");
+			/* skip this test */
+			return 3;
 		}
 		errno = -ret;
 		perror("io_submit");
@@ -166,7 +168,7 @@ test_main()
 
 	if (event.res != BUFLEN) {
 		fprintf(stderr, "Expected %d, got %lu\n", BUFLEN, event.res);
-		return 1;
+		return 3;
 	}
 
 	return 0;
-- 
2.17.1


From 5b12c666f514c258183c9f2fe3d4d925559828a4 Mon Sep 17 00:00:00 2001
From: Jeff Moyer <jmoyer@redhat.com>
Date: Mon, 29 Jul 2019 14:25:01 -0400
Subject: [PATCH 24/33] harness: skip 22.p if async_poll isn't supported

Use the new skip error code instead of failing the test.  Also
add in a Local variables: section for emacs.

Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 harness/cases/22.t | 14 +++++++++++++-
 1 file changed, 13 insertions(+), 1 deletion(-)

diff --git a/harness/cases/22.t b/harness/cases/22.t
index c7428a8..b13024e 100644
--- a/harness/cases/22.t
+++ b/harness/cases/22.t
@@ -83,6 +83,9 @@ int test_main(void)
 		io_prep_poll(&iocb, pipe1[0], POLLIN);
 		ret = io_submit(ctx, 1, iocbs);
 		if (ret != 1) {
+			/* if poll isn't supported, skip the test */
+			if (ret == -EINVAL)
+				return 3;
 			printf("child: io_submit failed\n");
 			return 1;
 		}
@@ -120,7 +123,10 @@ int test_main(void)
 
 		ret = io_submit(ctx, 1, iocbs);
 		if (ret != 1) {
-			printf("parent: io_submit failed\n");
+			/* if poll isn't supported, skip the test */
+			if (ret == -EINVAL)
+				return 3;
+			printf("parent: io_submit failed with %d\n", ret);
 			return 1;
 		}
 
@@ -147,3 +153,9 @@ int test_main(void)
 		return 0;
 	}
 }
+/*
+ * Local variables:
+ *  mode: c
+ *  c-basic-offset: 8
+ * End:
+ */
-- 
2.17.1


From 3106f11b54042b9b6190dafdf08d1ad1fd228a4d Mon Sep 17 00:00:00 2001
From: Jeff Moyer <jmoyer@redhat.com>
Date: Tue, 13 Aug 2019 15:30:05 -0400
Subject: [PATCH 25/33] harness: fix read into PROT_WRITE mmap test

This test has been broken forever.  Fix it up to perform an
aio_read using the result of a regular read as the expected
return code.

Reported-by: Guillem Jover <guillem@hadrons.org>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 harness/cases/5.t | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/harness/cases/5.t b/harness/cases/5.t
index 2b4b4bb..7d67562 100644
--- a/harness/cases/5.t
+++ b/harness/cases/5.t
@@ -40,14 +40,14 @@ int test_main(void)
 	buf = mmap(0, page_size, PROT_WRITE, MAP_SHARED, rwfd, 0);
 	assert(buf != (char *)-1);
 
-	status |= attempt_rw(rwfd, buf, SIZE,  0,  READ, SIZE);
-
 	/* Whether PROT_WRITE is readable is arch-dependent.  So compare
 	 * against read result. */
 	res = read(rwfd, buf, SIZE);
 	if (res < 0)
 		res = -errno;
-	status |= attempt_rw(rwfd, buf, SIZE,  0, WRITE, res);
+	status |= attempt_rw(rwfd, buf, SIZE,  0,  READ, res);
+
+	status |= attempt_rw(rwfd, buf, SIZE,  0, WRITE, SIZE);
 
 	return status;
 }
-- 
2.17.1


From a47419ab1496c7d0af080e07f548bc0be6284adb Mon Sep 17 00:00:00 2001
From: Guillem Jover <guillem@hadrons.org>
Date: Wed, 14 Aug 2019 04:42:42 +0200
Subject: [PATCH 26/33] harness: Fix PROT_WRITE mmap check

This partially reverts commit d7f5065448efb49b2a26e728ff735e12ea05b62e.

The actual problem in the original code was that read() was being used
to assert whether the buffer was readable, but the kernel was instead
reading from the file descriptor and then writing into the buffer, so
no EFAULT was being generated (on architectures that do so).

We needed to use a write() so that the kernel would read from the
buffer.

Signed-off-by: Guillem Jover <guillem@hadrons.org>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 harness/cases/5.t | 9 ++++-----
 1 file changed, 4 insertions(+), 5 deletions(-)

diff --git a/harness/cases/5.t b/harness/cases/5.t
index 7d67562..b0a7c56 100644
--- a/harness/cases/5.t
+++ b/harness/cases/5.t
@@ -41,13 +41,12 @@ int test_main(void)
 	assert(buf != (char *)-1);
 
 	/* Whether PROT_WRITE is readable is arch-dependent.  So compare
-	 * against read result. */
-	res = read(rwfd, buf, SIZE);
+	 * against write() result (to make the kernel read from buf). */
+	res = write(rwfd, buf, SIZE);
 	if (res < 0)
 		res = -errno;
-	status |= attempt_rw(rwfd, buf, SIZE,  0,  READ, res);
-
-	status |= attempt_rw(rwfd, buf, SIZE,  0, WRITE, SIZE);
+	status |= attempt_rw(rwfd, buf, SIZE,  0,  READ, SIZE);
+	status |= attempt_rw(rwfd, buf, SIZE,  0, WRITE, res);
 
 	return status;
 }
-- 
2.17.1


From e2a3d5e6814d5cbd6d1cc5da2f4a75232a20e79a Mon Sep 17 00:00:00 2001
From: Guillem Jover <guillem@hadrons.org>
Date: Wed, 21 Aug 2019 05:29:50 +0200
Subject: [PATCH 27/33] harness: Print better error messages on error
 conditions in 22.t

These should help diagnose problems when dealing with error failures.
In particular this helped distinguish the problem with io_pgetevents()
not being implemented and it failing due to the sigset_t layout bug.

Signed-off-by: Guillem Jover <guillem@hadrons.org>
[JEM: fix up 80 columns violations]
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 harness/cases/22.t | 15 +++++++++------
 1 file changed, 9 insertions(+), 6 deletions(-)

diff --git a/harness/cases/22.t b/harness/cases/22.t
index b13024e..c47140d 100644
--- a/harness/cases/22.t
+++ b/harness/cases/22.t
@@ -76,7 +76,7 @@ int test_main(void)
 
 		ret = io_setup(1, &ctx);
 		if (ret) {
-			printf("child: io_setup failed\n");
+			printf("child: io_setup failed: %s\n", strerror(-ret));
 			return 1;
 		}
 
@@ -86,7 +86,7 @@ int test_main(void)
 			/* if poll isn't supported, skip the test */
 			if (ret == -EINVAL)
 				return 3;
-			printf("child: io_submit failed\n");
+			printf("child: io_submit failed: %s\n", strerror(-ret));
 			return 1;
 		}
 
@@ -99,7 +99,8 @@ int test_main(void)
 		} while (ret == 0);
 
 		if (ret != -EINTR) {
-			printf("child: io_pgetevents did not set errno to EINTR\n");
+			printf("child: io_pgetevents did not set errno to "
+			       "EINTR: %s\n", strerror(-ret));
 			return 1;
 		}
 
@@ -117,7 +118,7 @@ int test_main(void)
 
 		ret = io_setup(1, &ctx);
 		if (ret) {
-			printf("parent: io_setup failed\n");
+			printf("parent: io_setup failed: %s\n", strerror(-ret));
 			return 1;
 		}
 
@@ -126,7 +127,8 @@ int test_main(void)
 			/* if poll isn't supported, skip the test */
 			if (ret == -EINVAL)
 				return 3;
-			printf("parent: io_submit failed with %d\n", ret);
+			printf("parent: io_submit failed with %d: %s\n",
+			       ret, strerror(-ret));
 			return 1;
 		}
 
@@ -134,7 +136,8 @@ int test_main(void)
 
 		ret = io_pgetevents(ctx, 1, 1, &ev, NULL, &sigmask);
 		if (ret < 0) {
-			printf("parent: io_pgetevents failed\n");
+			printf("parent: io_pgetevents failed: %s\n",
+			       strerror(-ret));
 			return 1;
 		}
 		if (ret != 1) {
-- 
2.17.1


From ee58a013283b8cef7570355a9a22514ed9e0e27c Mon Sep 17 00:00:00 2001
From: Guillem Jover <guillem@hadrons.org>
Date: Wed, 21 Aug 2019 05:29:52 +0200
Subject: [PATCH 28/33] harness: Skip the test if io_pgetevents() is not
 implemented

Either the kernel or the syscall wrapper will return -ENOSYS when this
syscall is not implemented. So we should cope with this in the test
suite and SKIP the test case.

This is currently the case for alpha and ia64, even though they have
already been wired up very recently in the kernel mainline.

Signed-off-by: Guillem Jover <guillem@hadrons.org>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 harness/cases/22.t | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/harness/cases/22.t b/harness/cases/22.t
index c47140d..d6a8986 100644
--- a/harness/cases/22.t
+++ b/harness/cases/22.t
@@ -98,6 +98,10 @@ int test_main(void)
 			ret = io_pgetevents(ctx, 1, 1, &ev, &to, &sigmask);
 		} while (ret == 0);
 
+		/* SKIP if the syscall has not been implemented. */
+		if (ret == -ENOSYS)
+			return 3;
+
 		if (ret != -EINTR) {
 			printf("child: io_pgetevents did not set errno to "
 			       "EINTR: %s\n", strerror(-ret));
@@ -135,6 +139,9 @@ int test_main(void)
 		kill(p, SIGUSR1);
 
 		ret = io_pgetevents(ctx, 1, 1, &ev, NULL, &sigmask);
+		/* SKIP if the syscall has not been implemented. */
+		if (ret == -ENOSYS)
+			return 3;
 		if (ret < 0) {
 			printf("parent: io_pgetevents failed: %s\n",
 			       strerror(-ret));
-- 
2.17.1


From a481f7f012ba0af268d0a1286610549055fa6a97 Mon Sep 17 00:00:00 2001
From: Lee Duncan <lduncan@suse.com>
Date: Sun, 14 Feb 2021 14:59:07 -0800
Subject: [PATCH 29/33] Fix test issue with gcc-11
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Test 3.t exercises io_submit() with invalid addresses,
and one test attempted to pass in "-1" as an invalid
pointer. But gcc-11 realizes you cannot take an offset
from an invalid pointer, making it impossible to
compile or run this test:

> sh# make CC=gcc-11 partcheck
> make[1]: Entering directory '/alt/public_software/libaio/src'
> make[1]: Nothing to be done for 'all'.
> make[1]: Leaving directory '/alt/public_software/libaio/src'
> make[1]: Entering directory '/alt/public_software/libaio/harness'
> gcc-11 -Wall -Werror -I../src -g -O2 -DTEST_NAME=\"cases/2.t\" -o cases/2.p main.c ../src/libaio.a -lpthread
> gcc-11 -Wall -Werror -I../src -g -O2 -DTEST_NAME=\"cases/3.t\" -o cases/3.p main.c ../src/libaio.a -lpthread
> In file included from main.c:24:
> cases/3.t: In function test_main:
> cases/3.t:18:19: error: attempt_io_submit accessing 8 bytes in a region of size 0 [-Werror=stringop-overflow=]
>    18 |         status |= attempt_io_submit( io_ctx, 1, (void *)-1, -EFAULT);
>       |                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
> cases/3.t:18:19: note: referencing argument 3 of type struct iocb **
> In file included from cases/3.t:5,
>                  from main.c:24:
> cases/aio_setup.h:15:5: note: in a call to function attempt_io_submit
>    15 | int attempt_io_submit(io_context_t ctx, long nr, struct iocb *ios[], int expect)
>       |     ^~~~~~~~~~~~~~~~~
> cc1: all warnings being treated as errors
> make[1]: *** [Makefile:19: cases/3.p] Error 1
> make[1]: Leaving directory '/alt/public_software/libaio/harness'
> make: *** [Makefile:23: partcheck] Error 2

The fix is to tell gcc to relax it's stringop overflow
testing for this one test.

Changes since v1:
* First version just skipped the test in question

Signed-off-by: Lee Duncan <leeman.duncan@gmail.com>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 harness/Makefile | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/harness/Makefile b/harness/Makefile
index 5cc2b25..4f225d3 100644
--- a/harness/Makefile
+++ b/harness/Makefile
@@ -9,6 +9,11 @@ HARNESS_SRCS:=main.c
 CFLAGS+=-Wall -Werror -I../src -g -O2
 #-lpthread -lrt
 
+# gcc-11 does not like the test case in 3.t that
+# passes an invalid pointer (-1) to the kernel, so
+# tell the compiler we do not need a warning here
+cases/3.p:	CFLAGS+=-Wno-stringop-overflow
+
 # Change this on the build line to run tests against the installed libraries:
 # make LIBAIO=-laio partcheck
 LIBAIO?=../src/libaio.a
-- 
2.17.1


From 3f3b823a6b732a6f2b8f2aa86a49dcda7e256aa5 Mon Sep 17 00:00:00 2001
From: yehui ren <renyehui@uniontech.com>
Date: Fri, 2 Jul 2021 03:42:26 +0000
Subject: [PATCH 30/33] cases/16.t: loongarch only supports eventfd2

Signed-off-by: yehui ren <renyehui@uniontech.com>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 harness/cases/16.t | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/harness/cases/16.t b/harness/cases/16.t
index b36bbd2..4d24b04 100644
--- a/harness/cases/16.t
+++ b/harness/cases/16.t
@@ -18,8 +18,8 @@
 #define SYS_eventfd 318
 #elif defined(__alpha__)
 #define SYS_eventfd 478
-#elif defined(__aarch64__) || defined(__riscv)
-/* arm64 and riscv do not implement eventfd, only eventfd2 */
+#elif defined(__aarch64__) || defined(__loongarch__) || defined(__riscv)
+/* these recent architectures do not implement eventfd, only eventfd2 */
 #define USE_EVENTFD2
 #ifndef SYS_eventfd2
 #define SYS_eventfd2 19
-- 
2.17.1


From 69f85d553c4268157d242c4ad1f1fdbf1ea425bc Mon Sep 17 00:00:00 2001
From: yehui ren <renyehui@uniontech.com>
Date: Fri, 2 Jul 2021 04:39:51 +0000
Subject: [PATCH 31/33] Add loongarch to supported architectures in libaio.spec

Signed-off-by: yehui ren <renyehui@uniontech.com>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 libaio.spec | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libaio.spec b/libaio.spec
index d1fa2cc..468be43 100644
--- a/libaio.spec
+++ b/libaio.spec
@@ -7,7 +7,7 @@ Group:  System Environment/Libraries
 Source: %{name}-%{version}.tar.gz
 BuildRoot: %{_tmppath}/%{name}-root
 # Fix ExclusiveArch as we implement this functionality on more architectures
-ExclusiveArch: i386 x86_64 ia64 s390 s390x ppc ppc64 ppc64pseries ppc64iseries alpha alphaev6 %{arm}
+ExclusiveArch: i386 x86_64 ia64 s390 s390x ppc ppc64 ppc64pseries ppc64iseries alpha alphaev6 %{arm} loongarch64
 
 %description
 The Linux-native asynchronous I/O facility ("async I/O", or "aio") has a
-- 
2.17.1


From 3164689607d72cd12a5812cbab0968a58abb54f5 Mon Sep 17 00:00:00 2001
From: yehui ren <renyehui@uniontech.com>
Date: Fri, 2 Jul 2021 05:02:04 +0000
Subject: [PATCH 32/33] Add endian detection and bit width detection for
 loongarch

Signed-off-by: yehui ren <renyehui@uniontech.com>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 src/libaio.h | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/libaio.h b/src/libaio.h
index 8b33382..4233303 100644
--- a/src/libaio.h
+++ b/src/libaio.h
@@ -53,7 +53,8 @@ typedef enum io_iocb_cmd {
 /* little endian, 32 bits */
 #if defined(__i386__) || (defined(__arm__) && !defined(__ARMEB__)) || \
     defined(__sh__) || defined(__bfin__) || defined(__MIPSEL__) || \
-    defined(__cris__) || (defined(__riscv) && __riscv_xlen == 32) || \
+    defined(__cris__) || defined(__loongarch32) || \
+    (defined(__riscv) && __riscv_xlen == 32) || \
     (defined(__GNUC__) && defined(__BYTE_ORDER__) && \
          __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ && __SIZEOF_LONG__ == 4)
 #define PADDED(x, y)	x; unsigned y
@@ -63,6 +64,7 @@ typedef enum io_iocb_cmd {
 /* little endian, 64 bits */
 #elif defined(__ia64__) || defined(__x86_64__) || defined(__alpha__) || \
       (defined(__aarch64__) && defined(__AARCH64EL__)) || \
+      defined(__loongarch64) || \
       (defined(__riscv) && __riscv_xlen == 64) || \
       (defined(__GNUC__) && defined(__BYTE_ORDER__) && \
           __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ && __SIZEOF_LONG__ == 8)
-- 
2.17.1


From 79bc78ed1a88b64d25dccffe83c146aa22425ef7 Mon Sep 17 00:00:00 2001
From: yehui ren <renyehui@uniontech.com>
Date: Fri, 2 Jul 2021 05:19:45 +0000
Subject: [PATCH 33/33] Use generic syscall number schema for loongarch

Signed-off-by: yehui ren <renyehui@uniontech.com>
Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
---
 src/syscall.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/syscall.h b/src/syscall.h
index b53da4c..d2a117b 100644
--- a/src/syscall.h
+++ b/src/syscall.h
@@ -27,7 +27,7 @@
 #include "syscall-arm.h"
 #elif defined(__sparc__)
 #include "syscall-sparc.h"
-#elif defined(__aarch64__) || defined(__riscv)
+#elif defined(__aarch64__) || defined(__loongarch__) || defined(__riscv)
 #include "syscall-generic.h"
 #else
 #warning "using system call numbers from sys/syscall.h"
-- 
2.17.1

