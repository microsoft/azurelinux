From 748a5c7104a0e68fa34c99323140acc7d2176f41 Mon Sep 17 00:00:00 2001
From: AllSpark <allspark@microsoft.com>
Date: Fri, 30 Jan 2026 12:16:17 +0000
Subject: [PATCH] Backport: fix error message leaks by wrapping errors in
 mapstructure decode hooks and parse functions; adjust messages and add helper
 wrappers

Signed-off-by: Azure Linux Security Servicing Account <azurelinux-security@microsoft.com>
Upstream-reference: AI Backport of https://github.com/go-viper/mapstructure/commit/742921c9ba2854d27baa64272487fc5075d2c39c.patch
---
 errors.go                                     | 206 ++++++++++++++++++
 .../mitchellh/mapstructure/decode_hooks.go    |  15 +-
 .../mitchellh/mapstructure/mapstructure.go    |  24 +-
 3 files changed, 237 insertions(+), 8 deletions(-)
 create mode 100644 errors.go

diff --git a/errors.go b/errors.go
new file mode 100644
index 0000000..e05d90e
--- /dev/null
+++ b/errors.go
@@ -0,0 +1,206 @@
+package mapstructure
+
+import (
+	"errors"
+	"fmt"
+	"net"
+	"net/url"
+	"reflect"
+	"strconv"
+	"strings"
+	"time"
+)
+
+// ParseError is returned when the input cannot be parsed into the provided type.
+// ParseError wraps the original error and provides additional context.
+// This error can provide additional context about the value and expected type.
+// All fields are optional.
+
+type ParseError struct {
+	Expected reflect.Value
+	Value    interface{}
+	Err      error
+}
+
+func (e *ParseError) Error() string {
+	if e == nil {
+		return ""
+	}
+
+	if e.Expected.IsValid() {
+		return fmt.Sprintf("could not parse %v into %v: %v", e.Value, e.Expected.Type(), e.Err)
+	}
+
+	return fmt.Sprintf("could not parse %v into the expected type: %v", e.Value, e.Err)
+}
+
+func (e *ParseError) Unwrap() error { return e.Err }
+
+func (*ParseError) mapstructure() {}
+
+type UnconvertibleTypeError struct {
+	Expected reflect.Value
+	Value    interface{}
+	Err      error
+}
+
+func (e *UnconvertibleTypeError) Error() string {
+	return fmt.Sprintf("'%v' expected type '%s', got unconvertible type '%T', value: '%v'",
+		e.Expected.String(), e.Expected.Type(), e.Value, e.Value)
+}
+
+func (e *UnconvertibleTypeError) Unwrap() error { return e.Err }
+
+func (*UnconvertibleTypeError) mapstructure() {}
+
+func wrapStrconvNumError(err error) error {
+	if err == nil {
+		return nil
+	}
+
+	if err, ok := err.(*strconv.NumError); ok {
+		return &strconvNumError{Err: err}
+	}
+
+	return err
+}
+
+type strconvNumError struct {
+	Err *strconv.NumError
+}
+
+func (e *strconvNumError) Error() string {
+	return "strconv." + e.Err.Func + ": " + e.Err.Err.Error()
+}
+
+func (e *strconvNumError) Unwrap() error { return e.Err }
+
+func wrapUrlError(err error) error {
+	if err == nil {
+		return nil
+	}
+
+	if err, ok := err.(*url.Error); ok {
+		return &urlError{Err: err}
+	}
+
+	return err
+}
+
+type urlError struct {
+	Err *url.Error
+}
+
+func (e *urlError) Error() string {
+	return fmt.Sprintf("%s", e.Err.Err)
+}
+
+func (e *urlError) Unwrap() error { return e.Err }
+
+func wrapNetParseError(err error) error {
+	if err == nil {
+		return nil
+	}
+
+	if err, ok := err.(*net.ParseError); ok {
+		return &netParseError{Err: err}
+	}
+
+	return err
+}
+
+type netParseError struct {
+	Err *net.ParseError
+}
+
+func (e *netParseError) Error() string {
+	return "invalid " + e.Err.Type
+}
+
+func (e *netParseError) Unwrap() error { return e.Err }
+
+func wrapTimeParseError(err error) error {
+	if err == nil {
+		return nil
+	}
+
+	if err, ok := err.(*time.ParseError); ok {
+		return &timeParseError{Err: err}
+	}
+
+	return err
+}
+
+type timeParseError struct {
+	Err *time.ParseError
+}
+
+func (e *timeParseError) Error() string {
+	if e.Err.Message == "" {
+		return fmt.Sprintf("parsing time as %q: cannot parse as %q", e.Err.Layout, e.Err.LayoutElem)
+	}
+
+	return "parsing time " + e.Err.Message
+}
+
+func (e *timeParseError) Unwrap() error { return e.Err }
+
+func wrapNetIPParseAddrError(err error) error {
+	if err == nil {
+		return nil
+	}
+
+	if errMsg := err.Error(); strings.HasPrefix(errMsg, "ParseAddr") {
+		errPieces := strings.Split(errMsg, ": ")
+
+		return fmt.Errorf("ParseAddr: %s", errPieces[len(errPieces)-1])
+	}
+
+	return err
+}
+
+func wrapNetIPParseAddrPortError(err error) error {
+	if err == nil {
+		return nil
+	}
+
+	errMsg := err.Error()
+	if strings.HasPrefix(errMsg, "invalid port ") {
+		return errors.New("invalid port")
+	} else if strings.HasPrefix(errMsg, "invalid ip:port ") {
+		return errors.New("invalid ip:port")
+	}
+
+	return err
+}
+
+func wrapNetIPParsePrefixError(err error) error {
+	if err == nil {
+		return nil
+	}
+
+	if errMsg := err.Error(); strings.HasPrefix(errMsg, "netip.ParsePrefix") {
+		errPieces := strings.Split(errMsg, ": ")
+
+		return fmt.Errorf("netip.ParsePrefix: %s", errPieces[len(errPieces)-1])
+	}
+
+	return err
+}
+
+func wrapTimeParseDurationError(err error) error {
+	if err == nil {
+		return nil
+	}
+
+	errMsg := err.Error()
+	if strings.HasPrefix(errMsg, "time: unknown unit ") {
+		return errors.New("time: unknown unit")
+	} else if strings.HasPrefix(errMsg, "time: ") {
+		idx := strings.LastIndex(errMsg, " ")
+
+		return errors.New(errMsg[:idx])
+	}
+
+	return err
+}
diff --git a/vendor/github.com/mitchellh/mapstructure/decode_hooks.go b/vendor/github.com/mitchellh/mapstructure/decode_hooks.go
index 3a754ca..4848c09 100644
--- a/vendor/github.com/mitchellh/mapstructure/decode_hooks.go
+++ b/vendor/github.com/mitchellh/mapstructure/decode_hooks.go
@@ -9,8 +9,11 @@ import (
 	"strconv"
 	"strings"
 	"time"
+
 )
 
+
+
 // typedDecodeHook takes a raw DecodeHookFunc (an interface{}) and turns
 // it into the proper DecodeHookFunc type, such as DecodeHookFuncType.
 func typedDecodeHook(h DecodeHookFunc) DecodeHookFunc {
@@ -134,7 +137,9 @@ func StringToTimeDurationHookFunc() DecodeHookFunc {
 		}
 
 		// Convert it by parsing
-		return time.ParseDuration(data.(string))
+		d, err := time.ParseDuration(data.(string))
+
+		return d, wrapTimeParseDurationError(err)
 	}
 }
 
@@ -155,7 +160,7 @@ func StringToIPHookFunc() DecodeHookFunc {
 		// Convert it by parsing
 		ip := net.ParseIP(data.(string))
 		if ip == nil {
-			return net.IP{}, fmt.Errorf("failed parsing ip %v", data)
+			return net.IP{}, fmt.Errorf("failed parsing ip")
 		}
 
 		return ip, nil
@@ -178,7 +183,7 @@ func StringToIPNetHookFunc() DecodeHookFunc {
 
 		// Convert it by parsing
 		_, net, err := net.ParseCIDR(data.(string))
-		return net, err
+		return net, wrapNetParseError(err)
 	}
 }
 
@@ -197,7 +202,9 @@ func StringToTimeHookFunc(layout string) DecodeHookFunc {
 		}
 
 		// Convert it by parsing
-		return time.Parse(layout, data.(string))
+		ti, err := time.Parse(layout, data.(string))
+
+		return ti, wrapTimeParseError(err)
 	}
 }
 
diff --git a/vendor/github.com/mitchellh/mapstructure/mapstructure.go b/vendor/github.com/mitchellh/mapstructure/mapstructure.go
index 1efb22a..20a85b4 100644
--- a/vendor/github.com/mitchellh/mapstructure/mapstructure.go
+++ b/vendor/github.com/mitchellh/mapstructure/mapstructure.go
@@ -642,7 +642,11 @@ func (d *Decoder) decodeInt(name string, data interface{}, val reflect.Value) er
 		if err == nil {
 			val.SetInt(i)
 		} else {
-			return fmt.Errorf("cannot parse '%s' as int: %s", name, err)
+			return newDecodeError(name, &ParseError{
+				Expected: val,
+				Value:    data,
+				Err:      wrapStrconvNumError(err),
+			})
 		}
 	case dataType.PkgPath() == "encoding/json" && dataType.Name() == "Number":
 		jn := data.(json.Number)
@@ -699,7 +703,11 @@ func (d *Decoder) decodeUint(name string, data interface{}, val reflect.Value) e
 		if err == nil {
 			val.SetUint(i)
 		} else {
-			return fmt.Errorf("cannot parse '%s' as uint: %s", name, err)
+			return newDecodeError(name, &ParseError{
+				Expected: val,
+				Value:    data,
+				Err:      wrapStrconvNumError(err),
+			})
 		}
 	case dataType.PkgPath() == "encoding/json" && dataType.Name() == "Number":
 		jn := data.(json.Number)
@@ -738,7 +746,11 @@ func (d *Decoder) decodeBool(name string, data interface{}, val reflect.Value) e
 		} else if dataVal.String() == "" {
 			val.SetBool(false)
 		} else {
-			return fmt.Errorf("cannot parse '%s' as bool: %s", name, err)
+			return newDecodeError(name, &ParseError{
+				Expected: val,
+				Value:    data,
+				Err:      wrapStrconvNumError(err),
+			})
 		}
 	default:
 		return fmt.Errorf(
@@ -777,7 +789,11 @@ func (d *Decoder) decodeFloat(name string, data interface{}, val reflect.Value)
 		if err == nil {
 			val.SetFloat(f)
 		} else {
-			return fmt.Errorf("cannot parse '%s' as float: %s", name, err)
+			return newDecodeError(name, &ParseError{
+				Expected: val,
+				Value:    data,
+				Err:      wrapStrconvNumError(err),
+			})
 		}
 	case dataType.PkgPath() == "encoding/json" && dataType.Name() == "Number":
 		jn := data.(json.Number)
-- 
2.45.4

