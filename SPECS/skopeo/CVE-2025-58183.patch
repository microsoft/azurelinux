From db3ce28d1b92813f66514c400325a8092f76b928 Mon Sep 17 00:00:00 2001
From: AllSpark <allspark@microsoft.com>
Date: Sat, 15 Nov 2025 06:20:04 +0000
Subject: [PATCH] archive/tar: set a limit on the size of GNU sparse file 1.0
 regions

Cap the size of the sparse block data to the same limit used for PAX headers (1 MiB). Add errSparseTooLong and maxSpecialFileSize, and enforce the limit in readGNUSparseMap1x0.

Thanks to Harshit Gupta (Mr HAX) for reporting.
Fixes CVE-2025-58183
Refs #75677
Fixes #75711

Signed-off-by: Azure Linux Security Servicing Account <azurelinux-security@microsoft.com>
Upstream-reference: AI Backport of https://github.com/vbatts/tar-split/commit/55da7d6b43bd806ee785d783bdf66bcf302af118.patch
---
 vendor/github.com/vbatts/tar-split/archive/tar/common.go | 5 +++++
 vendor/github.com/vbatts/tar-split/archive/tar/reader.go | 9 +++++++--
 2 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/vendor/github.com/vbatts/tar-split/archive/tar/common.go b/vendor/github.com/vbatts/tar-split/archive/tar/common.go
index dee9e47..babf403 100644
--- a/vendor/github.com/vbatts/tar-split/archive/tar/common.go
+++ b/vendor/github.com/vbatts/tar-split/archive/tar/common.go
@@ -34,8 +34,13 @@ var (
 	errMissData        = errors.New("archive/tar: sparse file references non-existent data")
 	errUnrefData       = errors.New("archive/tar: sparse file contains unreferenced data")
 	errWriteHole       = errors.New("archive/tar: write non-NUL byte in sparse hole")
+	errSparseTooLong   = errors.New("archive/tar: sparse map too long")
 )
 
+// Limit for special header data such as PAX headers and GNU sparse maps.
+// Matches the limit used for PAX headers (1 MiB).
+const maxSpecialFileSize = 1 << 20
+
 type headerError []string
 
 func (he headerError) Error() string {
diff --git a/vendor/github.com/vbatts/tar-split/archive/tar/reader.go b/vendor/github.com/vbatts/tar-split/archive/tar/reader.go
index af006fc..64a93f5 100644
--- a/vendor/github.com/vbatts/tar-split/archive/tar/reader.go
+++ b/vendor/github.com/vbatts/tar-split/archive/tar/reader.go
@@ -576,12 +576,17 @@ func readGNUSparseMap1x0(r io.Reader) (sparseDatas, error) {
 		cntNewline int64
 		buf        bytes.Buffer
 		blk        block
+		totalSize  int
 	)
 
 	// feedTokens copies data in blocks from r into buf until there are
 	// at least cnt newlines in buf. It will not read more blocks than needed.
 	feedTokens := func(n int64) error {
 		for cntNewline < n {
+			totalSize += len(blk)
+			if totalSize > maxSpecialFileSize {
+				return errSparseTooLong
+			}
 			if _, err := mustReadFull(r, blk[:]); err != nil {
 				return err
 			}
@@ -614,8 +619,8 @@ func readGNUSparseMap1x0(r io.Reader) (sparseDatas, error) {
 	}
 
 	// Parse for all member entries.
-	// numEntries is trusted after this since a potential attacker must have
-	// committed resources proportional to what this library used.
+	// numEntries is trusted after this since feedTokens limits the number of
+	// tokens based on maxSpecialFileSize.
 	if err := feedTokens(2 * numEntries); err != nil {
 		return nil, err
 	}
-- 
2.45.4

