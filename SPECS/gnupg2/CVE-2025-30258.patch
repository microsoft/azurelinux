From e149709fe7b26c546b59c98107f435f22394454e Mon Sep 17 00:00:00 2001
From: AllSpark <allspark@microsoft.com>
Date: Fri, 31 Oct 2025 19:43:34 +0000
Subject: [PATCH] Backport: gpg signature verification DoS fix; add r_keyblock
 propagation, get_pubkey_bykid, and logging tweaks per upstream patch

Signed-off-by: Azure Linux Security Servicing Account <azurelinux-security@microsoft.com>
Upstream-reference: AI Backport of https://github.com/gpg/gnupg/commit/48978ccb4e20866472ef18436a32744350a65158.patch
---
 g10/getkey.c     |  41 ++++++++++++--
 g10/getkey.c.rej | 138 +++++++++++++++++++++++++++++++++++++++++++++++
 g10/gpg.h        |   3 +-
 g10/keydb.h      |  11 +++-
 g10/mainproc.c   |  11 ++--
 5 files changed, 194 insertions(+), 10 deletions(-)
 create mode 100644 g10/getkey.c.rej

diff --git a/g10/getkey.c b/g10/getkey.c
index 6363fea..f926382 100644
--- a/g10/getkey.c
+++ b/g10/getkey.c
@@ -310,27 +310,50 @@ pk_from_block (PKT_public_key *pk, kbnode_t keyblock, kbnode_t found_key)
 
 /* Specialized version of get_pubkey which retrieves the key based on
  * information in SIG.  In contrast to get_pubkey PK is required.  IF
- * FORCED_PK is not NULL, this public key is used and copied to PK. */
+ * FORCED_PK is not NULL, this public key is used and copied to PK.
+ * If R_KEYBLOCK is not NULL the entire keyblock is stored there if
+ * found and FORCED_PK is not used; if not used or on error NULL is
+ * stored there. */
 gpg_error_t
 get_pubkey_for_sig (ctrl_t ctrl, PKT_public_key *pk, PKT_signature *sig,
-                    PKT_public_key *forced_pk)
+                    PKT_public_key *forced_pk, kbnode_t *r_keyblock)
 {
+  gpg_error_t err;
   const byte *fpr;
   size_t fprlen;
 
+  if (r_keyblock)
+    *r_keyblock = NULL;
+
   if (forced_pk)
     {
       copy_public_key (pk, forced_pk);
       return 0;
     }
 
+  /* Make sure to request only keys cabable of signing.  This makes
+   * sure that a subkey w/o a valid backsig or with bad usage flags
+   * will be skipped.  */
+  pk->req_usage = PUBKEY_USAGE_SIG;
+
   /* First try the ISSUER_FPR info.  */
   fpr = issuer_fpr_raw (sig, &fprlen);
-  if (fpr && !get_pubkey_byfprint (ctrl, pk, NULL, fpr, fprlen))
+  if (fpr && !get_pubkey_byfprint (ctrl, pk, r_keyblock, fpr, fprlen))
     return 0;
+  if (r_keyblock)
+    {
+      release_kbnode (*r_keyblock);
+      *r_keyblock = NULL;
+    }
 
   /* Fallback to use the ISSUER_KEYID.  */
-  return get_pubkey (ctrl, pk, sig->keyid);
+  err = get_pubkey_bykid (ctrl, pk, r_keyblock, sig->keyid);
+  if (err && r_keyblock)
+    {
+      release_kbnode (*r_keyblock);
+      *r_keyblock = NULL;
+    }
+  return err;
 }
 
 
@@ -356,7 +379,8 @@ get_pubkey_for_sig (ctrl_t ctrl, PKT_public_key *pk, PKT_signature *sig,
  * has definitely been merged into the public key using
  * merge_selfsigs.  */
 int
-get_pubkey (ctrl_t ctrl, PKT_public_key * pk, u32 * keyid)
+get_pubkey_bykid (ctrl_t ctrl, PKT_public_key *pk, kbnode_t *r_keyblock,
+                  u32 *keyid)
 {
   int internal = 0;
   int rc = 0;
@@ -444,6 +468,13 @@ leave:
   return rc;
 }
 
+/* Wrapper for get_pubkey_bykid w/o keyblock return feature.  */
+int
+get_pubkey (ctrl_t ctrl, PKT_public_key *pk, u32 *keyid)
+{
+  return get_pubkey_bykid (ctrl, pk, NULL, keyid);
+}
+
 
 /* Same as get_pubkey but if the key was not found the function tries
  * to import it from LDAP.  FIXME: We should not need this but swicth
diff --git a/g10/getkey.c.rej b/g10/getkey.c.rej
new file mode 100644
index 0000000..bedeed3
--- /dev/null
+++ b/g10/getkey.c.rej
@@ -0,0 +1,138 @@
+--- g10/getkey.c
++++ g10/getkey.c
+@@ -316,27 +316,50 @@ pk_from_block (PKT_public_key *pk, kbnode_t keyblock, kbnode_t found_key)
+ 
+ /* Specialized version of get_pubkey which retrieves the key based on
+  * information in SIG.  In contrast to get_pubkey PK is required.  IF
+- * FORCED_PK is not NULL, this public key is used and copied to PK. */
++ * FORCED_PK is not NULL, this public key is used and copied to PK.
++ * If R_KEYBLOCK is not NULL the entire keyblock is stored there if
++ * found and FORCED_PK is not used; if not used or on error NULL is
++ * stored there. */
+ gpg_error_t
+ get_pubkey_for_sig (ctrl_t ctrl, PKT_public_key *pk, PKT_signature *sig,
+-                    PKT_public_key *forced_pk)
++                    PKT_public_key *forced_pk, kbnode_t *r_keyblock)
+ {
++  gpg_error_t err;
+   const byte *fpr;
+   size_t fprlen;
+ 
++  if (r_keyblock)
++    *r_keyblock = NULL;
++
+   if (forced_pk)
+     {
+       copy_public_key (pk, forced_pk);
+       return 0;
+     }
+ 
++  /* Make sure to request only keys cabable of signing.  This makes
++   * sure that a subkey w/o a valid backsig or with bad usage flags
++   * will be skipped.  */
++  pk->req_usage = PUBKEY_USAGE_SIG;
++
+   /* First try the ISSUER_FPR info.  */
+   fpr = issuer_fpr_raw (sig, &fprlen);
+-  if (fpr && !get_pubkey_byfpr (ctrl, pk, NULL, fpr, fprlen))
++  if (fpr && !get_pubkey_byfpr (ctrl, pk, r_keyblock, fpr, fprlen))
+     return 0;
++  if (r_keyblock)
++    {
++      release_kbnode (*r_keyblock);
++      *r_keyblock = NULL;
++    }
+ 
+   /* Fallback to use the ISSUER_KEYID.  */
+-  return get_pubkey (ctrl, pk, sig->keyid);
++  err = get_pubkey_bykid (ctrl, pk, r_keyblock, sig->keyid);
++  if (err && r_keyblock)
++    {
++      release_kbnode (*r_keyblock);
++      *r_keyblock = NULL;
++    }
++  return err;
+ }
+ 
+ 
+@@ -365,24 +392,30 @@ get_pubkey_for_sig (ctrl_t ctrl, PKT_public_key *pk, PKT_signature *sig,
+  * If the data was not read from the cache, then the self-signed data
+  * has definitely been merged into the public key using
+  * merge_selfsigs.  */
+-int
+-get_pubkey (ctrl_t ctrl, PKT_public_key * pk, u32 * keyid)
++gpg_error_t
++get_pubkey_bykid (ctrl_t ctrl, PKT_public_key *pk, kbnode_t *r_keyblock,
++                  u32 *keyid)
+ {
+   int internal = 0;
+-  int rc = 0;
++  gpg_error_t rc = 0;
++
++  if (r_keyblock)
++    *r_keyblock = NULL;
+ 
+ #if MAX_PK_CACHE_ENTRIES
+-  if (pk)
++  if (pk && !r_keyblock)
+     {
+       /* Try to get it from the cache.  We don't do this when pk is
+-         NULL as it does not guarantee that the user IDs are
+-         cached. */
++       * NULL as it does not guarantee that the user IDs are cached.
++       * The old get_pubkey_function did not check PK->REQ_USAGE when
++       * reading form the caceh.  This is probably a bug.  Note that
++       * the cache is not used when the caller asked to return the
++       * entire keyblock.  This is because the cache does not
++       * associate the public key wit its primary key.  */
+       pk_cache_entry_t ce;
+       for (ce = pk_cache; ce; ce = ce->next)
+ 	{
+ 	  if (ce->keyid[0] == keyid[0] && ce->keyid[1] == keyid[1])
+-	    /* XXX: We don't check PK->REQ_USAGE here, but if we don't
+-	       read from the cache, we do check it!  */
+ 	    {
+ 	      copy_public_key (pk, ce->pk);
+ 	      return 0;
+@@ -578,28 +622,6 @@ get_pubkey_fast (ctrl_t ctrl, PKT_public_key * pk, u32 * keyid)
+ }
+ 
+ 
+-/* Return the entire keyblock used to create SIG.  This is a
+- * specialized version of get_pubkeyblock.
+- *
+- * FIXME: This is a hack because get_pubkey_for_sig was already called
+- * and it could have used a cache to hold the key.  */
+-kbnode_t
+-get_pubkeyblock_for_sig (ctrl_t ctrl, PKT_signature *sig)
+-{
+-  const byte *fpr;
+-  size_t fprlen;
+-  kbnode_t keyblock;
+-
+-  /* First try the ISSUER_FPR info.  */
+-  fpr = issuer_fpr_raw (sig, &fprlen);
+-  if (fpr && !get_pubkey_byfpr (ctrl, NULL, &keyblock, fpr, fprlen))
+-    return keyblock;
+-
+-  /* Fallback to use the ISSUER_KEYID.  */
+-  return get_pubkeyblock (ctrl, sig->keyid);
+-}
+-
+-
+ /* Return the key block for the key with key id KEYID or NULL, if an
+  * error occurs.  Use release_kbnode() to release the key block.
+  *
+@@ -3746,11 +3769,10 @@ finish_lookup (kbnode_t keyblock, unsigned int req_usage, int want_exact,
+         {
+           if (want_exact)
+             {
+-              if (DBG_LOOKUP)
+-                log_debug ("finish_lookup: exact search requested and found\n");
+               foundk = k;
+               pk = k->pkt->pkt.public_key;
+               pk->flags.exact = 1;
++              diag_exactfound = 1;
+               break;
+             }
+           else if (!allow_adsk && (k->pkt->pkt.public_key->pubkey_usage
diff --git a/g10/gpg.h b/g10/gpg.h
index c51bbbb..0cdcb8b 100644
--- a/g10/gpg.h
+++ b/g10/gpg.h
@@ -69,7 +69,8 @@ struct dirmngr_local_s;
 typedef struct dirmngr_local_s *dirmngr_local_t;
 
 /* Object used to describe a keyblock node.  */
-typedef struct kbnode_struct *KBNODE;   /* Deprecated use kbnode_t. */typedef struct kbnode_struct *kbnode_t;
+typedef struct kbnode_struct *KBNODE;   /* Deprecated use kbnode_t. */
+typedef struct kbnode_struct *kbnode_t;
 
 /* The handle for keydb operations.  */
 typedef struct keydb_handle_s *KEYDB_HANDLE;
diff --git a/g10/keydb.h b/g10/keydb.h
index 771bc8e..61e4cb0 100644
--- a/g10/keydb.h
+++ b/g10/keydb.h
@@ -332,7 +332,16 @@ void getkey_disable_caches(void);
 /* Return the public key used for signature SIG and store it at PK.  */
 gpg_error_t get_pubkey_for_sig (ctrl_t ctrl,
                                 PKT_public_key *pk, PKT_signature *sig,
-                                PKT_public_key *forced_pk);
+                                PKT_public_key *forced_pk,
+                                kbnode_t *r_keyblock);
+
+/* Return the public key with the key id KEYID and store it at PK.
+ * Optionally return the entire keyblock.  */
+gpg_error_t get_pubkey_bykid (ctrl_t ctrl, PKT_public_key *pk,
+                              kbnode_t *r_keyblock, u32 *keyid);
+
+/* Same as get_pubkey_bykid but w/o r_keyblock.  */
+int get_pubkey (ctrl_t ctrl, PKT_public_key *pk, u32 *keyid);
 
 /* Return the public key with the key id KEYID and store it at PK.  */
 int get_pubkey (ctrl_t ctrl, PKT_public_key *pk, u32 *keyid);
diff --git a/g10/mainproc.c b/g10/mainproc.c
index 330ad10..56990ee 100644
--- a/g10/mainproc.c
+++ b/g10/mainproc.c
@@ -1150,12 +1150,15 @@ proc_compressed (CTX c, PACKET *pkt)
  * used to verify the signature will be stored there, or NULL if not
  * found.  If FORCED_PK is not NULL, this public key is used to verify
  * _data signatures_ and no key lookup is done.  Returns: 0 = valid
- * signature or an error code
+ * signature or an error code.  If R_KEYBLOCK is not NULL the keyblock
+ * carries the used PK is stored there.  The caller should always free
+ * the return value using release_kbnode.
  */
 static int
 do_check_sig (CTX c, kbnode_t node, const void *extrahash, size_t extrahashlen,
               PKT_public_key *forced_pk, int *is_selfsig,
-	      int *is_expkey, int *is_revkey, PKT_public_key **r_pk)
+	      int *is_expkey, int *is_revkey,
+              PKT_public_key **r_pk, kbnode_t *r_keyblock)
 {
   PKT_signature *sig;
   gcry_md_hd_t md = NULL;
@@ -1165,6 +1168,8 @@ do_check_sig (CTX c, kbnode_t node, const void *extrahash, size_t extrahashlen,
 
   if (r_pk)
     *r_pk = NULL;
+  if (r_keyblock)
+    *r_keyblock = NULL;
 
   log_assert (node->pkt->pkttype == PKT_SIGNATURE);
   if (is_selfsig)
@@ -1875,7 +1880,7 @@ check_sig_and_print (CTX c, kbnode_t node)
   PKT_public_key *pk = NULL;  /* The public key for the signature or NULL. */
   const void *extrahash = NULL;
   size_t extrahashlen = 0;
-  kbnode_t included_keyblock = NULL;
+  kbnode_t keyblock = NULL;
 
   if (opt.skip_verify)
     {
-- 
2.45.4

