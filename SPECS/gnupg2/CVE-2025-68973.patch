From 33731863e1efaa7f3230a2a7335a87390f387444 Mon Sep 17 00:00:00 2001
From: AllSpark <allspark@microsoft.com>
Date: Mon, 29 Dec 2025 16:57:49 +0000
Subject: [PATCH] gpg: Fix possible memory corruption in armor parser; add
 filter len asserts in iobuf underflow; fix faulty double increment in
 armor_filter loop. (Backport)

Signed-off-by: Azure Linux Security Servicing Account <azurelinux-security@microsoft.com>
Upstream-reference: AI Backport of https://github.com/gpg/gnupg/commit/115d138ba599328005c5321c0ef9f00355838ca9.patch
---
 common/iobuf.c | 5 +++++
 g10/armor.c    | 6 +++---
 2 files changed, 8 insertions(+), 3 deletions(-)

diff --git a/common/iobuf.c b/common/iobuf.c
index 748e693..27c826b 100644
--- a/common/iobuf.c
+++ b/common/iobuf.c
@@ -2043,6 +2043,7 @@ underflow_target (iobuf_t a, int clear_pending_eof, size_t target)
 	rc = 0;
       else
       {
+	size_t tmplen;
 	/* If no buffered data and drain buffer has been setup, and drain
 	 * buffer is largish, read data directly to drain buffer. */
 	if (a->d.len == 0
@@ -2055,8 +2056,10 @@ underflow_target (iobuf_t a, int clear_pending_eof, size_t target)
 	      log_debug ("iobuf-%d.%d: underflow: A->FILTER (%lu bytes, to external drain)\n",
 			 a->no, a->subno, (ulong)len);
 
+	    tmplen = len;  /* Used to check for bugs in the filter.  */
 	    rc = a->filter (a->filter_ov, IOBUFCTRL_UNDERFLOW, a->chain,
 			    a->e_d.buf, &len);
+	    log_assert (len <= tmplen);
 	    a->e_d.used = len;
 	    len = 0;
 	  }
@@ -2066,8 +2069,10 @@ underflow_target (iobuf_t a, int clear_pending_eof, size_t target)
 	      log_debug ("iobuf-%d.%d: underflow: A->FILTER (%lu bytes)\n",
 			 a->no, a->subno, (ulong)len);
 
+	    tmplen = len;
 	    rc = a->filter (a->filter_ov, IOBUFCTRL_UNDERFLOW, a->chain,
 			    &a->d.buf[a->d.len], &len);
+	    log_assert (len <= tmplen);
 	  }
       }
       a->d.len += len;
diff --git a/g10/armor.c b/g10/armor.c
index 81af153..231d158 100644
--- a/g10/armor.c
+++ b/g10/armor.c
@@ -1301,9 +1301,9 @@ armor_filter( void *opaque, int control,
     if( control == IOBUFCTRL_UNDERFLOW && afx->inp_bypass ) {
 	n = 0;
 	if( afx->buffer_len ) {
-            /* Copy the data from AFX->BUFFER to BUF.  */
-	    for(; n < size && afx->buffer_pos < afx->buffer_len; n++ )
-		buf[n++] = afx->buffer[afx->buffer_pos++];
+                /* Copy the data from AFX->BUFFER to BUF.  */
+            for(; n < size && afx->buffer_pos < afx->buffer_len;)
+                buf[n++] = afx->buffer[afx->buffer_pos++];
 	    if( afx->buffer_pos >= afx->buffer_len )
 		afx->buffer_len = 0;
 	}
-- 
2.45.4

