From 958ab4d0c69f21a63ad226889cca0b37d2141c43 Mon Sep 17 00:00:00 2001
From: AllSpark <allspark@microsoft.com>
Date: Mon, 5 Jan 2026 05:57:22 +0000
Subject: [PATCH] gpg: Fix possible memory corruption in armor parser; add
 asserts in iobuf underflow. Backport patch.

Signed-off-by: Azure Linux Security Servicing Account <azurelinux-security@microsoft.com>
Upstream-reference: AI Backport of https://github.com/gpg/gnupg/commit/115d138ba599328005c5321c0ef9f00355838ca9.patch
---
 common/iobuf.c | 5 +++++
 g10/armor.c    | 8 ++++----
 2 files changed, 9 insertions(+), 4 deletions(-)

diff --git a/common/iobuf.c b/common/iobuf.c
index 86bb296..f0bde64 100644
--- a/common/iobuf.c
+++ b/common/iobuf.c
@@ -1933,6 +1933,7 @@ underflow_target (iobuf_t a, int clear_pending_eof, size_t target)
 	rc = 0;
       else
       {
+          size_t tmplen;
 	/* If no buffered data and drain buffer has been setup, and drain
 	 * buffer is largish, read data directly to drain buffer. */
 	if (a->d.len == 0
@@ -1945,9 +1946,11 @@ underflow_target (iobuf_t a, int clear_pending_eof, size_t target)
 	      log_debug ("iobuf-%d.%d: underflow: A->FILTER (%lu bytes, to external drain)\n",
 			 a->no, a->subno, (ulong)len);
 
+            tmplen = len;  /* Used to check for bugs in the filter.  */
 	    rc = a->filter (a->filter_ov, IOBUFCTRL_UNDERFLOW, a->chain,
 			    a->e_d.buf, &len);
 	    a->e_d.used = len;
+            log_assert (len <= tmplen);
 	    len = 0;
 	  }
 	else
@@ -1955,9 +1958,11 @@ underflow_target (iobuf_t a, int clear_pending_eof, size_t target)
 	    if (DBG_IOBUF)
 	      log_debug ("iobuf-%d.%d: underflow: A->FILTER (%lu bytes)\n",
 			 a->no, a->subno, (ulong)len);
+            tmplen = len;
 
 	    rc = a->filter (a->filter_ov, IOBUFCTRL_UNDERFLOW, a->chain,
 			    &a->d.buf[a->d.len], &len);
+            log_assert (len <= tmplen);
 	  }
       }
       a->d.len += len;
diff --git a/g10/armor.c b/g10/armor.c
index b47c04a..ad567a9 100644
--- a/g10/armor.c
+++ b/g10/armor.c
@@ -1302,10 +1302,10 @@ armor_filter( void *opaque, int control,
 	n = 0;
 	if( afx->buffer_len ) {
             /* Copy the data from AFX->BUFFER to BUF.  */
-	    for(; n < size && afx->buffer_pos < afx->buffer_len; n++ )
-		buf[n++] = afx->buffer[afx->buffer_pos++];
-	    if( afx->buffer_pos >= afx->buffer_len )
-		afx->buffer_len = 0;
+            for(; n < size && afx->buffer_pos < afx->buffer_len;)
+                buf[n++] = afx->buffer[afx->buffer_pos++];
+            if( afx->buffer_pos >= afx->buffer_len )
+                afx->buffer_len = 0;
 	}
         /* If there is still space in BUF, read directly into it.  */
 	for(; n < size; n++ ) {
-- 
2.45.4

