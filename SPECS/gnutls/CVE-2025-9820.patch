From 75ec339e8e960ab35f1261f3dc500aca1c3c46d1 Mon Sep 17 00:00:00 2001
From: AllSpark <allspark@microsoft.com>
Date: Wed, 28 Jan 2026 04:16:21 +0000
Subject: [PATCH] pkcs11: avoid stack overwrite when initializing a token

If gnutls_pkcs11_token_init is called with label longer than 32 characters, the internal storage used to blank-fill it would overflow. This adds a guard to prevent that.

Signed-off-by: Azure Linux Security Servicing Account <azurelinux-security@microsoft.com>
Upstream-reference: AI Backport of https://gitlab.com/gnutls/gnutls/-/commit/1d56f96f6ab5034d677136b9d50b5a75dff0faf5.patch
---
 NEWS                      |   5 ++
 lib/pkcs11_write.c        |   5 +-
 tests/Makefile.am         |   2 +-
 tests/pkcs11/long-label.c | 164 ++++++++++++++++++++++++++++++++++++++
 4 files changed, 173 insertions(+), 3 deletions(-)
 create mode 100644 tests/pkcs11/long-label.c

diff --git a/NEWS b/NEWS
index c9852ba..2911c46 100644
--- a/NEWS
+++ b/NEWS
@@ -7,6 +7,11 @@ See the end for copying conditions.
 
 - Fix for vulnerbaility CVE-2025-13151 Stack-based buffer overflow
 
+** libgnutls: Fix stack overwrite in gnutls_pkcs11_token_init
+   Reported by Luigino Camastra from Aisle Research. [GNUTLS-SA-2025-11-18,
+   CVSS: low] [CVE-2025-9820]
+
+
 * Version 3.8.3 (released 2024-01-16)
 
 ** libgnutls: Fix more timing side-channel inside RSA-PSK key exchange
diff --git a/lib/pkcs11_write.c b/lib/pkcs11_write.c
index a3201dd..e923dcd 100644
--- a/lib/pkcs11_write.c
+++ b/lib/pkcs11_write.c
@@ -28,6 +28,7 @@
 #include "pkcs11x.h"
 #include "x509/common.h"
 #include "pk.h"
+#include "minmax.h"
 
 static const ck_bool_t tval = 1;
 static const ck_bool_t fval = 0;
@@ -1170,7 +1171,7 @@ int gnutls_pkcs11_delete_url(const char *object_url, unsigned int flags)
  * gnutls_pkcs11_token_init:
  * @token_url: A PKCS #11 URL specifying a token
  * @so_pin: Security Officer's PIN
- * @label: A name to be used for the token
+ * @label: A name to be used for the token, at most 32 characters
  *
  * This function will initialize (format) a token. If the token is
  * at a factory defaults state the security officer's PIN given will be
@@ -1208,7 +1209,7 @@ int gnutls_pkcs11_token_init(const char *token_url, const char *so_pin,
 	/* so it seems memset has other uses than zeroing! */
 	memset(flabel, ' ', sizeof(flabel));
 	if (label != NULL)
-		memcpy(flabel, label, strlen(label));
+		memcpy(flabel, label, MIN(sizeof(flabel), strlen(label)));
 
 	rv = pkcs11_init_token(module, slot, (uint8_t *)so_pin, strlen(so_pin),
 			       (uint8_t *)flabel);
diff --git a/tests/Makefile.am b/tests/Makefile.am
index babf3be..5367ff2 100644
--- a/tests/Makefile.am
+++ b/tests/Makefile.am
@@ -493,7 +493,7 @@ pathbuf_CPPFLAGS = $(AM_CPPFLAGS) \
 if ENABLE_PKCS11
 if !WINDOWS
 ctests += tls13/post-handshake-with-cert-pkcs11 pkcs11/tls-neg-pkcs11-no-key \
-	global-init-override pkcs11/distrust-after
+	global-init-override pkcs11/distrust-after pkcs11/long-label
 tls13_post_handshake_with_cert_pkcs11_DEPENDENCIES = libpkcs11mock2.la libutils.la
 tls13_post_handshake_with_cert_pkcs11_LDADD = $(LDADD) $(LIBDL)
 pkcs11_tls_neg_pkcs11_no_key_DEPENDENCIES = libpkcs11mock2.la libutils.la
diff --git a/tests/pkcs11/long-label.c b/tests/pkcs11/long-label.c
new file mode 100644
index 0000000..21a52e8
--- /dev/null
+++ b/tests/pkcs11/long-label.c
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2025 Red Hat, Inc.
+ *
+ * Author: Daiki Ueno
+ *
+ * This file is part of GnuTLS.
+ *
+ * GnuTLS is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * GnuTLS is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#if defined(_WIN32)
+
+int main(void)
+{
+\texit(77);
+}
+
+#else
+
+#include <string.h>
+#include <unistd.h>
+#include <gnutls/gnutls.h>
+
+#include "cert-common.h"
+#include "pkcs11/softhsm.h"
+#include "utils.h"
+
+/* This program tests that a token can be initialized with
+ * a label longer than 32 characters.
+ */
+
+static void tls_log_func(int level, const char *str)
+{
+\tfprintf(stderr, "server|<%d>| %s", level, str);
+}
+
+#define PIN "1234"
+
+#define CONFIG_NAME "softhsm-long-label"
+#define CONFIG CONFIG_NAME ".config"
+
+static int pin_func(void *userdata, int attempt, const char *url,
+\t\t    const char *label, unsigned flags, char *pin,
+\t\t    size_t pin_max)
+{
+\tif (attempt == 0) {
+\t\tstrcpy(pin, PIN);
+\t\treturn 0;
+\t}
+\treturn -1;
+}
+
+static void test(const char *provider)
+{
+\tint ret;
+\tsize_t i;
+
+\tgnutls_pkcs11_init(GNUTLS_PKCS11_FLAG_MANUAL, NULL);
+
+\tsuccess("test with %s\n", provider);
+
+\tif (debug) {
+\t\tgnutls_global_set_log_function(tls_log_func);
+\t\tgnutls_global_set_log_level(4711);
+\t}
+
+\t/* point to SoftHSM token that libpkcs11mock4.so internally uses */
+\tsetenv(SOFTHSM_ENV, CONFIG, 1);
+
+\tgnutls_pkcs11_set_pin_function(pin_func, NULL);
+
+\tret = gnutls_pkcs11_add_provider(provider, "trusted");
+\tif (ret != 0) {
+\t\tfail("gnutls_pkcs11_add_provider: %s\n", gnutls_strerror(ret));
+\t}
+
+\t/* initialize softhsm token */
+\tret = gnutls_pkcs11_token_init(
+\t\tSOFTHSM_URL, PIN,
+\t\t"this is a very long label whose length exceeds 32");
+\tif (ret < 0) {
+\t\tfail("gnutls_pkcs11_token_init: %s\n", gnutls_strerror(ret));
+\t}
+
+\tfor (i = 0;; i++) {
+\t\tchar *url = NULL;
+
+\t\tret = gnutls_pkcs11_token_get_url(i, 0, &url);
+\t\tif (ret < 0)
+\t\t\tbreak;
+\t\tif (strstr(url,
+\t\t\t   "token=this%20is%20a%20very%20long%20label%20whose"))
+\t\t\tbreak;
+\t}
+\tif (ret < 0)
+\t\tfail("gnutls_pkcs11_token_get_url: %s\n", gnutls_strerror(ret));
+
+\tgnutls_pkcs11_deinit();
+}
+
+void doit(void)
+{
+\tconst char *bin;
+\tconst char *lib;
+\tchar buf[128];
+
+\tif (gnutls_fips140_mode_enabled())
+\t\texit(77);
+
+\t/* this must be called once in the program */
+\tglobal_init();
+
+\t/* we call gnutls_pkcs11_init manually */
+\tgnutls_pkcs11_deinit();
+
+\t/* check if softhsm module is loadable */
+\tlib = softhsm_lib();
+
+\t/* initialize SoftHSM token that libpkcs11mock4.so internally uses */
+\tbin = softhsm_bin();
+
+\tset_softhsm_conf(CONFIG);
+\tsnprintf(buf, sizeof(buf),
+\t\t "%s --init-token --slot 0 --label test --so-pin " PIN
+\t\t " --pin " PIN,
+\t\t bin);
+\tsystem(buf);
+
+\ttest(lib);
+
+\tlib = getenv("P11MOCKLIB4");
+\tif (lib == NULL) {
+\t\tfail("P11MOCKLIB4 is not set\n");
+\t}
+
+\tset_softhsm_conf(CONFIG);
+\tsnprintf(buf, sizeof(buf),
+\t\t "%s --init-token --slot 0 --label test --so-pin " PIN
+\t\t " --pin " PIN,
+\t\t bin);
+\tsystem(buf);
+
+\ttest(lib);
+}
+#endif /* _WIN32 */
-- 
2.45.4

