From 53b5b9ea5add2fbb5519737443089016c2d21e0a Mon Sep 17 00:00:00 2001
From: AllSpark <allspark@microsoft.com>
Date: Thu, 27 Nov 2025 06:51:43 +0000
Subject: [PATCH] qt: png: avoid interlaced read overflow by using local row
 buffer for 16-to-8 conversions; mirror libpng fix

Signed-off-by: Azure Linux Security Servicing Account <azurelinux-security@microsoft.com>
Upstream-reference: AI Backport of https://github.com/pnggroup/libpng/pull/751/commits/08da33b4c88cfcd36e5a706558a8d7e0e4773643.patch
---
 src/gui/image/qpnghandler.cpp | 46 ++++++++++++++++++++++++++++++-----
 1 file changed, 40 insertions(+), 6 deletions(-)

diff --git a/src/gui/image/qpnghandler.cpp b/src/gui/image/qpnghandler.cpp
index 85688bf1..93e5ac40 100644
--- a/src/gui/image/qpnghandler.cpp
+++ b/src/gui/image/qpnghandler.cpp
@@ -651,18 +651,52 @@ bool QPngHandlerPrivate::readPngImage(QImage *outImage)
 
         int bit_depth = 0;
         int color_type = 0;
+        int interlace_method = PNG_INTERLACE_LAST;
         int unit_type = PNG_OFFSET_PIXEL;
-        png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type, nullptr, nullptr, nullptr);
+        png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type, &interlace_method, nullptr, nullptr);
         png_get_oFFs(png_ptr, info_ptr, &offset_x, &offset_y, &unit_type);
         uchar *data = outImage->bits();
         qsizetype bpl = outImage->bytesPerLine();
-        amp.row_pointers = new png_bytep[height];
+        if (interlace_method != PNG_INTERLACE_NONE) {
+            /* For interlaced images, avoid writing directly into the user buffer
+             * when libpng combines rows, by using an intermediate local buffer.
+             * This mirrors the fix in libpng to avoid potential overflows when
+             * transforming bit depths (e.g., 16-to-8) during interlaced reads.
+             */
+            const png_size_t row_bytes = png_get_rowbytes(png_ptr, info_ptr);
+            png_bytep local_row = new png_byte[row_bytes];
+
+            int passes;
+            switch (interlace_method) {
+            case PNG_INTERLACE_NONE:
+                passes = 1;
+                break;
+            case PNG_INTERLACE_ADAM7:
+                passes = PNG_INTERLACE_ADAM7_PASSES;
+                break;
+            default:
+                passes = 1;
+                break;
+            }
 
-        for (uint y = 0; y < height; y++)
-            amp.row_pointers[y] = data + y * bpl;
+            while (--passes >= 0) {
+                png_bytep output_row = data;
+                for (png_uint_32 y = 0; y < height; ++y) {
+                    png_read_row(png_ptr, local_row, nullptr);
+                    memcpy(output_row, local_row, size_t(row_bytes));
+                    output_row += bpl;
+                }
+            }
 
-        png_read_image(png_ptr, amp.row_pointers);
-        amp.deallocate();
+            delete [] local_row;
+        } else {
+            amp.row_pointers = new png_bytep[height];
+            for (uint y = 0; y < height; y++)
+                amp.row_pointers[y] = data + y * bpl;
+
+            png_read_image(png_ptr, amp.row_pointers);
+            amp.deallocate();
+        }
 
         outImage->setDotsPerMeterX(png_get_x_pixels_per_meter(png_ptr,info_ptr));
         outImage->setDotsPerMeterY(png_get_y_pixels_per_meter(png_ptr,info_ptr));
-- 
2.45.4

