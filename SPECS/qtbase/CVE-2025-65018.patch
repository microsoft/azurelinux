From f749da422cfb3a7f96d0b00e9ef912ba8a0d68bc Mon Sep 17 00:00:00 2001
From: AllSpark <allspark@microsoft.com>
Date: Thu, 27 Nov 2025 08:15:38 +0000
Subject: [PATCH] PNG: Avoid potential overflow when reading interlaced 16-bit
 images scaled to 8-bit by using an intermediate local row buffer. Mirrors
 upstream fix that rearchitects 16-to-8 conversion for interlaced PNGs to use
 a local buffer instead of rejecting mismatched bit depths.

Signed-off-by: Azure Linux Security Servicing Account <azurelinux-security@microsoft.com>
Upstream-reference: AI Backport of https://github.com/pnggroup/libpng/pull/757/commits/baa0413c0f64248cfd6a3a2ae5bddd2e9f12c0cc.patch
---
 src/gui/image/qpnghandler.cpp | 34 ++++++++++++++++++++++++++++------
 1 file changed, 28 insertions(+), 6 deletions(-)

diff --git a/src/gui/image/qpnghandler.cpp b/src/gui/image/qpnghandler.cpp
index 615a36fa..42b1ae2c 100644
--- a/src/gui/image/qpnghandler.cpp
+++ b/src/gui/image/qpnghandler.cpp
@@ -651,17 +651,39 @@ bool QPngHandlerPrivate::readPngImage(QImage *outImage)
 
         int bit_depth = 0;
         int color_type = 0;
+        int interlace_method = PNG_INTERLACE_LAST;
         int unit_type = PNG_OFFSET_PIXEL;
-        png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type, nullptr, nullptr, nullptr);
+        png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type, &interlace_method, nullptr, nullptr);
         png_get_oFFs(png_ptr, info_ptr, &offset_x, &offset_y, &unit_type);
         uchar *data = outImage->bits();
         qsizetype bpl = outImage->bytesPerLine();
-        amp.row_pointers = new png_bytep[height];
-
-        for (uint y = 0; y < height; y++)
-            amp.row_pointers[y] = data + y * bpl;
 
-        png_read_image(png_ptr, amp.row_pointers);
+        // Use a local intermediate row buffer when reading interlaced 16-bit images
+        // that are transformed to 8-bit output (strip_16). This avoids potential
+        // overflows caused by libpng combining rows using the IHDR bit depth before
+        // finishing the transformation.
+        const bool interlaced16to8 = (interlace_method != PNG_INTERLACE_NONE)
+                                     && (bit_depth == 16)
+                                     && (outImage->format() == QImage::Format_ARGB32
+                                         || outImage->format() == QImage::Format_RGB32);
+        if (interlaced16to8) {
+            // Read each pass using a local row buffer sized for transformed output.
+            const int passes = (interlace_method == PNG_INTERLACE_ADAM7) ? 7 : 1;
+            const png_size_t row_bytes = png_get_rowbytes(png_ptr, info_ptr);
+            png_bytep local_row = new png_byte[row_bytes];
+            for (int pass = 0; pass < passes; ++pass) {
+                for (png_uint_32 y = 0; y < height; ++y) {
+                    png_read_row(png_ptr, local_row, nullptr);
+                    memcpy(data + y * bpl, local_row, row_bytes);
+                }
+            }
+            delete [] local_row;
+        } else {
+            amp.row_pointers = new png_bytep[height];
+            for (uint y = 0; y < height; y++)
+                amp.row_pointers[y] = data + y * bpl;
+            png_read_image(png_ptr, amp.row_pointers);
+        }
         amp.deallocate();
 
         outImage->setDotsPerMeterX(png_get_x_pixels_per_meter(png_ptr,info_ptr));
-- 
2.45.4

