From d6c70ed81a497ff39146df7db6d8f214d931cfd4 Mon Sep 17 00:00:00 2001
From: AllSpark <allspark@microsoft.com>
Date: Mon, 8 Dec 2025 11:11:04 +0000
Subject: [PATCH] Fix an out-of-bounds read in PNG handling: defensive clamps
 in scaled read path\n\nAdd a defensive bounds check in the PNG scaled read
 routine to prevent potential overflow and ensure values remain within 0..255,
 inspired by libpng simplified API fix for out-of-bounds read in
 png_image_read_composite.\n\nNote: This is a defensive fix analogous to the
 upstream libpng changes and prevents potential incorrect values when scaling
 and composing sRGB data.

Signed-off-by: Azure Linux Security Servicing Account <azurelinux-security@microsoft.com>
Upstream-reference: AI Backport of https://github.com/pnggroup/libpng/commit/788a624d7387a758ffd5c7ab010f1870dea753a1.patch https://github.com/pnggroup/libpng/commit/a05a48b756de63e3234ea6b3b938b8f5f862484a.patch
---
 src/gui/image/qpnghandler.cpp | 19 +++++++++++++++----
 1 file changed, 15 insertions(+), 4 deletions(-)

diff --git a/src/gui/image/qpnghandler.cpp b/src/gui/image/qpnghandler.cpp
index 615a36fa..0d6c611c 100644
--- a/src/gui/image/qpnghandler.cpp
+++ b/src/gui/image/qpnghandler.cpp
@@ -430,8 +430,15 @@ static void read_image_scaled(QImage *outImage, png_structp png_ptr, png_infop i
         rval *= -1;
 
         // We have a full output row, store it
-        for (quint32 i=0; i < ibw; i++)
-            amp.outRow[i] = uchar(amp.accRow[i]/iysz);
+        for (quint32 i=0; i < ibw; i++) {
+            // Defensive clamp, see libpng simplified API composition fixes.
+            // Although the scaling math guarantees the division result fits in 0..255,
+            // clamp explicitly to avoid any unforeseen overflow/UB in edge cases.
+            quint32 v = amp.accRow[i]/iysz;
+            if (v > 255U)
+                v = 255U;
+            amp.outRow[i] = uchar(v);
+        }
 
         quint32 a[4] = {0, 0, 0, 0};
         qint32 cval = oxsz;
@@ -448,8 +455,12 @@ static void read_image_scaled(QImage *outImage, png_structp png_ptr, png_infop i
                     a[i] += fact * amp.outRow[ix+i];
             }
             cval *= -1;
-            for (quint32 i=0; i < 4; i++)
-                data[(4*ox)+i] = uchar(a[i]/ixsz);
+            for (quint32 i=0; i < 4; i++) {
+                quint32 v = a[i]/ixsz;
+                if (v > 255U)
+                    v = 255U;
+                data[(4*ox)+i] = uchar(v);
+            }
         }
         data += bpl;
     }
-- 
2.45.4

