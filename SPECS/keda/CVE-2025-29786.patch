From 387fc2ebedb3b5f54f9494c95506e6163f6f7af5 Mon Sep 17 00:00:00 2001
From: Kshitiz Godara <kgodara@microsoft.com>
Date: Mon, 24 Mar 2025 13:30:36 +0000
Subject: [PATCH] Fix for CVE-2025-29786

Upstream source reference:
https://github.com/expr-lang/expr/pull/762

Signed-off-by: Kshitiz Godara <kgodara@microsoft.com>
---
 .../github.com/expr-lang/expr/conf/config.go  |  52 ++--
 .../expr-lang/expr/parser/parser.go           | 228 +++++++++++++-----
 vendor/github.com/expr-lang/expr/vm/utils.go  |   3 -
 vendor/github.com/expr-lang/expr/vm/vm.go     |  23 +-
 4 files changed, 213 insertions(+), 93 deletions(-)

diff --git a/vendor/github.com/expr-lang/expr/conf/config.go b/vendor/github.com/expr-lang/expr/conf/config.go
index 01a407a..2312984 100644
--- a/vendor/github.com/expr-lang/expr/conf/config.go
+++ b/vendor/github.com/expr-lang/expr/conf/config.go
@@ -9,34 +9,46 @@ import (
 	"github.com/expr-lang/expr/vm/runtime"
 )
 
+const (
+	// DefaultMemoryBudget represents an upper limit of memory usage
+	DefaultMemoryBudget uint = 1e6
+
+	// DefaultMaxNodes represents an upper limit of AST nodes
+	DefaultMaxNodes uint = 10000
+)
+
 type FunctionsTable map[string]*builtin.Function
 
 type Config struct {
-	Env         any
-	Types       TypesTable
-	MapEnv      bool
-	DefaultType reflect.Type
-	Expect      reflect.Kind
-	ExpectAny   bool
-	Optimize    bool
-	Strict      bool
-	Profile     bool
-	ConstFns    map[string]reflect.Value
-	Visitors    []ast.Visitor
-	Functions   FunctionsTable
-	Builtins    FunctionsTable
-	Disabled    map[string]bool // disabled builtins
+	Env          any
+	Types        TypesTable
+	MapEnv       bool
+	DefaultType  reflect.Type
+	Expect       reflect.Kind
+	ExpectAny    bool
+	Optimize     bool
+	Strict       bool
+	Profile      bool
+	MaxNodes     uint
+	MemoryBudget uint
+	ConstFns     map[string]reflect.Value
+	Visitors     []ast.Visitor
+	Functions    FunctionsTable
+	Builtins     FunctionsTable
+	Disabled     map[string]bool // disabled builtins
 }
 
 // CreateNew creates new config with default values.
 func CreateNew() *Config {
 	c := &Config{
-		Optimize:  true,
-		Types:     make(TypesTable),
-		ConstFns:  make(map[string]reflect.Value),
-		Functions: make(map[string]*builtin.Function),
-		Builtins:  make(map[string]*builtin.Function),
-		Disabled:  make(map[string]bool),
+		Optimize:     true,
+		Types:        make(TypesTable),
+		MaxNodes:     DefaultMaxNodes,
+		MemoryBudget: DefaultMemoryBudget,
+		ConstFns:     make(map[string]reflect.Value),
+		Functions:    make(map[string]*builtin.Function),
+		Builtins:     make(map[string]*builtin.Function),
+		Disabled:     make(map[string]bool),
 	}
 	for _, f := range builtin.Builtins {
 		c.Builtins[f.Name] = f
diff --git a/vendor/github.com/expr-lang/expr/parser/parser.go b/vendor/github.com/expr-lang/expr/parser/parser.go
index 6d96561..a75557c 100644
--- a/vendor/github.com/expr-lang/expr/parser/parser.go
+++ b/vendor/github.com/expr-lang/expr/parser/parser.go
@@ -45,12 +45,47 @@ var predicates = map[string]struct {
 }
 
 type parser struct {
-	tokens  []Token
-	current Token
-	pos     int
-	err     *file.Error
-	depth   int // closure call depth
-	config  *conf.Config
+	tokens    []Token
+	current   Token
+	pos       int
+	err       *file.Error
+	depth     int // closure call depth
+	config    *conf.Config
+	nodeCount uint // tracks number of AST nodes created
+}
+
+// checkNodeLimit verifies that adding a new node won't exceed configured limits
+func (p *parser) checkNodeLimit() error {
+	p.nodeCount++
+	if p.config.MaxNodes > 0 && p.nodeCount > p.config.MaxNodes {
+		p.error("compilation failed: expression exceeds maximum allowed nodes")
+		return nil
+	}
+	return nil
+}
+
+// createNode handles creation of regular nodes
+func (p *parser) createNode(n Node, loc file.Location) Node {
+	if err := p.checkNodeLimit(); err != nil {
+		return nil
+	}
+	if n == nil || p.err != nil {
+		return nil
+	}
+	n.SetLocation(loc)
+	return n
+}
+
+// createMemberNode handles creation of member nodes
+func (p *parser) createMemberNode(n *MemberNode, loc file.Location) *MemberNode {
+	if err := p.checkNodeLimit(); err != nil {
+		return nil
+	}
+	if n == nil || p.err != nil {
+		return nil
+	}
+	n.SetLocation(loc)
+	return n
 }
 
 type Tree struct {
@@ -127,6 +162,10 @@ func (p *parser) expect(kind Kind, values ...string) {
 // parse functions
 
 func (p *parser) parseExpression(precedence int) Node {
+	if p.err != nil {
+		return nil
+	}
+
 	if precedence == 0 && p.current.Is(Operator, "let") {
 		return p.parseVariableDeclaration()
 	}
@@ -185,19 +224,23 @@ func (p *parser) parseExpression(precedence int) Node {
 				nodeRight = p.parseExpression(op.Precedence)
 			}
 
-			nodeLeft = &BinaryNode{
+			nodeLeft = p.createNode(&BinaryNode{
 				Operator: opToken.Value,
 				Left:     nodeLeft,
 				Right:    nodeRight,
+			}, opToken.Location)
+			if nodeLeft == nil {
+				return nil
 			}
-			nodeLeft.SetLocation(opToken.Location)
 
 			if negate {
-				nodeLeft = &UnaryNode{
+				nodeLeft = p.createNode(&UnaryNode{
 					Operator: "not",
 					Node:     nodeLeft,
+				}, notToken.Location)
+				if nodeLeft == nil {
+					return nil
 				}
-				nodeLeft.SetLocation(notToken.Location)
 			}
 
 			goto next
@@ -224,13 +267,11 @@ func (p *parser) parseVariableDeclaration() Node {
 	value := p.parseExpression(0)
 	p.expect(Operator, ";")
 	node := p.parseExpression(0)
-	let := &VariableDeclaratorNode{
+	return p.createNode(&VariableDeclaratorNode{
 		Name:  variableName.Value,
 		Value: value,
 		Expr:  node,
-	}
-	let.SetLocation(variableName.Location)
-	return let
+	}, variableName.Location)
 }
 
 func (p *parser) parseConditional(node Node) Node {
@@ -248,10 +289,13 @@ func (p *parser) parseConditional(node Node) Node {
 			expr2 = p.parseExpression(0)
 		}
 
-		node = &ConditionalNode{
+		node = p.createNode(&ConditionalNode{
 			Cond: node,
 			Exp1: expr1,
 			Exp2: expr2,
+		}, p.current.Location)
+		if node == nil {
+			return nil
 		}
 	}
 	return node
@@ -264,11 +308,13 @@ func (p *parser) parsePrimary() Node {
 		if op, ok := operator.Unary[token.Value]; ok {
 			p.next()
 			expr := p.parseExpression(op.Precedence)
-			node := &UnaryNode{
+			node := p.createNode(&UnaryNode{
 				Operator: token.Value,
 				Node:     expr,
+			}, token.Location)
+			if node == nil {
+				return nil
 			}
-			node.SetLocation(token.Location)
 			return p.parsePostfixExpression(node)
 		}
 	}
@@ -290,8 +336,10 @@ func (p *parser) parsePrimary() Node {
 					p.next()
 				}
 			}
-			node := &PointerNode{Name: name}
-			node.SetLocation(token.Location)
+			node := p.createNode(&PointerNode{Name: name}, token.Location)
+			if node == nil {
+				return nil
+			}
 			return p.parsePostfixExpression(node)
 		}
 	} else {
@@ -320,23 +368,31 @@ func (p *parser) parseSecondary() Node {
 		p.next()
 		switch token.Value {
 		case "true":
-			node := &BoolNode{Value: true}
-			node.SetLocation(token.Location)
+			node = p.createNode(&BoolNode{Value: true}, token.Location)
+			if node == nil {
+				return nil
+			}
 			return node
 		case "false":
-			node := &BoolNode{Value: false}
-			node.SetLocation(token.Location)
+			node = p.createNode(&BoolNode{Value: false}, token.Location)
+			if node == nil {
+				return nil
+			}
 			return node
 		case "nil":
-			node := &NilNode{}
-			node.SetLocation(token.Location)
+			node = p.createNode(&NilNode{}, token.Location)
+			if node == nil {
+				return nil
+			}
 			return node
 		default:
 			if p.current.Is(Bracket, "(") {
 				node = p.parseCall(token, []Node{}, true)
 			} else {
-				node = &IdentifierNode{Value: token.Value}
-				node.SetLocation(token.Location)
+				node = p.createNode(&IdentifierNode{Value: token.Value}, token.Location)
+				if node == nil {
+					return nil
+				}
 			}
 		}
 
@@ -383,8 +439,10 @@ func (p *parser) parseSecondary() Node {
 		return node
 	case String:
 		p.next()
-		node = &StringNode{Value: token.Value}
-		node.SetLocation(token.Location)
+		node = p.createNode(&StringNode{Value: token.Value}, token.Location)
+		if node == nil {
+			return nil
+		}
 
 	default:
 		if token.Is(Bracket, "[") {
@@ -404,7 +462,7 @@ func (p *parser) toIntegerNode(number int64) Node {
 		p.error("integer literal is too large")
 		return nil
 	}
-	return &IntegerNode{Value: int(number)}
+	return p.createNode(&IntegerNode{Value: int(number)}, p.current.Location)
 }
 
 func (p *parser) toFloatNode(number float64) Node {
@@ -412,7 +470,7 @@ func (p *parser) toFloatNode(number float64) Node {
 		p.error("float literal is too large")
 		return nil
 	}
-	return &FloatNode{Value: number}
+	return p.createNode(&FloatNode{Value: number}, p.current.Location)
 }
 
 func (p *parser) parseCall(token Token, arguments []Node, checkOverrides bool) Node {
@@ -454,25 +512,34 @@ func (p *parser) parseCall(token Token, arguments []Node, checkOverrides bool) N
 
 		p.expect(Bracket, ")")
 
-		node = &BuiltinNode{
+		node = p.createNode(&BuiltinNode{
 			Name:      token.Value,
 			Arguments: arguments,
+		}, token.Location)
+		if node == nil {
+			return nil
 		}
-		node.SetLocation(token.Location)
 	} else if _, ok := builtin.Index[token.Value]; ok && !p.config.Disabled[token.Value] && !isOverridden {
-		node = &BuiltinNode{
+		node = p.createNode(&BuiltinNode{
 			Name:      token.Value,
 			Arguments: p.parseArguments(arguments),
+		}, token.Location)
+		if node == nil {
+			return nil
 		}
-		node.SetLocation(token.Location)
+
 	} else {
-		callee := &IdentifierNode{Value: token.Value}
-		callee.SetLocation(token.Location)
-		node = &CallNode{
+		callee := p.createNode(&IdentifierNode{Value: token.Value}, token.Location)
+		if callee == nil {
+			return nil
+		}
+		node = p.createNode(&CallNode{
 			Callee:    callee,
 			Arguments: p.parseArguments(arguments),
+		}, token.Location)
+		if node == nil {
+			return nil
 		}
-		node.SetLocation(token.Location)
 	}
 	return node
 }
@@ -534,8 +601,10 @@ func (p *parser) parseArrayExpression(token Token) Node {
 end:
 	p.expect(Bracket, "]")
 
-	node := &ArrayNode{Nodes: nodes}
-	node.SetLocation(token.Location)
+	node := p.createNode(&ArrayNode{Nodes: nodes}, token.Location)
+	if node == nil {
+		return nil
+	}
 	return node
 }
 
@@ -561,8 +630,10 @@ func (p *parser) parseMapExpression(token Token) Node {
 		//  * identifier, which is equivalent to a string
 		//  * expression, which must be enclosed in parentheses -- (1 + 2)
 		if p.current.Is(Number) || p.current.Is(String) || p.current.Is(Identifier) {
-			key = &StringNode{Value: p.current.Value}
-			key.SetLocation(token.Location)
+			key = p.createNode(&StringNode{Value: p.current.Value}, p.current.Location)
+			if key == nil {
+				return nil
+			}
 			p.next()
 		} else if p.current.Is(Bracket, "(") {
 			key = p.parseExpression(0)
@@ -573,16 +644,20 @@ func (p *parser) parseMapExpression(token Token) Node {
 		p.expect(Operator, ":")
 
 		node := p.parseExpression(0)
-		pair := &PairNode{Key: key, Value: node}
-		pair.SetLocation(token.Location)
+		pair := p.createNode(&PairNode{Key: key, Value: node}, token.Location)
+		if pair == nil {
+			return nil
+		}
 		nodes = append(nodes, pair)
 	}
 
 end:
 	p.expect(Bracket, "}")
 
-	node := &MapNode{Pairs: nodes}
-	node.SetLocation(token.Location)
+	node := p.createNode(&MapNode{Pairs: nodes}, token.Location)
+	if node == nil {
+		return nil
+	}
 	return node
 }
 
@@ -607,8 +682,10 @@ func (p *parser) parsePostfixExpression(node Node) Node {
 				p.error("expected name")
 			}
 
-			property := &StringNode{Value: propertyToken.Value}
-			property.SetLocation(propertyToken.Location)
+			property := p.createNode(&StringNode{Value: propertyToken.Value}, propertyToken.Location)
+			if property == nil {
+				return nil
+			}
 
 			chainNode, isChain := node.(*ChainNode)
 			optional := postfixToken.Value == "?."
@@ -617,26 +694,33 @@ func (p *parser) parsePostfixExpression(node Node) Node {
 				node = chainNode.Node
 			}
 
-			memberNode := &MemberNode{
+			memberNode := p.createMemberNode(&MemberNode{
 				Node:     node,
 				Property: property,
 				Optional: optional,
+			}, propertyToken.Location)
+			if memberNode == nil {
+				return nil
 			}
-			memberNode.SetLocation(propertyToken.Location)
 
 			if p.current.Is(Bracket, "(") {
 				memberNode.Method = true
-				node = &CallNode{
+				node = p.createNode(&CallNode{
 					Callee:    memberNode,
 					Arguments: p.parseArguments([]Node{}),
+				}, propertyToken.Location)
+				if node == nil {
+					return nil
 				}
-				node.SetLocation(propertyToken.Location)
 			} else {
 				node = memberNode
 			}
 
 			if isChain || optional {
-				node = &ChainNode{Node: node}
+				node = p.createNode(&ChainNode{Node: node}, propertyToken.Location)
+				if node == nil {
+					return nil
+				}
 			}
 
 		} else if postfixToken.Value == "[" {
@@ -650,11 +734,13 @@ func (p *parser) parsePostfixExpression(node Node) Node {
 					to = p.parseExpression(0)
 				}
 
-				node = &SliceNode{
+				node = p.createNode(&SliceNode{
 					Node: node,
 					To:   to,
+				}, postfixToken.Location)
+				if node == nil {
+					return nil
 				}
-				node.SetLocation(postfixToken.Location)
 				p.expect(Bracket, "]")
 
 			} else {
@@ -668,25 +754,32 @@ func (p *parser) parsePostfixExpression(node Node) Node {
 						to = p.parseExpression(0)
 					}
 
-					node = &SliceNode{
+					node = p.createNode(&SliceNode{
 						Node: node,
 						From: from,
 						To:   to,
+					}, postfixToken.Location)
+					if node == nil {
+						return nil
 					}
-					node.SetLocation(postfixToken.Location)
 					p.expect(Bracket, "]")
 
 				} else {
 					// Slice operator [:] was not found,
 					// it should be just an index node.
-					node = &MemberNode{
+					node = p.createNode(&MemberNode{
 						Node:     node,
 						Property: from,
 						Optional: optional,
+					}, postfixToken.Location)
+					if node == nil {
+						return nil
 					}
-					node.SetLocation(postfixToken.Location)
 					if optional {
-						node = &ChainNode{Node: node}
+						node = p.createNode(&ChainNode{Node: node}, postfixToken.Location)
+						if node == nil {
+							return nil
+						}
 					}
 					p.expect(Bracket, "]")
 				}
@@ -698,26 +791,29 @@ func (p *parser) parsePostfixExpression(node Node) Node {
 	}
 	return node
 }
-
 func (p *parser) parseComparison(left Node, token Token, precedence int) Node {
 	var rootNode Node
 	for {
 		comparator := p.parseExpression(precedence + 1)
-		cmpNode := &BinaryNode{
+		cmpNode := p.createNode(&BinaryNode{
 			Operator: token.Value,
 			Left:     left,
 			Right:    comparator,
+		}, token.Location)
+		if cmpNode == nil {
+			return nil
 		}
-		cmpNode.SetLocation(token.Location)
 		if rootNode == nil {
 			rootNode = cmpNode
 		} else {
-			rootNode = &BinaryNode{
+			rootNode = p.createNode(&BinaryNode{
 				Operator: "&&",
 				Left:     rootNode,
 				Right:    cmpNode,
+			}, token.Location)
+			if rootNode == nil {
+				return nil
 			}
-			rootNode.SetLocation(token.Location)
 		}
 
 		left = comparator
diff --git a/vendor/github.com/expr-lang/expr/vm/utils.go b/vendor/github.com/expr-lang/expr/vm/utils.go
index fc2f5e7..1100513 100644
--- a/vendor/github.com/expr-lang/expr/vm/utils.go
+++ b/vendor/github.com/expr-lang/expr/vm/utils.go
@@ -11,9 +11,6 @@ type (
 )
 
 var (
-	// MemoryBudget represents an upper limit of memory usage.
-	MemoryBudget uint = 1e6
-
 	errorType = reflect.TypeOf((*error)(nil)).Elem()
 )
 
diff --git a/vendor/github.com/expr-lang/expr/vm/vm.go b/vendor/github.com/expr-lang/expr/vm/vm.go
index 7e933ce..b497990 100644
--- a/vendor/github.com/expr-lang/expr/vm/vm.go
+++ b/vendor/github.com/expr-lang/expr/vm/vm.go
@@ -11,6 +11,7 @@ import (
 	"time"
 
 	"github.com/expr-lang/expr/builtin"
+	"github.com/expr-lang/expr/conf"
 	"github.com/expr-lang/expr/file"
 	"github.com/expr-lang/expr/internal/deref"
 	"github.com/expr-lang/expr/vm/runtime"
@@ -20,11 +21,23 @@ func Run(program *Program, env any) (any, error) {
 	if program == nil {
 		return nil, fmt.Errorf("program is nil")
 	}
-
 	vm := VM{}
 	return vm.Run(program, env)
 }
 
+func RunWithConfig(program *Program, env any, config *conf.Config) (any, error) {
+	if program == nil {
+		return nil, fmt.Errorf("program is nil")
+	}
+	if config == nil {
+		return nil, fmt.Errorf("config is nil")
+	}
+	vm := VM{
+		MemoryBudget: config.MemoryBudget,
+	}
+	return vm.Run(program, env)
+}
+
 func Debug() *VM {
 	vm := &VM{
 		debug: true,
@@ -38,9 +51,9 @@ type VM struct {
 	Stack        []any
 	Scopes       []*Scope
 	Variables    []any
+	MemoryBudget uint
 	ip           int
 	memory       uint
-	memoryBudget uint
 	debug        bool
 	step         chan struct{}
 	curr         chan int
@@ -76,7 +89,9 @@ func (vm *VM) Run(program *Program, env any) (_ any, err error) {
 		vm.Variables = make([]any, program.variables)
 	}
 
-	vm.memoryBudget = MemoryBudget
+	if vm.MemoryBudget == 0 {
+		vm.MemoryBudget = conf.DefaultMemoryBudget
+	}
 	vm.memory = 0
 	vm.ip = 0
 
@@ -580,7 +595,7 @@ func (vm *VM) pop() any {
 
 func (vm *VM) memGrow(size uint) {
 	vm.memory += size
-	if vm.memory >= vm.memoryBudget {
+	if vm.memory >= vm.MemoryBudget {
 		panic("memory budget exceeded")
 	}
 }
-- 
2.48.1.431.g5a526e5e18

