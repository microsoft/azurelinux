From 992f7096f32ec5da1effcda2304f9ead7dc28956 Mon Sep 17 00:00:00 2001
From: AllSpark <allspark@microsoft.com>
Date: Fri, 21 Nov 2025 17:12:05 +0000
Subject: [PATCH] *: switch to safer securejoin.Reopen via internal/pathrs
 wrapper; adjust exec fifo reopen in standard_init_linux.go

Signed-off-by: Azure Linux Security Servicing Account <azurelinux-security@microsoft.com>
Upstream-reference: AI Backport of https://github.com/opencontainers/runc/commit/ff94f9991bd32076c871ef0ad8bc1b763458e480.patch
---
 .../runc/internal/pathrs/procfs_securejoin.go | 39 +++++++++++++++++++
 .../runc/libcontainer/standard_init_linux.go  | 11 +++---
 2 files changed, 45 insertions(+), 5 deletions(-)
 create mode 100644 vendor/github.com/opencontainers/runc/internal/pathrs/procfs_securejoin.go

diff --git a/vendor/github.com/opencontainers/runc/internal/pathrs/procfs_securejoin.go b/vendor/github.com/opencontainers/runc/internal/pathrs/procfs_securejoin.go
new file mode 100644
index 00000000..2702770e
--- /dev/null
+++ b/vendor/github.com/opencontainers/runc/internal/pathrs/procfs_securejoin.go
@@ -0,0 +1,39 @@
+// SPDX-License-Identifier: Apache-2.0
+/*
+ * Copyright (C) 2025 Aleksa Sarai <cyphar@cyphar.com>
+ * Copyright (C) 2025 SUSE LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package pathrs
+
+import (
+	"fmt"
+	"os"
+
+	"golang.org/x/sys/unix"
+)
+
+// Reopen is a wrapper intended to mirror securejoin.Reopen. Since our
+// vendored version of filepath-securejoin may not provide Reopen, implement
+// a minimal procfs-based reopen which re-opens the provided file descriptor
+// via /proc/self/fd with the requested flags.
+func Reopen(file *os.File, flags int) (*os.File, error) {
+	path := fmt.Sprintf("/proc/self/fd/%d", file.Fd())
+	fd, err := unix.Open(path, flags, 0)
+	if err != nil {
+		return nil, err
+	}
+	return os.NewFile(uintptr(fd), path), nil
+}
diff --git a/vendor/github.com/opencontainers/runc/libcontainer/standard_init_linux.go b/vendor/github.com/opencontainers/runc/libcontainer/standard_init_linux.go
index afd4f564..d619d3b2 100644
--- a/vendor/github.com/opencontainers/runc/libcontainer/standard_init_linux.go
+++ b/vendor/github.com/opencontainers/runc/libcontainer/standard_init_linux.go
@@ -13,6 +13,7 @@ import (
 	"golang.org/x/sys/unix"
 
 	"github.com/opencontainers/runc/libcontainer/apparmor"
+	"github.com/opencontainers/runc/internal/pathrs"
 	"github.com/opencontainers/runc/libcontainer/configs"
 	"github.com/opencontainers/runc/libcontainer/keys"
 	"github.com/opencontainers/runc/libcontainer/seccomp"
@@ -235,13 +236,13 @@ func (l *linuxStandardInit) Init() error {
 	// user process. We open it through /proc/self/fd/$fd, because the fd that
 	// was given to us was an O_PATH fd to the fifo itself. Linux allows us to
 	// re-open an O_PATH fd through /proc.
-	fifoPath := "/proc/self/fd/" + strconv.Itoa(l.fifoFd)
-	fd, err := unix.Open(fifoPath, unix.O_WRONLY|unix.O_CLOEXEC, 0)
+	fifoFile, err := pathrs.Reopen(os.NewFile(uintptr(l.fifoFd), "exec-fifo"), unix.O_WRONLY|unix.O_CLOEXEC)
 	if err != nil {
-		return &os.PathError{Op: "open exec fifo", Path: fifoPath, Err: err}
+		return &os.PathError{Op: "reopen exec fifo", Path: "fd "+strconv.Itoa(l.fifoFd), Err: err}
 	}
-	if _, err := unix.Write(fd, []byte("0")); err != nil {
-		return &os.PathError{Op: "write exec fifo", Path: fifoPath, Err: err}
+	defer fifoFile.Close()
+	if _, err := fifoFile.Write([]byte("0")); err != nil {
+		return &os.PathError{Op: "write exec fifo", Path: fifoFile.Name(), Err: err}
 	}
 
 	// Close the O_PATH fifofd fd before exec because the kernel resets
-- 
2.45.4

