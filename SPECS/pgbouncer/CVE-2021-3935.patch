From e4453c9151a2f5af0a9cb049b302a3f9f9654453 Mon Sep 17 00:00:00 2001
From: Peter Eisentraut <peter@eisentraut.org>
Date: Thu, 4 Nov 2021 07:55:57 +0100
Subject: [PATCH] Reject extraneous data after SSL or GSS encryption handshakes

PgBouncer, talking to a client (so PgBouncer is the server), collects
up to a bufferload of data whenever it reads data from the client
socket.  When SSL or GSS encryption is requested during startup, any
additional data received with the initial request message remained in
the buffer, and would be treated as already-decrypted data once the
encryption handshake completed.  Thus, a man-in-the-middle with the
ability to inject data into the TCP connection could stuff some
cleartext data into the start of a supposedly encryption-protected
database session.

This could be abused to send faked SQL commands to PgBouncer, although
it would only work if PgBouncer did not demand any authentication
data.  (However, an instance relying on SSL certificate authentication
might well not do so.)

To fix, throw a protocol-violation error if the internal buffer is not
empty after the encryption handshake.

(PgBouncer does not support GSS encryption, but we put the check in
place anyway for completeness.)

The analogous issue with PgBouncer talking to a server (so PgBouncer
is the client) did not exist, since there was already a check whether
the buffer was empty after reading an SSL response.  But just for
clarity, split out that check and give it its own error message.

Based on security report for PostgreSQL, reported by Jacob Champion,
code by Tom Lane; PgBouncer code by Peter Eisentraut, reviewed by
Andrew Dunstan
---
 src/client.c | 18 ++++++++++++++++++
 src/server.c | 12 +++++++++++-
 2 files changed, 29 insertions(+), 1 deletion(-)

diff --git a/src/client.c b/src/client.c
index 50ab0cfc..7d8c406b 100644
--- a/src/client.c
+++ b/src/client.c
@@ -1015,6 +1015,24 @@ bool client_proto(SBuf *sbuf, SBufEvent evtype, struct MBuf *data)
 		}
 		slog_noise(client, "read pkt='%c' len=%d", pkt_desc(&pkt), pkt.len);
 
+		/*
+		 * If we are reading an SSL request or GSSAPI
+		 * encryption request, we should have no data already
+		 * buffered at this point.  If we do, it was received
+		 * before we performed the SSL or GSSAPI handshake, so
+		 * it wasn't encrypted and indeed may have been
+		 * injected by a man-in-the-middle.  We report this
+		 * case to the client.
+		 */
+		if (pkt.type == PKT_SSLREQ && mbuf_avail_for_read(data) > 0) {
+			disconnect_client(client, true, "received unencrypted data after SSL request");
+			return false;
+		}
+		if (pkt.type == PKT_GSSENCREQ && mbuf_avail_for_read(data) > 0) {
+			disconnect_client(client, true, "received unencrypted data after GSSAPI encryption request");
+			return false;
+		}
+
 		client->request_time = get_cached_time();
 		switch (client->state) {
 		case CL_LOGIN:
diff --git a/src/server.c b/src/server.c
index d03714d2..caf2625b 100644
--- a/src/server.c
+++ b/src/server.c
@@ -480,10 +480,20 @@ static bool handle_sslchar(PgSocket *server, struct MBuf *data)
 	server->wait_sslchar = false;
 
 	ok = mbuf_get_byte(data, &schar);
-	if (!ok || (schar != 'S' && schar != 'N') || mbuf_avail_for_read(data) != 0) {
+	if (!ok || (schar != 'S' && schar != 'N')) {
 		disconnect_server(server, false, "bad sslreq answer");
 		return false;
 	}
+	/*
+	 * At this point we should have no data already buffered.  If
+	 * we do, it was received before we performed the SSL
+	 * handshake, so it wasn't encrypted and indeed may have been
+	 * injected by a man-in-the-middle.
+	 */
+	if (mbuf_avail_for_read(data) != 0) {
+		disconnect_server(server, false, "received unencrypted data after SSL response");
+		return false;
+	}
 
 	if (schar == 'S') {
 		slog_noise(server, "launching tls");
