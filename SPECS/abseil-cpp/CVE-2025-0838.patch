From 527ce2ccd0bbe40603c3efa150e08ec1554a6653 Mon Sep 17 00:00:00 2001
From: AllSpark <allspark@microsoft.com>
Date: Tue, 10 Feb 2026 09:40:55 +0000
Subject: [PATCH] Fix potential integer overflow in hash container
 create/resize: add overflow checks, adjust max_size, enforce limits in
 constructors, reserve, rehash; add fatal overflow handler and tests

Signed-off-by: Azure Linux Security Servicing Account <azurelinux-security@microsoft.com>
Upstream-reference: AI Backport of https://github.com/abseil/abseil-cpp/commit/5a0e2cb5e3958dd90bb8569a2766622cb74d90c1.patch
---
 absl/container/internal/raw_hash_set.cc      |  6 ++++
 absl/container/internal/raw_hash_set.h       | 32 ++++++++++++++++++--
 absl/container/internal/raw_hash_set_test.cc |  9 ++++++
 3 files changed, 45 insertions(+), 2 deletions(-)

diff --git a/absl/container/internal/raw_hash_set.cc b/absl/container/internal/raw_hash_set.cc
index c63a2e0..11359ec 100644
--- a/absl/container/internal/raw_hash_set.cc
+++ b/absl/container/internal/raw_hash_set.cc
@@ -18,6 +18,7 @@
 #include <cstddef>
 
 #include "absl/base/config.h"
+#include "absl/base/internal/raw_logging.h"
 
 namespace absl {
 ABSL_NAMESPACE_BEGIN
@@ -63,6 +64,11 @@ void ConvertDeletedToEmptyAndFullToDeleted(ctrl_t* ctrl, size_t capacity) {
   std::memcpy(ctrl + capacity + 1, ctrl, NumClonedBytes());
   ctrl[capacity] = ctrl_t::kSentinel;
 }
+
+void HashTableSizeOverflow() {
+  ABSL_RAW_LOG(FATAL, "Hash table size overflow");
+}
+
 // Extern template instantiotion for inline function.
 template FindInfo find_first_non_full(const ctrl_t*, size_t, size_t);
 
diff --git a/absl/container/internal/raw_hash_set.h b/absl/container/internal/raw_hash_set.h
index ea912f8..6b5707f 100644
--- a/absl/container/internal/raw_hash_set.h
+++ b/absl/container/internal/raw_hash_set.h
@@ -745,6 +745,16 @@ inline size_t NormalizeCapacity(size_t n) {
   return n ? ~size_t{} >> countl_zero(n) : 1;
 }
 
+// Maximum valid capacity for a given slot size, preventing overflow in backing store size computation.
+template <size_t kSlotSize>
+inline size_t MaxValidCapacity() {
+  return NormalizeCapacity((std::numeric_limits<size_t>::max)() / 4 / kSlotSize);
+}
+
+// Use a non-inlined function to avoid code bloat.
+[[noreturn]] void HashTableSizeOverflow();
+
+
 // General notes on capacity/growth methods below:
 // - We use 7/8th as maximum load factor. For 16-wide groups, that gives an
 //   average of two empty slots per group.
@@ -913,7 +923,13 @@ inline size_t SlotOffset(size_t capacity, size_t slot_align) {
 // Given the capacity of a table, computes the total size of the backing
 // array.
 inline size_t AllocSize(size_t capacity, size_t slot_size, size_t slot_align) {
-  return SlotOffset(capacity, slot_align) + capacity * slot_size;
+  size_t slot_offset = SlotOffset(capacity, slot_align);
+  if (capacity != 0) {
+    ABSL_HARDENING_ASSERT(
+        slot_size <= ((std::numeric_limits<size_t>::max)() - slot_offset) /
+                          capacity);
+  }
+  return slot_offset + capacity * slot_size;
 }
 
 // A SwissTable.
@@ -1148,6 +1164,9 @@ class raw_hash_set {
       : ctrl_(EmptyGroup()),
         settings_(0, HashtablezInfoHandle(), hash, eq, alloc) {
     if (bucket_count) {
+      if (ABSL_PREDICT_FALSE(bucket_count > MaxValidCapacity<sizeof(slot_type)>())) {
+        HashTableSizeOverflow();
+      }
       capacity_ = NormalizeCapacity(bucket_count);
       initialize_slots();
     }
@@ -1338,10 +1357,13 @@ class raw_hash_set {
   const_iterator cbegin() const { return begin(); }
   const_iterator cend() const { return end(); }
 
+  size_t max_size() const {
+    return CapacityToGrowth(MaxValidCapacity<sizeof(slot_type)>());
+  }
+
   bool empty() const { return !size(); }
   size_t size() const { return size_; }
   size_t capacity() const { return capacity_; }
-  size_t max_size() const { return (std::numeric_limits<size_t>::max)(); }
 
   ABSL_ATTRIBUTE_REINITIALIZES void clear() {
     // Iterating over this container is O(bucket_count()). When bucket_count()
@@ -1678,6 +1700,9 @@ class raw_hash_set {
     auto m = NormalizeCapacity(n | GrowthToLowerboundCapacity(size()));
     // n == 0 unconditionally rehashes as per the standard.
     if (n == 0 || m > capacity_) {
+      if (ABSL_PREDICT_FALSE(m > MaxValidCapacity<sizeof(slot_type)>())) {
+        HashTableSizeOverflow();
+      }
       resize(m);
 
       // This is after resize, to ensure that we have completed the allocation
@@ -1689,6 +1714,9 @@ class raw_hash_set {
   void reserve(size_t n) {
     if (n > size() + growth_left()) {
       size_t m = GrowthToLowerboundCapacity(n);
+      if (ABSL_PREDICT_FALSE(n > max_size())) {
+        HashTableSizeOverflow();
+      }
       resize(NormalizeCapacity(m));
 
       // This is after resize, to ensure that we have completed the allocation
diff --git a/absl/container/internal/raw_hash_set_test.cc b/absl/container/internal/raw_hash_set_test.cc
index f77ffbc..edf06a9 100644
--- a/absl/container/internal/raw_hash_set_test.cc
+++ b/absl/container/internal/raw_hash_set_test.cc
@@ -35,6 +35,15 @@
 #include "absl/base/internal/raw_logging.h"
 #include "absl/container/internal/container_memory.h"
 #include "absl/container/internal/hash_function_defaults.h"
+
+TEST(Table, MaxSizeOverflow) {
+  size_t overflow = (std::numeric_limits<size_t>::max)();
+  EXPECT_DEATH_IF_SUPPORTED(IntTable t(overflow), "Hash table size overflow");
+  IntTable t;
+  EXPECT_DEATH_IF_SUPPORTED(t.reserve(overflow), "Hash table size overflow");
+  EXPECT_DEATH_IF_SUPPORTED(t.rehash(overflow), "Hash table size overflow");
+}
+
 #include "absl/container/internal/hash_policy_testing.h"
 #include "absl/container/internal/hashtable_debug.h"
 #include "absl/strings/string_view.h"
-- 
2.45.4

