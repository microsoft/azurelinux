From c60dfd478d798d3b164ef23911ee0ef5ffdbc6f3 Mon Sep 17 00:00:00 2001
From: Luboslav Pivarc <lpivarc@redhat.com>
Date: Fri, 1 Aug 2025 21:52:31 +0200
Subject: [PATCH] Host-disk & PVC: Contain disk inside volume

As we are dealing with un-trusted launchers we need to
use safe path in order to contain the disks.

Signed-off-by: Luboslav Pivarc <lpivarc@redhat.com>
Signed-off-by: Azure Linux Security Servicing Account <azurelinux-security@microsoft.com>
Upstream-reference: https://github.com/kubevirt/kubevirt/commit/09eafa068ec01eca0e96ebafeeb9522a878dbf64.patch
---
 pkg/host-disk/BUILD.bazel       |  1 +
 pkg/host-disk/host-disk.go      | 65 +++++++++++++++++++++++----------
 pkg/host-disk/host-disk_test.go | 12 ++++--
 3 files changed, 55 insertions(+), 23 deletions(-)

diff --git a/pkg/host-disk/BUILD.bazel b/pkg/host-disk/BUILD.bazel
index 85e0e79..c776c5e 100644
--- a/pkg/host-disk/BUILD.bazel
+++ b/pkg/host-disk/BUILD.bazel
@@ -13,6 +13,7 @@ go_library(
         "//pkg/util:go_default_library",
         "//staging/src/kubevirt.io/api/core/v1:go_default_library",
         "//staging/src/kubevirt.io/client-go/log:go_default_library",
+        "//vendor/golang.org/x/sys/unix:go_default_library",
         "//vendor/k8s.io/api/core/v1:go_default_library",
         "//vendor/k8s.io/client-go/tools/record:go_default_library",
     ],
diff --git a/pkg/host-disk/host-disk.go b/pkg/host-disk/host-disk.go
index 895006f..bfe95ee 100644
--- a/pkg/host-disk/host-disk.go
+++ b/pkg/host-disk/host-disk.go
@@ -20,12 +20,14 @@
 package hostdisk
 
 import (
+	"errors"
 	"fmt"
 	"os"
 	"path"
 	"path/filepath"
 	"syscall"
 
+	"golang.org/x/sys/unix"
 	"kubevirt.io/client-go/log"
 
 	ephemeraldiskutils "kubevirt.io/kubevirt/pkg/ephemeral-disk-utils"
@@ -157,13 +159,34 @@ func dirBytesAvailable(path string, reserve uint64) (uint64, error) {
 	return stat.Bavail*uint64(stat.Bsize) - reserve, nil
 }
 
-func createSparseRaw(fullPath string, size int64) (err error) {
+func createSparseRaw(diskdir *safepath.Path, diskName string, size int64) (err error) {
 	offset := size - 1
-	f, err := os.Create(fullPath)
+	if filepath.Base(diskName) != diskName {
+		return fmt.Errorf("Disk name needs to be base")
+	}
+
+	err = safepath.TouchAtNoFollow(diskdir, filepath.Base(diskName), 0666)
+	if err != nil {
+		return err
+	}
+
+	diskPath, err := safepath.JoinNoFollow(diskdir, diskName)
+	if err != nil {
+		return err
+	}
+
+	sFile, err := safepath.OpenAtNoFollow(diskPath)
+	if err != nil {
+		return err
+	}
+	defer util.CloseIOAndCheckErr(sFile, &err)
+
+	f, err := os.OpenFile(sFile.SafePath(), os.O_WRONLY, 0666)
 	if err != nil {
 		return err
 	}
 	defer util.CloseIOAndCheckErr(f, &err)
+
 	_, err = f.WriteAt([]byte{0}, offset)
 	if err != nil {
 		return err
@@ -175,14 +198,6 @@ func getPVCDiskImgPath(volumeName string, diskName string) string {
 	return path.Join(pvcBaseDir, volumeName, diskName)
 }
 
-func GetMountedHostDiskPathFromHandler(mountRoot, volumeName, path string) string {
-	return filepath.Join(mountRoot, getPVCDiskImgPath(volumeName, filepath.Base(path)))
-}
-
-func GetMountedHostDiskDirFromHandler(mountRoot, volumeName string) string {
-	return filepath.Join(mountRoot, getPVCDiskImgPath(volumeName, ""))
-}
-
 func GetMountedHostDiskPath(volumeName string, path string) string {
 	return getPVCDiskImgPath(volumeName, filepath.Base(path))
 }
@@ -229,18 +244,27 @@ func shouldMountHostDisk(hostDisk *v1.HostDisk) bool {
 }
 
 func (hdc *DiskImgCreator) mountHostDiskAndSetOwnership(vmi *v1.VirtualMachineInstance, volumeName string, hostDisk *v1.HostDisk) error {
-	diskPath := GetMountedHostDiskPathFromHandler(unsafepath.UnsafeAbsolute(hdc.mountRoot.Raw()), volumeName, hostDisk.Path)
-	diskDir := GetMountedHostDiskDirFromHandler(unsafepath.UnsafeAbsolute(hdc.mountRoot.Raw()), volumeName)
-	fileExists, err := ephemeraldiskutils.FileExists(diskPath)
+	diskDir, err := hdc.mountRoot.AppendAndResolveWithRelativeRoot(GetMountedHostDiskDir(volumeName))
 	if err != nil {
 		return err
 	}
-	if !fileExists {
-		if err = hdc.handleRequestedSizeAndCreateSparseRaw(vmi, diskDir, diskPath, hostDisk); err != nil {
+	diskPath, err := safepath.JoinNoFollow(diskDir, filepath.Base(hostDisk.Path))
+	fileNotExists := errors.Is(err, unix.ENOENT)
+	if err != nil && !fileNotExists {
+		return err
+	}
+
+	if fileNotExists {
+		if err := hdc.handleRequestedSizeAndCreateSparseRaw(vmi, diskDir, filepath.Base(hostDisk.Path), hostDisk); err != nil {
+			return err
+		}
+
+		diskPath, err = safepath.JoinNoFollow(diskDir, filepath.Base(hostDisk.Path))
+		if err != nil {
 			return err
 		}
 		// Change file ownership to the qemu user.
-                if err = ephemeraldiskutils.DefaultOwnershipManager.UnsafeSetFileOwnership(diskPath); err != nil {
+                if err = ephemeraldiskutils.DefaultOwnershipManager.SetFileOwnership(diskPath); err != nil {
                        log.Log.Reason(err).Errorf("Couldn't set Ownership on %s: %v", diskPath, err)
                        return err
                 }
@@ -248,8 +272,8 @@ func (hdc *DiskImgCreator) mountHostDiskAndSetOwnership(vmi *v1.VirtualMachineIn
 	return nil
 }
 
-func (hdc *DiskImgCreator) handleRequestedSizeAndCreateSparseRaw(vmi *v1.VirtualMachineInstance, diskDir string, diskPath string, hostDisk *v1.HostDisk) error {
-	size, err := hdc.dirBytesAvailableFunc(diskDir, hdc.minimumPVCReserveBytes)
+func (hdc *DiskImgCreator) handleRequestedSizeAndCreateSparseRaw(vmi *v1.VirtualMachineInstance, diskDir *safepath.Path, diskName string, hostDisk *v1.HostDisk) error {
+	size, err := hdc.dirBytesAvailableFunc(unsafepath.UnsafeAbsolute(diskDir.Raw()), hdc.minimumPVCReserveBytes)
 	availableSize := int64(size)
 	if err != nil {
 		return err
@@ -261,9 +285,10 @@ func (hdc *DiskImgCreator) handleRequestedSizeAndCreateSparseRaw(vmi *v1.Virtual
 			return err
 		}
 	}
-	err = createSparseRaw(diskPath, requestedSize)
+	err = createSparseRaw(diskDir, diskName, requestedSize)
 	if err != nil {
-		log.Log.Reason(err).Errorf("Couldn't create a sparse raw file for disk path: %s, error: %v", diskPath, err)
+		fullPath := filepath.Join(unsafepath.UnsafeAbsolute(diskDir.Raw()), diskName)
+		log.Log.Reason(err).Errorf("Couldn't create a sparse raw file for disk path: %s, error: %v", fullPath, err)
 		return err
 	}
 	return nil
diff --git a/pkg/host-disk/host-disk_test.go b/pkg/host-disk/host-disk_test.go
index 57f3a26..60dba99 100644
--- a/pkg/host-disk/host-disk_test.go
+++ b/pkg/host-disk/host-disk_test.go
@@ -24,6 +24,7 @@ import (
 	"fmt"
 	"os"
 	"path"
+	"path/filepath"
 	"strings"
 
 	"github.com/golang/mock/gomock"
@@ -80,11 +81,16 @@ var _ = Describe("HostDisk", func() {
 	createTempDiskImg := func(volumeName string) os.FileInfo {
 		imgPath := path.Join(tempDir, volumeName, "disk.img")
 
-		err := os.Mkdir(path.Join(tempDir, volumeName), 0755)
+		// 67108864 = 64Mi
+		dir := filepath.Dir(imgPath)
+
+		err := os.Mkdir(dir, 0755)
 		Expect(err).NotTo(HaveOccurred())
 
-		// 67108864 = 64Mi
-		err = createSparseRaw(imgPath, 67108864)
+		sDir, err := safepath.NewPathNoFollow(dir)
+		Expect(err).To(Not(HaveOccurred()))
+
+		err = createSparseRaw(sDir, filepath.Base(imgPath), 67108864)
 		Expect(err).NotTo(HaveOccurred())
 
 		file, err := os.Stat(imgPath)
-- 
2.45.4

