From b8de4b25d47e006b49bc64c175cf02ce0d7f7635 Mon Sep 17 00:00:00 2001
From: AllSpark <allspark@microsoft.com>
Date: Thu, 20 Nov 2025 09:55:43 +0000
Subject: [PATCH] host-path: only chown files we created; tests: adjust
 host-path test according to previous fix

- Only chown host-disk image when it is created, not on every run
- Add MockDefaultOwnershipManagerWithFailure to catch unexpected chown calls
- Update DiskImgCreator.Create receiver to pointer to allow stateful ops
- Update host-disk test to ensure no chown occurs for existing disk
- Adjust storage test to handle images not owned by qemu by expecting scheduling failure event instead of successful launch

Signed-off-by: AllSpark <allspark@microsoft.com>
Signed-off-by: Azure Linux Security Servicing Account <azurelinux-security@microsoft.com>
Upstream-reference: AI Backport of https://github.com/kubevirt/kubevirt/pull/15037.patch
---
 pkg/ephemeral-disk-utils/utils.go | 19 +++++++++++++++++--
 pkg/host-disk/host-disk.go        | 14 +++++++-------
 pkg/host-disk/host-disk_test.go   | 10 +++++++++-
 tests/storage/storage.go          | 23 +++++++++++++++++------
 4 files changed, 50 insertions(+), 16 deletions(-)

diff --git a/pkg/ephemeral-disk-utils/utils.go b/pkg/ephemeral-disk-utils/utils.go
index fc1a07b..869ddf6 100644
--- a/pkg/ephemeral-disk-utils/utils.go
+++ b/pkg/ephemeral-disk-utils/utils.go
@@ -41,17 +41,32 @@ func MockDefaultOwnershipManager() {
 	DefaultOwnershipManager = &nonOpManager{}
 }
 
+func MockDefaultOwnershipManagerWithFailure() {
+	DefaultOwnershipManager = &failureManager{}
+}
+
 type nonOpManager struct {
 }
 
-func (no *nonOpManager) UnsafeSetFileOwnership(file string) error {
+type failureManager struct {
+}
+
+func (no *nonOpManager) UnsafeSetFileOwnership(_ string) error {
 	return nil
 }
 
-func (no *nonOpManager) SetFileOwnership(file *safepath.Path) error {
+func (no *nonOpManager) SetFileOwnership(_ *safepath.Path) error {
 	return nil
 }
 
+func (no *failureManager) UnsafeSetFileOwnership(_ string) error {
+	panic("unexpected call to UnsafeSetFileOwnership")
+}
+
+func (no *failureManager) SetFileOwnership(_ *safepath.Path) error {
+	panic("unexpected call to SetFileOwnership")
+}
+
 type OwnershipManager struct {
 	user string
 }
diff --git a/pkg/host-disk/host-disk.go b/pkg/host-disk/host-disk.go
index ca6893a..414b2be 100644
--- a/pkg/host-disk/host-disk.go
+++ b/pkg/host-disk/host-disk.go
@@ -213,7 +213,7 @@ func (hdc *DiskImgCreator) setlessPVCSpaceToleration(toleration int) {
 	hdc.lessPVCSpaceToleration = toleration
 }
 
-func (hdc DiskImgCreator) Create(vmi *v1.VirtualMachineInstance) error {
+func (hdc *DiskImgCreator) Create(vmi *v1.VirtualMachineInstance) error {
 	for _, volume := range vmi.Spec.Volumes {
 		if hostDisk := volume.VolumeSource.HostDisk; shouldMountHostDisk(hostDisk) {
 			if err := hdc.mountHostDiskAndSetOwnership(vmi, volume.Name, hostDisk); err != nil {
@@ -236,14 +236,14 @@ func (hdc *DiskImgCreator) mountHostDiskAndSetOwnership(vmi *v1.VirtualMachineIn
 		return err
 	}
 	if !fileExists {
-		if err := hdc.handleRequestedSizeAndCreateSparseRaw(vmi, diskDir, diskPath, hostDisk); err != nil {
+		if err = hdc.handleRequestedSizeAndCreateSparseRaw(vmi, diskDir, diskPath, hostDisk); err != nil {
+			return err
+		}
+		// Change file ownership to the qemu user.
+		if err = ephemeraldiskutils.DefaultOwnershipManager.UnsafeSetFileOwnership(diskPath); err != nil {
+			log.Log.Reason(err).Errorf("Couldn't set Ownership on %s: %v", diskPath, err)
 			return err
 		}
-	}
-	// Change file ownership to the qemu user.
-	if err := ephemeraldiskutils.DefaultOwnershipManager.UnsafeSetFileOwnership(diskPath); err != nil {
-		log.Log.Reason(err).Errorf("Couldn't set Ownership on %s: %v", diskPath, err)
-		return err
 	}
 	return nil
 }
diff --git a/pkg/host-disk/host-disk_test.go b/pkg/host-disk/host-disk_test.go
index 184c0d8..ab43765 100644
--- a/pkg/host-disk/host-disk_test.go
+++ b/pkg/host-disk/host-disk_test.go
@@ -35,6 +35,7 @@ import (
 	"k8s.io/client-go/kubernetes/fake"
 	"k8s.io/client-go/tools/record"
 
+	ephemeraldiskutils "kubevirt.io/kubevirt/pkg/ephemeral-disk-utils"
 	"kubevirt.io/kubevirt/pkg/safepath"
 
 	"kubevirt.io/client-go/api"
@@ -321,7 +322,14 @@ var _ = Describe("HostDisk", func() {
 			})
 		})
 		Context("With existing disk.img", func() {
-			It("Should not re-create disk.img", func() {
+			AfterEach(func() {
+				By("Switching back to the regular mock ownership manager")
+				ephemeraldiskutils.MockDefaultOwnershipManager()
+			})
+
+			It("Should not re-create or chown disk.img", func() {
+				By("Switching to an ownership manager that panics when called")
+				ephemeraldiskutils.MockDefaultOwnershipManagerWithFailure()
 				By("Creating a disk.img before adding a HostDisk volume")
 				tmpDiskImg := createTempDiskImg("volume1")
 
diff --git a/tests/storage/storage.go b/tests/storage/storage.go
index 1ed1d86..381cabb 100644
--- a/tests/storage/storage.go
+++ b/tests/storage/storage.go
@@ -283,14 +283,25 @@ var _ = SIGDescribe("Storage", func() {
 					}
 					vmi = newVMI(pvName)
 
-					if storageEngine == "nfs" {
-						vmi = tests.RunVMIAndExpectLaunchIgnoreWarnings(vmi, 180)
+					if imageOwnedByQEMU {
+						if storageEngine == "nfs" {
+							vmi = tests.RunVMIAndExpectLaunchIgnoreWarnings(vmi, 180)
+						} else {
+							vmi = tests.RunVMIAndExpectLaunch(vmi, 180)
+						}
+
+						By(checkingVMInstanceConsoleOut)
+						Expect(console.LoginToAlpine(vmi)).To(Succeed())
 					} else {
-						vmi = tests.RunVMIAndExpectLaunch(vmi, 180)
+						By("Starting a VirtualMachineInstance")
+						createdVMI := tests.RunVMIAndExpectScheduling(vmi, 60)
+
+						By(fmt.Sprintf("Checking that VirtualMachineInstance start failed: starting at %v", time.Now()))
+						ctx, cancel := context.WithCancel(context.Background())
+						defer cancel()
+						event := watcher.New(createdVMI).Timeout(60*time.Second).SinceWatchedObjectResourceVersion().WaitFor(ctx, watcher.WarningEvent, "SyncFailed")
+						Expect(event.Message).To(ContainSubstring("Could not open '/var/run/kubevirt-private/vmi-disks/disk0/disk.img': Permission denied"), "VMI should not be started")
 					}
-
-					By(checkingVMInstanceConsoleOut)
-					Expect(console.LoginToAlpine(vmi)).To(Succeed())
 				},
 					Entry("[test_id:3130]with Disk PVC", newRandomVMIWithPVC, "", nil, true),
 					Entry("[test_id:3131]with CDRom PVC", newRandomVMIWithCDRom, "", nil, true),
-- 
2.45.4

