From 5fc09595bb88f4e0ae2998dcc1a271cf810d77fc Mon Sep 17 00:00:00 2001
From: Luboslav Pivarc <lpivarc@redhat.com>
Date: Thu, 30 May 2024 10:37:24 +0200
Subject: [PATCH 1/3] Node restiction

Introduce NodeRestriction feature gate. This enables
us to check if a virt-handler request is authorized to
modify VMI.

This feature requires following Kubernetes feature gate
ServiceAccountTokenPodNodeInfo. The feature gate is available
in 1.30 as Beta.

Signed-off-by: Luboslav Pivarc <lpivarc@redhat.com>
---
 pkg/virt-api/webhooks/utils.go                |  18 +-
 .../validating-webhook/admitters/BUILD.bazel  |   2 +
 .../admitters/vmi-update-admitter.go          |  43 ++++-
 .../admitters/vmi-update-admitter_test.go     | 156 ++++++++++++++++++
 pkg/virt-config/feature-gates.go              |  11 ++
 tests/decorators/decorators.go                |   3 +
 8 files changed, 336 insertions(+), 6 deletions(-)
 create mode 100644 tests/infrastructure/security.go

diff --git a/pkg/virt-api/webhooks/utils.go b/pkg/virt-api/webhooks/utils.go
index 1307cb366fdb..e6ee54431f91 100644
--- a/pkg/virt-api/webhooks/utils.go
+++ b/pkg/virt-api/webhooks/utils.go
@@ -79,7 +79,11 @@ type Informers struct {
 	DataSourceInformer cache.SharedIndexInformer
 }
 
-func IsKubeVirtServiceAccount(serviceAccount string) bool {
+func IsComponentServiceAccount(serviceAccount, namespace, component string) bool {
+	return serviceAccount == fmt.Sprintf("system:serviceaccount:%s:%s", namespace, component)
+}
+
+func GetNamespace() string {
 	ns, err := clientutil.GetNamespace()
 	logger := log.DefaultLogger()
 
@@ -87,11 +91,14 @@ func IsKubeVirtServiceAccount(serviceAccount string) bool {
 		logger.Info("Failed to get namespace. Fallback to default: 'kubevirt'")
 		ns = "kubevirt"
 	}
+	return ns
+}
 
-	prefix := fmt.Sprintf("system:serviceaccount:%s", ns)
-	return serviceAccount == fmt.Sprintf("%s:%s", prefix, rbac.ApiServiceAccountName) ||
-		serviceAccount == fmt.Sprintf("%s:%s", prefix, rbac.HandlerServiceAccountName) ||
-		serviceAccount == fmt.Sprintf("%s:%s", prefix, rbac.ControllerServiceAccountName)
+func IsKubeVirtServiceAccount(serviceAccount string) bool {
+	ns := GetNamespace()
+	return IsComponentServiceAccount(serviceAccount, ns, rbac.ApiServiceAccountName) ||
+		IsComponentServiceAccount(serviceAccount, ns, rbac.HandlerServiceAccountName) ||
+		IsComponentServiceAccount(serviceAccount, ns, rbac.ControllerServiceAccountName)
 }
 
 func IsARM64() bool {
diff --git a/pkg/virt-api/webhooks/validating-webhook/admitters/BUILD.bazel b/pkg/virt-api/webhooks/validating-webhook/admitters/BUILD.bazel
index 1a71fdf6eab2..8c507b7d9bc2 100644
--- a/pkg/virt-api/webhooks/validating-webhook/admitters/BUILD.bazel
+++ b/pkg/virt-api/webhooks/validating-webhook/admitters/BUILD.bazel
@@ -43,6 +43,7 @@ go_library(
         "//pkg/virt-config:go_default_library",
         "//pkg/virt-handler/node-labeller/util:go_default_library",
         "//pkg/virt-operator/resource/generate/rbac:go_default_library",
+        "//pkg/virt-operator/resource/generate/components:go_default_library",
         "//staging/src/kubevirt.io/api/clone:go_default_library",
         "//staging/src/kubevirt.io/api/clone/v1alpha1:go_default_library",
         "//staging/src/kubevirt.io/api/core:go_default_library",
@@ -135,6 +136,7 @@ go_test(
         "//vendor/github.com/golang/mock/gomock:go_default_library",
         "//vendor/github.com/onsi/ginkgo/v2:go_default_library",
         "//vendor/github.com/onsi/gomega:go_default_library",
+        "//vendor/github.com/onsi/gomega/gstruct:go_default_library",
         "//vendor/github.com/onsi/gomega/types:go_default_library",
         "//vendor/k8s.io/api/admission/v1:go_default_library",
         "//vendor/k8s.io/api/authentication/v1:go_default_library",
diff --git a/pkg/virt-api/webhooks/validating-webhook/admitters/vmi-update-admitter.go b/pkg/virt-api/webhooks/validating-webhook/admitters/vmi-update-admitter.go
index b33f167eb37b..2c56c4be80dd 100644
--- a/pkg/virt-api/webhooks/validating-webhook/admitters/vmi-update-admitter.go
+++ b/pkg/virt-api/webhooks/validating-webhook/admitters/vmi-update-admitter.go
@@ -29,18 +29,20 @@ import (
 
 	"kubevirt.io/kubevirt/pkg/virt-api/webhooks"
 	virtconfig "kubevirt.io/kubevirt/pkg/virt-config"
+	"kubevirt.io/kubevirt/pkg/virt-operator/resource/generate/components"
 
 	v1 "kubevirt.io/api/core/v1"
 
 	webhookutils "kubevirt.io/kubevirt/pkg/util/webhooks"
 )
 
+const nodeNameExtraInfo = "authentication.kubernetes.io/node-name"
+
 type VMIUpdateAdmitter struct {
 	ClusterConfig *virtconfig.ClusterConfig
 }
 
 func (admitter *VMIUpdateAdmitter) Admit(ar *admissionv1.AdmissionReview) *admissionv1.AdmissionResponse {
-
 	if resp := webhookutils.ValidateSchema(v1.VirtualMachineInstanceGroupVersionKind, ar.Request.Object.Raw); resp != nil {
 		return resp
 	}
@@ -50,6 +52,45 @@ func (admitter *VMIUpdateAdmitter) Admit(ar *admissionv1.AdmissionReview) *admis
 		return webhookutils.ToAdmissionResponseError(err)
 	}
 
+	if admitter.ClusterConfig.NodeRestrictionEnabled() && webhooks.IsComponentServiceAccount(ar.Request.UserInfo.Username, webhooks.GetNamespace(), rbac.HandlerServiceAccountName) {
+		values, exist := ar.Request.UserInfo.Extra[nodeNameExtraInfo]
+		if exist && len(values) > 0 {
+			nodeName := values[0]
+			sourceNode := oldVMI.Status.NodeName
+			targetNode := ""
+			if oldVMI.Status.MigrationState != nil {
+				targetNode = oldVMI.Status.MigrationState.TargetNode
+			}
+
+			// Check that source or target is making this request
+			if nodeName != sourceNode && (targetNode == "" || nodeName != targetNode) {
+				return webhookutils.ToAdmissionResponse([]metav1.StatusCause{
+					{
+						Type:    metav1.CauseTypeFieldValueInvalid,
+						Message: "Node restriction, virt-handler is only allowed to modify VMIs it owns",
+					},
+				})
+			}
+
+			// Check that handler is not setting target
+			if targetNode == "" && newVMI.Status.MigrationState != nil && newVMI.Status.MigrationState.TargetNode != targetNode {
+				return webhookutils.ToAdmissionResponse([]metav1.StatusCause{
+					{
+						Type:    metav1.CauseTypeFieldValueInvalid,
+						Message: "Node restriction, virt-handler is not allowed to set target node",
+					},
+				})
+			}
+		} else {
+			return webhookutils.ToAdmissionResponse([]metav1.StatusCause{
+				{
+					Type:    metav1.CauseTypeFieldValueInvalid,
+					Message: "Node restriction failed, virt-handler service account is missing node name",
+				},
+			})
+		}
+	}
+
 	// Reject VMI update if VMI spec changed
 	if !equality.Semantic.DeepEqual(newVMI.Spec, oldVMI.Spec) {
 		// Only allow the KubeVirt SA to modify the VMI spec, since that means it went through the sub resource.
diff --git a/pkg/virt-api/webhooks/validating-webhook/admitters/vmi-update-admitter_test.go b/pkg/virt-api/webhooks/validating-webhook/admitters/vmi-update-admitter_test.go
index a12cd35a4207..edfe94022436 100644
--- a/pkg/virt-api/webhooks/validating-webhook/admitters/vmi-update-admitter_test.go
+++ b/pkg/virt-api/webhooks/validating-webhook/admitters/vmi-update-admitter_test.go
@@ -25,6 +25,7 @@ import (
 
 	. "github.com/onsi/ginkgo/v2"
 	. "github.com/onsi/gomega"
+	"github.com/onsi/gomega/gstruct"
 	"github.com/onsi/gomega/types"
 	admissionv1 "k8s.io/api/admission/v1"
 	authv1 "k8s.io/api/authentication/v1"
@@ -76,6 +77,161 @@ var _ = Describe("Validating VMIUpdate Admitter", func() {
 	config, _, _ := testutils.NewFakeClusterConfigUsingKV(kv)
 	vmiUpdateAdmitter := &VMIUpdateAdmitter{config}
 
+	Context("Node restriction", func() {
+		mustMarshal := func(vmi *v1.VirtualMachineInstance) []byte {
+			b, err := json.Marshal(vmi)
+			Expect(err).To(Not(HaveOccurred()))
+			return b
+		}
+
+		admissionWithCustomUpdate := func(vmi, updatedVMI *v1.VirtualMachineInstance, handlernode string) *admissionv1.AdmissionReview {
+			newVMIBytes := mustMarshal(updatedVMI)
+			oldVMIBytes := mustMarshal(vmi)
+			return &admissionv1.AdmissionReview{
+				Request: &admissionv1.AdmissionRequest{
+					UserInfo: authv1.UserInfo{
+						Username: "system:serviceaccount:kubevirt:kubevirt-handler",
+						Extra: map[string]authv1.ExtraValue{
+							"authentication.kubernetes.io/node-name": {handlernode},
+						},
+					},
+					Resource: webhooks.VirtualMachineInstanceGroupVersionResource,
+					Object: runtime.RawExtension{
+						Raw: newVMIBytes,
+					},
+					OldObject: runtime.RawExtension{
+						Raw: oldVMIBytes,
+					},
+					Operation: admissionv1.Update,
+				},
+			}
+		}
+
+		admission := func(vmi *v1.VirtualMachineInstance, handlernode string) *admissionv1.AdmissionReview {
+			updatedVMI := vmi.DeepCopy()
+			if updatedVMI.Labels == nil {
+				updatedVMI.Labels = map[string]string{}
+			}
+			updatedVMI.Labels["allowed.io"] = "value"
+			return admissionWithCustomUpdate(vmi, updatedVMI, handlernode)
+		}
+
+		Context("with Node Restriction feature gate enabled", func() {
+			BeforeEach(func() { enableFeatureGate(virtconfig.NodeRestrictionGate) })
+
+			shouldNotAllowCrossNodeRequest := And(
+				WithTransform(func(resp *admissionv1.AdmissionResponse) bool { return resp.Allowed },
+					BeFalse(),
+				),
+				WithTransform(func(resp *admissionv1.AdmissionResponse) []metav1.StatusCause { return resp.Result.Details.Causes },
+					ContainElement(
+						gstruct.MatchFields(gstruct.IgnoreExtras, gstruct.Fields{
+							"Message": Equal("Node restriction, virt-handler is only allowed to modify VMIs it owns"),
+						}),
+					),
+				),
+			)
+
+			shouldBeAllowed := WithTransform(func(resp *admissionv1.AdmissionResponse) bool { return resp.Allowed },
+				BeTrue(),
+			)
+
+			DescribeTable("and NodeName set", func(handlernode string, matcher types.GomegaMatcher) {
+				vmi := api.NewMinimalVMI("testvmi")
+				vmi.Status.NodeName = "got"
+
+				resp := vmiUpdateAdmitter.Admit(admission(vmi, handlernode))
+				Expect(resp).To(matcher)
+			},
+				Entry("should deny request if handler is on different node", "diff",
+					shouldNotAllowCrossNodeRequest,
+				),
+				Entry("should allow request if handler is on same node", "got",
+					shouldBeAllowed,
+				),
+			)
+
+			DescribeTable("and TargetNode set", func(handlernode string, matcher types.GomegaMatcher) {
+				vmi := api.NewMinimalVMI("testvmi")
+				vmi.Status.NodeName = "got"
+				vmi.Status.MigrationState = &v1.VirtualMachineInstanceMigrationState{
+					TargetNode: "git",
+				}
+
+				resp := vmiUpdateAdmitter.Admit(admission(vmi, handlernode))
+				Expect(resp).To(matcher)
+			},
+				Entry("should deny request if handler is on different node", "diff",
+					shouldNotAllowCrossNodeRequest,
+				),
+				Entry("should allow request if handler is on same node", "git",
+					shouldBeAllowed,
+				),
+			)
+
+			DescribeTable("and both NodeName and TargetNode set", func(handlernode string, matcher types.GomegaMatcher) {
+				vmi := api.NewMinimalVMI("testvmi")
+				vmi.Status.NodeName = "got"
+				vmi.Status.MigrationState = &v1.VirtualMachineInstanceMigrationState{
+					TargetNode: "target",
+				}
+
+				resp := vmiUpdateAdmitter.Admit(admission(vmi, handlernode))
+				Expect(resp).To(matcher)
+			},
+				Entry("should deny request if handler is on different node", "diff",
+					shouldNotAllowCrossNodeRequest,
+				),
+				Entry("should allow request if handler is on source node", "got",
+					shouldBeAllowed,
+				),
+
+				Entry("should allow request if handler is on target node", "target",
+					shouldBeAllowed,
+				),
+			)
+
+			It("should allow finalize migration", func() {
+				vmi := api.NewMinimalVMI("testvmi")
+				vmi.Status.NodeName = "got"
+				vmi.Status.MigrationState = &v1.VirtualMachineInstanceMigrationState{
+					TargetNode: "target",
+				}
+
+				updatedVMI := vmi.DeepCopy()
+				updatedVMI.Status.NodeName = "target"
+
+				resp := vmiUpdateAdmitter.Admit(admissionWithCustomUpdate(vmi, updatedVMI, "got"))
+				Expect(resp.Allowed).To(BeTrue())
+			})
+
+			It("should not allow to set targetNode to source handler", func() {
+				vmi := api.NewMinimalVMI("testvmi")
+				vmi.Status.NodeName = "got"
+
+				updatedVMI := vmi.DeepCopy()
+				updatedVMI.Status.MigrationState = &v1.VirtualMachineInstanceMigrationState{
+					TargetNode: "target",
+				}
+				resp := vmiUpdateAdmitter.Admit(admissionWithCustomUpdate(vmi, updatedVMI, "got"))
+				Expect(resp.Allowed).To(BeFalse())
+			})
+		})
+
+		DescribeTable("with Node Restriction feature gate disabled should allow different handler", func(migrationState *v1.VirtualMachineInstanceMigrationState) {
+			vmi := api.NewMinimalVMI("testvmi")
+			vmi.Status.NodeName = "got"
+			vmi.Status.MigrationState = migrationState
+
+			resp := vmiUpdateAdmitter.Admit(admission(vmi, "diff"))
+			Expect(resp.Allowed).To(BeTrue())
+		},
+			Entry("when TargetNode is not set", nil),
+			Entry("when TargetNode is set", &v1.VirtualMachineInstanceMigrationState{TargetNode: "git"}),
+		)
+
+	})
+
 	DescribeTable("should reject documents containing unknown or missing fields for", func(data string, validationResult string, gvr metav1.GroupVersionResource, review func(ar *admissionv1.AdmissionReview) *admissionv1.AdmissionResponse) {
 		input := map[string]interface{}{}
 		json.Unmarshal([]byte(data), &input)
diff --git a/pkg/virt-config/feature-gates.go b/pkg/virt-config/feature-gates.go
index f1b7ecfb2ad2..71551da7de7b 100644
--- a/pkg/virt-config/feature-gates.go
+++ b/pkg/virt-config/feature-gates.go
@@ -85,6 +85,13 @@ const (
 	// KubevirtSeccompProfile indicate that Kubevirt will install its custom profile and
 	// user can tell Kubevirt to use it
 	KubevirtSeccompProfile = "KubevirtSeccompProfile"
+	// Owner: @xpivarc
+	// Alpha: v1.3.0
+	//
+	// NodeRestriction enables Kubelet's like NodeRestriction but for Kubevirt's virt-handler.
+	// This feature requires following Kubernetes feature gate "ServiceAccountTokenPodNodeInfo". The feature gate is available
+	// in Kubernetes 1.30 as Beta.
+	NodeRestrictionGate = "NodeRestriction"
 )
 
 var deprecatedFeatureGates = [...]string{
@@ -256,3 +263,7 @@ func (config *ClusterConfig) VolumesUpdateStrategyEnabled() bool {
 func (config *ClusterConfig) KubevirtSeccompProfileEnabled() bool {
 	return config.isFeatureGateEnabled(KubevirtSeccompProfile)
 }
+
+func (config *ClusterConfig) NodeRestrictionEnabled() bool {
+	return config.isFeatureGateEnabled(NodeRestrictionGate)
+}
diff --git a/tests/decorators/decorators.go b/tests/decorators/decorators.go
index 6f728b176c0e..a39c77f569b7 100644
--- a/tests/decorators/decorators.go
+++ b/tests/decorators/decorators.go
@@ -56,4 +56,7 @@ var (
 	Upgrade          = []interface{}{Label("Upgrade")}
 	CustomSELinux    = []interface{}{Label("CustomSELinux")}
 	Istio            = []interface{}{Label("Istio")}
+
+	// Kubernetes versions
+	Kubernetes130 = []interface{}{Label("kubernetes130")}
 )
From d1d26f9cba0decb69e3e610971ed70edba53d906 Mon Sep 17 00:00:00 2001
From: Luboslav Pivarc <lpivarc@redhat.com>
Date: Tue, 11 Jun 2024 13:47:46 +0200
Subject: [PATCH 3/3] Run NodeIsolation tests only on 1.30 lane

Signed-off-by: Luboslav Pivarc <lpivarc@redhat.com>
---
 automation/test.sh | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/automation/test.sh b/automation/test.sh
index b3bf13dacc55..4ea306a710bf 100755
--- a/automation/test.sh
+++ b/automation/test.sh
@@ -455,6 +455,10 @@ if [[ -z ${KUBEVIRT_E2E_FOCUS} && -z ${KUBEVIRT_E2E_SKIP} && -z ${label_filter}
   else
     label_filter='(!(Multus,SRIOV,Macvtap,GPU,VGPU))'
   fi
+
+  if [[ ! $TARGET =~ k8s-1\.3[0-9].* ]]; then
+    add_to_label_filter "(!kubernetes130)" "&&"
+  fi
 fi
 
 add_to_label_filter() {
