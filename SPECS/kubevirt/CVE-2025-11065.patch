From 17b02f8f32d2788646acd111a31840262d18e599 Mon Sep 17 00:00:00 2001
From: AllSpark <allspark@microsoft.com>
Date: Thu, 29 Jan 2026 14:48:25 +0000
Subject: [PATCH] fix: error message leaks

Signed-off-by: Azure Linux Security Servicing Account <azurelinux-security@microsoft.com>
Upstream-reference: AI Backport of https://github.com/go-viper/mapstructure/commit/742921c9ba2854d27baa64272487fc5075d2c39c.patch
---
 .../mitchellh/mapstructure/decode_hooks.go    |  13 +-
 .../mitchellh/mapstructure/error.go           | 212 +++++++++++++++---
 .../mitchellh/mapstructure/mapstructure.go    |   4 +-
 3 files changed, 196 insertions(+), 33 deletions(-)

diff --git a/vendor/github.com/mitchellh/mapstructure/decode_hooks.go b/vendor/github.com/mitchellh/mapstructure/decode_hooks.go
index 3a754ca..30a4c16 100644
--- a/vendor/github.com/mitchellh/mapstructure/decode_hooks.go
+++ b/vendor/github.com/mitchellh/mapstructure/decode_hooks.go
@@ -11,6 +11,7 @@ import (
 	"time"
 )
 
+
 // typedDecodeHook takes a raw DecodeHookFunc (an interface{}) and turns
 // it into the proper DecodeHookFunc type, such as DecodeHookFuncType.
 func typedDecodeHook(h DecodeHookFunc) DecodeHookFunc {
@@ -134,7 +135,9 @@ func StringToTimeDurationHookFunc() DecodeHookFunc {
 		}
 
 		// Convert it by parsing
-		return time.ParseDuration(data.(string))
+		d, err := time.ParseDuration(data.(string))
+		
+		return d, wrapTimeParseDurationError(err)
 	}
 }
 
@@ -155,7 +158,7 @@ func StringToIPHookFunc() DecodeHookFunc {
 		// Convert it by parsing
 		ip := net.ParseIP(data.(string))
 		if ip == nil {
-			return net.IP{}, fmt.Errorf("failed parsing ip %v", data)
+			return net.IP{}, fmt.Errorf("failed parsing ip")
 		}
 
 		return ip, nil
@@ -178,7 +181,7 @@ func StringToIPNetHookFunc() DecodeHookFunc {
 
 		// Convert it by parsing
 		_, net, err := net.ParseCIDR(data.(string))
-		return net, err
+		return net, wrapNetParseError(err)
 	}
 }
 
@@ -197,7 +200,9 @@ func StringToTimeHookFunc(layout string) DecodeHookFunc {
 		}
 
 		// Convert it by parsing
-		return time.Parse(layout, data.(string))
+		ti, err := time.Parse(layout, data.(string))
+		
+		return ti, wrapTimeParseError(err)
 	}
 }
 
diff --git a/vendor/github.com/mitchellh/mapstructure/error.go b/vendor/github.com/mitchellh/mapstructure/error.go
index 47a99e5..6145cd6 100644
--- a/vendor/github.com/mitchellh/mapstructure/error.go
+++ b/vendor/github.com/mitchellh/mapstructure/error.go
@@ -1,50 +1,208 @@
 package mapstructure
 
 import (
-	"errors"
-	"fmt"
-	"sort"
-	"strings"
+    "errors"
+    "fmt"
+    "net"
+    "net/url"
+    "strconv"
+    "strings"
+    "time"
+    "sort"
 )
 
 // Error implements the error interface and can represents multiple
 // errors that occur in the course of a single decode.
 type Error struct {
-	Errors []string
+    Errors []string
 }
 
 func (e *Error) Error() string {
-	points := make([]string, len(e.Errors))
-	for i, err := range e.Errors {
-		points[i] = fmt.Sprintf("* %s", err)
-	}
+    points := make([]string, len(e.Errors))
+    for i, err := range e.Errors {
+        points[i] = fmt.Sprintf("* %s", err)
+    }
 
-	sort.Strings(points)
-	return fmt.Sprintf(
-		"%d error(s) decoding:\n\n%s",
-		len(e.Errors), strings.Join(points, "\n"))
+    sort.Strings(points)
+    return fmt.Sprintf(
+        "%d error(s) decoding:\n\n%s",
+        len(e.Errors), strings.Join(points, "\n"))
 }
 
 // WrappedErrors implements the errwrap.Wrapper interface to make this
 // return value more useful with the errwrap and go-multierror libraries.
 func (e *Error) WrappedErrors() []error {
-	if e == nil {
-		return nil
-	}
+    if e == nil {
+        return nil
+    }
 
-	result := make([]error, len(e.Errors))
-	for i, e := range e.Errors {
-		result[i] = errors.New(e)
-	}
+    result := make([]error, len(e.Errors))
+    for i, e := range e.Errors {
+        result[i] = errors.New(e)
+    }
 
-	return result
+    return result
 }
 
 func appendErrors(errors []string, err error) []string {
-	switch e := err.(type) {
-	case *Error:
-		return append(errors, e.Errors...)
-	default:
-		return append(errors, e.Error())
-	}
+    switch e := err.(type) {
+    case *Error:
+        return append(errors, e.Errors...)
+    default:
+        return append(errors, e.Error())
+    }
+}
+
+// Error wrapping helpers to prevent leaking raw error messages
+
+func wrapStrconvNumError(err error) error {
+    if err == nil {
+        return nil
+    }
+
+    if err, ok := err.(*strconv.NumError); ok {
+        return &strconvNumError{Err: err}
+    }
+
+    return err
+}
+
+type strconvNumError struct {
+    Err *strconv.NumError
+}
+
+func (e *strconvNumError) Error() string {
+    return "strconv." + e.Err.Func + ": " + e.Err.Err.Error()
+}
+
+func (e *strconvNumError) Unwrap() error { return e.Err }
+
+func wrapUrlError(err error) error {
+    if err == nil {
+        return nil
+    }
+
+    if err, ok := err.(*url.Error); ok {
+        return &urlError{Err: err}
+    }
+
+    return err
+}
+
+type urlError struct {
+    Err *url.Error
+}
+
+func (e *urlError) Error() string {
+    return fmt.Sprintf("%s", e.Err.Err)
+}
+
+func (e *urlError) Unwrap() error { return e.Err }
+
+func wrapNetParseError(err error) error {
+    if err == nil {
+        return nil
+    }
+
+    if err, ok := err.(*net.ParseError); ok {
+        return &netParseError{Err: err}
+    }
+
+    return err
+}
+
+type netParseError struct {
+    Err *net.ParseError
+}
+
+func (e *netParseError) Error() string {
+    return "invalid " + e.Err.Type
+}
+
+func (e *netParseError) Unwrap() error { return e.Err }
+
+func wrapTimeParseError(err error) error {
+    if err == nil {
+        return nil
+    }
+
+    if err, ok := err.(*time.ParseError); ok {
+        return &timeParseError{Err: err}
+    }
+
+    return err
+}
+
+type timeParseError struct {
+    Err *time.ParseError
+}
+
+func (e *timeParseError) Error() string {
+    if e.Err.Message == "" {
+        return fmt.Sprintf("parsing time as %q: cannot parse as %q", e.Err.Layout, e.Err.LayoutElem)
+    }
+
+    return "parsing time " + e.Err.Message
+}
+
+func (e *timeParseError) Unwrap() error { return e.Err }
+
+func wrapNetIPParseAddrError(err error) error {
+    if err == nil {
+        return nil
+    }
+
+    if errMsg := err.Error(); strings.HasPrefix(errMsg, "ParseAddr") {
+        errPieces := strings.Split(errMsg, ": ")
+
+        return fmt.Sprintf("ParseAddr: %s", errPieces[len(errPieces)-1])
+    }
+
+    return err
+}
+
+func wrapNetIPParseAddrPortError(err error) error {
+    if err == nil {
+        return nil
+    }
+
+    errMsg := err.Error()
+    if strings.HasPrefix(errMsg, "invalid port ") {
+        return errors.New("invalid port")
+    } else if strings.HasPrefix(errMsg, "invalid ip:port ") {
+        return errors.New("invalid ip:port")
+    }
+
+    return err
+}
+
+func wrapNetIPParsePrefixError(err error) error {
+    if err == nil {
+        return nil
+    }
+
+    if errMsg := err.Error(); strings.HasPrefix(errMsg, "netip.ParsePrefix") {
+        errPieces := strings.Split(errMsg, ": ")
+
+        return fmt.Sprintf("netip.ParsePrefix: %s", errPieces[len(errPieces)-1])
+    }
+
+    return err
+}
+
+func wrapTimeParseDurationError(err error) error {
+    if err == nil {
+        return nil
+    }
+
+    errMsg := err.Error()
+    if strings.HasPrefix(errMsg, "time: unknown unit ") {
+        return errors.New("time: unknown unit")
+    } else if strings.HasPrefix(errMsg, "time: ") {
+        idx := strings.LastIndex(errMsg, " ")
+
+        return errors.New(errMsg[:idx])
+    }
+
+    return err
 }
diff --git a/vendor/github.com/mitchellh/mapstructure/mapstructure.go b/vendor/github.com/mitchellh/mapstructure/mapstructure.go
index 1efb22a..72da47a 100644
--- a/vendor/github.com/mitchellh/mapstructure/mapstructure.go
+++ b/vendor/github.com/mitchellh/mapstructure/mapstructure.go
@@ -642,7 +642,7 @@ func (d *Decoder) decodeInt(name string, data interface{}, val reflect.Value) er
 		if err == nil {
 			val.SetInt(i)
 		} else {
-			return fmt.Errorf("cannot parse '%s' as int: %s", name, err)
+			return fmt.Errorf("cannot parse '%s' as int: %s", name, wrapStrconvNumError(err))
 		}
 	case dataType.PkgPath() == "encoding/json" && dataType.Name() == "Number":
 		jn := data.(json.Number)
@@ -738,7 +738,7 @@ func (d *Decoder) decodeBool(name string, data interface{}, val reflect.Value) e
 		} else if dataVal.String() == "" {
 			val.SetBool(false)
 		} else {
-			return fmt.Errorf("cannot parse '%s' as bool: %s", name, err)
+			return fmt.Errorf("cannot parse '%s' as bool: %s", name, wrapStrconvNumError(err))
 		}
 	default:
 		return fmt.Errorf(
-- 
2.45.4

