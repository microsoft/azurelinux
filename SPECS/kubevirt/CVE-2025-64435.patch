From 0e11a68b243d5f0b2f09def23cb7c67cbdf038cd Mon Sep 17 00:00:00 2001
From: fossedihelm <ffossemo@redhat.com>
Date: Mon, 15 Sep 2025 08:26:00 +0200
Subject: [PATCH 1/6] ctrl: Do not fallback using labels for getting owner ref

Currently, in case the pods don't have the ownerRef, we
try to rely on pod labels to get the vmi owner ref.
This fallback should not be allowed because nowadays,
every pod created by KV have the ownerRef.

Signed-off-by: fossedihelm <ffossemo@redhat.com>
Upstream-reference: https://github.com/kubevirt/kubevirt/commit/9a6f4a3a707992038ef705da4cb3bba8c89d36ba.patch
---
 pkg/controller/BUILD.bazel                    |  1 -
 pkg/controller/controller.go                  |  7 ++-
 pkg/controller/controller_ref.go              | 50 -------------------
 .../watch/drain/evacuation/evacuation_test.go |  1 +
 pkg/virt-controller/watch/migration_test.go   |  2 +
 pkg/virt-controller/watch/node.go             |  4 +-
 pkg/virt-controller/watch/node_test.go        |  1 +
 pkg/virt-controller/watch/vmi.go              | 22 ++++----
 pkg/virt-controller/watch/vmi_test.go         |  7 ++-
 .../workload-updater/workload-updater_test.go |  1 +
 tests/libvmi/status.go                        |  3 +-
 11 files changed, 27 insertions(+), 72 deletions(-)
 delete mode 100644 pkg/controller/controller_ref.go

diff --git a/pkg/controller/BUILD.bazel b/pkg/controller/BUILD.bazel
index cdb700c..30621d9 100644
--- a/pkg/controller/BUILD.bazel
+++ b/pkg/controller/BUILD.bazel
@@ -5,7 +5,6 @@ go_library(
     srcs = [
         "conditions.go",
         "controller.go",
-        "controller_ref.go",
         "controller_ref_manager.go",
         "expectations.go",
         "keys.go",
diff --git a/pkg/controller/controller.go b/pkg/controller/controller.go
index 333b023..142d56a 100644
--- a/pkg/controller/controller.go
+++ b/pkg/controller/controller.go
@@ -264,7 +264,7 @@ func CurrentVMIPod(vmi *v1.VirtualMachineInstance, podInformer cache.SharedIndex
 
 	var curPod *k8sv1.Pod = nil
 	for _, pod := range pods {
-		if !IsControlledBy(pod, vmi) {
+		if !metav1.IsControlledBy(pod, vmi) {
 			continue
 		}
 
@@ -298,7 +298,7 @@ func VMIActivePodsCount(vmi *v1.VirtualMachineInstance, vmiPodInformer cache.Sha
 		if pod.Status.Phase == k8sv1.PodSucceeded || pod.Status.Phase == k8sv1.PodFailed {
 			// not interested in terminated pods
 			continue
-		} else if !IsControlledBy(pod, vmi) {
+		} else if !metav1.IsControlledBy(pod, vmi) {
 			// not interested pods not associated with the vmi
 			continue
 		}
@@ -371,8 +371,7 @@ func AttachmentPods(ownerPod *k8sv1.Pod, podInformer cache.SharedIndexInformer)
 	attachmentPods := []*k8sv1.Pod{}
 	for _, obj := range objs {
 		pod := obj.(*k8sv1.Pod)
-		ownerRef := GetControllerOf(pod)
-		if ownerRef == nil || ownerRef.UID != ownerPod.UID {
+		if !metav1.IsControlledBy(pod, ownerPod) {
 			continue
 		}
 		attachmentPods = append(attachmentPods, pod)
diff --git a/pkg/controller/controller_ref.go b/pkg/controller/controller_ref.go
deleted file mode 100644
index 9a247de..0000000
--- a/pkg/controller/controller_ref.go
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
-Copyright 2016 The Kubernetes Authors.
-Copyright 2017 The KubeVirt Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package controller
-
-import (
-	k8sv1 "k8s.io/api/core/v1"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/apimachinery/pkg/types"
-
-	virtv1 "kubevirt.io/api/core/v1"
-)
-
-// GetControllerOf returns the controllerRef if controllee has a controller,
-// otherwise returns nil.
-func GetControllerOf(pod *k8sv1.Pod) *metav1.OwnerReference {
-	controllerRef := metav1.GetControllerOf(pod)
-	if controllerRef != nil {
-		return controllerRef
-	}
-	// We may find pods that are only using CreatedByLabel and not set with an OwnerReference
-	if createdBy := pod.Labels[virtv1.CreatedByLabel]; len(createdBy) > 0 {
-		name := pod.Annotations[virtv1.DomainAnnotation]
-		uid := types.UID(createdBy)
-		vmi := virtv1.NewVMI(name, uid)
-		return metav1.NewControllerRef(vmi, virtv1.VirtualMachineInstanceGroupVersionKind)
-	}
-	return nil
-}
-
-func IsControlledBy(pod *k8sv1.Pod, vmi *virtv1.VirtualMachineInstance) bool {
-	if controllerRef := GetControllerOf(pod); controllerRef != nil {
-		return controllerRef.UID == vmi.UID
-	}
-	return false
-}
diff --git a/pkg/virt-controller/watch/drain/evacuation/evacuation_test.go b/pkg/virt-controller/watch/drain/evacuation/evacuation_test.go
index afce970..afca5a5 100644
--- a/pkg/virt-controller/watch/drain/evacuation/evacuation_test.go
+++ b/pkg/virt-controller/watch/drain/evacuation/evacuation_test.go
@@ -520,6 +520,7 @@ func newPod(vmi *v1.VirtualMachineInstance, name string, phase v12.PodPhase, own
 		pod.Annotations = map[string]string{
 			v1.DomainAnnotation: vmi.Name,
 		}
+		pod.OwnerReferences = []metav1.OwnerReference{*metav1.NewControllerRef(vmi, v1.VirtualMachineInstanceGroupVersionKind)}
 	}
 
 	return pod
diff --git a/pkg/virt-controller/watch/migration_test.go b/pkg/virt-controller/watch/migration_test.go
index 91aadf8..40726c2 100644
--- a/pkg/virt-controller/watch/migration_test.go
+++ b/pkg/virt-controller/watch/migration_test.go
@@ -1903,6 +1903,7 @@ func newSourcePodForVirtualMachine(vmi *virtv1.VirtualMachineInstance) *k8sv1.Po
 			Annotations: map[string]string{
 				virtv1.DomainAnnotation: vmi.Name,
 			},
+			OwnerReferences: []metav1.OwnerReference{*metav1.NewControllerRef(vmi, virtv1.VirtualMachineInstanceGroupVersionKind)},
 		},
 		Status: k8sv1.PodStatus{
 			Phase: k8sv1.PodRunning,
@@ -1931,6 +1932,7 @@ func newTargetPodForVirtualMachine(vmi *virtv1.VirtualMachineInstance, migration
 				virtv1.DomainAnnotation:           vmi.Name,
 				virtv1.MigrationJobNameAnnotation: migration.Name,
 			},
+			OwnerReferences: []metav1.OwnerReference{*metav1.NewControllerRef(vmi, virtv1.VirtualMachineInstanceGroupVersionKind)},
 		},
 		Status: k8sv1.PodStatus{
 			Phase: phase,
diff --git a/pkg/virt-controller/watch/node.go b/pkg/virt-controller/watch/node.go
index fda6e0b..03f629c 100644
--- a/pkg/virt-controller/watch/node.go
+++ b/pkg/virt-controller/watch/node.go
@@ -382,7 +382,7 @@ func (c *NodeController) alivePodsOnNode(nodeName string) ([]*v1.Pod, error) {
 
 	for i := range list.Items {
 		pod := &list.Items[i]
-		if controllerRef := controller.GetControllerOf(pod); !isControlledByVMI(controllerRef) {
+		if controllerRef := metav1.GetControllerOf(pod); !isControlledByVMI(controllerRef) {
 			continue
 		}
 
@@ -419,7 +419,7 @@ func filterStuckVirtualMachinesWithoutPods(vmis []*virtv1.VirtualMachineInstance
 		if !ok {
 			podsForVMI = map[string]*v1.Pod{}
 		}
-		if controllerRef := controller.GetControllerOf(pod); isControlledByVMI(controllerRef) {
+		if controllerRef := metav1.GetControllerOf(pod); isControlledByVMI(controllerRef) {
 			podsForVMI[string(controllerRef.UID)] = pod
 			podsPerNamespace[pod.Namespace] = podsForVMI
 		}
diff --git a/pkg/virt-controller/watch/node_test.go b/pkg/virt-controller/watch/node_test.go
index 290b433..092d774 100644
--- a/pkg/virt-controller/watch/node_test.go
+++ b/pkg/virt-controller/watch/node_test.go
@@ -497,6 +497,7 @@ func NewHealthyPodForVirtualMachine(podName string, vmi *virtv1.VirtualMachineIn
 				virtv1.CreatedByLabel: string(vmi.UID),
 				virtv1.AppLabel:       "virt-launcher",
 			},
+			OwnerReferences: []metav1.OwnerReference{*metav1.NewControllerRef(vmi, virtv1.VirtualMachineInstanceGroupVersionKind)},
 		},
 		Spec: k8sv1.PodSpec{NodeName: vmi.Status.NodeName},
 		Status: k8sv1.PodStatus{
diff --git a/pkg/virt-controller/watch/vmi.go b/pkg/virt-controller/watch/vmi.go
index b1cbbc8..cdf10e1 100644
--- a/pkg/virt-controller/watch/vmi.go
+++ b/pkg/virt-controller/watch/vmi.go
@@ -1269,7 +1269,7 @@ func (c *VMIController) addPod(obj interface{}) {
 		return
 	}
 
-	controllerRef := controller.GetControllerOf(pod)
+	controllerRef := v1.GetControllerOf(pod)
 	vmi := c.resolveControllerRef(pod.Namespace, controllerRef)
 	if vmi == nil {
 		return
@@ -1306,8 +1306,8 @@ func (c *VMIController) updatePod(old, cur interface{}) {
 		return
 	}
 
-	curControllerRef := controller.GetControllerOf(curPod)
-	oldControllerRef := controller.GetControllerOf(oldPod)
+	curControllerRef := v1.GetControllerOf(curPod)
+	oldControllerRef := v1.GetControllerOf(oldPod)
 	controllerRefChanged := !equality.Semantic.DeepEqual(curControllerRef, oldControllerRef)
 	if controllerRefChanged {
 		// The ControllerRef was changed. Sync the old controller, if any.
@@ -1347,7 +1347,7 @@ func (c *VMIController) deletePod(obj interface{}) {
 		}
 	}
 
-	controllerRef := controller.GetControllerOf(pod)
+	controllerRef := v1.GetControllerOf(pod)
 	vmi := c.resolveControllerRef(pod.Namespace, controllerRef)
 	if vmi == nil {
 		return
@@ -1425,7 +1425,7 @@ func (c *VMIController) resolveControllerRef(namespace string, controllerRef *v1
 			return nil
 		}
 		pod, _ := obj.(*k8sv1.Pod)
-		controllerRef = controller.GetControllerOf(pod)
+		controllerRef = v1.GetControllerOf(pod)
 	}
 	// We can't look up by UID, so look up by Name and then verify UID.
 	// Don't even try to look up by Name if it is nil or the wrong Kind.
@@ -1471,7 +1471,7 @@ func (c *VMIController) allPodsDeleted(vmi *virtv1.VirtualMachineInstance) (bool
 	}
 
 	for _, pod := range pods {
-		if controller.IsControlledBy(pod, vmi) {
+		if v1.IsControlledBy(pod, vmi) {
 			return false, nil
 		}
 	}
@@ -1493,7 +1493,7 @@ func (c *VMIController) deleteAllMatchingPods(vmi *virtv1.VirtualMachineInstance
 			continue
 		}
 
-		if !controller.IsControlledBy(pod, vmi) {
+		if !v1.IsControlledBy(pod, vmi) {
 			continue
 		}
 
@@ -1535,7 +1535,7 @@ func (c *VMIController) setActivePods(vmi *virtv1.VirtualMachineInstance) (*virt
 	activePods := make(map[types.UID]string)
 	count := 0
 	for _, pod := range pods {
-		if !controller.IsControlledBy(pod, vmi) {
+		if !v1.IsControlledBy(pod, vmi) {
 			continue
 		}
 
@@ -1631,11 +1631,11 @@ func (c *VMIController) waitForFirstConsumerTemporaryPods(vmi *virtv1.VirtualMac
 			continue
 		}
 
-		if controller.IsControlledBy(pod, vmi) {
+		if v1.IsControlledBy(pod, vmi) {
 			temporaryPods = append(temporaryPods, pod)
 		}
 
-		if ownerRef := controller.GetControllerOf(pod); ownerRef != nil && ownerRef.UID == virtLauncherPod.UID {
+		if ownerRef := v1.GetControllerOf(pod); ownerRef != nil && ownerRef.UID == virtLauncherPod.UID {
 			temporaryPods = append(temporaryPods, pod)
 		}
 	}
@@ -1906,7 +1906,7 @@ func (c *VMIController) deleteOrphanedAttachmentPods(vmi *virtv1.VirtualMachineI
 	}
 
 	for _, pod := range pods {
-		if !controller.IsControlledBy(pod, vmi) {
+		if !v1.IsControlledBy(pod, vmi) {
 			continue
 		}
 
diff --git a/pkg/virt-controller/watch/vmi_test.go b/pkg/virt-controller/watch/vmi_test.go
index 5cff47b..fad95bb 100644
--- a/pkg/virt-controller/watch/vmi_test.go
+++ b/pkg/virt-controller/watch/vmi_test.go
@@ -1935,7 +1935,7 @@ var _ = Describe("VirtualMachineInstance watcher", func() {
 		It("Should find vmi, from virt-launcher pod", func() {
 			vmi := NewPendingVirtualMachine("testvmi")
 			pod := NewPodForVirtualMachine(vmi, k8sv1.PodRunning)
-			controllerRef := kvcontroller.GetControllerOf(pod)
+			controllerRef := metav1.GetControllerOf(pod)
 			addVirtualMachine(vmi)
 
 			result := controller.resolveControllerRef(k8sv1.NamespaceDefault, controllerRef)
@@ -1946,7 +1946,7 @@ var _ = Describe("VirtualMachineInstance watcher", func() {
 			vmi := NewPendingVirtualMachine("testvmi")
 			pod := NewPodForVirtualMachine(vmi, k8sv1.PodRunning)
 			attachmentPod := NewPodForVirtlauncher(pod, "hp-test", "abcd", k8sv1.PodRunning)
-			controllerRef := kvcontroller.GetControllerOf(attachmentPod)
+			controllerRef := metav1.GetControllerOf(attachmentPod)
 			addVirtualMachine(vmi)
 			podFeeder.Add(pod)
 
@@ -3031,6 +3031,9 @@ func NewDv(namespace string, name string, phase cdiv1.DataVolumePhase) *cdiv1.Da
 			Name:      name,
 			Namespace: namespace,
 		},
+		OwnerReferences: []metav1.OwnerReference{
+			*metav1.NewControllerRef(vmi, virtv1.VirtualMachineInstanceGroupVersionKind),
+		},
 		Status: cdiv1.DataVolumeStatus{
 			Phase: phase,
 		},
diff --git a/pkg/virt-controller/watch/workload-updater/workload-updater_test.go b/pkg/virt-controller/watch/workload-updater/workload-updater_test.go
index 8cd9755..8448be5 100644
--- a/pkg/virt-controller/watch/workload-updater/workload-updater_test.go
+++ b/pkg/virt-controller/watch/workload-updater/workload-updater_test.go
@@ -488,6 +488,7 @@ func newVirtualMachine(name string, isMigratable bool, image string, vmiSource *
 			Annotations: map[string]string{
 				v1.DomainAnnotation: vmi.Name,
 			},
+			OwnerReferences: []metav1.OwnerReference{*metav1.NewControllerRef(vmi, v1.VirtualMachineInstanceGroupVersionKind)},
 		},
 		Status: k8sv1.PodStatus{
 			Phase: k8sv1.PodRunning,
diff --git a/tests/libvmi/status.go b/tests/libvmi/status.go
index dc1b5e9..f361408 100644
--- a/tests/libvmi/status.go
+++ b/tests/libvmi/status.go
@@ -11,7 +11,6 @@ import (
 
 	v1 "kubevirt.io/api/core/v1"
 
-	"kubevirt.io/kubevirt/pkg/controller"
 )
 
 func GetPodByVirtualMachineInstance(vmi *v1.VirtualMachineInstance, namespace string) (*k8sv1.Pod, error) {
@@ -25,7 +24,7 @@ func GetPodByVirtualMachineInstance(vmi *v1.VirtualMachineInstance, namespace st
 	var controlledPod *k8sv1.Pod
 	for podIndex := range pods.Items {
 		pod := &pods.Items[podIndex]
-		if controller.IsControlledBy(pod, vmi) {
+		if metav1.IsControlledBy(pod, vmi) {
 			controlledPod = pod
 			break
 		}
-- 
2.45.4

