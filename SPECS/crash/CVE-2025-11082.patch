From 7c3786c60d077cbd97e5f45aef5e6d3f39c66354 Mon Sep 17 00:00:00 2001
From: AllSpark <allspark@microsoft.com>
Date: Fri, 3 Oct 2025 07:58:41 +0000
Subject: [PATCH] eh_frame: ensure augmentation string parsing does not read
 beyond section bounds; use memchr to find terminator and validate length

Signed-off-by: Azure Linux Security Servicing Account <azurelinux-security@microsoft.com>
Upstream-reference: AI Backport of https://github.com/bminor/binutils-gdb/commit/ea1a0737c7692737a644af0486b71e4a392cbca8
---
 unwind_x86_32_64.c | 30 ++++++++++++++++++++++++------
 1 file changed, 24 insertions(+), 6 deletions(-)

diff --git a/unwind_x86_32_64.c b/unwind_x86_32_64.c
index c7c30d6..debc7f9 100644
--- a/unwind_x86_32_64.c
+++ b/unwind_x86_32_64.c
@@ -573,13 +573,31 @@ unwind(struct unwind_frame_info *frame, int is_ehframe)
 			/* check if augmentation size is first (and thus present) */
 			if (*ptr == 'z') {
 				/* check for ignorable (or already handled)
-				 * nul-terminated augmentation string */
-				while (++ptr < end && *ptr)
-					if (strchr("LPR", *ptr) == NULL)
-						break;
+				 * nul-terminated augmentation string within bounds */
+				const char *aug = (const char *)ptr;
+				const char *null_byte = (const char *)memchr(aug, 0, end - aug);
+				if (null_byte == NULL) {
+					cie = NULL;
+				} else {
+					/* ensure only ignorable characters appear before terminator */
+					const char *p = aug;
+					while (p < null_byte && *p) {
+						if (strchr("LPR", *p) == NULL)
+							break;
+						p++;
+					}
+					if (p != null_byte)
+						cie = NULL;
+					ptr = (const u8 *)(null_byte + 1);
+				}
+			} else {
+				/* augmentation string must be NUL-terminated within bounds */
+				const char *null_byte = (const char *)memchr((const char *)ptr, 0, end - (const u8 *)ptr);
+				if (null_byte == NULL)
+					cie = NULL;
+				else
+					ptr = (const u8 *)(null_byte + 1);
 			}
-			if (ptr >= end || *ptr)
-				cie = NULL;
 		}
 		++ptr;
 	}
-- 
2.45.4

