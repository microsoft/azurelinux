From 151f04fa89e7e70d6637fa33e31d1ae51de08266 Mon Sep 17 00:00:00 2001
From: AllSpark <allspark@microsoft.com>
Date: Mon, 5 Jan 2026 09:32:54 +0000
Subject: [PATCH] CVE-2025-11961: Fix OOBR and OOBW in MAC-48
 parsing\n\nImplement strict validation and FSM-based parsing for MAC-48
 address formats to avoid out-of-bounds reads and writes. Replace the previous
 permissive loop in eth_pton() with calls to the new validators, returning
 failure for malformed input.\n\nThis adapts the upstream fix originally
 applied to pcap_ether_aton() (backported from commit
 dd08e53e9380e217ae7c7768da9cc3d7bf37bf83) to Nmap's libdnet
 eth_pton().\n\nReported by Jin Wei, Kunwei Qian and Ping Chen.

Signed-off-by: Azure Linux Security Servicing Account <azurelinux-security@microsoft.com>
Upstream-reference: AI Backport of https://github.com/the-tcpdump-group/libpcap/commit/b2d2f9a9a0581c40780bde509f7cc715920f1c02.patch
---
 libdnet-stripped/src/addr-util.c | 376 ++++++++++++++++++++++++++++++-
 1 file changed, 364 insertions(+), 12 deletions(-)

diff --git a/libdnet-stripped/src/addr-util.c b/libdnet-stripped/src/addr-util.c
index 09c0807..8038578 100644
--- a/libdnet-stripped/src/addr-util.c
+++ b/libdnet-stripped/src/addr-util.c
@@ -15,6 +15,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <ctype.h>
 
 #include "dnet.h"
 
@@ -103,23 +104,374 @@ eth_ntoa(const eth_addr_t *eth)
 	addr_pack(&a, ADDR_TYPE_ETH, ETH_ADDR_BITS, eth->data, ETH_ADDR_LEN);
 	return (addr_ntoa(&a));
 }
+/*
+ * Convert MAC-48 address strings to binary with strict validation to avoid
+ * out-of-bounds reads/writes. Supported forms:
+ *  - "xxxxxxxxxxxx" (12 hex digits)
+ *  - "xxxx.xxxx.xxxx" (3 groups of 4 hex digits separated by '.')
+ *  - "x[:.-]x[:.-]x[:.-]x[:.-]x[:.-]x" (each octet is 1 or 2 hex digits,
+ *    all separators must be the same and one of ':', '.', '-')
+ * Any "xx" above can be "x", which is equivalent to "0x".
+ */
+
+static u_char xdtoi(char c)
+{
+	if (c >= '0' && c <= '9')
+		return (u_char)(c - '0');
+	if (c >= 'a' && c <= 'f')
+		return (u_char)(c - 'a' + 10);
+	if (c >= 'A' && c <= 'F')
+		return (u_char)(c - 'A' + 10);
+	return 0;
+}
+
+// Man page: "xxxxxxxxxxxx", regexp: "^[0-9a-fA-F]{12}$".
+static u_char
+atomac48_xxxxxxxxxxxx(const char *s, u_char *addr)
+{
+	if (strlen(s) == 12 &&
+	    isxdigit((unsigned char)s[0]) &&
+	    isxdigit((unsigned char)s[1]) &&
+	    isxdigit((unsigned char)s[2]) &&
+	    isxdigit((unsigned char)s[3]) &&
+	    isxdigit((unsigned char)s[4]) &&
+	    isxdigit((unsigned char)s[5]) &&
+	    isxdigit((unsigned char)s[6]) &&
+	    isxdigit((unsigned char)s[7]) &&
+	    isxdigit((unsigned char)s[8]) &&
+	    isxdigit((unsigned char)s[9]) &&
+	    isxdigit((unsigned char)s[10]) &&
+	    isxdigit((unsigned char)s[11])) {
+		addr[0] = xdtoi(s[0]) << 4 | xdtoi(s[1]);
+		addr[1] = xdtoi(s[2]) << 4 | xdtoi(s[3]);
+		addr[2] = xdtoi(s[4]) << 4 | xdtoi(s[5]);
+		addr[3] = xdtoi(s[6]) << 4 | xdtoi(s[7]);
+		addr[4] = xdtoi(s[8]) << 4 | xdtoi(s[9]);
+		addr[5] = xdtoi(s[10]) << 4 | xdtoi(s[11]);
+		return 1;
+	}
+	return 0;
+}
+
+// Man page: "xxxx.xxxx.xxxx", regexp: "^[0-9a-fA-F]{4}(\.[0-9a-fA-F]{4}){2}$".
+static u_char
+atomac48_xxxx_3_times(const char *s, u_char *addr)
+{
+	const char sep = '.';
+	if (strlen(s) == 14 &&
+	    isxdigit((unsigned char)s[0]) &&
+	    isxdigit((unsigned char)s[1]) &&
+	    isxdigit((unsigned char)s[2]) &&
+	    isxdigit((unsigned char)s[3]) &&
+	    s[4] == sep &&
+	    isxdigit((unsigned char)s[5]) &&
+	    isxdigit((unsigned char)s[6]) &&
+	    isxdigit((unsigned char)s[7]) &&
+	    isxdigit((unsigned char)s[8]) &&
+	    s[9] == sep &&
+	    isxdigit((unsigned char)s[10]) &&
+	    isxdigit((unsigned char)s[11]) &&
+	    isxdigit((unsigned char)s[12]) &&
+	    isxdigit((unsigned char)s[13])) {
+		addr[0] = xdtoi(s[0]) << 4 | xdtoi(s[1]);
+		addr[1] = xdtoi(s[2]) << 4 | xdtoi(s[3]);
+		addr[2] = xdtoi(s[5]) << 4 | xdtoi(s[6]);
+		addr[3] = xdtoi(s[7]) << 4 | xdtoi(s[8]);
+		addr[4] = xdtoi(s[10]) << 4 | xdtoi(s[11]);
+		addr[5] = xdtoi(s[12]) << 4 | xdtoi(s[13]);
+		return 1;
+	}
+	return 0;
+}
+
+/*
+ * Man page: "xx:xx:xx:xx:xx:xx", regexp: "^[0-9a-fA-F]{1,2}(:[0-9a-fA-F]{1,2}){5}$".
+ * Man page: "xx-xx-xx-xx-xx-xx", regexp: "^[0-9a-fA-F]{1,2}(-[0-9a-fA-F]{1,2}){5}$".
+ * Man page: "xx.xx.xx.xx.xx.xx", regexp: "^[0-9a-fA-F]{1,2}(\.[0-9a-fA-F]{1,2}){5}$".
+ * (Any "xx" above can be "x", which is equivalent to "0x".)
+ *
+ * An equivalent (and parametrisable for EUI-64) FSM could be implemented using
+ * a smaller graph, but that graph would be neither acyclic nor planar nor
+ * trivial to verify.
+ *
+ *                |
+ *    [.]         v
+ * +<---------- START
+ * |              |
+ * |              | [0-9a-fA-F]
+ * |  [.]         v
+ * +<--------- BYTE0_X ----------+
+ * |              |              |
+ * |              | [0-9a-fA-F]  |
+ * |  [.]         v              |
+ * +<--------- BYTE0_XX          | [:\.-]
+ * |              |              |
+ * |              | [:\.-]       |
+ * |  [.]         v              |
+ * +<----- BYTE0_SEP_BYTE1 <-----+
+ * |              |
+ * |              | [0-9a-fA-F]
+ * |  [.]         v
+ * +<--------- BYTE1_X ----------+
+ * |              |              |
+ * |              | [0-9a-fA-F]  |
+ * |  [.]         v              |
+ * +<--------- BYTE1_XX          | <sep>
+ * |              |              |
+ * |              | <sep>        |
+ * |  [.]         v              |
+ * +<----- BYTE1_SEP_BYTE2 <-----+
+ * |              |
+ * |              | [0-9a-fA-F]
+ * |  [.]         v
+ * +<--------- BYTE2_X ----------+
+ * |              |              |
+ * |              | [0-9a-fA-F]  |
+ * |  [.]         v              |
+ * +<--------- BYTE2_XX          | <sep>
+ * |              |              |
+ * |              | <sep>        |
+ * |  [.]         v              |
+ * +<----- BYTE2_SEP_BYTE3 <-----+
+ * |              |
+ * |              | [0-9a-fA-F]
+ * |  [.]         v
+ * +<--------- BYTE3_X ----------+
+ * |              |              |
+ * |              | [0-9a-fA-F]  |
+ * |  [.]         v              |
+ * +<--------- BYTE3_XX          | <sep>
+ * |              |              |
+ * |              | <sep>        |
+ * |  [.]         v              |
+ * +<----- BYTE3_SEP_BYTE4 <-----+
+ * |              |
+ * |              | [0-9a-fA-F]
+ * |  [.]         v
+ * +<--------- BYTE4_X ----------+
+ * |              |              |
+ * |              | [0-9a-fA-F]  |
+ * |  [.]         v              |
+ * +<--------- BYTE4_XX          | <sep>
+ * |              |              |
+ * |              | <sep>        |
+ * |  [.]         v              |
+ * +<----- BYTE4_SEP_BYTE5 <-----+
+ * |              |
+ * |              | [0-9a-fA-F]
+ * |  [.]         v
+ * +<--------- BYTE5_X ----------+
+ * |              |              |
+ * |              | [0-9a-fA-F]  |
+ * |  [.]         v              |
+ * +<--------- BYTE5_XX          | \0
+ * |              |              |
+ * |              | \0           |
+ * |              |              v
+ * +--> (reject)  +---------> (accept)
+ */
+static u_char
+atomac48_x_xx_6_times(const char *s, u_char *addr)
+{
+	enum {
+		START,
+		BYTE0_X,
+		BYTE0_XX,
+		BYTE0_SEP_BYTE1,
+		BYTE1_X,
+		BYTE1_XX,
+		BYTE1_SEP_BYTE2,
+		BYTE2_X,
+		BYTE2_XX,
+		BYTE2_SEP_BYTE3,
+		BYTE3_X,
+		BYTE3_XX,
+		BYTE3_SEP_BYTE4,
+		BYTE4_X,
+		BYTE4_XX,
+		BYTE4_SEP_BYTE5,
+		BYTE5_X,
+		BYTE5_XX,
+	} fsm_state = START;
+	u_char buf[6];
+	const char *seplist = ":.-";
+	char sep = 0;
+
+	while (*s) {
+		switch (fsm_state) {
+		case START:
+			if (isxdigit((unsigned char)*s)) {
+				buf[0] = xdtoi(*s);
+				fsm_state = BYTE0_X;
+				break;
+			}
+			goto reject;
+		case BYTE0_X:
+			if (strchr(seplist, *s)) {
+				sep = *s;
+				fsm_state = BYTE0_SEP_BYTE1;
+				break;
+			}
+			if (isxdigit((unsigned char)*s)) {
+				buf[0] = (u_char)(buf[0] << 4) | xdtoi(*s);
+				fsm_state = BYTE0_XX;
+				break;
+			}
+			goto reject;
+		case BYTE0_XX:
+			if (strchr(seplist, *s)) {
+				sep = *s;
+				fsm_state = BYTE0_SEP_BYTE1;
+				break;
+			}
+			goto reject;
+		case BYTE0_SEP_BYTE1:
+			if (isxdigit((unsigned char)*s)) {
+				buf[1] = xdtoi(*s);
+				fsm_state = BYTE1_X;
+				break;
+			}
+			goto reject;
+		case BYTE1_X:
+			if (*s == sep) {
+				fsm_state = BYTE1_SEP_BYTE2;
+				break;
+			}
+			if (isxdigit((unsigned char)*s)) {
+				buf[1] = (u_char)(buf[1] << 4) | xdtoi(*s);
+				fsm_state = BYTE1_XX;
+				break;
+			}
+			goto reject;
+		case BYTE1_XX:
+			if (*s == sep) {
+				fsm_state = BYTE1_SEP_BYTE2;
+				break;
+			}
+			goto reject;
+		case BYTE1_SEP_BYTE2:
+			if (isxdigit((unsigned char)*s)) {
+				buf[2] = xdtoi(*s);
+				fsm_state = BYTE2_X;
+				break;
+			}
+			goto reject;
+		case BYTE2_X:
+			if (*s == sep) {
+				fsm_state = BYTE2_SEP_BYTE3;
+				break;
+			}
+			if (isxdigit((unsigned char)*s)) {
+				buf[2] = (u_char)(buf[2] << 4) | xdtoi(*s);
+				fsm_state = BYTE2_XX;
+				break;
+			}
+			goto reject;
+		case BYTE2_XX:
+			if (*s == sep) {
+				fsm_state = BYTE2_SEP_BYTE3;
+				break;
+			}
+			goto reject;
+		case BYTE2_SEP_BYTE3:
+			if (isxdigit((unsigned char)*s)) {
+				buf[3] = xdtoi(*s);
+				fsm_state = BYTE3_X;
+				break;
+			}
+			goto reject;
+		case BYTE3_X:
+			if (*s == sep) {
+				fsm_state = BYTE3_SEP_BYTE4;
+				break;
+			}
+			if (isxdigit((unsigned char)*s)) {
+				buf[3] = (u_char)(buf[3] << 4) | xdtoi(*s);
+				fsm_state = BYTE3_XX;
+				break;
+			}
+			goto reject;
+		case BYTE3_XX:
+			if (*s == sep) {
+				fsm_state = BYTE3_SEP_BYTE4;
+				break;
+			}
+			goto reject;
+		case BYTE3_SEP_BYTE4:
+			if (isxdigit((unsigned char)*s)) {
+				buf[4] = xdtoi(*s);
+				fsm_state = BYTE4_X;
+				break;
+			}
+			goto reject;
+		case BYTE4_X:
+			if (*s == sep) {
+				fsm_state = BYTE4_SEP_BYTE5;
+				break;
+			}
+			if (isxdigit((unsigned char)*s)) {
+				buf[4] = (u_char)(buf[4] << 4) | xdtoi(*s);
+				fsm_state = BYTE4_XX;
+				break;
+			}
+			goto reject;
+		case BYTE4_XX:
+			if (*s == sep) {
+				fsm_state = BYTE4_SEP_BYTE5;
+				break;
+			}
+			goto reject;
+		case BYTE4_SEP_BYTE5:
+			if (isxdigit((unsigned char)*s)) {
+				buf[5] = xdtoi(*s);
+				fsm_state = BYTE5_X;
+				break;
+			}
+			goto reject;
+		case BYTE5_X:
+			if (isxdigit((unsigned char)*s)) {
+				buf[5] = (u_char)(buf[5] << 4) | xdtoi(*s);
+				fsm_state = BYTE5_XX;
+				break;
+			}
+			goto reject;
+		case BYTE5_XX:
+			goto reject;
+		}
+		s++;
+	}
+
+	if (fsm_state == BYTE5_X || fsm_state == BYTE5_XX) {
+		/* accept */
+		memcpy(addr, buf, sizeof(buf));
+		return 1;
+	}
+
+reject:
+	return 0;
+}
+
+// The 'addr' argument must point to an array of at least 6 elements.
+static int
+atomac48(const char *s, u_char *addr)
+{
+	return s && (
+	    atomac48_xxxxxxxxxxxx(s, addr) ||
+	    atomac48_xxxx_3_times(s, addr) ||
+	    atomac48_x_xx_6_times(s, addr)
+	);
+}
+
 
 int
 eth_pton(const char *p, eth_addr_t *eth)
 {
-	char *ep;
-	long l;
-	int i;
-	
-	for (i = 0; i < ETH_ADDR_LEN; i++) {
-		l = strtol(p, &ep, 16);
-		if (ep == p || l < 0 || l > 0xff ||
-		    (i < ETH_ADDR_LEN - 1 && *ep != ':'))
-			break;
-		eth->data[i] = (u_char)l;
-		p = ep + 1;
+	u_char tmp[ETH_ADDR_LEN];
+	if (atomac48(p, tmp)) {
+		memcpy(eth->data, tmp, ETH_ADDR_LEN);
+		return 0;
 	}
-	return ((i == ETH_ADDR_LEN && *ep == '\0') ? 0 : -1);
+	return -1;
 }
 
 char *
-- 
2.45.4

