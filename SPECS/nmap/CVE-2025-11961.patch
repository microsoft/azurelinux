From fdcfe0427e0c6cd0c6d76b1f381313d8c01c3b44 Mon Sep 17 00:00:00 2001
From: AllSpark <allspark@microsoft.com>
Date: Mon, 5 Jan 2026 09:30:21 +0000
Subject: [PATCH] CVE-2025-11961: Harden MAC-48 parsing to prevent OOB
 reads/writes.

Replace naive len-17 + separator-based parse in parseMAC() with validated format parsers:
- xxxxxxxxxxxx (12 hex digits)
- xxxx.xxxx.xxxx (Cisco-style with dots)
- xx:xx:xx:xx:xx:xx and variants with '-', '.'; single hex nibble allowed per byte via FSM.

Preserve behavior for 'random' and 'broadcast'.

Backported from upstream libpcap change to pcap_ether_aton() with adaptation for nping.

Signed-off-by: Azure Linux Security Servicing Account <azurelinux-security@microsoft.com>
Upstream-reference: AI Backport of https://github.com/the-tcpdump-group/libpcap/commit/b2d2f9a9a0581c40780bde509f7cc715920f1c02.patch
---
 nping/utils_net.cc | 363 ++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 341 insertions(+), 22 deletions(-)

diff --git a/nping/utils_net.cc b/nping/utils_net.cc
index e132e02..03b4307 100644
--- a/nping/utils_net.cc
+++ b/nping/utils_net.cc
@@ -761,10 +761,343 @@ int hostentfree(struct hostent *src){
  *  @return OP_SUCCESS on success and OP_FAILURE in case of error.
  *  Buffer targetbuff is NOT modified if "txt" does not have the proper
  *  format */
+/* Helper: convert hex digit to integer nibble */
+static inline u8 nping_xdtoi(char c) {
+  if (c >= '0' && c <= '9') return (u8)(c - '0');
+  c = (char)tolower((unsigned char)c);
+  if (c >= 'a' && c <= 'f') return (u8)(10 + (c - 'a'));
+  return 0;
+}
+
+/* Man page: "xxxxxxxxxxxx", regexp: "^[0-9a-fA-F]{12}$". */
+static int nping_atomac48_xxxxxxxxxxxx(const char *s, u8 *addr) {
+  if (strlen(s) == 12 &&
+      isxdigit((unsigned char)s[0]) &&
+      isxdigit((unsigned char)s[1]) &&
+      isxdigit((unsigned char)s[2]) &&
+      isxdigit((unsigned char)s[3]) &&
+      isxdigit((unsigned char)s[4]) &&
+      isxdigit((unsigned char)s[5]) &&
+      isxdigit((unsigned char)s[6]) &&
+      isxdigit((unsigned char)s[7]) &&
+      isxdigit((unsigned char)s[8]) &&
+      isxdigit((unsigned char)s[9]) &&
+      isxdigit((unsigned char)s[10]) &&
+      isxdigit((unsigned char)s[11])) {
+    addr[0] = (nping_xdtoi(s[0]) << 4) | nping_xdtoi(s[1]);
+    addr[1] = (nping_xdtoi(s[2]) << 4) | nping_xdtoi(s[3]);
+    addr[2] = (nping_xdtoi(s[4]) << 4) | nping_xdtoi(s[5]);
+    addr[3] = (nping_xdtoi(s[6]) << 4) | nping_xdtoi(s[7]);
+    addr[4] = (nping_xdtoi(s[8]) << 4) | nping_xdtoi(s[9]);
+    addr[5] = (nping_xdtoi(s[10]) << 4) | nping_xdtoi(s[11]);
+    return 1;
+  }
+  return 0;
+}
+
+/* Man page: "xxxx.xxxx.xxxx", regexp: "^[0-9a-fA-F]{4}(\.[0-9a-fA-F]{4}){2}$". */
+static int nping_atomac48_xxxx_3_times(const char *s, u8 *addr) {
+  const char sep = '.';
+  if (strlen(s) == 14 &&
+      isxdigit((unsigned char)s[0]) &&
+      isxdigit((unsigned char)s[1]) &&
+      isxdigit((unsigned char)s[2]) &&
+      isxdigit((unsigned char)s[3]) &&
+      s[4] == sep &&
+      isxdigit((unsigned char)s[5]) &&
+      isxdigit((unsigned char)s[6]) &&
+      isxdigit((unsigned char)s[7]) &&
+      isxdigit((unsigned char)s[8]) &&
+      s[9] == sep &&
+      isxdigit((unsigned char)s[10]) &&
+      isxdigit((unsigned char)s[11]) &&
+      isxdigit((unsigned char)s[12]) &&
+      isxdigit((unsigned char)s[13])) {
+    addr[0] = (nping_xdtoi(s[0]) << 4) | nping_xdtoi(s[1]);
+    addr[1] = (nping_xdtoi(s[2]) << 4) | nping_xdtoi(s[3]);
+    addr[2] = (nping_xdtoi(s[5]) << 4) | nping_xdtoi(s[6]);
+    addr[3] = (nping_xdtoi(s[7]) << 4) | nping_xdtoi(s[8]);
+    addr[4] = (nping_xdtoi(s[10]) << 4) | nping_xdtoi(s[11]);
+    addr[5] = (nping_xdtoi(s[12]) << 4) | nping_xdtoi(s[13]);
+    return 1;
+  }
+  return 0;
+}
+
+/*
+ * Man page: "xx:xx:xx:xx:xx:xx", regexp: "^[0-9a-fA-F]{1,2}(:[0-9a-fA-F]{1,2}){5}$".
+ * Man page: "xx-xx-xx-xx-xx-xx", regexp: "^[0-9a-fA-F]{1,2}(-[0-9a-fA-F]{1,2}){5}$".
+ * Man page: "xx.xx.xx.xx.xx.xx", regexp: "^[0-9a-fA-F]{1,2}(\.[0-9a-fA-F]{1,2}){5}$".
+ * (Any "xx" above can be "x", which is equivalent to "0x".)
+ *
+ * An equivalent (and parametrisable for EUI-64) FSM could be implemented using
+ * a smaller graph, but that graph would be neither acyclic nor planar nor
+ * trivial to verify.
+ *
+ *                |
+ *    [.]         v
+ * +<---------- START
+ * |              |
+ * |              | [0-9a-fA-F]
+ * |  [.]         v
+ * +<--------- BYTE0_X ----------+
+ * |              |              |
+ * |              | [0-9a-fA-F]  |
+ * |  [.]         v              |
+ * +<--------- BYTE0_XX          | [:\.-]
+ * |              |              |
+ * |              | [:\.-]       |
+ * |  [.]         v              |
+ * +<----- BYTE0_SEP_BYTE1 <-----+
+ * |              |
+ * |              | [0-9a-fA-F]
+ * |  [.]         v
+ * +<--------- BYTE1_X ----------+
+ * |              |              |
+ * |              | [0-9a-fA-F]  |
+ * |  [.]         v              |
+ * +<--------- BYTE1_XX          | <sep>
+ * |              |              |
+ * |              | <sep>        |
+ * |  [.]         v              |
+ * +<----- BYTE1_SEP_BYTE2 <-----+
+ * |              |
+ * |              | [0-9a-fA-F]
+ * |  [.]         v
+ * +<--------- BYTE2_X ----------+
+ * |              |              |
+ * |              | [0-9a-fA-F]  |
+ * |  [.]         v              |
+ * +<--------- BYTE2_XX          | <sep>
+ * |              |              |
+ * |              | <sep>        |
+ * |  [.]         v              |
+ * +<----- BYTE2_SEP_BYTE3 <-----+
+ * |              |
+ * |              | [0-9a-fA-F]
+ * |  [.]         v
+ * +<--------- BYTE3_X ----------+
+ * |              |              |
+ * |              | [0-9a-fA-F]  |
+ * |  [.]         v              |
+ * +<--------- BYTE3_XX          | <sep>
+ * |              |              |
+ * |              | <sep>        |
+ * |  [.]         v              |
+ * +<----- BYTE3_SEP_BYTE4 <-----+
+ * |              |
+ * |              | [0-9a-fA-F]
+ * |  [.]         v
+ * +<--------- BYTE4_X ----------+
+ * |              |              |
+ * |              | [0-9a-fA-F]  |
+ * |  [.]         v              |
+ * +<--------- BYTE4_XX          | <sep>
+ * |              |              |
+ * |              | <sep>        |
+ * |  [.]         v              |
+ * +<----- BYTE4_SEP_BYTE5 <-----+
+ * |              |
+ * |              | [0-9a-fA-F]
+ * |  [.]         v
+ * +<--------- BYTE5_X ----------+
+ * |              |              |
+ * |              | [0-9a-fA-F]  |
+ * |  [.]         v              |
+ * +<--------- BYTE5_XX          | \0
+ * |              |              |
+ * |              | \0           |
+ * |              |              v
+ * +--> (reject)  +---------> (accept)
+ *
+ */
+static int nping_atomac48_x_xx_6_times(const char *s, u8 *addr) {
+  enum {
+    START,
+    BYTE0_X,
+    BYTE0_XX,
+    BYTE0_SEP_BYTE1,
+    BYTE1_X,
+    BYTE1_XX,
+    BYTE1_SEP_BYTE2,
+    BYTE2_X,
+    BYTE2_XX,
+    BYTE2_SEP_BYTE3,
+    BYTE3_X,
+    BYTE3_XX,
+    BYTE3_SEP_BYTE4,
+    BYTE4_X,
+    BYTE4_XX,
+    BYTE4_SEP_BYTE5,
+    BYTE5_X,
+    BYTE5_XX,
+  } fsm_state = START;
+  u8 buf[6];
+  const char *seplist = ":.-";
+  char sep = 0;
+
+  while (*s) {
+    switch (fsm_state) {
+    case START:
+      if (isxdigit((unsigned char)*s)) {
+        buf[0] = nping_xdtoi(*s);
+        fsm_state = BYTE0_X;
+        break;
+      }
+      return 0;
+    case BYTE0_X:
+      if (strchr(seplist, *s)) {
+        sep = *s;
+        fsm_state = BYTE0_SEP_BYTE1;
+        break;
+      }
+      if (isxdigit((unsigned char)*s)) {
+        buf[0] = (u8)((buf[0] << 4) | nping_xdtoi(*s));
+        fsm_state = BYTE0_XX;
+        break;
+      }
+      return 0;
+    case BYTE0_XX:
+      if (strchr(seplist, *s)) {
+        sep = *s;
+        fsm_state = BYTE0_SEP_BYTE1;
+        break;
+      }
+      return 0;
+    case BYTE0_SEP_BYTE1:
+      if (isxdigit((unsigned char)*s)) {
+        buf[1] = nping_xdtoi(*s);
+        fsm_state = BYTE1_X;
+        break;
+      }
+      return 0;
+    case BYTE1_X:
+      if (*s == sep) {
+        fsm_state = BYTE1_SEP_BYTE2;
+        break;
+      }
+      if (isxdigit((unsigned char)*s)) {
+        buf[1] = (u8)((buf[1] << 4) | nping_xdtoi(*s));
+        fsm_state = BYTE1_XX;
+        break;
+      }
+      return 0;
+    case BYTE1_XX:
+      if (*s == sep) {
+        fsm_state = BYTE1_SEP_BYTE2;
+        break;
+      }
+      return 0;
+    case BYTE1_SEP_BYTE2:
+      if (isxdigit((unsigned char)*s)) {
+        buf[2] = nping_xdtoi(*s);
+        fsm_state = BYTE2_X;
+        break;
+      }
+      return 0;
+    case BYTE2_X:
+      if (*s == sep) {
+        fsm_state = BYTE2_SEP_BYTE3;
+        break;
+      }
+      if (isxdigit((unsigned char)*s)) {
+        buf[2] = (u8)((buf[2] << 4) | nping_xdtoi(*s));
+        fsm_state = BYTE2_XX;
+        break;
+      }
+      return 0;
+    case BYTE2_XX:
+      if (*s == sep) {
+        fsm_state = BYTE2_SEP_BYTE3;
+        break;
+      }
+      return 0;
+    case BYTE2_SEP_BYTE3:
+      if (isxdigit((unsigned char)*s)) {
+        buf[3] = nping_xdtoi(*s);
+        fsm_state = BYTE3_X;
+        break;
+      }
+      return 0;
+    case BYTE3_X:
+      if (*s == sep) {
+        fsm_state = BYTE3_SEP_BYTE4;
+        break;
+      }
+      if (isxdigit((unsigned char)*s)) {
+        buf[3] = (u8)((buf[3] << 4) | nping_xdtoi(*s));
+        fsm_state = BYTE3_XX;
+        break;
+      }
+      return 0;
+    case BYTE3_XX:
+      if (*s == sep) {
+        fsm_state = BYTE3_SEP_BYTE4;
+        break;
+      }
+      return 0;
+    case BYTE3_SEP_BYTE4:
+      if (isxdigit((unsigned char)*s)) {
+        buf[4] = nping_xdtoi(*s);
+        fsm_state = BYTE4_X;
+        break;
+      }
+      return 0;
+    case BYTE4_X:
+      if (*s == sep) {
+        fsm_state = BYTE4_SEP_BYTE5;
+        break;
+      }
+      if (isxdigit((unsigned char)*s)) {
+        buf[4] = (u8)((buf[4] << 4) | nping_xdtoi(*s));
+        fsm_state = BYTE4_XX;
+        break;
+      }
+      return 0;
+    case BYTE4_XX:
+      if (*s == sep) {
+        fsm_state = BYTE4_SEP_BYTE5;
+        break;
+      }
+      return 0;
+    case BYTE4_SEP_BYTE5:
+      if (isxdigit((unsigned char)*s)) {
+        buf[5] = nping_xdtoi(*s);
+        fsm_state = BYTE5_X;
+        break;
+      }
+      return 0;
+    case BYTE5_X:
+      if (isxdigit((unsigned char)*s)) {
+        buf[5] = (u8)((buf[5] << 4) | nping_xdtoi(*s));
+        fsm_state = BYTE5_XX;
+        break;
+      }
+      return 0;
+    case BYTE5_XX:
+      return 0;
+    }
+    s++;
+  }
+
+  if (fsm_state == BYTE5_X || fsm_state == BYTE5_XX) {
+    memcpy(addr, buf, sizeof(buf));
+    return 1;
+  }
+  return 0;
+}
+
+/* The 'addr' argument must point to an array of at least 6 elements. */
+static int nping_atomac48(const char *s, u8 *addr) {
+  return s && (
+    nping_atomac48_xxxxxxxxxxxx(s, addr) ||
+    nping_atomac48_xxxx_3_times(s, addr) ||
+    nping_atomac48_x_xx_6_times(s, addr)
+  );
+}
+
 int parseMAC(const char *txt, u8 *targetbuff){
   u8 mac_data[6];
-  char tmphex[3];
-  int i=0, j=0;
 
   if( txt==NULL || targetbuff==NULL )
     return OP_FAILURE;
@@ -779,27 +1112,13 @@ int parseMAC(const char *txt, u8 *targetbuff){
     return OP_SUCCESS;
   }
 
-  /* Array should look like  00:13:01:e6:c7:ae  or  00-13-01-e6-c7-ae
-     Array positions:        01234567890123456      01234567890123456  */
-  if( strlen(txt)!=17 )
-    return OP_FAILURE;
-  /* Check MAC has the correct ':' or '-' characters */
-  if( (txt[2]!=':' && txt[2]!='-') || (txt[5]!=':' && txt[5]!='-')   ||
-      (txt[8]!=':' && txt[8]!='-') || (txt[11]!=':' && txt[11]!='-') ||
-      (txt[14]!=':' && txt[14]!='-') )
-      return OP_FAILURE;
-
-  /* Convert txt into actual bytes */
-  for(i=0, j=0; i<6; i++, j+=3 ){
-    if( !isxdigit(txt[j]) || !isxdigit(txt[j+1]) )
-        return OP_FAILURE;
-    tmphex[0] = txt[j];
-    tmphex[1] = txt[j+1];
-    tmphex[2] = '\0';
-    mac_data[i] = (u8) strtol(tmphex, NULL, 16);
+  /* Try to parse one of the supported formats safely */
+  if (nping_atomac48(txt, mac_data)) {
+    memcpy(targetbuff, mac_data, 6);
+    return OP_SUCCESS;
   }
-  memcpy(targetbuff, mac_data, 6);
-  return OP_SUCCESS;
+
+  return OP_FAILURE;
 } /* End of parseMAC() */
 
 
-- 
2.45.4

