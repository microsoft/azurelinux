From 0c05b3adb5e5479582e96110b6dcddf107a87f11 Mon Sep 17 00:00:00 2001
From: Kshitiz Godara <kgodara@microsoft.com>
Date: Mon, 31 Mar 2025 17:30:42 +0000
Subject: [PATCH] Fix for CVE-2025-29786

Upstream source:
https://github.com/expr-lang/expr/pull/762

Signed-off-by: Kshitiz Godara <kgodara@microsoft.com>
---
 .../github.com/antonmedv/expr/conf/config.go  |  42 ++--
 .../antonmedv/expr/parser/parser.go           | 199 ++++++++++++------
 vendor/github.com/antonmedv/expr/vm/vm.go     |  27 ++-
 3 files changed, 187 insertions(+), 81 deletions(-)

diff --git a/vendor/github.com/antonmedv/expr/conf/config.go b/vendor/github.com/antonmedv/expr/conf/config.go
index 1ac0fa7..d9a72d4 100644
--- a/vendor/github.com/antonmedv/expr/conf/config.go
+++ b/vendor/github.com/antonmedv/expr/conf/config.go
@@ -9,27 +9,39 @@ import (
 	"github.com/antonmedv/expr/vm/runtime"
 )
 
+const (
+	// DefaultMemoryBudget represents an upper limit of memory usage
+	DefaultMemoryBudget uint = 1e6
+
+	// DefaultMaxNodes represents an upper limit of AST nodes
+	DefaultMaxNodes uint = 10000
+)
+
 type Config struct {
-	Env         interface{}
-	Types       TypesTable
-	MapEnv      bool
-	DefaultType reflect.Type
-	Operators   OperatorsTable
-	Expect      reflect.Kind
-	Optimize    bool
-	Strict      bool
-	ConstFns    map[string]reflect.Value
-	Visitors    []ast.Visitor
-	Functions   map[string]*builtin.Function
+	Env          interface{}
+	Types        TypesTable
+	MapEnv       bool
+	DefaultType  reflect.Type
+	Operators    OperatorsTable
+	Expect       reflect.Kind
+	Optimize     bool
+	Strict       bool
+	MaxNodes     uint
+	MemoryBudget uint
+	ConstFns     map[string]reflect.Value
+	Visitors     []ast.Visitor
+	Functions    map[string]*builtin.Function
 }
 
 // CreateNew creates new config with default values.
 func CreateNew() *Config {
 	c := &Config{
-		Operators: make(map[string][]string),
-		ConstFns:  make(map[string]reflect.Value),
-		Functions: make(map[string]*builtin.Function),
-		Optimize:  true,
+		Operators:    make(map[string][]string),
+		MaxNodes:     DefaultMaxNodes,
+		MemoryBudget: DefaultMemoryBudget,
+		ConstFns:     make(map[string]reflect.Value),
+		Functions:    make(map[string]*builtin.Function),
+		Optimize:     true,
 	}
 	for _, f := range builtin.Builtins {
 		c.Functions[f.Name] = f
diff --git a/vendor/github.com/antonmedv/expr/parser/parser.go b/vendor/github.com/antonmedv/expr/parser/parser.go
index fd26fe1..d395cc0 100644
--- a/vendor/github.com/antonmedv/expr/parser/parser.go
+++ b/vendor/github.com/antonmedv/expr/parser/parser.go
@@ -7,6 +7,7 @@ import (
 	"unicode/utf8"
 
 	. "github.com/antonmedv/expr/ast"
+	"github.com/antonmedv/expr/conf"
 	"github.com/antonmedv/expr/file"
 	. "github.com/antonmedv/expr/parser/lexer"
 )
@@ -72,11 +73,48 @@ var builtins = map[string]builtin{
 }
 
 type parser struct {
-	tokens  []Token
-	current Token
-	pos     int
-	err     *file.Error
-	depth   int // closure call depth
+	tokens    []Token
+	current   Token
+	pos       int
+	err       *file.Error
+	depth     int // closure call depth
+	config    *conf.Config
+	nodeCount uint // tracks number of AST nodes created
+}
+
+
+// checkNodeLimit verifies that adding a new node won't exceed configured limits
+func (p *parser) checkNodeLimit() error {
+	p.nodeCount++
+	if p.config.MaxNodes > 0 && p.nodeCount > p.config.MaxNodes {
+		p.error("compilation failed: expression exceeds maximum allowed nodes")
+		return nil
+	}
+	return nil
+}
+
+// createNode handles creation of regular nodes
+func (p *parser) createNode(n Node, loc file.Location) Node {
+	if err := p.checkNodeLimit(); err != nil {
+		return nil
+	}
+	if n == nil || p.err != nil {
+		return nil
+	}
+	n.SetLocation(loc)
+	return n
+}
+
+// createMemberNode handles creation of member nodes
+func (p *parser) createMemberNode(n *MemberNode, loc file.Location) *MemberNode {
+	if err := p.checkNodeLimit(); err != nil {
+		return nil
+	}
+	if n == nil || p.err != nil {
+		return nil
+	}
+	n.SetLocation(loc)
+	return n
 }
 
 type Tree struct {
@@ -95,6 +133,7 @@ func Parse(input string) (*Tree, error) {
 	p := &parser{
 		tokens:  tokens,
 		current: tokens[0],
+		config: &conf.Config{},
 	}
 
 	node := p.parseExpression(0)
@@ -146,6 +185,10 @@ func (p *parser) expect(kind Kind, values ...string) {
 // parse functions
 
 func (p *parser) parseExpression(precedence int) Node {
+	if p.err != nil {
+		return nil
+	}
+
 	nodeLeft := p.parsePrimary()
 
 	lastOperator := ""
@@ -177,19 +220,23 @@ func (p *parser) parseExpression(precedence int) Node {
 					nodeRight = p.parseExpression(op.precedence)
 				}
 
-				nodeLeft = &BinaryNode{
+				nodeLeft = p.createNode(&BinaryNode{
 					Operator: opToken.Value,
 					Left:     nodeLeft,
 					Right:    nodeRight,
+				}, opToken.Location)
+				if nodeLeft == nil {
+					return nil
 				}
-				nodeLeft.SetLocation(opToken.Location)
 
 				if negate {
-					nodeLeft = &UnaryNode{
+					nodeLeft = p.createNode(&UnaryNode{
 						Operator: "not",
 						Node:     nodeLeft,
+					}, notToken.Location)
+					if nodeLeft == nil {
+						return nil
 					}
-					nodeLeft.SetLocation(notToken.Location)
 				}
 
 				lastOperator = opToken.Value
@@ -214,11 +261,13 @@ func (p *parser) parsePrimary() Node {
 		if op, ok := unaryOperators[token.Value]; ok {
 			p.next()
 			expr := p.parseExpression(op.precedence)
-			node := &UnaryNode{
+			node := p.createNode(&UnaryNode{
 				Operator: token.Value,
 				Node:     expr,
+			}, token.Location)
+			if node == nil {
+				return nil
 			}
-			node.SetLocation(token.Location)
 			return p.parsePostfixExpression(node)
 		}
 	}
@@ -235,8 +284,10 @@ func (p *parser) parsePrimary() Node {
 			if token.Is(Operator, "#") {
 				p.next()
 			}
-			node := &PointerNode{}
-			node.SetLocation(token.Location)
+			node := p.createNode(&PointerNode{}, token.Location)
+			if node == nil {
+				return nil
+			}
 			return p.parsePostfixExpression(node)
 		}
 	} else {
@@ -263,10 +314,13 @@ func (p *parser) parseConditionalExpression(node Node) Node {
 			expr2 = p.parseExpression(0)
 		}
 
-		node = &ConditionalNode{
+		node = p.createNode(&ConditionalNode{
 			Cond: node,
 			Exp1: expr1,
 			Exp2: expr2,
+		}, p.current.Location)
+		if node == nil {
+			return nil
 		}
 	}
 	return node
@@ -282,16 +336,13 @@ func (p *parser) parsePrimaryExpression() Node {
 		p.next()
 		switch token.Value {
 		case "true":
-			node := &BoolNode{Value: true}
-			node.SetLocation(token.Location)
+			node := p.createNode(&BoolNode{Value: true}, token.Location)
 			return node
 		case "false":
-			node := &BoolNode{Value: false}
-			node.SetLocation(token.Location)
+			node := p.createNode(&BoolNode{Value: false}, token.Location)
 			return node
 		case "nil":
-			node := &NilNode{}
-			node.SetLocation(token.Location)
+			node := p.createNode(&NilNode{}, token.Location)
 			return node
 		default:
 			node = p.parseIdentifierExpression(token)
@@ -305,31 +356,27 @@ func (p *parser) parsePrimaryExpression() Node {
 			if err != nil {
 				p.error("invalid hex literal: %v", err)
 			}
-			node := &IntegerNode{Value: int(number)}
-			node.SetLocation(token.Location)
+			node := p.createNode(&IntegerNode{Value: int(number)}, token.Location)
 			return node
 		} else if strings.ContainsAny(value, ".eE") {
 			number, err := strconv.ParseFloat(value, 64)
 			if err != nil {
 				p.error("invalid float literal: %v", err)
 			}
-			node := &FloatNode{Value: number}
-			node.SetLocation(token.Location)
+			node := p.createNode(&FloatNode{Value: number}, token.Location)
 			return node
 		} else {
 			number, err := strconv.ParseInt(value, 10, 64)
 			if err != nil {
 				p.error("invalid integer literal: %v", err)
 			}
-			node := &IntegerNode{Value: int(number)}
-			node.SetLocation(token.Location)
+			node := p.createNode(&IntegerNode{Value: int(number)}, token.Location)
 			return node
 		}
 
 	case String:
 		p.next()
-		node := &StringNode{Value: token.Value}
-		node.SetLocation(token.Location)
+		node := p.createNode(&StringNode{Value: token.Value}, token.Location)
 		return node
 
 	default:
@@ -364,23 +411,32 @@ func (p *parser) parseIdentifierExpression(token Token) Node {
 			}
 			p.expect(Bracket, ")")
 
-			node = &BuiltinNode{
+			node = p.createNode(&BuiltinNode{
 				Name:      token.Value,
 				Arguments: arguments,
+			}, token.Location)
+			if node == nil {
+				return nil
 			}
-			node.SetLocation(token.Location)
 		} else {
-			callee := &IdentifierNode{Value: token.Value}
-			callee.SetLocation(token.Location)
-			node = &CallNode{
+			callee := p.createNode(&IdentifierNode{Value: token.Value}, token.Location)
+			if callee == nil {
+				return nil
+			}
+			node = p.createNode(&CallNode{
 				Callee:    callee,
 				Arguments: p.parseArguments(),
+			}, token.Location)
+
+			if node == nil {
+				return nil
 			}
-			node.SetLocation(token.Location)
 		}
 	} else {
-		node = &IdentifierNode{Value: token.Value}
-		node.SetLocation(token.Location)
+		node = p.createNode(&IdentifierNode{Value: token.Value}, token.Location)
+		if node == nil {
+			return nil
+		}
 	}
 	return node
 }
@@ -400,10 +456,9 @@ func (p *parser) parseClosure() Node {
 	if expectClosingBracket {
 		p.expect(Bracket, "}")
 	}
-	closure := &ClosureNode{
+	closure := p.createNode(&ClosureNode{
 		Node: node,
-	}
-	closure.SetLocation(startToken.Location)
+	}, startToken.Location)
 	return closure
 }
 
@@ -424,8 +479,10 @@ func (p *parser) parseArrayExpression(token Token) Node {
 end:
 	p.expect(Bracket, "]")
 
-	node := &ArrayNode{Nodes: nodes}
-	node.SetLocation(token.Location)
+	node := p.createNode(&ArrayNode{Nodes: nodes}, token.Location)
+	if node == nil {
+		return nil
+	}
 	return node
 }
 
@@ -451,8 +508,10 @@ func (p *parser) parseMapExpression(token Token) Node {
 		//  * identifier, which is equivalent to a string
 		//  * expression, which must be enclosed in parentheses -- (1 + 2)
 		if p.current.Is(Number) || p.current.Is(String) || p.current.Is(Identifier) {
-			key = &StringNode{Value: p.current.Value}
-			key.SetLocation(token.Location)
+			key = p.createNode(&StringNode{Value: p.current.Value}, p.current.Location)
+			if key == nil {
+				return nil
+			}
 			p.next()
 		} else if p.current.Is(Bracket, "(") {
 			key = p.parseExpression(0)
@@ -463,16 +522,20 @@ func (p *parser) parseMapExpression(token Token) Node {
 		p.expect(Operator, ":")
 
 		node := p.parseExpression(0)
-		pair := &PairNode{Key: key, Value: node}
-		pair.SetLocation(token.Location)
+		pair := p.createNode(&PairNode{Key: key, Value: node}, token.Location)
+		if pair == nil {
+			return nil
+		}
 		nodes = append(nodes, pair)
 	}
 
 end:
 	p.expect(Bracket, "}")
 
-	node := &MapNode{Pairs: nodes}
-	node.SetLocation(token.Location)
+	node := p.createNode(&MapNode{Pairs: nodes}, token.Location)
+	if node == nil {
+		return nil
+	}
 	return node
 }
 
@@ -491,8 +554,10 @@ func (p *parser) parsePostfixExpression(node Node) Node {
 				p.error("expected name")
 			}
 
-			property := &StringNode{Value: propertyToken.Value}
-			property.SetLocation(propertyToken.Location)
+			property := p.createNode(&StringNode{Value: propertyToken.Value}, propertyToken.Location)
+			if property == nil {
+				return nil
+			}
 
 			chainNode, isChain := node.(*ChainNode)
 			optional := postfixToken.Value == "?."
@@ -501,25 +566,32 @@ func (p *parser) parsePostfixExpression(node Node) Node {
 				node = chainNode.Node
 			}
 
-			memberNode := &MemberNode{
+			memberNode := p.createMemberNode(&MemberNode{
 				Node:     node,
 				Property: property,
 				Optional: optional,
+			}, propertyToken.Location)
+			if memberNode == nil {
+				return nil
 			}
-			memberNode.SetLocation(propertyToken.Location)
 
 			if p.current.Is(Bracket, "(") {
-				node = &CallNode{
+				node = p.createNode(&CallNode{
 					Callee:    memberNode,
 					Arguments: p.parseArguments(),
+				}, propertyToken.Location)
+				if node == nil {
+					return nil
 				}
-				node.SetLocation(propertyToken.Location)
 			} else {
 				node = memberNode
 			}
 
 			if isChain || optional {
-				node = &ChainNode{Node: node}
+				node = p.createNode(&ChainNode{Node: node}, propertyToken.Location)
+				if node == nil {
+					return nil
+				}
 			}
 
 		} else if postfixToken.Value == "[" {
@@ -533,11 +605,13 @@ func (p *parser) parsePostfixExpression(node Node) Node {
 					to = p.parseExpression(0)
 				}
 
-				node = &SliceNode{
+				node = p.createNode(&SliceNode{
 					Node: node,
 					To:   to,
+				}, postfixToken.Location)
+				if node == nil {
+					return nil
 				}
-				node.SetLocation(postfixToken.Location)
 				p.expect(Bracket, "]")
 
 			} else {
@@ -551,22 +625,27 @@ func (p *parser) parsePostfixExpression(node Node) Node {
 						to = p.parseExpression(0)
 					}
 
-					node = &SliceNode{
+					node = p.createNode(&SliceNode{
 						Node: node,
 						From: from,
 						To:   to,
+					}, postfixToken.Location)
+
+					if node == nil {
+						return nil
 					}
-					node.SetLocation(postfixToken.Location)
 					p.expect(Bracket, "]")
 
 				} else {
 					// Slice operator [:] was not found,
 					// it should be just an index node.
-					node = &MemberNode{
+					node = p.createMemberNode(&MemberNode{
 						Node:     node,
 						Property: from,
+					}, postfixToken.Location)
+					if node == nil {
+						return nil
 					}
-					node.SetLocation(postfixToken.Location)
 					p.expect(Bracket, "]")
 				}
 			}
diff --git a/vendor/github.com/antonmedv/expr/vm/vm.go b/vendor/github.com/antonmedv/expr/vm/vm.go
index ec22c25..52122ed 100644
--- a/vendor/github.com/antonmedv/expr/vm/vm.go
+++ b/vendor/github.com/antonmedv/expr/vm/vm.go
@@ -9,11 +9,11 @@ import (
 	"strings"
 
 	"github.com/antonmedv/expr/builtin"
+	"github.com/antonmedv/expr/conf"
 	"github.com/antonmedv/expr/file"
 	"github.com/antonmedv/expr/vm/runtime"
 )
 
-var MemoryBudget int = 1e6
 var errorType = reflect.TypeOf((*error)(nil)).Elem()
 
 type Function = func(params ...interface{}) (interface{}, error)
@@ -27,6 +27,19 @@ func Run(program *Program, env interface{}) (interface{}, error) {
 	return vm.Run(program, env)
 }
 
+func RunWithConfig(program *Program, env interface{}, config *conf.Config) (interface{}, error) {
+	if program == nil {
+		return nil, fmt.Errorf("program is nil")
+	}
+	if config == nil {
+		return nil, fmt.Errorf("config is nil")
+	}
+	vm := VM{
+		MemoryBudget: int(config.MemoryBudget),
+	}
+	return vm.Run(program, env)
+}
+
 type VM struct {
 	stack        []interface{}
 	ip           int
@@ -35,7 +48,7 @@ type VM struct {
 	step         chan struct{}
 	curr         chan int
 	memory       int
-	memoryBudget int
+	MemoryBudget int
 }
 
 type Scope struct {
@@ -78,7 +91,9 @@ func (vm *VM) Run(program *Program, env interface{}) (_ interface{}, err error)
 		vm.scopes = vm.scopes[0:0]
 	}
 
-	vm.memoryBudget = MemoryBudget
+	if vm.MemoryBudget == 0 {
+		vm.MemoryBudget = int(conf.DefaultMemoryBudget)
+	}
 	vm.memory = 0
 	vm.ip = 0
 
@@ -258,7 +273,7 @@ func (vm *VM) Run(program *Program, env interface{}) (_ interface{}, err error)
 			min := runtime.ToInt(a)
 			max := runtime.ToInt(b)
 			size := max - min + 1
-			if vm.memory+size >= vm.memoryBudget {
+			if vm.memory+size >= vm.MemoryBudget {
 				panic("memory budget exceeded")
 			}
 			vm.push(runtime.MakeRange(min, max))
@@ -389,7 +404,7 @@ func (vm *VM) Run(program *Program, env interface{}) (_ interface{}, err error)
 			}
 			vm.push(array)
 			vm.memory += size
-			if vm.memory >= vm.memoryBudget {
+			if vm.memory >= vm.MemoryBudget {
 				panic("memory budget exceeded")
 			}
 
@@ -403,7 +418,7 @@ func (vm *VM) Run(program *Program, env interface{}) (_ interface{}, err error)
 			}
 			vm.push(m)
 			vm.memory += size
-			if vm.memory >= vm.memoryBudget {
+			if vm.memory >= vm.MemoryBudget {
 				panic("memory budget exceeded")
 			}
 
-- 
2.45.3

