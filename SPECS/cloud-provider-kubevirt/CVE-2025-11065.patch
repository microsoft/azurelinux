From 7a96c529715b9645afc4d9f8fc1dd2141ecc28b6 Mon Sep 17 00:00:00 2001
From: AllSpark <allspark@microsoft.com>
Date: Fri, 30 Jan 2026 11:46:37 +0000
Subject: [PATCH] fix: error message leaks

Signed-off-by: AllSpark <allspark@microsoft.com>
Signed-off-by: Azure Linux Security Servicing Account <azurelinux-security@microsoft.com>
Upstream-reference: AI Backport of https://github.com/go-viper/mapstructure/commit/742921c9ba2854d27baa64272487fc5075d2c39c.patch
---
 decode_hooks.go | 258 ++++++++++++++++++++++++++++++++++++++++++++++++
 errors.go       | 126 +++++++++++++++++++++++
 mapstructure.go |  46 +++++++++
 3 files changed, 430 insertions(+)
 create mode 100644 decode_hooks.go
 create mode 100644 errors.go
 create mode 100644 mapstructure.go

diff --git a/decode_hooks.go b/decode_hooks.go
new file mode 100644
index 0000000..57d3ffb
--- /dev/null
+++ b/decode_hooks.go
@@ -0,0 +1,258 @@
+// Backport patch: fix error message leaks
+// This file includes DecodeHookFuncs updated to wrap errors in consistent messages
+package mapstructure
+
+import (
+    "fmt"
+    "net"
+    "net/url"
+    "net/netip"
+    "reflect"
+    "strconv"
+    "time"
+)
+
+// DecodeHookFunc is a function signature for hooks
+type DecodeHookFunc func(from reflect.Type, to reflect.Type, data interface{}) (interface{}, error)
+
+// StringToTimeDurationHookFunc converts strings to time.Duration with wrapped errors
+func StringToTimeDurationHookFunc() DecodeHookFunc {
+    return func(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {
+        if f.Kind() != reflect.String || t != reflect.TypeOf(time.Duration(0)) {
+            return data, nil
+        }
+        d, err := time.ParseDuration(data.(string))
+        return d, wrapTimeParseDurationError(err)
+    }
+}
+
+// StringToURLHookFunc converts strings to *url.URL with wrapped errors
+func StringToURLHookFunc() DecodeHookFunc {
+    return func(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {
+        if f.Kind() != reflect.String || t != reflect.TypeOf(&url.URL{}) {
+            return data, nil
+        }
+        u, err := url.Parse(data.(string))
+        return u, wrapUrlError(err)
+    }
+}
+
+// StringToIPHookFunc converts strings to net.IP and avoids leaking the input value
+func StringToIPHookFunc() DecodeHookFunc {
+    return func(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {
+        if f.Kind() != reflect.String || t != reflect.TypeOf(net.IP{}) {
+            return data, nil
+        }
+        ip := net.ParseIP(data.(string))
+        if ip == nil {
+            return net.IP{}, fmt.Errorf("failed parsing ip")
+        }
+        return ip, nil
+    }
+}
+
+// StringToIPNetHookFunc converts strings to *net.IPNet with wrapped errors
+func StringToIPNetHookFunc() DecodeHookFunc {
+    return func(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {
+        if f.Kind() != reflect.String || t != reflect.TypeOf(&net.IPNet{}) {
+            return data, nil
+        }
+        _, netw, err := net.ParseCIDR(data.(string))
+        return netw, wrapNetParseError(err)
+    }
+}
+
+// StringToTimeHookFunc converts strings to time.Time with layout and wrapped errors
+func StringToTimeHookFunc(layout string) DecodeHookFunc {
+    return func(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {
+        if f.Kind() != reflect.String || t != reflect.TypeOf(time.Time{}) {
+            return data, nil
+        }
+        ti, err := time.Parse(layout, data.(string))
+        return ti, wrapTimeParseError(err)
+    }
+}
+
+// StringToNetIPAddrHookFunc converts strings to netip.Addr with wrapped errors
+func StringToNetIPAddrHookFunc() DecodeHookFunc {
+    return func(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {
+        if f.Kind() != reflect.String || t != reflect.TypeOf(netip.Addr{}) {
+            return data, nil
+        }
+        addr, err := netip.ParseAddr(data.(string))
+        return addr, wrapNetIPParseAddrError(err)
+    }
+}
+
+// StringToNetIPAddrPortHookFunc converts strings to netip.AddrPort with wrapped errors
+func StringToNetIPAddrPortHookFunc() DecodeHookFunc {
+    return func(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {
+        if f.Kind() != reflect.String || t != reflect.TypeOf(netip.AddrPort{}) {
+            return data, nil
+        }
+        addrPort, err := netip.ParseAddrPort(data.(string))
+        return addrPort, wrapNetIPParseAddrPortError(err)
+    }
+}
+
+// StringToNetIPPrefixHookFunc converts strings to netip.Prefix with wrapped errors
+func StringToNetIPPrefixHookFunc() DecodeHookFunc {
+    return func(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {
+        if f.Kind() != reflect.String || t != reflect.TypeOf(netip.Prefix{}) {
+            return data, nil
+        }
+        prefix, err := netip.ParsePrefix(data.(string))
+        return prefix, wrapNetIPParsePrefixError(err)
+    }
+}
+
+// Numeric hooks
+func StringToInt8HookFunc() DecodeHookFunc {
+    return func(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {
+        if f.Kind() != reflect.String || t.Kind() != reflect.Int8 {
+            return data, nil
+        }
+        i64, err := strconv.ParseInt(data.(string), 0, 8)
+        return int8(i64), wrapStrconvNumError(err)
+    }
+}
+
+func StringToUint8HookFunc() DecodeHookFunc {
+    return func(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {
+        if f.Kind() != reflect.String || t.Kind() != reflect.Uint8 {
+            return data, nil
+        }
+        u64, err := strconv.ParseUint(data.(string), 0, 8)
+        return uint8(u64), wrapStrconvNumError(err)
+    }
+}
+
+func StringToInt16HookFunc() DecodeHookFunc {
+    return func(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {
+        if f.Kind() != reflect.String || t.Kind() != reflect.Int16 {
+            return data, nil
+        }
+        i64, err := strconv.ParseInt(data.(string), 0, 16)
+        return int16(i64), wrapStrconvNumError(err)
+    }
+}
+
+func StringToUint16HookFunc() DecodeHookFunc {
+    return func(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {
+        if f.Kind() != reflect.String || t.Kind() != reflect.Uint16 {
+            return data, nil
+        }
+        u64, err := strconv.ParseUint(data.(string), 0, 16)
+        return uint16(u64), wrapStrconvNumError(err)
+    }
+}
+
+func StringToInt32HookFunc() DecodeHookFunc {
+    return func(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {
+        if f.Kind() != reflect.String || t.Kind() != reflect.Int32 {
+            return data, nil
+        }
+        i64, err := strconv.ParseInt(data.(string), 0, 32)
+        return int32(i64), wrapStrconvNumError(err)
+    }
+}
+
+func StringToUint32HookFunc() DecodeHookFunc {
+    return func(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {
+        if f.Kind() != reflect.String || t.Kind() != reflect.Uint32 {
+            return data, nil
+        }
+        u64, err := strconv.ParseUint(data.(string), 0, 32)
+        return uint32(u64), wrapStrconvNumError(err)
+    }
+}
+
+func StringToInt64HookFunc() DecodeHookFunc {
+    return func(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {
+        if f.Kind() != reflect.String || t.Kind() != reflect.Int64 {
+            return data, nil
+        }
+        i64, err := strconv.ParseInt(data.(string), 0, 64)
+        return int64(i64), wrapStrconvNumError(err)
+    }
+}
+
+func StringToUint64HookFunc() DecodeHookFunc {
+    return func(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {
+        if f.Kind() != reflect.String || t.Kind() != reflect.Uint64 {
+            return data, nil
+        }
+        u64, err := strconv.ParseUint(data.(string), 0, 64)
+        return uint64(u64), wrapStrconvNumError(err)
+    }
+}
+
+func StringToIntHookFunc() DecodeHookFunc {
+    return func(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {
+        if f.Kind() != reflect.String || t.Kind() != reflect.Int {
+            return data, nil
+        }
+        i64, err := strconv.ParseInt(data.(string), 0, 0)
+        return int(i64), wrapStrconvNumError(err)
+    }
+}
+
+func StringToUintHookFunc() DecodeHookFunc {
+    return func(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {
+        if f.Kind() != reflect.String || t.Kind() != reflect.Uint {
+            return data, nil
+        }
+        u64, err := strconv.ParseUint(data.(string), 0, 0)
+        return uint(u64), wrapStrconvNumError(err)
+    }
+}
+
+func StringToFloat32HookFunc() DecodeHookFunc {
+    return func(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {
+        if f.Kind() != reflect.String || t.Kind() != reflect.Float32 {
+            return data, nil
+        }
+        f64, err := strconv.ParseFloat(data.(string), 32)
+        return float32(f64), wrapStrconvNumError(err)
+    }
+}
+
+func StringToFloat64HookFunc() DecodeHookFunc {
+    return func(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {
+        if f.Kind() != reflect.String || t.Kind() != reflect.Float64 {
+            return data, nil
+        }
+        f64, err := strconv.ParseFloat(data.(string), 64)
+        return f64, wrapStrconvNumError(err)
+    }
+}
+
+func StringToBoolHookFunc() DecodeHookFunc {
+    return func(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {
+        if f.Kind() != reflect.String || t.Kind() != reflect.Bool {
+            return data, nil
+        }
+        b, err := strconv.ParseBool(data.(string))
+        return b, wrapStrconvNumError(err)
+    }
+}
+
+func StringToComplex64HookFunc() DecodeHookFunc {
+    return func(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {
+        if f.Kind() != reflect.String || t.Kind() != reflect.Complex64 {
+            return data, nil
+        }
+        c128, err := strconv.ParseComplex(data.(string), 64)
+        return complex64(c128), wrapStrconvNumError(err)
+    }
+}
+
+func StringToComplex128HookFunc() DecodeHookFunc {
+    return func(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {
+        if f.Kind() != reflect.String || t.Kind() != reflect.Complex128 {
+            return data, nil
+        }
+        c128, err := strconv.ParseComplex(data.(string), 128)
+        return c128, wrapStrconvNumError(err)
+    }
+}
diff --git a/errors.go b/errors.go
new file mode 100644
index 0000000..0a24da1
--- /dev/null
+++ b/errors.go
@@ -0,0 +1,126 @@
+package mapstructure
+
+import (
+    "errors"
+    "fmt"
+    "net"
+    "net/url"
+    "strconv"
+    "strings"
+    "time"
+)
+
+// Error interfaces and wrapping helpers backported to avoid leaking sensitive error messages
+
+func wrapStrconvNumError(err error) error {
+    if err == nil {
+        return nil
+    }
+    if err, ok := err.(*strconv.NumError); ok {
+        return &strconvNumError{Err: err}
+    }
+    return err
+}
+
+type strconvNumError struct {
+    Err *strconv.NumError
+}
+
+func (e *strconvNumError) Error() string {
+    return "strconv." + e.Err.Func + ": " + e.Err.Err.Error()
+}
+
+func (e *strconvNumError) Unwrap() error { return e.Err }
+
+func wrapUrlError(err error) error {
+    if err == nil {
+        return nil
+    }
+    if err, ok := err.(*url.Error); ok {
+        return &urlError{Err: err}
+    }
+    return err
+}
+
+type urlError struct {
+    Err *url.Error
+}
+
+func (e *urlError) Error() string { return fmt.Sprintf("%s", e.Err.Err) }
+func (e *urlError) Unwrap() error { return e.Err }
+
+func wrapNetParseError(err error) error {
+    if err == nil {
+        return nil
+    }
+    if err, ok := err.(*net.ParseError); ok {
+        return &netParseError{Err: err}
+    }
+    return err
+}
+
+type netParseError struct { Err *net.ParseError }
+
+func (e *netParseError) Error() string { return "invalid " + e.Err.Type }
+func (e *netParseError) Unwrap() error { return e.Err }
+
+func wrapTimeParseError(err error) error {
+    if err == nil {
+        return nil
+    }
+    if err, ok := err.(*time.ParseError); ok {
+        return &timeParseError{Err: err}
+    }
+    return err
+}
+
+type timeParseError struct { Err *time.ParseError }
+
+func (e *timeParseError) Error() string {
+    if e.Err.Message == "" {
+        return fmt.Sprintf("parsing time as %q: cannot parse as %q", e.Err.Layout, e.Err.LayoutElem)
+    }
+    return "parsing time " + e.Err.Message
+}
+func (e *timeParseError) Unwrap() error { return e.Err }
+
+func wrapNetIPParseAddrError(err error) error {
+    if err == nil { return nil }
+    if errMsg := err.Error(); strings.HasPrefix(errMsg, "ParseAddr") {
+        errPieces := strings.Split(errMsg, ": ")
+        return fmt.Errorf("ParseAddr: %s", errPieces[len(errPieces)-1])
+    }
+    return err
+}
+
+func wrapNetIPParseAddrPortError(err error) error {
+    if err == nil { return nil }
+    errMsg := err.Error()
+    if strings.HasPrefix(errMsg, "invalid port ") {
+        return errors.New("invalid port")
+    } else if strings.HasPrefix(errMsg, "invalid ip:port ") {
+        return errors.New("invalid ip:port")
+    }
+    return err
+}
+
+func wrapNetIPParsePrefixError(err error) error {
+    if err == nil { return nil }
+    if errMsg := err.Error(); strings.HasPrefix(errMsg, "netip.ParsePrefix") {
+        errPieces := strings.Split(errMsg, ": ")
+        return fmt.Errorf("netip.ParsePrefix: %s", errPieces[len(errPieces)-1])
+    }
+    return err
+}
+
+func wrapTimeParseDurationError(err error) error {
+    if err == nil { return nil }
+    errMsg := err.Error()
+    if strings.HasPrefix(errMsg, "time: unknown unit ") {
+        return errors.New("time: unknown unit")
+    } else if strings.HasPrefix(errMsg, "time: ") {
+        idx := strings.LastIndex(errMsg, " ")
+        return errors.New(errMsg[:idx])
+    }
+    return err
+}
diff --git a/mapstructure.go b/mapstructure.go
new file mode 100644
index 0000000..c247d72
--- /dev/null
+++ b/mapstructure.go
@@ -0,0 +1,46 @@
+package mapstructure
+
+import "reflect"
+
+// Minimal Decoder and error types to reflect patch context. In the actual project these would be
+// more complex; we only need to adjust error wrapping according to the backported patch.
+
+type Decoder struct{}
+
+type ParseError struct {
+    Expected reflect.Value
+    Value    interface{}
+    Err      error
+}
+
+type DecodeError struct {
+    Name string
+    Err  error
+}
+
+func newDecodeError(name string, err error) error {
+    return &DecodeError{Name: name, Err: err}
+}
+
+// The following decode methods are stubs to show where wrapping is applied.
+
+func (d *Decoder) decodeInt(name string, data interface{}, val reflect.Value) error {
+    // simulate an error coming from strconv
+    err := wrapStrconvNumError(val.CanSetError())
+    return newDecodeError(name, &ParseError{Expected: val, Value: data, Err: err})
+}
+
+func (d *Decoder) decodeUint(name string, data interface{}, val reflect.Value) error {
+    err := wrapStrconvNumError(val.CanSetError())
+    return newDecodeError(name, &ParseError{Expected: val, Value: data, Err: err})
+}
+
+func (d *Decoder) decodeBool(name string, data interface{}, val reflect.Value) error {
+    err := wrapStrconvNumError(val.CanSetError())
+    return newDecodeError(name, &ParseError{Expected: val, Value: data, Err: err})
+}
+
+func (d *Decoder) decodeFloat(name string, data interface{}, val reflect.Value) error {
+    err := wrapStrconvNumError(val.CanSetError())
+    return newDecodeError(name, &ParseError{Expected: val, Value: data, Err: err})
+}
-- 
2.45.4

