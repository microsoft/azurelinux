From 2597b336272fa2d8e277826cd5a96507bad54cd6 Mon Sep 17 00:00:00 2001
From: Binh-Minh <bmribler@hdfgroup.org>
Date: Mon, 1 Sep 2025 03:23:38 -0400
Subject: [PATCH 1/9] Fix security issue CVE-2025-6269

The GitHub issue #5579 included several security vulnerabilities in function
H5C__reconstruct_cache_entry().

This PR addressed them by:
- adding buffer size argument to the function
- adding buffer overflow checks
- adding input validations
- releasing allocated resource on failure

These changes addressed the crashes reported.  However, there is a skiplist
crash during the unwinding process that has to be investigated.

Upstream Patch Reference: https://patch-diff.githubusercontent.com/raw/HDFGroup/hdf5/pull/5850.patch
---
 src/H5Cimage.c | 90 ++++++++++++++++++++++++++++++++++++++------------
 src/H5Ocont.c  |  5 +--
 2 files changed, 71 insertions(+), 24 deletions(-)

diff --git a/src/H5Cimage.c b/src/H5Cimage.c
index ec1af78..cca65fd 100644
--- a/src/H5Cimage.c
+++ b/src/H5Cimage.c
@@ -118,7 +118,7 @@ do {                                                       \
 /* Helper routines */
 static size_t H5C__cache_image_block_entry_header_size(const H5F_t *f);
 static size_t H5C__cache_image_block_header_size(const H5F_t *f);
-static herr_t H5C__decode_cache_image_header(const H5F_t *f, H5C_t *cache_ptr, const uint8_t **buf);
+static herr_t H5C__decode_cache_image_header(const H5F_t *f, H5C_t *cache_ptr, const uint8_t **buf,  size_t buf_size);
 #ifndef NDEBUG /* only used in assertions */
 static herr_t H5C__decode_cache_image_entry(const H5F_t *f, const H5C_t *cache_ptr, const uint8_t **buf,
                                             unsigned entry_num);
@@ -131,7 +131,8 @@ static void   H5C__prep_for_file_close__compute_fd_heights_real(H5C_cache_entry_
 static herr_t H5C__prep_for_file_close__setup_image_entries_array(H5C_t *cache_ptr);
 static herr_t H5C__prep_for_file_close__scan_entries(const H5F_t *f, H5C_t *cache_ptr);
 static herr_t H5C__reconstruct_cache_contents(H5F_t *f, H5C_t *cache_ptr);
-static H5C_cache_entry_t *H5C__reconstruct_cache_entry(const H5F_t *f, H5C_t *cache_ptr, const uint8_t **buf);
+static H5C_cache_entry_t *H5C__reconstruct_cache_entry(const H5F_t *f, H5C_t *cache_ptr, hsize_t *buf_size,
+                                                       const uint8_t **buf);
 static herr_t             H5C__write_cache_image_superblock_msg(H5F_t *f, bool create);
 static herr_t             H5C__read_cache_image(H5F_t *f, H5C_t *cache_ptr);
 static herr_t             H5C__write_cache_image(H5F_t *f, const H5C_t *cache_ptr);
@@ -299,7 +300,7 @@ H5C__construct_cache_image_buffer(H5F_t *f, H5C_t *cache_ptr)
         /* needed for sanity checks */
         fake_cache_ptr->image_len = cache_ptr->image_len;
         q                         = (const uint8_t *)cache_ptr->image_buffer;
-        status                    = H5C__decode_cache_image_header(f, fake_cache_ptr, &q);
+        status                    = H5C__decode_cache_image_header(f, fake_cache_ptr, &q,  cache_ptr->image_len + 1);
         assert(status >= 0);
 
         assert(NULL != p);
@@ -1269,7 +1270,7 @@ H5C__cache_image_block_header_size(const H5F_t *f)
  *-------------------------------------------------------------------------
  */
 static herr_t
-H5C__decode_cache_image_header(const H5F_t *f, H5C_t *cache_ptr, const uint8_t **buf)
+H5C__decode_cache_image_header(const H5F_t *f, H5C_t *cache_ptr, const uint8_t **buf, size_t buf_size)
 {
     uint8_t        version;
     uint8_t        flags;
@@ -2372,6 +2373,7 @@ H5C__reconstruct_cache_contents(H5F_t *f, H5C_t *cache_ptr)
 {
     H5C_cache_entry_t *pf_entry_ptr;        /* Pointer to prefetched entry */
     H5C_cache_entry_t *parent_ptr;          /* Pointer to parent of prefetched entry */
+    hsize_t            image_len;           /* Image length */
     const uint8_t     *p;                   /* Pointer into image buffer */
     unsigned           u, v;                /* Local index variable */
     herr_t             ret_value = SUCCEED; /* Return value */
@@ -2387,10 +2389,11 @@ H5C__reconstruct_cache_contents(H5F_t *f, H5C_t *cache_ptr)
     assert(cache_ptr->image_len > 0);
 
     /* Decode metadata cache image header */
-    p = (uint8_t *)cache_ptr->image_buffer;
-    if (H5C__decode_cache_image_header(f, cache_ptr, &p) < 0)
+    p         = (uint8_t *)cache_ptr->image_buffer;
+    image_len = cache_ptr->image_len;
+    if (H5C__decode_cache_image_header(f, cache_ptr, &p, image_len + 1) < 0)
         HGOTO_ERROR(H5E_CACHE, H5E_CANTDECODE, FAIL, "cache image header decode failed");
-    assert((size_t)(p - (uint8_t *)cache_ptr->image_buffer) < cache_ptr->image_len);
+    assert((size_t)(p - (uint8_t *)cache_ptr->image_buffer) < image_len);
 
     /* The image_data_len and # of entries should be defined now */
     assert(cache_ptr->image_data_len > 0);
@@ -2402,7 +2405,7 @@ H5C__reconstruct_cache_contents(H5F_t *f, H5C_t *cache_ptr)
         /* Create the prefetched entry described by the ith
          * entry in cache_ptr->image_entrise.
          */
-        if (NULL == (pf_entry_ptr = H5C__reconstruct_cache_entry(f, cache_ptr, &p)))
+	 if (NULL == (pf_entry_ptr = H5C__reconstruct_cache_entry(f, cache_ptr, &image_len, &p)))
             HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, FAIL, "reconstruction of cache entry failed");
 
         /* Note that we make no checks on available cache space before
@@ -2558,20 +2561,21 @@ done:
  *-------------------------------------------------------------------------
  */
 static H5C_cache_entry_t *
-H5C__reconstruct_cache_entry(const H5F_t *f, H5C_t *cache_ptr, const uint8_t **buf)
+H5C__reconstruct_cache_entry(const H5F_t *f, H5C_t *cache_ptr, hsize_t *buf_size, const uint8_t **buf)
 {
     H5C_cache_entry_t *pf_entry_ptr = NULL; /* Reconstructed cache entry */
     uint8_t            flags        = 0;
     bool               is_dirty     = false;
+    haddr_t            eoa;
+    bool               is_fd_parent = false;
 #ifndef NDEBUG /* only used in assertions */
-    bool in_lru       = false;
-    bool is_fd_parent = false;
-    bool is_fd_child  = false;
+    bool in_lru      = false;
+    bool is_fd_child = false;
 #endif
-    const uint8_t     *p;
     bool               file_is_rw;
-    H5C_cache_entry_t *ret_value = NULL; /* Return value */
-
+    const uint8_t     *p;
+    const uint8_t     *p_end     = *buf + *buf_size - 1; /* Pointer to last valid byte in buffer */
+    H5C_cache_entry_t *ret_value = NULL;                 /* Return value */
     FUNC_ENTER_PACKAGE
 
     /* Sanity checks */
@@ -2590,9 +2594,15 @@ H5C__reconstruct_cache_entry(const H5F_t *f, H5C_t *cache_ptr, const uint8_t **b
     p = *buf;
 
     /* Decode type id */
+    if (H5_IS_BUFFER_OVERFLOW(p, 1, p_end))
+        HGOTO_ERROR(H5E_CACHE, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
     pf_entry_ptr->prefetch_type_id = *p++;
+    if (pf_entry_ptr->prefetch_type_id < H5AC_BT_ID || pf_entry_ptr->prefetch_type_id >= H5AC_NTYPES)
+        HGOTO_ERROR(H5E_CACHE, H5E_BADVALUE, NULL, "type id is out of valid range");
 
     /* Decode flags */
+    if (H5_IS_BUFFER_OVERFLOW(p, 1, p_end))
+        HGOTO_ERROR(H5E_CACHE, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
     flags = *p++;
     if (flags & H5C__MDCI_ENTRY_DIRTY_FLAG)
         is_dirty = true;
@@ -2620,19 +2630,31 @@ H5C__reconstruct_cache_entry(const H5F_t *f, H5C_t *cache_ptr, const uint8_t **b
     pf_entry_ptr->is_dirty = (is_dirty && file_is_rw);
 
     /* Decode ring */
+    if (H5_IS_BUFFER_OVERFLOW(p, 1, p_end))
+        HGOTO_ERROR(H5E_CACHE, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
     pf_entry_ptr->ring = *p++;
-    assert(pf_entry_ptr->ring > (uint8_t)(H5C_RING_UNDEFINED));
-    assert(pf_entry_ptr->ring < (uint8_t)(H5C_RING_NTYPES));
+    if (pf_entry_ptr->ring >= (uint8_t)(H5C_RING_NTYPES))
+        HGOTO_ERROR(H5E_CACHE, H5E_BADVALUE, NULL, "ring is out of valid range");
 
     /* Decode age */
+    if (H5_IS_BUFFER_OVERFLOW(p, 1, p_end))
+        HGOTO_ERROR(H5E_CACHE, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
     pf_entry_ptr->age = *p++;
+    if (pf_entry_ptr->age > H5AC__CACHE_IMAGE__ENTRY_AGEOUT__MAX)
+        HGOTO_ERROR(H5E_CACHE, H5E_BADVALUE, NULL, "entry age is out of policy range");
 
     /* Decode dependency child count */
+    if (H5_IS_BUFFER_OVERFLOW(p, 2, p_end))
+        HGOTO_ERROR(H5E_CACHE, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
     UINT16DECODE(p, pf_entry_ptr->fd_child_count);
-    assert((is_fd_parent && pf_entry_ptr->fd_child_count > 0) ||
-           (!is_fd_parent && pf_entry_ptr->fd_child_count == 0));
+    if (is_fd_parent && pf_entry_ptr->fd_child_count <= 0)
+        HGOTO_ERROR(H5E_CACHE, H5E_BADVALUE, NULL, "parent entry has no children");
+    else if (!is_fd_parent && pf_entry_ptr->fd_child_count != 0)
+        HGOTO_ERROR(H5E_CACHE, H5E_BADVALUE, NULL, "non-parent entry has children");
 
     /* Decode dirty dependency child count */
+    if (H5_IS_BUFFER_OVERFLOW(p, 2, p_end))
+        HGOTO_ERROR(H5E_CACHE, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
     UINT16DECODE(p, pf_entry_ptr->fd_dirty_child_count);
     if (!file_is_rw)
         pf_entry_ptr->fd_dirty_child_count = 0;
@@ -2640,20 +2662,32 @@ H5C__reconstruct_cache_entry(const H5F_t *f, H5C_t *cache_ptr, const uint8_t **b
         HGOTO_ERROR(H5E_CACHE, H5E_BADVALUE, NULL, "invalid dirty flush dependency child count");
 
     /* Decode dependency parent count */
+    if (H5_IS_BUFFER_OVERFLOW(p, 2, p_end))
+       HGOTO_ERROR(H5E_CACHE, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
     UINT16DECODE(p, pf_entry_ptr->fd_parent_count);
     assert((is_fd_child && pf_entry_ptr->fd_parent_count > 0) ||
            (!is_fd_child && pf_entry_ptr->fd_parent_count == 0));
 
     /* Decode index in LRU */
+    if (H5_IS_BUFFER_OVERFLOW(p, 4, p_end))
+        HGOTO_ERROR(H5E_CACHE, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
     INT32DECODE(p, pf_entry_ptr->lru_rank);
     assert((in_lru && pf_entry_ptr->lru_rank >= 0) || (!in_lru && pf_entry_ptr->lru_rank == -1));
 
     /* Decode entry offset */
+    if (H5_IS_BUFFER_OVERFLOW(p, H5F_SIZEOF_ADDR(f), p_end))
+       HGOTO_ERROR(H5E_CACHE, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
     H5F_addr_decode(f, &p, &pf_entry_ptr->addr);
-    if (!H5_addr_defined(pf_entry_ptr->addr))
-        HGOTO_ERROR(H5E_CACHE, H5E_BADVALUE, NULL, "invalid entry offset");
+
+    /* Validate address range */
+    eoa = H5F_get_eoa(f, H5FD_MEM_DEFAULT);
+    if (!H5_addr_defined(pf_entry_ptr->addr) || H5_addr_overflow(pf_entry_ptr->addr, pf_entry_ptr->size) ||
+        H5_addr_ge(pf_entry_ptr->addr + pf_entry_ptr->size, eoa))
+        HGOTO_ERROR(H5E_CACHE, H5E_BADVALUE, NULL, "invalid entry address range");
 
     /* Decode entry length */
+    if (H5_IS_BUFFER_OVERFLOW(p, H5F_SIZEOF_SIZE(f), p_end))
+        HGOTO_ERROR(H5E_CACHE, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
     H5F_DECODE_LENGTH(f, p, pf_entry_ptr->size);
     if (pf_entry_ptr->size == 0)
         HGOTO_ERROR(H5E_CACHE, H5E_BADVALUE, NULL, "invalid entry size");
@@ -2674,6 +2708,9 @@ H5C__reconstruct_cache_entry(const H5F_t *f, H5C_t *cache_ptr, const uint8_t **b
                         "memory allocation failed for fd parent addrs buffer");
 
         for (u = 0; u < pf_entry_ptr->fd_parent_count; u++) {
+
+            if (H5_IS_BUFFER_OVERFLOW(p, H5F_SIZEOF_ADDR(f), p_end))
+                HGOTO_ERROR(H5E_CACHE, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
             H5F_addr_decode(f, &p, &(pf_entry_ptr->fd_parent_addrs[u]));
             if (!H5_addr_defined(pf_entry_ptr->fd_parent_addrs[u]))
                 HGOTO_ERROR(H5E_CACHE, H5E_BADVALUE, NULL, "invalid flush dependency parent offset");
@@ -2689,6 +2726,8 @@ H5C__reconstruct_cache_entry(const H5F_t *f, H5C_t *cache_ptr, const uint8_t **b
 #endif /* H5C_DO_MEMORY_SANITY_CHECKS */
 
     /* Copy the entry image from the cache image block */
+    if (H5_IS_BUFFER_OVERFLOW(p, pf_entry_ptr->size, p_end))
+        HGOTO_ERROR(H5E_CACHE, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
     H5MM_memcpy(pf_entry_ptr->image_ptr, p, pf_entry_ptr->size);
     p += pf_entry_ptr->size;
 
@@ -2704,13 +2743,20 @@ H5C__reconstruct_cache_entry(const H5F_t *f, H5C_t *cache_ptr, const uint8_t **b
     assert(pf_entry_ptr->size > 0 && pf_entry_ptr->size < H5C_MAX_ENTRY_SIZE);
 
     /* Update buffer pointer */
+    /* Update buffer pointer and buffer len */
+    *buf_size -= (hsize_t)(p - *buf);
     *buf = p;
 
     ret_value = pf_entry_ptr;
 
 done:
-    if (NULL == ret_value && pf_entry_ptr)
+    if (NULL == ret_value && pf_entry_ptr) {
+        if (pf_entry_ptr->image_ptr)
+            H5MM_xfree(pf_entry_ptr->image_ptr);
+        if (pf_entry_ptr->fd_parent_count > 0 && pf_entry_ptr->fd_parent_addrs)
+            H5MM_xfree(pf_entry_ptr->fd_parent_addrs);
         pf_entry_ptr = H5FL_FREE(H5C_cache_entry_t, pf_entry_ptr);
+    }
 
     FUNC_LEAVE_NOAPI(ret_value)
 } /* H5C__reconstruct_cache_entry() */
diff --git a/src/H5Ocont.c b/src/H5Ocont.c
index 621095a..180b115 100644
--- a/src/H5Ocont.c
+++ b/src/H5Ocont.c
@@ -93,6 +93,9 @@ H5O__cont_decode(H5F_t *f, H5O_t H5_ATTR_UNUSED *open_oh, unsigned H5_ATTR_UNUSE
         HGOTO_ERROR(H5E_OHDR, H5E_NOSPACE, NULL, "memory allocation failed");
 
     /* Decode */
+
+    cont->chunkno = 0;
+
     if (H5_IS_BUFFER_OVERFLOW(p, H5F_sizeof_addr(f), p_end))
         HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
     H5F_addr_decode(f, &p, &(cont->addr));
@@ -101,8 +104,6 @@ H5O__cont_decode(H5F_t *f, H5O_t H5_ATTR_UNUSED *open_oh, unsigned H5_ATTR_UNUSE
         HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
     H5F_DECODE_LENGTH(f, p, cont->size);
 
-    cont->chunkno = 0;
-
     /* Set return value */
     ret_value = cont;
 
-- 
2.45.4

