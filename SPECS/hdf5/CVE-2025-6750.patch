From aaaf32bb035f8b1ad8f634d799688587590d8544 Mon Sep 17 00:00:00 2001
From: Binh-Minh <bmribler@hdfgroup.org>
Date: Sun, 21 Sep 2025 22:29:27 -0400
Subject: [PATCH 1/4] Fixes CVE-2025-6750

A heap buffer overflow occurred because an mtime message was not properly decoded, resulting in a buffer of size 0 being passed into the encoder.

This PR added decoding for both old and new mtime messages which will allow invalid message size to be detected.

Fixes #5549
Upstream Patch Reference: https://patch-diff.githubusercontent.com/raw/HDFGroup/hdf5/pull/5856.patch
---
 src/H5Ocache.c | 43 ++++++++++++++++++++++++++++++++++++-------
 1 file changed, 36 insertions(+), 7 deletions(-)

diff --git a/src/H5Ocache.c b/src/H5Ocache.c
index 4337d6e..d54e0b1 100644
--- a/src/H5Ocache.c
+++ b/src/H5Ocache.c
@@ -1266,7 +1266,10 @@ H5O__chunk_deserialize(H5O_t *oh, haddr_t addr, size_t chunk_size, const uint8_t
         if (mesg_size != H5O_ALIGN_OH(oh, mesg_size))
             HGOTO_ERROR(H5E_OHDR, H5E_CANTLOAD, FAIL, "message not aligned");
 
-        /* Message flags */
+        if (H5_IS_BUFFER_OVERFLOW(chunk_image, mesg_size, p_end))
+            HGOTO_ERROR(H5E_OHDR, H5E_BADVALUE, FAIL, "message size exceeds buffer end");
+
+	/* Message flags */
         if (H5_IS_BUFFER_OVERFLOW(chunk_image, 1, p_end))
             HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL, "ran off end of input buffer while decoding");
         flags = *chunk_image++;
@@ -1298,12 +1301,6 @@ H5O__chunk_deserialize(H5O_t *oh, haddr_t addr, size_t chunk_size, const uint8_t
             }
         }
 
-        /* Try to detect invalidly formatted object header message that
-         *  extends past end of chunk.
-         */
-        if (chunk_image + mesg_size > eom_ptr)
-            HGOTO_ERROR(H5E_OHDR, H5E_CANTINIT, FAIL, "corrupt object header");
-
         /* Increment count of null messages */
         if (H5O_NULL_ID == id)
             nullcnt++;
@@ -1450,6 +1447,38 @@ H5O__chunk_deserialize(H5O_t *oh, haddr_t addr, size_t chunk_size, const uint8_t
                     HGOTO_ERROR(H5E_OHDR, H5E_CANTSET, FAIL, "can't decode refcount");
                 oh->nlink = *refcount;
             }
+	    /* Check if message is an old mtime message */
+            else if (H5O_MTIME_ID == id) {
+                time_t *mtime = NULL;
+
+                /* Decode mtime message */
+                mtime =
+                    (time_t *)(H5O_MSG_MTIME->decode)(udata->f, NULL, 0, &ioflags, mesg->raw_size, mesg->raw);
+
+                /* Save the decoded old format mtime */
+                if (!mtime)
+                    HGOTO_ERROR(H5E_OHDR, H5E_CANTDECODE, FAIL, "can't decode old format mtime");
+
+                /* Save 'native' form of mtime message and its value */
+                mesg->native = mtime;
+                oh->ctime    = *mtime;
+            }
+            /* Check if message is an new mtime message */
+            else if (H5O_MTIME_NEW_ID == id) {
+                time_t *mtime = NULL;
+
+                /* Decode mtime message */
+                mtime = (time_t *)(H5O_MSG_MTIME_NEW->decode)(udata->f, NULL, 0, &ioflags, mesg->raw_size,
+                                                              mesg->raw);
+
+                /* Save the decoded new format mtime */
+                if (!mtime)
+                    HGOTO_ERROR(H5E_OHDR, H5E_CANTDECODE, FAIL, "can't decode new format mtime");
+
+                /* Save 'native' form of mtime message and its value */
+                mesg->native = mtime;
+                oh->ctime    = *mtime;
+            }
             /* Check if message is a link message */
             else if (H5O_LINK_ID == id) {
                 /* Increment the count of link messages */
-- 
2.45.4

