From 852a9f87849833074683038ea47ddf3cb5e10311 Mon Sep 17 00:00:00 2001
From: Jordan Henderson <jhenderson@hdfgroup.org>
Date: Wed, 10 Sep 2025 16:41:49 -0500
Subject: [PATCH] Fix CVE-2025-6857

Add additional checks for v1 B-tree corruption
Upstream Patch Reference :https://patch-diff.githubusercontent.com/raw/HDFGroup/hdf5/pull/5799.patch
---
 src/H5B.c    | 58 ++++++++++++++++++++++++++++++++++++++++++++++++++--
 src/H5Bpkg.h |  6 ++++++
 2 files changed, 62 insertions(+), 2 deletions(-)

diff --git a/src/H5B.c b/src/H5B.c
index 30e39ef..fd2069b 100644
--- a/src/H5B.c
+++ b/src/H5B.c
@@ -140,6 +140,8 @@ typedef struct H5B_ins_ud_t {
 /********************/
 /* Local Prototypes */
 /********************/
+static herr_t    H5B_find_helper(H5F_t *f, const H5B_class_t *type, haddr_t addr, int exp_level, bool *found,
+                                 void *udata);
 static H5B_ins_t H5B__insert_helper(H5F_t *f, H5B_ins_ud_t *bt_ud, const H5B_class_t *type, uint8_t *lt_key,
                                     bool *lt_key_changed, uint8_t *md_key, void *udata, uint8_t *rt_key,
                                     bool *rt_key_changed, H5B_ins_ud_t *split_bt_ud /*out*/);
@@ -272,6 +274,47 @@ done:
  */
 herr_t
 H5B_find(H5F_t *f, const H5B_class_t *type, haddr_t addr, bool *found, void *udata)
+{
+    herr_t ret_value = SUCCEED;
+
+    FUNC_ENTER_NOAPI(FAIL)
+
+    /*
+     * Check arguments.
+     */
+    assert(f);
+    assert(type);
+    assert(type->decode);
+    assert(type->cmp3);
+    assert(type->found);
+    assert(H5_addr_defined(addr));
+
+    if ((ret_value = H5B_find_helper(f, type, addr, H5B_UNKNOWN_NODELEVEL, found, udata)) < 0)
+        HGOTO_ERROR(H5E_BTREE, H5E_NOTFOUND, FAIL, "can't lookup key");
+
+done:
+    FUNC_LEAVE_NOAPI(ret_value)
+} /* end H5B_find() */
+
+/*-------------------------------------------------------------------------
+ * Function:    H5B_find_helper
+ *
+ * Purpose:     Recursive helper routine for H5B_find used to track node
+ *              levels and attempt to detect B-tree corruption during
+ *              lookups.
+ *
+ * Note:        This function does not follow the left/right sibling
+ *              pointers since it assumes that all nodes can be reached
+ *              from the parent node.
+ *
+ * Return:      Non-negative on success (if found, values returned through
+ *              the UDATA argument). Negative on failure (if not found,
+ *              UDATA is undefined).
+ *
+ *-------------------------------------------------------------------------
+ */
+static herr_t
+H5B_find_helper(H5F_t *f, const H5B_class_t *type, haddr_t addr, int exp_level, bool *found, void *udata)
 {
     H5B_t         *bt = NULL;
     H5UC_t        *rc_shared;           /* Ref-counted shared info */
@@ -306,6 +349,7 @@ H5B_find(H5F_t *f, const H5B_class_t *type, haddr_t addr, bool *found, void *uda
     cache_udata.f         = f;
     cache_udata.type      = type;
     cache_udata.rc_shared = rc_shared;
+    cache_udata.exp_level = exp_level;
     if (NULL == (bt = (H5B_t *)H5AC_protect(f, H5AC_BT, addr, &cache_udata, H5AC__READ_ONLY_FLAG)))
         HGOTO_ERROR(H5E_BTREE, H5E_CANTPROTECT, FAIL, "unable to load B-tree node");
 
@@ -329,7 +373,17 @@ H5B_find(H5F_t *f, const H5B_class_t *type, haddr_t addr, bool *found, void *uda
         assert(idx < bt->nchildren);
 
         if (bt->level > 0) {
-            if ((ret_value = H5B_find(f, type, bt->child[idx], found, udata)) < 0)
+	     /* Sanity check to catch the case where the current node points to
+             * itself and the current node was loaded with an expected node level
+             * of H5B_UNKNOWN_NODELEVEL, thus bypassing the expected node level
+             * check during deserialization and in the future if the node was
+             * cached.
+             */
+            if (bt->child[idx] == addr)
+                HGOTO_ERROR(H5E_BTREE, H5E_BADVALUE, FAIL, "cyclic B-tree detected");
+
+            if ((ret_value = H5B_find_helper(f, type, bt->child[idx], (int)(bt->level - 1), found, udata)) <
+                0)
                 HGOTO_ERROR(H5E_BTREE, H5E_NOTFOUND, FAIL, "can't lookup key in subtree");
         } /* end if */
         else {
@@ -343,7 +397,7 @@ done:
         HDONE_ERROR(H5E_BTREE, H5E_CANTUNPROTECT, FAIL, "unable to release node");
 
     FUNC_LEAVE_NOAPI(ret_value)
-} /* end H5B_find() */
+} /* end H5B_find_helper() */
 
 /*-------------------------------------------------------------------------
  * Function:	H5B__split
diff --git a/src/H5Bpkg.h b/src/H5Bpkg.h
index d1ad647..f75e857 100644
--- a/src/H5Bpkg.h
+++ b/src/H5Bpkg.h
@@ -39,6 +39,11 @@
 /* # of bits for node level: 1 byte */
 #define LEVEL_BITS 8
 
+/* Indicates that the level of the current node is unknown.  When the level
+ * is known, it can be used to detect corrupted level during decoding
+ */
+#define H5B_UNKNOWN_NODELEVEL -1
+
 /****************************/
 /* Package Private Typedefs */
 /****************************/
@@ -60,6 +65,7 @@ typedef struct H5B_t {
 typedef struct H5B_cache_ud_t {
     H5F_t                    *f;         /* File that B-tree node is within */
     const struct H5B_class_t *type;      /* Type of tree */
+    int                       exp_level; /* Expected level of the current node */
     H5UC_t                   *rc_shared; /* Ref-counted shared info */
 } H5B_cache_ud_t;
 
-- 
2.45.4

