From 5c1a2e9c06a834eb715f60265a877f5b882cc1b1 Mon Sep 17 00:00:00 2001
From: Carlos Garcia Campos <cgarcia@igalia.com>
Date: Fri, 23 Jan 2026 12:56:25 +0100
Subject: [PATCH] Always validate the headers value when coming from untrusted
 source

Add trusted_value parameter to soup_message_headers_append_common() and
soup_message_headers_replace_common() and check that the value is valid
when FALSE is passed.

Closes #486
Upstream Patch Reference: https://gitlab.gnome.org/GNOME/libsoup/-/merge_requests/500.patch
---
 libsoup/auth/soup-auth-manager.c              |   2 +-
 libsoup/auth/soup-auth-ntlm.c                 |   2 +-
 libsoup/cache/soup-cache.c                    |   4 +-
 .../content-decoder/soup-content-decoder.c    |   2 +-
 libsoup/cookies/soup-cookie-jar.c             |   2 +-
 libsoup/cookies/soup-cookie.c                 |   4 +-
 libsoup/http1/soup-client-message-io-http1.c  |   2 +-
 .../http1/soup-server-message-io-http1.c      |   4 +-
 libsoup/server/soup-auth-domain.c             |   2 +-
 libsoup/server/soup-server-message.c          |   4 +-
 libsoup/server/soup-server.c                  |   4 +-
 libsoup/soup-headers.c                        |   3 +-
 libsoup/soup-message-headers-private.h        |  10 +-
 libsoup/soup-message-headers.c                | 127 +++++----
 libsoup/soup-message.c                        |   8 +-
 libsoup/soup-multipart.c                      |   4 +-
 libsoup/soup-session.c                        |   4 +-
 libsoup/websocket/soup-websocket.c            |  28 +-
 tests/header-parsing-test.c                   | 257 +++++++++++++-----
 tests/http2-test.c                            |   4 +-
 20 files changed, 317 insertions(+), 160 deletions(-)

diff --git a/libsoup/auth/soup-auth-manager.c b/libsoup/auth/soup-auth-manager.c
index 402967d..1800190 100644
--- a/libsoup/auth/soup-auth-manager.c
+++ b/libsoup/auth/soup-auth-manager.c
@@ -441,7 +441,7 @@ update_authorization_header (SoupMessage *msg, SoupAuth *auth, gboolean is_proxy
 	if (!token)
 		return;
 
-	soup_message_headers_replace_common (soup_message_get_request_headers (msg), authorization_header, token);
+	soup_message_headers_replace_common (soup_message_get_request_headers (msg), authorization_header, token, TRUE);
 	g_free (token);
 }
 
diff --git a/libsoup/auth/soup-auth-ntlm.c b/libsoup/auth/soup-auth-ntlm.c
index 7108a32..b4fc1d1 100644
--- a/libsoup/auth/soup-auth-ntlm.c
+++ b/libsoup/auth/soup-auth-ntlm.c
@@ -328,7 +328,7 @@ soup_auth_ntlm_update_connection (SoupConnectionAuth *auth, SoupMessage *msg,
 			conn->state = SOUP_NTLM_FAILED;
 			if (soup_message_is_keepalive (msg)) {
 				soup_message_headers_append_common (soup_message_get_response_headers (msg),
-                                                                    SOUP_HEADER_CONNECTION, "close");
+                                                                    SOUP_HEADER_CONNECTION, "close", TRUE);
 			}
 			return TRUE;
 		}
diff --git a/libsoup/cache/soup-cache.c b/libsoup/cache/soup-cache.c
index bc733a6..8e86682 100644
--- a/libsoup/cache/soup-cache.c
+++ b/libsoup/cache/soup-cache.c
@@ -1471,11 +1471,11 @@ soup_cache_generate_conditional_request (SoupCache *cache, SoupMessage *original
 	if (last_modified)
 		soup_message_headers_append_common (soup_message_get_request_headers (msg),
                                                     SOUP_HEADER_IF_MODIFIED_SINCE,
-                                                    last_modified);
+                                                    last_modified, TRUE);
 	if (etag)
 		soup_message_headers_append_common (soup_message_get_request_headers (msg),
                                                     SOUP_HEADER_IF_NONE_MATCH,
-                                                    etag);
+                                                    etag, TRUE);
 
 	return msg;
 }
diff --git a/libsoup/content-decoder/soup-content-decoder.c b/libsoup/content-decoder/soup-content-decoder.c
index f75ebce..2fdad66 100644
--- a/libsoup/content-decoder/soup-content-decoder.c
+++ b/libsoup/content-decoder/soup-content-decoder.c
@@ -249,7 +249,7 @@ soup_content_decoder_request_queued (SoupSessionFeature *feature,
 #endif
 
 		soup_message_headers_append_common (soup_message_get_request_headers (msg),
-                                                    SOUP_HEADER_ACCEPT_ENCODING, header);
+                                                    SOUP_HEADER_ACCEPT_ENCODING, header, TRUE);
 	}
 }
 
diff --git a/libsoup/cookies/soup-cookie-jar.c b/libsoup/cookies/soup-cookie-jar.c
index 1609a56..1575dfe 100644
--- a/libsoup/cookies/soup-cookie-jar.c
+++ b/libsoup/cookies/soup-cookie-jar.c
@@ -893,7 +893,7 @@ msg_starting_cb (SoupMessage *msg, gpointer feature)
 							               soup_message_get_is_top_level_navigation (msg));
 	if (cookies != NULL) {
 		char *cookie_header = soup_cookies_to_cookie_header (cookies);
-		soup_message_headers_replace_common (soup_message_get_request_headers (msg), SOUP_HEADER_COOKIE, cookie_header);
+		soup_message_headers_replace_common (soup_message_get_request_headers (msg), SOUP_HEADER_COOKIE, cookie_header, TRUE);
 		g_free (cookie_header);
 		g_slist_free_full (cookies, (GDestroyNotify)soup_cookie_free);
 	} else {
diff --git a/libsoup/cookies/soup-cookie.c b/libsoup/cookies/soup-cookie.c
index 5af154d..774fc2b 100644
--- a/libsoup/cookies/soup-cookie.c
+++ b/libsoup/cookies/soup-cookie.c
@@ -956,7 +956,7 @@ soup_cookies_to_response (GSList *cookies, SoupMessage *msg)
 	while (cookies) {
 		serialize_cookie (cookies->data, header, TRUE);
 		soup_message_headers_append_common (soup_message_get_response_headers (msg),
-                                                    SOUP_HEADER_SET_COOKIE, header->str);
+                                                    SOUP_HEADER_SET_COOKIE, header->str, TRUE);
 		g_string_truncate (header, 0);
 		cookies = cookies->next;
 	}
@@ -987,7 +987,7 @@ soup_cookies_to_request (GSList *cookies, SoupMessage *msg)
 		cookies = cookies->next;
 	}
 	soup_message_headers_replace_common (soup_message_get_request_headers (msg),
-                                             SOUP_HEADER_COOKIE, header->str);
+                                             SOUP_HEADER_COOKIE, header->str, TRUE);
 	g_string_free (header, TRUE);
 }
 
diff --git a/libsoup/http1/soup-client-message-io-http1.c b/libsoup/http1/soup-client-message-io-http1.c
index ee5738e..5170885 100644
--- a/libsoup/http1/soup-client-message-io-http1.c
+++ b/libsoup/http1/soup-client-message-io-http1.c
@@ -568,7 +568,7 @@ io_read (SoupClientMessageIOHTTP1 *client_io,
                          * closed when we're done.
                          */
                         soup_message_headers_append_common (soup_message_get_request_headers (msg),
-                                                            SOUP_HEADER_CONNECTION, "close");
+                                                            SOUP_HEADER_CONNECTION, "close", TRUE);
                         soup_message_set_metrics_timestamp (msg, SOUP_MESSAGE_METRICS_RESPONSE_END);
                         io->read_state = SOUP_MESSAGE_IO_STATE_FINISHING;
                         break;
diff --git a/libsoup/server/http1/soup-server-message-io-http1.c b/libsoup/server/http1/soup-server-message-io-http1.c
index 3803cab..d1bcf51 100644
--- a/libsoup/server/http1/soup-server-message-io-http1.c
+++ b/libsoup/server/http1/soup-server-message-io-http1.c
@@ -305,7 +305,7 @@ handle_partial_get (SoupServerMessage *msg)
                         if (content_type) {
                                 soup_message_headers_append_common (part_headers,
                                                                     SOUP_HEADER_CONTENT_TYPE,
-                                                                    content_type);
+                                                                    content_type, TRUE);
                         }
                         soup_message_headers_set_content_range (part_headers,
                                                                 ranges[i].start,
@@ -762,7 +762,7 @@ io_read (SoupServerMessageIOHTTP1 *server_io,
                          * closed when we're done.
                          */
                         soup_server_message_set_status (msg, status, NULL);
-                        soup_message_headers_append_common (request_headers, SOUP_HEADER_CONNECTION, "close");
+                        soup_message_headers_append_common (request_headers, SOUP_HEADER_CONNECTION, "close", TRUE);
                         io->read_state = SOUP_MESSAGE_IO_STATE_FINISHING;
                         break;
                 }
diff --git a/libsoup/server/soup-auth-domain.c b/libsoup/server/soup-auth-domain.c
index c901bd2..b4718b8 100644
--- a/libsoup/server/soup-auth-domain.c
+++ b/libsoup/server/soup-auth-domain.c
@@ -581,6 +581,6 @@ soup_auth_domain_challenge (SoupAuthDomain    *domain,
                                             priv->proxy ?
                                             SOUP_HEADER_PROXY_AUTHENTICATE :
                                             SOUP_HEADER_WWW_AUTHENTICATE,
-                                            challenge);
+                                            challenge, FALSE);
 	g_free (challenge);
 }
diff --git a/libsoup/server/soup-server-message.c b/libsoup/server/soup-server-message.c
index 1450b04..1d372a4 100644
--- a/libsoup/server/soup-server-message.c
+++ b/libsoup/server/soup-server-message.c
@@ -939,7 +939,7 @@ soup_server_message_set_response (SoupServerMessage *msg,
 
                 soup_message_headers_replace_common (msg->response_headers,
                                                      SOUP_HEADER_CONTENT_TYPE,
-                                                     content_type);
+                                                     content_type, FALSE);
                 soup_message_body_append (msg->response_body, resp_use,
                                           resp_body, resp_length);
         } else {
@@ -980,7 +980,7 @@ soup_server_message_set_redirect (SoupServerMessage *msg,
 	soup_server_message_set_status (msg, status_code, NULL);
 	location_str = g_uri_to_string (location);
 	soup_message_headers_replace_common (msg->response_headers, SOUP_HEADER_LOCATION,
-                                             location_str);
+                                             location_str, FALSE);
 	g_free (location_str);
 	g_uri_unref (location);
 }
diff --git a/libsoup/server/soup-server.c b/libsoup/server/soup-server.c
index f002456..c17465a 100644
--- a/libsoup/server/soup-server.c
+++ b/libsoup/server/soup-server.c
@@ -860,7 +860,7 @@ got_headers (SoupServer        *server,
 
 	date = g_date_time_new_now_utc ();
 	date_string = soup_date_time_to_string (date, SOUP_DATE_HTTP);
-	soup_message_headers_replace_common (headers, SOUP_HEADER_DATE, date_string);
+	soup_message_headers_replace_common (headers, SOUP_HEADER_DATE, date_string, TRUE);
 	g_free (date_string);
 	g_date_time_unref (date);
 
@@ -1048,7 +1048,7 @@ request_started_cb (SoupServer           *server,
 
                 headers = soup_server_message_get_response_headers (msg);
                 soup_message_headers_append_common (headers, SOUP_HEADER_SERVER,
-                                                    priv->server_header);
+                                                    priv->server_header, FALSE);
         }
 
         g_signal_emit (server, signals[REQUEST_STARTED], 0, msg);
diff --git a/libsoup/soup-headers.c b/libsoup/soup-headers.c
index d28ddff..baf3055 100644
--- a/libsoup/soup-headers.c
+++ b/libsoup/soup-headers.c
@@ -139,7 +139,8 @@ soup_headers_parse (const char *str, int len, SoupMessageHeaders *dest)
 		for (p = strchr (value, '\r'); p; p = strchr (p, '\r'))
 			*p = ' ';
 
-		soup_message_headers_append_untrusted_data (dest, name, value);
+		if (!soup_message_headers_append_untrusted_data (dest, name, value))
+                        goto done;
         }
 	success = TRUE;
 
diff --git a/libsoup/soup-message-headers-private.h b/libsoup/soup-message-headers-private.h
index 9815464..59fb206 100644
--- a/libsoup/soup-message-headers-private.h
+++ b/libsoup/soup-message-headers-private.h
@@ -10,12 +10,13 @@
 
 G_BEGIN_DECLS
 
-void        soup_message_headers_append_untrusted_data  (SoupMessageHeaders *hdrs,
+gboolean    soup_message_headers_append_untrusted_data  (SoupMessageHeaders *hdrs,
                                                          const char         *name,
                                                          const char         *value);
-void        soup_message_headers_append_common          (SoupMessageHeaders *hdrs,
+gboolean    soup_message_headers_append_common          (SoupMessageHeaders *hdrs,
                                                          SoupHeaderName      name,
-                                                         const char         *value);
+                                                         const char         *value,
+                                                         gboolean            trusted_value);
 const char *soup_message_headers_get_one_common         (SoupMessageHeaders *hdrs,
                                                          SoupHeaderName      name);
 const char *soup_message_headers_get_list_common        (SoupMessageHeaders *hdrs,
@@ -24,7 +25,8 @@ void        soup_message_headers_remove_common          (SoupMessageHeaders *hdr
                                                          SoupHeaderName      name);
 void        soup_message_headers_replace_common         (SoupMessageHeaders *hdrs,
                                                          SoupHeaderName      name,
-                                                         const char         *value);
+                                                         const char         *value,
+                                                         gboolean            trusted_value);
 gboolean    soup_message_headers_header_contains_common (SoupMessageHeaders *hdrs,
                                                          SoupHeaderName      name,
                                                          const char         *token);
diff --git a/libsoup/soup-message-headers.c b/libsoup/soup-message-headers.c
index c1b7454..b24f09a 100644
--- a/libsoup/soup-message-headers.c
+++ b/libsoup/soup-message-headers.c
@@ -267,12 +267,32 @@ soup_message_headers_clean_connection_headers (SoupMessageHeaders *hdrs)
 	soup_header_free_list (tokens);
 }
 
-void
+static inline gboolean is_valid_header_name (const char *name)
+{
+        return name && *name && strpbrk (name, " \t\r\n:") == NULL;
+}
+
+static inline gboolean is_valid_header_value (const char *value)
+{
+        return value && strpbrk (value, "\r\n") == NULL;
+}
+
+gboolean
 soup_message_headers_append_common (SoupMessageHeaders *hdrs,
                                     SoupHeaderName      name,
-                                    const char         *value)
+                                    const char         *value,
+                                    gboolean            trusted_value)
 {
         SoupCommonHeader header;
+        if (name == SOUP_HEADER_HOST && soup_message_headers_get_one (hdrs, "Host")) {
+                g_warning ("soup_message_headers_append_common: Rejecting duplicate Host header");
+                return FALSE;
+        }
+
+        if (!trusted_value && !is_valid_header_value (value)) {
+                g_warning ("soup_message_headers_append: Rejecting bad value '%s'", value);
+                return FALSE;
+        }
 
         if (!hdrs->common_headers)
                 hdrs->common_headers = g_array_sized_new (FALSE, FALSE, sizeof (SoupCommonHeader), 6);
@@ -284,6 +304,42 @@ soup_message_headers_append_common (SoupMessageHeaders *hdrs,
                 g_hash_table_remove (hdrs->common_concat, GUINT_TO_POINTER (header.name));
 
         soup_message_headers_set (hdrs, name, value);
+        return TRUE;
+}
+
+static gboolean
+soup_message_headers_append_internal (SoupMessageHeaders *hdrs,
+			              const char *name, const char *value)
+{
+	SoupUncommonHeader header;
+        SoupHeaderName header_name;
+
+	g_return_val_if_fail (name != NULL, FALSE);
+	g_return_val_if_fail (value != NULL, FALSE);
+
+	if (!is_valid_header_name (name)) {
+		g_warning ("soup_message_headers_append: Rejecting bad name '%s'", name);
+		return FALSE;
+	}
+
+        header_name = soup_header_name_from_string (name);
+        if (header_name != SOUP_HEADER_UNKNOWN)
+                return soup_message_headers_append_common (hdrs, header_name, value, FALSE);
+
+        if (!is_valid_header_value (value)) {
+                g_warning ("soup_message_headers_append: Rejecting bad value '%s'", value);
+                return FALSE;
+        }
+
+        if (!hdrs->uncommon_headers)
+                hdrs->uncommon_headers = g_array_sized_new (FALSE, FALSE, sizeof (SoupUncommonHeader), 6);
+
+	header.name = g_strdup (name);
+	header.value = g_strdup (value);
+	g_array_append_val (hdrs->uncommon_headers, header);
+	if (hdrs->uncommon_concat)
+		g_hash_table_remove (hdrs->uncommon_concat, header.name);
+        return TRUE;
 }
 
 /**
@@ -305,69 +361,36 @@ void
 soup_message_headers_append (SoupMessageHeaders *hdrs,
 			     const char *name, const char *value)
 {
-	SoupUncommonHeader header;
-        SoupHeaderName header_name;
-
-	g_return_if_fail (name != NULL);
-	g_return_if_fail (value != NULL);
-
-	/* Setting a syntactically invalid header name or value is
-	 * considered to be a programming error. However, it can also
-	 * be a security hole, so we want to fail here even if
-	 * compiled with G_DISABLE_CHECKS.
-	 */
-#ifndef G_DISABLE_CHECKS
-	g_return_if_fail (*name && strpbrk (name, " \t\r\n:") == NULL);
-	g_return_if_fail (strpbrk (value, "\r\n") == NULL);
-#else
-	if (*name && strpbrk (name, " \t\r\n:")) {
-		g_warning ("soup_message_headers_append: Ignoring bad name '%s'", name);
-		return;
-	}
-	if (strpbrk (value, "\r\n")) {
-		g_warning ("soup_message_headers_append: Ignoring bad value '%s'", value);
-		return;
-	}
-#endif
-
-        header_name = soup_header_name_from_string (name);
-        if (header_name != SOUP_HEADER_UNKNOWN) {
-                soup_message_headers_append_common (hdrs, header_name, value);
-                return;
-        }
-
-        if (!hdrs->uncommon_headers)
-                hdrs->uncommon_headers = g_array_sized_new (FALSE, FALSE, sizeof (SoupUncommonHeader), 6);
-
-	header.name = g_strdup (name);
-	header.value = g_strdup (value);
-	g_array_append_val (hdrs->uncommon_headers, header);
-	if (hdrs->uncommon_concat)
-		g_hash_table_remove (hdrs->uncommon_concat, header.name);
+	soup_message_headers_append_internal (hdrs, name, value);
 }
 
 /*
- * Appends a header value ensuring that it is valid UTF8.
+ * Appends a header value ensuring that it is valid UTF-8, and also checking the
+ * return value of soup_message_headers_append_internal() to report whether the
+ * headers are invalid for various other reasons.
  */
-void
+gboolean
 soup_message_headers_append_untrusted_data (SoupMessageHeaders *hdrs,
                                             const char         *name,
                                             const char         *value)
 {
         char *safe_value = g_utf8_make_valid (value, -1);
         char *safe_name = g_utf8_make_valid (name, -1);
-        soup_message_headers_append (hdrs, safe_name, safe_value);
+        gboolean result = soup_message_headers_append_internal (hdrs, safe_name, safe_value);
+
         g_free (safe_value);
         g_free (safe_name);
+        return result;
 }
 
 void
 soup_message_headers_replace_common (SoupMessageHeaders *hdrs,
                                      SoupHeaderName      name,
-                                     const char         *value)
+                                     const char         *value,
+                                     gboolean            trusted_value)
 {
         soup_message_headers_remove_common (hdrs, name);
-        soup_message_headers_append_common (hdrs, name, value);
+        soup_message_headers_append_common (hdrs, name, value, trusted_value);
 }
 
 /**
@@ -980,7 +1003,7 @@ soup_message_headers_set_encoding (SoupMessageHeaders *hdrs,
 
 	case SOUP_ENCODING_CHUNKED:
 		soup_message_headers_remove_common (hdrs, SOUP_HEADER_CONTENT_LENGTH);
-		soup_message_headers_replace_common (hdrs, SOUP_HEADER_TRANSFER_ENCODING, "chunked");
+		soup_message_headers_replace_common (hdrs, SOUP_HEADER_TRANSFER_ENCODING, "chunked", TRUE);
 		break;
 
 	default:
@@ -1039,7 +1062,7 @@ soup_message_headers_set_content_length (SoupMessageHeaders *hdrs,
 	g_snprintf (length, sizeof (length), "%" G_GUINT64_FORMAT,
 		    content_length);
 	soup_message_headers_remove_common (hdrs, SOUP_HEADER_TRANSFER_ENCODING);
-	soup_message_headers_replace_common (hdrs, SOUP_HEADER_CONTENT_LENGTH, length);
+	soup_message_headers_replace_common (hdrs, SOUP_HEADER_CONTENT_LENGTH, length, TRUE);
 }
 
 /**
@@ -1090,7 +1113,7 @@ soup_message_headers_set_expectations (SoupMessageHeaders *hdrs,
 	g_return_if_fail ((expectations & ~SOUP_EXPECTATION_CONTINUE) == 0);
 
 	if (expectations & SOUP_EXPECTATION_CONTINUE)
-		soup_message_headers_replace_common (hdrs, SOUP_HEADER_EXPECT, "100-continue");
+		soup_message_headers_replace_common (hdrs, SOUP_HEADER_EXPECT, "100-continue", TRUE);
 	else
 		soup_message_headers_remove_common (hdrs, SOUP_HEADER_EXPECT);
 }
@@ -1324,7 +1347,7 @@ soup_message_headers_set_ranges (SoupMessageHeaders  *hdrs,
 		}
 	}
 
-	soup_message_headers_replace_common (hdrs, SOUP_HEADER_RANGE, header->str);
+	soup_message_headers_replace_common (hdrs, SOUP_HEADER_RANGE, header->str, TRUE);
 	g_string_free (header, TRUE);
 }
 
@@ -1437,7 +1460,7 @@ soup_message_headers_set_content_range (SoupMessageHeaders  *hdrs,
 		header = g_strdup_printf ("bytes %" G_GINT64_FORMAT "-%"
 					  G_GINT64_FORMAT "/*", start, end);
 	}
-	soup_message_headers_replace_common (hdrs, SOUP_HEADER_CONTENT_RANGE, header);
+	soup_message_headers_replace_common (hdrs, SOUP_HEADER_CONTENT_RANGE, header, TRUE);
 	g_free (header);
 }
 
@@ -1512,7 +1535,7 @@ set_content_foo (SoupMessageHeaders *hdrs,
 		}
 	}
 
-	soup_message_headers_replace_common (hdrs, header_name, str->str);
+	soup_message_headers_replace_common (hdrs, header_name, str->str, FALSE);
 	g_string_free (str, TRUE);
 }
 
diff --git a/libsoup/soup-message.c b/libsoup/soup-message.c
index 7a1a065..a722571 100644
--- a/libsoup/soup-message.c
+++ b/libsoup/soup-message.c
@@ -1158,7 +1158,7 @@ soup_message_set_request_body (SoupMessage  *msg,
                         g_warn_if_fail (strchr (content_type, '/') != NULL);
 
                         if (soup_message_headers_get_content_type (priv->request_headers, NULL) != content_type)
-                                soup_message_headers_replace_common (priv->request_headers, SOUP_HEADER_CONTENT_TYPE, content_type);
+                                soup_message_headers_replace_common (priv->request_headers, SOUP_HEADER_CONTENT_TYPE, content_type, FALSE);
                 }
 
                 if (content_length == -1)
@@ -3235,12 +3235,12 @@ soup_message_set_request_host_from_uri (SoupMessage *msg,
 
         host = soup_uri_get_host_for_headers (uri);
         if (soup_uri_uses_default_port (uri))
-                soup_message_headers_replace_common (priv->request_headers, SOUP_HEADER_HOST, host);
+                soup_message_headers_replace_common (priv->request_headers, SOUP_HEADER_HOST, host, FALSE);
         else {
                 char *value;
 
                 value = g_strdup_printf ("%s:%d", host, g_uri_get_port (uri));
-                soup_message_headers_replace_common (priv->request_headers, SOUP_HEADER_HOST, value);
+                soup_message_headers_replace_common (priv->request_headers, SOUP_HEADER_HOST, value, FALSE);
                 g_free (value);
         }
         g_free (host);
@@ -3280,7 +3280,7 @@ soup_message_force_keep_alive_if_needed (SoupMessage *msg)
         if (!soup_message_headers_header_contains_common (priv->request_headers, SOUP_HEADER_CONNECTION, "Keep-Alive") &&
             !soup_message_headers_header_contains_common (priv->request_headers, SOUP_HEADER_CONNECTION, "close") &&
             !soup_message_headers_header_contains_common (priv->request_headers, SOUP_HEADER_CONNECTION, "Upgrade")) {
-                soup_message_headers_append_common (priv->request_headers, SOUP_HEADER_CONNECTION, "Keep-Alive");
+                soup_message_headers_append_common (priv->request_headers, SOUP_HEADER_CONNECTION, "Keep-Alive", TRUE);
         }
 }
 
diff --git a/libsoup/soup-multipart.c b/libsoup/soup-multipart.c
index 27257e4..c75b4da 100644
--- a/libsoup/soup-multipart.c
+++ b/libsoup/soup-multipart.c
@@ -354,12 +354,12 @@ soup_multipart_append_form_file (SoupMultipart *multipart,
 		soup_header_g_string_append_param_quoted (disposition, "filename", filename);
 	}
 	soup_message_headers_append_common (headers, SOUP_HEADER_CONTENT_DISPOSITION,
-                                            disposition->str);
+                                            disposition->str, FALSE);
 	g_string_free (disposition, TRUE);
 
 	if (content_type) {
 		soup_message_headers_append_common (headers, SOUP_HEADER_CONTENT_TYPE,
-                                                    content_type);
+                                                    content_type, FALSE);
 	}
 
 	g_ptr_array_add (multipart->headers, headers);
diff --git a/libsoup/soup-session.c b/libsoup/soup-session.c
index 9f00b05..0017cdb 100644
--- a/libsoup/soup-session.c
+++ b/libsoup/soup-session.c
@@ -1386,10 +1386,10 @@ soup_session_send_queue_item (SoupSession *session,
 
 	request_headers = soup_message_get_request_headers (item->msg);
 	if (priv->user_agent)
-		soup_message_headers_replace_common (request_headers, SOUP_HEADER_USER_AGENT, priv->user_agent);
+		soup_message_headers_replace_common (request_headers, SOUP_HEADER_USER_AGENT, priv->user_agent, FALSE);
 
 	if (priv->accept_language && !soup_message_headers_get_list_common (request_headers, SOUP_HEADER_ACCEPT_LANGUAGE))
-		soup_message_headers_append_common (request_headers, SOUP_HEADER_ACCEPT_LANGUAGE, priv->accept_language);
+		soup_message_headers_append_common (request_headers, SOUP_HEADER_ACCEPT_LANGUAGE, priv->accept_language, FALSE);
 
         conn = soup_message_get_connection (item->msg);
         soup_message_set_http_version (item->msg, soup_connection_get_negotiated_protocol (conn));
diff --git a/libsoup/websocket/soup-websocket.c b/libsoup/websocket/soup-websocket.c
index 64e66fd..9863e94 100644
--- a/libsoup/websocket/soup-websocket.c
+++ b/libsoup/websocket/soup-websocket.c
@@ -257,21 +257,21 @@ soup_websocket_client_prepare_handshake (SoupMessage *msg,
 
 	g_return_if_fail (SOUP_IS_MESSAGE (msg));
 
-	soup_message_headers_replace_common (soup_message_get_request_headers (msg), SOUP_HEADER_UPGRADE, "websocket");
-	soup_message_headers_append_common (soup_message_get_request_headers (msg), SOUP_HEADER_CONNECTION, "Upgrade");
+	soup_message_headers_replace_common (soup_message_get_request_headers (msg), SOUP_HEADER_UPGRADE, "websocket", TRUE);
+	soup_message_headers_append_common (soup_message_get_request_headers (msg), SOUP_HEADER_CONNECTION, "Upgrade", TRUE);
 
 	raw[0] = g_random_int ();
 	raw[1] = g_random_int ();
 	raw[2] = g_random_int ();
 	raw[3] = g_random_int ();
 	key = g_base64_encode ((const guchar *)raw, sizeof (raw));
-	soup_message_headers_replace_common (soup_message_get_request_headers (msg), SOUP_HEADER_SEC_WEBSOCKET_KEY, key);
+	soup_message_headers_replace_common (soup_message_get_request_headers (msg), SOUP_HEADER_SEC_WEBSOCKET_KEY, key, TRUE);
 	g_free (key);
 
-	soup_message_headers_replace_common (soup_message_get_request_headers (msg), SOUP_HEADER_SEC_WEBSOCKET_VERSION, "13");
+	soup_message_headers_replace_common (soup_message_get_request_headers (msg), SOUP_HEADER_SEC_WEBSOCKET_VERSION, "13", TRUE);
 
 	if (origin)
-		soup_message_headers_replace_common (soup_message_get_request_headers (msg), SOUP_HEADER_ORIGIN, origin);
+		soup_message_headers_replace_common (soup_message_get_request_headers (msg), SOUP_HEADER_ORIGIN, origin, FALSE);
 
 	if (protocols && *protocols) {
 		char *protocols_str;
@@ -279,7 +279,7 @@ soup_websocket_client_prepare_handshake (SoupMessage *msg,
 		protocols_str = g_strjoinv (", ", protocols);
 		if (*protocols_str)
 			soup_message_headers_replace_common (soup_message_get_request_headers (msg),
-                                                         SOUP_HEADER_SEC_WEBSOCKET_PROTOCOL, protocols_str);
+                                                             SOUP_HEADER_SEC_WEBSOCKET_PROTOCOL, protocols_str, TRUE);
 		g_free (protocols_str);
 	}
 
@@ -316,7 +316,7 @@ soup_websocket_client_prepare_handshake (SoupMessage *msg,
 		if (extensions->len > 0) {
 			soup_message_headers_replace_common (soup_message_get_request_headers (msg),
                                                              SOUP_HEADER_SEC_WEBSOCKET_EXTENSIONS,
-                                                             extensions->str);
+                                                             extensions->str, FALSE);
 		} else {
 			soup_message_headers_remove_common (soup_message_get_request_headers (msg),
                                                             SOUP_HEADER_SEC_WEBSOCKET_EXTENSIONS);
@@ -633,7 +633,7 @@ respond_handshake_forbidden (SoupServerMessage *msg)
 {
 	soup_server_message_set_status (msg, SOUP_STATUS_FORBIDDEN, NULL);
 	soup_message_headers_append_common (soup_server_message_get_response_headers (msg),
-                                            SOUP_HEADER_CONNECTION, "close");
+                                            SOUP_HEADER_CONNECTION, "close", TRUE);
 	soup_server_message_set_response (msg, "text/html", SOUP_MEMORY_COPY,
 					  RESPONSE_FORBIDDEN, strlen (RESPONSE_FORBIDDEN));
 }
@@ -650,7 +650,7 @@ respond_handshake_bad (SoupServerMessage *msg,
 	text = g_strdup_printf (RESPONSE_BAD, why);
 	soup_server_message_set_status (msg, SOUP_STATUS_BAD_REQUEST, NULL);
 	soup_message_headers_append_common (soup_server_message_get_response_headers (msg),
-                                            SOUP_HEADER_CONNECTION, "close");
+                                            SOUP_HEADER_CONNECTION, "close", TRUE);
 	soup_server_message_set_response (msg, "text/html", SOUP_MEMORY_TAKE,
 					  text, strlen (text));
 }
@@ -716,18 +716,18 @@ soup_websocket_server_process_handshake (SoupServerMessage *msg,
 
 	soup_server_message_set_status (msg, SOUP_STATUS_SWITCHING_PROTOCOLS, NULL);
 	response_headers = soup_server_message_get_response_headers (msg);
-	soup_message_headers_replace_common (response_headers, SOUP_HEADER_UPGRADE, "websocket");
-	soup_message_headers_append_common (response_headers, SOUP_HEADER_CONNECTION, "Upgrade");
+	soup_message_headers_replace_common (response_headers, SOUP_HEADER_UPGRADE, "websocket", TRUE);
+	soup_message_headers_append_common (response_headers, SOUP_HEADER_CONNECTION, "Upgrade", TRUE);
 
 	request_headers = soup_server_message_get_request_headers (msg);
 	key = soup_message_headers_get_one_common (request_headers, SOUP_HEADER_SEC_WEBSOCKET_KEY);
 	accept_key = compute_accept_key (key);
-	soup_message_headers_append_common (response_headers, SOUP_HEADER_SEC_WEBSOCKET_ACCEPT, accept_key);
+	soup_message_headers_append_common (response_headers, SOUP_HEADER_SEC_WEBSOCKET_ACCEPT, accept_key, TRUE);
 	g_free (accept_key);
 
 	choose_subprotocol (msg, (const char **) protocols, &chosen_protocol);
 	if (chosen_protocol)
-		soup_message_headers_append_common (response_headers, SOUP_HEADER_SEC_WEBSOCKET_PROTOCOL, chosen_protocol);
+		soup_message_headers_append_common (response_headers, SOUP_HEADER_SEC_WEBSOCKET_PROTOCOL, chosen_protocol, TRUE);
 
 	extensions = soup_message_headers_get_list_common (request_headers, SOUP_HEADER_SEC_WEBSOCKET_EXTENSIONS);
 	if (extensions && *extensions) {
@@ -758,7 +758,7 @@ soup_websocket_server_process_handshake (SoupServerMessage *msg,
 			if (response_extensions->len > 0) {
 				soup_message_headers_replace_common (response_headers,
                                                                      SOUP_HEADER_SEC_WEBSOCKET_EXTENSIONS,
-                                                                     response_extensions->str);
+                                                                     response_extensions->str, FALSE);
 			} else {
 				soup_message_headers_remove_common (response_headers,
                                                                     SOUP_HEADER_SEC_WEBSOCKET_EXTENSIONS);
diff --git a/tests/header-parsing-test.c b/tests/header-parsing-test.c
index 5e423d2..e81d3b7 100644
--- a/tests/header-parsing-test.c
+++ b/tests/header-parsing-test.c
@@ -15,6 +15,7 @@ static struct RequestTest {
 	const char *method, *path;
 	SoupHTTPVersion version;
 	Header headers[10];
+	GLogLevelFlags log_flags;
 } reqtests[] = {
 	/**********************/
 	/*** VALID REQUESTS ***/
@@ -24,7 +25,7 @@ static struct RequestTest {
 	  "GET / HTTP/1.0\r\n", -1,
 	  SOUP_STATUS_OK,
 	  "GET", "/", SOUP_HTTP_1_0,
-	  { { NULL } }
+	  { { NULL } }, 0
 	},
 
 	{ "Req w/ 1 header", NULL,
@@ -33,7 +34,7 @@ static struct RequestTest {
 	  "GET", "/", SOUP_HTTP_1_1,
 	  { { "Host", "example.com" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	{ "Req w/ 1 header, no leading whitespace", NULL,
@@ -42,7 +43,7 @@ static struct RequestTest {
 	  "GET", "/", SOUP_HTTP_1_1,
 	  { { "Host", "example.com" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	{ "Req w/ 1 header including trailing whitespace", NULL,
@@ -51,7 +52,7 @@ static struct RequestTest {
 	  "GET", "/", SOUP_HTTP_1_1,
 	  { { "Host", "example.com" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	{ "Req w/ 1 header, wrapped", NULL,
@@ -60,7 +61,7 @@ static struct RequestTest {
 	  "GET", "/", SOUP_HTTP_1_1,
 	  { { "Foo", "bar baz" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	{ "Req w/ 1 header, wrapped with additional whitespace", NULL,
@@ -69,7 +70,7 @@ static struct RequestTest {
 	  "GET", "/", SOUP_HTTP_1_1,
 	  { { "Foo", "bar baz" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	{ "Req w/ 1 header, wrapped with tab", NULL,
@@ -78,7 +79,7 @@ static struct RequestTest {
 	  "GET", "/", SOUP_HTTP_1_1,
 	  { { "Foo", "bar baz" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	{ "Req w/ 1 header, wrapped before value", NULL,
@@ -87,7 +88,7 @@ static struct RequestTest {
 	  "GET", "/", SOUP_HTTP_1_1,
 	  { { "Foo", "bar baz" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	{ "Req w/ 1 header with empty value", NULL,
@@ -96,7 +97,7 @@ static struct RequestTest {
 	  "GET", "/", SOUP_HTTP_1_1,
 	  { { "Host", "" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	{ "Req w/ 2 headers", NULL,
@@ -106,7 +107,7 @@ static struct RequestTest {
 	  { { "Host", "example.com" },
 	    { "Connection", "close" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	{ "Req w/ 3 headers", NULL,
@@ -117,7 +118,7 @@ static struct RequestTest {
 	    { "Connection", "close" },
 	    { "Blah", "blah" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	{ "Req w/ 3 headers, 1st wrapped", NULL,
@@ -128,7 +129,7 @@ static struct RequestTest {
             { "Foo", "bar baz" },
 	    { "Blah", "blah" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	{ "Req w/ 3 headers, 2nd wrapped", NULL,
@@ -139,7 +140,7 @@ static struct RequestTest {
 	    { "Blah", "blah" },
 	    { "Foo", "bar baz" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	{ "Req w/ 3 headers, 3rd wrapped", NULL,
@@ -150,7 +151,7 @@ static struct RequestTest {
 	    { "Blah", "blah" },
 	    { "Foo", "bar baz" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	{ "Req w/ same header multiple times", NULL,
@@ -159,7 +160,7 @@ static struct RequestTest {
 	  "GET", "/", SOUP_HTTP_1_1,
 	  { { "Foo", "bar, baz, quux" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	{ "Connection header on HTTP/1.0 message", NULL,
@@ -169,21 +170,21 @@ static struct RequestTest {
 	  { { "Connection", "Bar, Quux" },
             { "Foo", "bar" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	{ "GET with full URI", "667637",
 	  "GET http://example.com HTTP/1.1\r\n", -1,
 	  SOUP_STATUS_OK,
 	  "GET", "http://example.com", SOUP_HTTP_1_1,
-	  { { NULL } }
+	  { { NULL } }, 0
 	},
 
 	{ "GET with full URI in upper-case", "667637",
 	  "GET HTTP://example.com HTTP/1.1\r\n", -1,
 	  SOUP_STATUS_OK,
 	  "GET", "HTTP://example.com", SOUP_HTTP_1_1,
-	  { { NULL } }
+	  { { NULL } }, 0
 	},
 
 	/* It's better for this to be passed through: this means a SoupServer
@@ -193,7 +194,7 @@ static struct RequestTest {
 	  "GET AbOuT: HTTP/1.1\r\n", -1,
 	  SOUP_STATUS_OK,
 	  "GET", "AbOuT:", SOUP_HTTP_1_1,
-	  { { NULL } }
+	  { { NULL } }, 0
 	},
 
 	/****************************/
@@ -208,7 +209,7 @@ static struct RequestTest {
 	  "GET", "/", SOUP_HTTP_1_1,
 	  { { "Host", "example.com" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	/* RFC 2616 section 3.1 says we MUST accept this */
@@ -219,7 +220,7 @@ static struct RequestTest {
 	  "GET", "/", SOUP_HTTP_1_1,
 	  { { "Host", "example.com" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	/* RFC 2616 section 19.3 says we SHOULD accept these */
@@ -231,7 +232,7 @@ static struct RequestTest {
 	  { { "Host", "example.com" },
 	    { "Connection", "close" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	{ "LF instead of CRLF after Request-Line", NULL,
@@ -240,7 +241,7 @@ static struct RequestTest {
 	  "GET", "/", SOUP_HTTP_1_1,
 	  { { "Host", "example.com" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	{ "Mixed CRLF/LF", "666316",
@@ -252,7 +253,7 @@ static struct RequestTest {
 	    { "e", "f" },
 	    { "g", "h" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	{ "Req w/ incorrect whitespace in Request-Line", NULL,
@@ -261,7 +262,7 @@ static struct RequestTest {
 	  "GET", "/", SOUP_HTTP_1_1,
 	  { { "Host", "example.com" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	{ "Req w/ incorrect whitespace after Request-Line", "475169",
@@ -270,7 +271,7 @@ static struct RequestTest {
 	  "GET", "/", SOUP_HTTP_1_1,
 	  { { "Host", "example.com" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	/* If the request/status line is parseable, then we
@@ -284,7 +285,7 @@ static struct RequestTest {
 	  { { "Host", "example.com" },
 	    { "Bar", "two" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	{ "First header line is continuation", "666316",
@@ -294,7 +295,7 @@ static struct RequestTest {
 	  { { "Host", "example.com" },
 	    { "c", "d" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	{ "Zero-length header name", "666316",
@@ -304,7 +305,7 @@ static struct RequestTest {
 	  { { "a", "b" },
 	    { "c", "d" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	{ "CR in header name", "666316",
@@ -314,7 +315,7 @@ static struct RequestTest {
 	  { { "a", "b" },
 	    { "c", "d" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	{ "CR in header value", "666316",
@@ -327,7 +328,7 @@ static struct RequestTest {
 	    { "s", "t" },		/* CR at end is ignored */
 	    { "c", "d" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	{ "Tab in header name", "666316",
@@ -342,7 +343,7 @@ static struct RequestTest {
 	    { "p", "q z: w" },
 	    { "c", "d" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	{ "Tab in header value", "666316",
@@ -355,7 +356,7 @@ static struct RequestTest {
 	    { "z", "w" },	/* trailing tab ignored */
 	    { "c", "d" },
 	    { NULL }
-	  }
+	  }, 0
 	},
 
 	/************************/
@@ -366,70 +367,70 @@ static struct RequestTest {
 	  "GET /\r\n", -1,
 	  SOUP_STATUS_BAD_REQUEST,
 	  NULL, NULL, -1,
-	  { { NULL } }
+	  { { NULL } }, 0
 	},
 
 	{ "HTTP 1.2 request (no such thing)", NULL,
 	  "GET / HTTP/1.2\r\n", -1,
 	  SOUP_STATUS_HTTP_VERSION_NOT_SUPPORTED,
 	  NULL, NULL, -1,
-	  { { NULL } }
+	  { { NULL } }, 0
 	},
 
 	{ "HTTP 2000 request (no such thing)", NULL,
 	  "GET / HTTP/2000.0\r\n", -1,
 	  SOUP_STATUS_HTTP_VERSION_NOT_SUPPORTED,
 	  NULL, NULL, -1,
-	  { { NULL } }
+	  { { NULL } }, 0
 	},
 
 	{ "Non-HTTP request", NULL,
 	  "GET / SOUP/1.1\r\nHost: example.com\r\n", -1,
 	  SOUP_STATUS_BAD_REQUEST,
 	  NULL, NULL, -1,
-	  { { NULL } }
+	  { { NULL } }, 0
 	},
 
 	{ "Junk after Request-Line", NULL,
 	  "GET / HTTP/1.1 blah\r\nHost: example.com\r\n", -1,
 	  SOUP_STATUS_BAD_REQUEST,
 	  NULL, NULL, -1,
-	  { { NULL } }
+	  { { NULL } }, 0
 	},
 
 	{ "NUL in Method", NULL,
 	  "G\x00T / HTTP/1.1\r\nHost: example.com\r\n", 37,
 	  SOUP_STATUS_BAD_REQUEST,
 	  NULL, NULL, -1,
-	  { { NULL } }
+	  { { NULL } }, 0
 	},
 
 	{ "NUL at beginning of Method", "666316",
 	  "\x00 / HTTP/1.1\r\nHost: example.com\r\n", 35,
 	  SOUP_STATUS_BAD_REQUEST,
 	  NULL, NULL, -1,
-	  { { NULL } }
+	  { { NULL } }, 0
 	},
 
 	{ "NUL in Path", NULL,
 	  "GET /\x00 HTTP/1.1\r\nHost: example.com\r\n", 38,
 	  SOUP_STATUS_BAD_REQUEST,
 	  NULL, NULL, -1,
-	  { { NULL } }
+	  { { NULL } }, 0
 	},
 
 	{ "No terminating CRLF", NULL,
 	  "GET / HTTP/1.1\r\nHost: example.com", -1,
 	  SOUP_STATUS_BAD_REQUEST,
 	  NULL, NULL, -1,
-	  { { NULL } }
+	  { { NULL } }, 0
 	},
 
 	{ "Unrecognized expectation", NULL,
 	  "GET / HTTP/1.1\r\nHost: example.com\r\nExpect: the-impossible\r\n", -1,
 	  SOUP_STATUS_EXPECTATION_FAILED,
 	  NULL, NULL, -1,
-	  { { NULL } }
+	  { { NULL } }, 0
 	},
 
 	// https://gitlab.gnome.org/GNOME/libsoup/-/issues/377
@@ -437,15 +438,42 @@ static struct RequestTest {
 	  "GET / HTTP/1.1\r\nHost\x00: example.com\r\n", 36,
 	  SOUP_STATUS_BAD_REQUEST,
 	  NULL, NULL, -1,
-	  { { NULL } }
+	  { { NULL } }, 0
 	},
 
 	{ "NUL in header value", NULL,
 	  "HTTP/1.1 200 OK\r\nFoo: b\x00" "ar\r\n", 28,
 	  SOUP_STATUS_BAD_REQUEST,
            NULL, NULL, -1,
-	  { { NULL } }
+	  { { NULL } }, 0
 	}
+
+	{ "Only newlines", NULL,
+          only_newlines, sizeof (only_newlines),
+          SOUP_STATUS_BAD_REQUEST,
+            NULL, NULL, -1,
+         { { NULL } }, 0
+       },
+
+       { "Duplicate Host headers",
+         "https://gitlab.gnome.org/GNOME/libsoup/-/issues/472",
+         "GET / HTTP/1.1\r\nHost: example.com\r\nHost: example.org\r\n",
+         -1,
+         SOUP_STATUS_BAD_REQUEST,
+         NULL, NULL, -1,
+         { { NULL } },
+         G_LOG_LEVEL_WARNING
+       },
+
+       { "Duplicate Host headers, case insensitive",
+         "https://gitlab.gnome.org/GNOME/libsoup/-/issues/472",
+         "GET / HTTP/1.1\r\nHost: example.com\r\nhost: example.org\r\n",
+         -1,
+         SOUP_STATUS_BAD_REQUEST,
+         NULL, NULL, -1,
+         { { NULL } },
+         G_LOG_LEVEL_WARNING
+        }
 };
 static const int num_reqtests = G_N_ELEMENTS (reqtests);
 
@@ -892,10 +920,17 @@ do_request_tests (void)
 			len = strlen (reqtests[i].request);
 		else
 			len = reqtests[i].length;
+
+		if (reqtests[i].log_flags)
+			g_test_expect_message ("libsoup", reqtests[i].log_flags, "*");
+
 		status = soup_headers_parse_request (reqtests[i].request, len,
 						     headers, &method, &path,
 						     &version);
 		g_assert_cmpint (status, ==, reqtests[i].status);
+		if (reqtests[i].log_flags)
+			g_test_assert_expected_messages ();
+
 		if (SOUP_STATUS_IS_SUCCESSFUL (status)) {
 			g_assert_cmpstr (method, ==, reqtests[i].method);
 			g_assert_cmpstr (path, ==, reqtests[i].path);
@@ -1245,16 +1280,21 @@ do_append_param_tests (void)
 
 static const struct {
 	const char *description, *name, *value;
-} bad_headers[] = {
-	{ "Empty name", "", "value" },
-	{ "Name with spaces", "na me", "value" },
-	{ "Name with colon", "na:me", "value" },
-	{ "Name with CR", "na\rme", "value" },
-	{ "Name with LF", "na\nme", "value" },
-	{ "Name with tab", "na\tme", "value" },
-	{ "Value with CR", "name", "val\rue" },
-	{ "Value with LF", "name", "val\nue" },
-	{ "Value with LWS", "name", "val\r\n ue" }
+} bad_header_names[] = {
+	{ "empty name", "", "value" },
+	{ "name with spaces", "na me", "value" },
+	{ "name with colon", "na:me", "value" },
+	{ "name with CR", "na\rme", "value" },
+	{ "name with LF", "na\nme", "value" },
+	{ "name with tab", "na\tme", "value" }
+};
+
+static const struct {
+        const char *description, *name, *value;
+} bad_header_values[] = {
+	{ "value with CR", "name", "val\rue" },
+	{ "value with LF", "name", "val\nue" },
+	{ "value with LWS", "name", "val\r\n ue" }
 };
 
 static void
@@ -1264,15 +1304,105 @@ do_bad_header_tests (void)
 	int i;
 
 	hdrs = soup_message_headers_new (SOUP_MESSAGE_HEADERS_MULTIPART);
-	for (i = 0; i < G_N_ELEMENTS (bad_headers); i++) {
-		debug_printf (1, "  %s\n", bad_headers[i].description);
-
-		g_test_expect_message ("libsoup", G_LOG_LEVEL_CRITICAL,
-				       "*soup_message_headers_append*assertion*failed*");
-		soup_message_headers_append (hdrs, bad_headers[i].name,
-					     bad_headers[i].value);
-		g_test_assert_expected_messages ();
+
+        /* soup_message_headers_append: bad names */
+	for (i = 0; i < G_N_ELEMENTS (bad_header_names); i++) {
+		debug_printf (1, "  Append %s\n", bad_header_names[i].description);
+
+                g_test_expect_message ("libsoup", G_LOG_LEVEL_WARNING,
+                                       "*soup_message_headers_append*Rejecting bad name*");
+		soup_message_headers_append (hdrs, bad_header_names[i].name,
+					     bad_header_names[i].value);
+                g_test_assert_expected_messages ();
+	}
+
+        /* soup_message_headers_append: bad values */
+        for (i = 0; i < G_N_ELEMENTS (bad_header_values); i++) {
+		debug_printf (1, "  Append %s\n", bad_header_values[i].description);
+
+                g_test_expect_message ("libsoup", G_LOG_LEVEL_WARNING,
+                                       "*soup_message_headers_append*Rejecting bad value*");
+		soup_message_headers_append (hdrs, bad_header_values[i].name,
+					     bad_header_values[i].value);
+                g_test_assert_expected_messages ();
 	}
+
+        /* soup_message_headers_replace: bad values */
+        for (i = 0; i < G_N_ELEMENTS (bad_header_values); i++) {
+		debug_printf (1, "  Replace %s\n", bad_header_values[i].description);
+
+                g_test_expect_message ("libsoup", G_LOG_LEVEL_WARNING,
+                                       "*soup_message_headers_append*Rejecting bad value*");
+		soup_message_headers_replace (hdrs, bad_header_values[i].name,
+                                              bad_header_values[i].value);
+                g_test_assert_expected_messages ();
+	}
+
+        /* soup_message_headers_set_content_type: bad values */
+        for (i = 0; i < G_N_ELEMENTS (bad_header_values); i++) {
+                GHashTable *params;
+
+                debug_printf (1, "  Content type with %s\n", bad_header_values[i].description);
+
+                g_test_expect_message ("libsoup", G_LOG_LEVEL_WARNING,
+                                       "*soup_message_headers_append*Rejecting bad value*");
+                soup_message_headers_set_content_type (hdrs, bad_header_values[i].value, NULL);
+                g_test_assert_expected_messages ();
+
+                g_test_expect_message ("libsoup", G_LOG_LEVEL_WARNING,
+                                       "*soup_message_headers_append*Rejecting bad value*");
+                params = g_hash_table_new (g_str_hash, g_str_equal);
+                g_hash_table_insert (params, CONTENT_TYPE_TEST_ATTRIBUTE, (gpointer)bad_header_values[i].value);
+                soup_message_headers_set_content_type (hdrs, CONTENT_TYPE_TEST_MIME_TYPE, params);
+                g_hash_table_destroy (params);
+                g_test_assert_expected_messages ();
+        }
+
+        /* soup_message_headers_set_content_disposition: bad values */
+        for (i = 0; i < G_N_ELEMENTS (bad_header_values); i++) {
+                GHashTable *params;
+
+                debug_printf (1, "  Content disposition with %s\n", bad_header_values[i].description);
+
+                g_test_expect_message ("libsoup", G_LOG_LEVEL_WARNING,
+                                       "*soup_message_headers_append*Rejecting bad value*");
+                soup_message_headers_set_content_disposition (hdrs, bad_header_values[i].value, NULL);
+                g_test_assert_expected_messages ();
+
+                g_test_expect_message ("libsoup", G_LOG_LEVEL_WARNING,
+                                       "*soup_message_headers_append*Rejecting bad value*");
+                params = g_hash_table_new (g_str_hash, g_str_equal);
+                g_hash_table_insert (params, "filename", (gpointer)bad_header_values[i].value);
+                soup_message_headers_set_content_disposition (hdrs, "attachment", params);
+                g_hash_table_destroy (params);
+                g_test_assert_expected_messages ();
+        }
+	soup_message_headers_unref (hdrs);
+}
+
+static void
+do_append_duplicate_host_test (void)
+{
+	SoupMessageHeaders *hdrs;
+	const char *list_value;
+
+	hdrs = soup_message_headers_new (SOUP_MESSAGE_HEADERS_REQUEST);
+	soup_message_headers_append (hdrs, "Host", "a");
+
+	g_test_expect_message ("libsoup", G_LOG_LEVEL_WARNING,
+		               "soup_message_headers_append_common: Rejecting duplicate Host header");
+	soup_message_headers_append (hdrs, "Host", "b");
+	g_test_assert_expected_messages ();
+
+        /* Case insensitive */
+	g_test_expect_message ("libsoup", G_LOG_LEVEL_WARNING,
+		               "soup_message_headers_append_common: Rejecting duplicate Host header");
+	soup_message_headers_append (hdrs, "host", "b");
+	g_test_assert_expected_messages ();
+
+	list_value = soup_message_headers_get_list (hdrs, "Host");
+	g_assert_cmpstr (list_value, ==, "a");
+
 	soup_message_headers_unref (hdrs);
 }
 
@@ -1291,6 +1421,7 @@ main (int argc, char **argv)
 	g_test_add_func ("/header-parsing/content-type", do_content_type_tests);
 	g_test_add_func ("/header-parsing/append-param", do_append_param_tests);
 	g_test_add_func ("/header-parsing/bad", do_bad_header_tests);
+	g_test_add_func ("/header-parsing/append-duplicate-host", do_append_duplicate_host_test);
 
 	ret = g_test_run ();
 
diff --git a/tests/http2-test.c b/tests/http2-test.c
index 92944d6..6fa63e9 100644
--- a/tests/http2-test.c
+++ b/tests/http2-test.c
@@ -1351,8 +1351,8 @@ server_handler (SoupServer        *server,
                 SoupMessageHeaders *response_headers;
 
                 response_headers = soup_server_message_get_response_headers (msg);
-                /* Use soup_message_headers_append_common to skip the validation check. */
-                soup_message_headers_append_common (response_headers, SOUP_HEADER_CONTENT_TYPE, "\r");
+                /* Use soup_message_headers_append_common with trusted_value=TRUE to skip the validation check. */
+                soup_message_headers_append_common (response_headers, SOUP_HEADER_CONTENT_TYPE, "\r", TRUE);
                 soup_server_message_set_status (msg, SOUP_STATUS_OK, NULL);
         } else if (strcmp (path, "/invalid-header-rfc9113") == 0) {
                 SoupMessageHeaders *response_headers;
-- 
2.45.4

