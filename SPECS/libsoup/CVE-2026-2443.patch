From 61d80f22c9117d6d73c20d506346a2e9a4d5d42b Mon Sep 17 00:00:00 2001
From: Philip Withnall <pwithnall@gnome.org>
Date: Fri, 19 Dec 2025 23:49:05 +0000
Subject: [PATCH 1/7] soup-message-headers: Reject invalid Range ends longer
 than the content

If the `Range` header in a request specifies a range longer than the
full content, it should be rejected. Previously, only the start of the
range was validated, rather than the start and the end. This led to an
assertion failure in `g_bytes_new_from_bytes()` (or a buffer overflow if
GLib was compiled with `G_DISABLE_CHECKS`, which is not recommended).

Add the missing check on the Range end, and add a unit test.

Spotted by Codean Labs.

Signed-off-by: Philip Withnall <pwithnall@gnome.org>

Fixes: #487
---
 libsoup/soup-message-headers.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/libsoup/soup-message-headers.c b/libsoup/soup-message-headers.c
index 1a6be25..f869bac 100644
--- a/libsoup/soup-message-headers.c
+++ b/libsoup/soup-message-headers.c
@@ -1203,7 +1203,9 @@ soup_message_headers_get_ranges_internal (SoupMessageHeaders  *hdrs,
 		if (*end) {
 			status = SOUP_STATUS_OK;
 			break;
-		} else if (check_satisfiable && cur.start >= total_length) {
+		} else if (check_satisfiable &&
+			   (cur.start >= total_length ||
+			    cur.end >= total_length)) {
 			if (status == SOUP_STATUS_OK)
 				status = SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE;
 			continue;
-- 
2.45.4


From 24a1aa4270ae60c125354a5dda5d28fd9e5aff2d Mon Sep 17 00:00:00 2001
From: Philip Withnall <pwithnall@gnome.org>
Date: Fri, 19 Dec 2025 23:51:52 +0000
Subject: [PATCH 2/7] soup-message-headers: Reject ranges where end is before
 start

Previously this returned HTTP status 200 OK, which is not what MDN says
should happen for an invalid range:
https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Range.

Add a unit test.

Signed-off-by: Philip Withnall <pwithnall@gnome.org>
---
 libsoup/soup-message-headers.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libsoup/soup-message-headers.c b/libsoup/soup-message-headers.c
index f869bac..3c07207 100644
--- a/libsoup/soup-message-headers.c
+++ b/libsoup/soup-message-headers.c
@@ -1194,7 +1194,7 @@ soup_message_headers_get_ranges_internal (SoupMessageHeaders  *hdrs,
 			if (*end) {
 				cur.end = g_ascii_strtoull (end, &end, 10);
 				if (cur.end < cur.start) {
-					status = SOUP_STATUS_OK;
+					status = SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE;
 					break;
 				}
 			} else
-- 
2.45.4


From db5bf089791da03f4fc566a8c9f890376e10776c Mon Sep 17 00:00:00 2001
From: Philip Withnall <pwithnall@gnome.org>
Date: Sat, 20 Dec 2025 00:14:00 +0000
Subject: [PATCH 3/7] soup-message-headers: Fix parsing of invalid Range suffix
 lengths

The way the parser for the `Range` header is implemented, this would
result in a range with an end 1 byte before its start.

Add a unit test.

Signed-off-by: Philip Withnall <pwithnall@gnome.org>
---
 libsoup/soup-message-headers.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/libsoup/soup-message-headers.c b/libsoup/soup-message-headers.c
index 3c07207..6450ef9 100644
--- a/libsoup/soup-message-headers.c
+++ b/libsoup/soup-message-headers.c
@@ -1187,6 +1187,10 @@ soup_message_headers_get_ranges_internal (SoupMessageHeaders  *hdrs,
 		if (*spec == '-') {
 			cur.start = g_ascii_strtoll (spec, &end, 10) + total_length;
 			cur.end = total_length - 1;
+			if (cur.end < cur.start) {
+				status = SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE;
+				break;
+			}
 		} else {
 			cur.start = g_ascii_strtoull (spec, &end, 10);
 			if (*end == '-')
-- 
2.45.4


From 98f252c826ef11fcaf74a0c51c2eab59c95bc9e9 Mon Sep 17 00:00:00 2001
From: Philip Withnall <pwithnall@gnome.org>
Date: Sat, 20 Dec 2025 00:18:25 +0000
Subject: [PATCH 4/7] soup-message-headers: Fix rejection of Range headers with
 trailing garbage
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

If thereâ€™s unparseable content after a range, reject the header as
invalid rather than ignoring it and returning status 200 OK.

Add a unit test.

Signed-off-by: Philip Withnall <pwithnall@gnome.org>
---
 libsoup/soup-message-headers.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libsoup/soup-message-headers.c b/libsoup/soup-message-headers.c
index 6450ef9..2752420 100644
--- a/libsoup/soup-message-headers.c
+++ b/libsoup/soup-message-headers.c
@@ -1205,7 +1205,7 @@ soup_message_headers_get_ranges_internal (SoupMessageHeaders  *hdrs,
 				cur.end = total_length - 1;
 		}
 		if (*end) {
-			status = SOUP_STATUS_OK;
+			status = SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE;
 			break;
 		} else if (check_satisfiable &&
 			   (cur.start >= total_length ||
-- 
2.45.4


From 7916ba538ebd5c15b5b46f7e5ea6c405d2726270 Mon Sep 17 00:00:00 2001
From: Philip Withnall <pwithnall@gnome.org>
Date: Thu, 25 Dec 2025 23:16:02 +0000
Subject: [PATCH 5/7] tests: Allow range tests to check more response statuses

Currently the tests can either assert that a response to a Range request
is HTTP 206 (Partial Content) or HTTP 416 (Range Not Satisfiable).
However, many of the states resulting from parsing a Range header
actually should have a HTTP 200 (OK) response, where the Range header is
ignored due to being completely invalid. This is what Apache does when,
for example, given a Range header where the end of the range is before
the start.

Add some extra arguments to the helper functions in `range-test.c` to
allow the expected response status and expected response start and end
(of the full response) to be given by the test, and change the existing
tests to use these extra arguments.

This introduces no behavioural changes for now, but will allow following
commits to test their status 200 responses.

Signed-off-by: Philip Withnall <pwithnall@gnome.org>
-- 
2.45.4


From f638a577e497c3e84fb86d56035ac44e465c3748 Mon Sep 17 00:00:00 2001
From: Philip Withnall <pwithnall@gnome.org>
Date: Thu, 25 Dec 2025 23:20:03 +0000
Subject: [PATCH 6/7] soup-message-headers: Rework Range response statuses to
 match Apache

And for the parsing logic to more closely match the wording of the
HTTP specification (https://httpwg.org/specs/rfc9110.html#field.range).

The previous behaviour (from my previous few commits) was potentially
correct according to the spec, but differed from what Apache implements,
so was inadvisable. Specifically, the code returned HTTP 416 for various
parsing errors on the Range header; whereas Apache ignores completely
invalid Range headers and returns HTTP 200 with the full response. For
partially invalid Range headers, it returns the valid ranges.

Implement that behaviour instead, and rework the structure of the Range
parsing code to (hopefully) make that intent clearer. For example,
separate the string parsing code from the numeric range checks, and
separate those from the decision about which HTTP status to return.

Signed-off-by: Philip Withnall <pwithnall@gnome.org>

Helps: #487
---
 libsoup/soup-message-headers.c | 68 ++++++++++++++++++++++------------
 1 file changed, 44 insertions(+), 24 deletions(-)

diff --git a/libsoup/soup-message-headers.c b/libsoup/soup-message-headers.c
index 2752420..d208191 100644
--- a/libsoup/soup-message-headers.c
+++ b/libsoup/soup-message-headers.c
@@ -1146,10 +1146,16 @@ sort_ranges (gconstpointer a, gconstpointer b)
 }
 
 /* like soup_message_headers_get_ranges(), except it returns:
- *   SOUP_STATUS_OK if there is no Range or it should be ignored.
- *   SOUP_STATUS_PARTIAL_CONTENT if there is at least one satisfiable range.
- *   SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE if @check_satisfiable
- *     is %TRUE and the request is not satisfiable given @total_length.
+ *  - SOUP_STATUS_OK if there is no Range or it should be ignored due to being
+ *    entirely invalid.
+ *  - SOUP_STATUS_PARTIAL_CONTENT if there is at least one satisfiable range.
+ *  - SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE if @check_satisfiable
+ *     is %TRUE, the Range is valid, but no part of the request is satisfiable
+ *     given @total_length.
+ *
+ * @ranges and @length are only set if SOUP_STATUS_PARTIAL_CONTENT is returned.
+ *
+ * See https://httpwg.org/specs/rfc9110.html#field.range
  */
 guint
 soup_message_headers_get_ranges_internal (SoupMessageHeaders  *hdrs,
@@ -1163,22 +1169,28 @@ soup_message_headers_get_ranges_internal (SoupMessageHeaders  *hdrs,
 	GArray *array;
 	char *spec, *end;
 	guint status = SOUP_STATUS_OK;
+	gboolean is_all_valid = TRUE;
 
 	if (!range || strncmp (range, "bytes", 5) != 0)
-		return status;
+		return SOUP_STATUS_OK;  /* invalid header or unknown range unit */
 
 	range += 5;
 	while (g_ascii_isspace (*range))
 		range++;
 	if (*range++ != '=')
-		return status;
+		return SOUP_STATUS_OK;  /* invalid header */
 	while (g_ascii_isspace (*range))
 		range++;
 
 	range_list = soup_header_parse_list (range);
 	if (!range_list)
-		return status;
+		return SOUP_STATUS_OK;  /* invalid list */
 
+	/* Loop through the ranges and modify the status accordingly. Default to
+	 * status 200 (OK, ignoring the ranges). Switch to status 206 (Partial
+	 * Content) if there is at least one partially valid range. Switch to
+	 * status 416 (Range Not Satisfiable) if there are no partially valid
+	 * ranges at all. */
 	array = g_array_new (FALSE, FALSE, sizeof (SoupRange));
 	for (r = range_list; r; r = r->next) {
 		SoupRange cur;
@@ -1187,40 +1199,48 @@ soup_message_headers_get_ranges_internal (SoupMessageHeaders  *hdrs,
 		if (*spec == '-') {
 			cur.start = g_ascii_strtoll (spec, &end, 10) + total_length;
 			cur.end = total_length - 1;
-			if (cur.end < cur.start) {
-				status = SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE;
-				break;
-			}
 		} else {
 			cur.start = g_ascii_strtoull (spec, &end, 10);
 			if (*end == '-')
 				end++;
-			if (*end) {
+			if (*end)
 				cur.end = g_ascii_strtoull (end, &end, 10);
-				if (cur.end < cur.start) {
-					status = SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE;
-					break;
-				}
-			} else
+			else
 				cur.end = total_length - 1;
 		}
+
 		if (*end) {
-			status = SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE;
-			break;
-		} else if (check_satisfiable &&
-			   (cur.start >= total_length ||
-			    cur.end >= total_length)) {
-			if (status == SOUP_STATUS_OK)
-				status = SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE;
+			/* Junk after the range */
+			is_all_valid = FALSE;
 			continue;
 		}
 
+		if (cur.end < cur.start) {
+			is_all_valid = FALSE;
+			continue;
+		}
+
+		g_assert (cur.start >= 0);
+		if (cur.end >= total_length)
+			cur.end = total_length - 1;
+
+		if (cur.start >= total_length) {
+			/* Range is valid, but unsatisfiable */
+			continue;
+		}
+
+		/* We have at least one (at least partially) satisfiable range */
 		g_array_append_val (array, cur);
 		status = SOUP_STATUS_PARTIAL_CONTENT;
 	}
 	soup_header_free_list (range_list);
 
 	if (status != SOUP_STATUS_PARTIAL_CONTENT) {
+		g_assert (status == SOUP_STATUS_OK);
+
+		if (is_all_valid && check_satisfiable)
+			status = SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE;
+
 		g_array_free (array, TRUE);
 		return status;
 	}
-- 
2.45.4


From 2f462883ba2130170aae68bc27b20faa21cc5a6b Mon Sep 17 00:00:00 2001
From: Philip Withnall <pwithnall@gnome.org>
Date: Thu, 25 Dec 2025 23:50:30 +0000
Subject: [PATCH 7/7] tests: Add more tests for invalid Range headers

This gives full line and branch coverage of
`soup_message_headers_get_ranges_internal()`.

Signed-off-by: Philip Withnall <pwithnall@gnome.org>
-- 
2.45.4

