From cd0dc66eb17166e77b2cabd12cf981e4ee650976 Mon Sep 17 00:00:00 2001
From: AllSpark <allspark@microsoft.com>
Date: Mon, 9 Feb 2026 08:17:31 +0000
Subject: [PATCH] http1: Use CRLF boundaries when parsing chunked encoding;
 server: close connection if both Content-Length and Transfer-Encoding are
 present; headers: prioritize Transfer-Encoding over Content-Length and adjust
 encoding detection; add server chunked test

Signed-off-by: Azure Linux Security Servicing Account <azurelinux-security@microsoft.com>
Upstream-reference: AI Backport of https://gitlab.gnome.org/GNOME/libsoup/-/merge_requests/500.patch
---
 libsoup/http1/soup-body-input-stream.c        | 34 ++++---
 .../http1/soup-server-message-io-http1.c      |  8 ++
 libsoup/soup-message-headers.c                | 89 +++++++++----------
 tests/server-test.c                           | 71 +++++++++++++++
 4 files changed, 141 insertions(+), 61 deletions(-)

diff --git a/libsoup/http1/soup-body-input-stream.c b/libsoup/http1/soup-body-input-stream.c
index 69a93c0..b030968 100644
--- a/libsoup/http1/soup-body-input-stream.c
+++ b/libsoup/http1/soup-body-input-stream.c
@@ -176,15 +176,19 @@ soup_body_input_stream_read_chunked (SoupBodyInputStream  *bistream,
 again:
 	switch (priv->chunked_state) {
 	case SOUP_BODY_INPUT_STREAM_STATE_CHUNK_SIZE:
-		nread = soup_filter_input_stream_read_line (
-			fstream, metabuf, sizeof (metabuf), blocking,
+		nread = soup_filter_input_stream_read_until (
+			fstream, metabuf, sizeof (metabuf),
+					"\r\n", 2, blocking, TRUE,
 			&got_line, cancellable, error);
-		if (nread <= 0)
+		if (nread < 0)
 			return nread;
-		if (!got_line) {
-			g_set_error_literal (error, G_IO_ERROR,
-					     G_IO_ERROR_PARTIAL_INPUT,
-					     _("Connection terminated unexpectedly"));
+
+		if (nread == 0 || !got_line) {
+			if (error && *error == NULL) {
+				g_set_error_literal (error, G_IO_ERROR,
+						     G_IO_ERROR_PARTIAL_INPUT,
+						     _("Connection terminated unexpectedly"));
+			}
 			return -1;
 		}
 
@@ -208,11 +212,12 @@ again:
 		return nread;
 
 	case SOUP_BODY_INPUT_STREAM_STATE_CHUNK_END:
-		nread = soup_filter_input_stream_read_line (
+		nread = soup_filter_input_stream_read_until (
 			SOUP_FILTER_INPUT_STREAM (priv->base_stream),
-			metabuf, sizeof (metabuf), blocking,
+			metabuf, sizeof (metabuf),
+					"\r\n", 2, blocking, TRUE,
 			&got_line, cancellable, error);
-		if (nread <= 0)
+		if (nread < 0)
 			return nread;
 		if (!got_line) {
 			g_set_error_literal (error, G_IO_ERROR,
@@ -225,13 +230,14 @@ again:
 		break;
 
 	case SOUP_BODY_INPUT_STREAM_STATE_TRAILERS:
-		nread = soup_filter_input_stream_read_line (
-			fstream, metabuf, sizeof (metabuf), blocking,
+		nread = soup_filter_input_stream_read_until (
+			fstream, metabuf, sizeof (metabuf),
+					"\r\n", 2, blocking, TRUE,
 			&got_line, cancellable, error);
-		if (nread <= 0)
+		if (nread < 0)
 			return nread;
 
-		if (strncmp (metabuf, "\r\n", nread) || strncmp (metabuf, "\n", nread)) {
+		if (nread == 2 && strncmp (metabuf, "\r\n", nread) == 0) {
 			priv->chunked_state = SOUP_BODY_INPUT_STREAM_STATE_DONE;
 			priv->eof = TRUE;
 		}
diff --git a/libsoup/server/http1/soup-server-message-io-http1.c b/libsoup/server/http1/soup-server-message-io-http1.c
index 3803cab..c0cbbc9 100644
--- a/libsoup/server/http1/soup-server-message-io-http1.c
+++ b/libsoup/server/http1/soup-server-message-io-http1.c
@@ -653,6 +653,14 @@ parse_headers (SoupServerMessage *msg,
                         return SOUP_STATUS_BAD_REQUEST;
         }
 
+        /* A server MAY reject a request that contains both Content-Length and
+         * Transfer-Encoding or process such a request in accordance with the
+         * Transfer-Encoding alone. Regardless, the server MUST close the connection
+         * after responding to such a request to avoid the potential attacks
+         */
+        if (*encoding == SOUP_ENCODING_CHUNKED && soup_message_headers_get_one_common (request_headers, SOUP_HEADER_CONTENT_LENGTH))
+                soup_message_headers_replace_common (request_headers, SOUP_HEADER_CONNECTION, "close");
+
         /* Generate correct context for request */
         req_host = soup_message_headers_get_one_common (request_headers, SOUP_HEADER_HOST);
         if (req_host && strchr (req_host, '/')) {
diff --git a/libsoup/soup-message-headers.c b/libsoup/soup-message-headers.c
index c1b7454..b7e7a23 100644
--- a/libsoup/soup-message-headers.c
+++ b/libsoup/soup-message-headers.c
@@ -148,19 +148,8 @@ soup_message_headers_set (SoupMessageHeaders *hdrs,
 {
         switch (name) {
         case SOUP_HEADER_CONTENT_LENGTH:
-                if (hdrs->encoding == SOUP_ENCODING_CHUNKED)
-                        return;
-
-                if (value) {
-                        char *end;
-
-                        hdrs->content_length = g_ascii_strtoull (value, &end, 10);
-                        if (*end)
-                                hdrs->encoding = SOUP_ENCODING_UNRECOGNIZED;
-                        else
-                                hdrs->encoding = SOUP_ENCODING_CONTENT_LENGTH;
-                } else
-                        hdrs->encoding = -1;
+        case SOUP_HEADER_TRANSFER_ENCODING:
+                hdrs->encoding = -1;
                 break;
         case SOUP_HEADER_CONTENT_TYPE:
                 g_clear_pointer (&hdrs->content_type, g_free);
@@ -186,21 +175,6 @@ soup_message_headers_set (SoupMessageHeaders *hdrs,
                 } else
                         hdrs->expectations = 0;
                 break;
-        case SOUP_HEADER_TRANSFER_ENCODING:
-                if (value) {
-                        /* "identity" is a wrong value according to RFC errata 408,
-                         * and RFC 7230 does not list it as valid transfer-coding.
-                         * Nevertheless, the obsolete RFC 2616 stated "identity"
-                         * as valid, so we can't handle it as unrecognized here
-                         * for compatibility reasons.
-                         */
-                        if (g_ascii_strcasecmp (value, "chunked") == 0)
-                                hdrs->encoding = SOUP_ENCODING_CHUNKED;
-                        else if (g_ascii_strcasecmp (value, "identity") != 0)
-                                hdrs->encoding = SOUP_ENCODING_UNRECOGNIZED;
-                } else
-                        hdrs->encoding = -1;
-                break;
         default:
                 break;
         }
@@ -923,30 +897,51 @@ soup_message_headers_foreach (SoupMessageHeaders           *hdrs,
 SoupEncoding
 soup_message_headers_get_encoding (SoupMessageHeaders *hdrs)
 {
-	const char *header;
+	const char *content_length;
+        const char *transfer_encoding;
+
+	g_return_val_if_fail (hdrs, SOUP_ENCODING_UNRECOGNIZED);
 
 	if (hdrs->encoding != -1)
 		return hdrs->encoding;
 
-	/* If Transfer-Encoding was set, hdrs->encoding would already
-	 * be set. So we don't need to check that possibility.
-	 */
-	header = soup_message_headers_get_one_common (hdrs, SOUP_HEADER_CONTENT_LENGTH);
-	if (header) {
-                soup_message_headers_set (hdrs, SOUP_HEADER_CONTENT_LENGTH, header);
-		if (hdrs->encoding != -1)
-			return hdrs->encoding;
-	}
+        /* Transfer-Encoding is checked first because it overrides the Content-Length */
+        transfer_encoding = soup_message_headers_get_one_common (hdrs, SOUP_HEADER_TRANSFER_ENCODING);
+        if (transfer_encoding) {
+                /* "identity" is a wrong value according to RFC errata 408,
+                 * and RFC 7230 does not list it as valid transfer-coding.
+                 * Nevertheless, the obsolete RFC 2616 stated "identity"
+                 * as valid, so we can't handle it as unrecognized here
+                 * for compatibility reasons.
+                 */
+                if (g_ascii_strcasecmp (transfer_encoding, "chunked") == 0)
+                        hdrs->encoding = SOUP_ENCODING_CHUNKED;
+                else if (g_ascii_strcasecmp (transfer_encoding, "identity") != 0)
+                        hdrs->encoding = SOUP_ENCODING_UNRECOGNIZED;
+        } else {
+                content_length = soup_message_headers_get_one_common (hdrs, SOUP_HEADER_CONTENT_LENGTH);
+                if (content_length) {
+                        char *end;
 
-	/* Per RFC 2616 4.4, a response body that doesn't indicate its
-	 * encoding otherwise is terminated by connection close, and a
-	 * request that doesn't indicate otherwise has no body. Note
-	 * that SoupMessage calls soup_message_headers_set_encoding()
-	 * to override the response body default for our own
-	 * server-side messages.
-	 */
-	hdrs->encoding = (hdrs->type == SOUP_MESSAGE_HEADERS_RESPONSE) ?
-		SOUP_ENCODING_EOF : SOUP_ENCODING_NONE;
+                        hdrs->content_length = g_ascii_strtoull (content_length, &end, 10);
+                        if (*end)
+                                hdrs->encoding = SOUP_ENCODING_UNRECOGNIZED;
+                        else
+                                hdrs->encoding = SOUP_ENCODING_CONTENT_LENGTH;
+                }
+        }
+
+        if (hdrs->encoding == -1) {
+                /* Per RFC 2616 4.4, a response body that doesn't indicate its
+                 * encoding otherwise is terminated by connection close, and a
+                 * request that doesn't indicate otherwise has no body. Note
+                 * that SoupMessage calls soup_message_headers_set_encoding()
+                 * to override the response body default for our own
+                 * server-side messages.
+                 */
+                hdrs->encoding = (hdrs->type == SOUP_MESSAGE_HEADERS_RESPONSE) ?
+                        SOUP_ENCODING_EOF : SOUP_ENCODING_NONE;
+        }
 	return hdrs->encoding;
 }
 
diff --git a/tests/server-test.c b/tests/server-test.c
index 8d0c38b..63ffb4d 100644
--- a/tests/server-test.c
+++ b/tests/server-test.c
@@ -1352,6 +1352,74 @@ do_idle_connection_closed_test (ServerData *sd, gconstpointer test_data)
         soup_test_session_abort_unref (session);
 
         while (soup_server_get_clients (sd->server))
+
+static void
+server_chunked_hundler (SoupServer        *server,
+                        SoupServerMessage *msg,
+                        const char        *path,
+                        GHashTable        *query,
+                        gpointer           data)
+{
+        g_assert_true (soup_server_message_get_method (msg) == SOUP_METHOD_POST);
+        g_assert_cmpstr (path, ==, "/valid");
+
+        soup_server_message_set_status (msg, SOUP_STATUS_OK, NULL);
+        soup_server_message_set_response (msg, "text/plain", SOUP_MEMORY_STATIC, "index", 5);
+}
+
+#define CHUNKED_FORMAT_REQUEST "POST /valid HTTP/1.1\r\nHost: 127.0.0.1\r\n%sGET /invalid HTTP/1.1\r\nHost: 127.0.0.1\r\n\r\n"
+
+static void
+do_chunked_test (ServerData *sd, gconstpointer test_data)
+{
+        gint i;
+        struct {
+                const char *description;
+                const char *test;
+        } tests[] = {
+                { "Lone LF", "Transfer-Encoding: chunked\r\n\r\n5;ext\n data\r\n0\r\n\r\n" },
+        };
+
+        sd->server = soup_test_server_new (SOUP_TEST_SERVER_IN_THREAD);
+        sd->base_uri = soup_test_server_get_uri (sd->server, "http", NULL);
+        server_add_handler (sd, NULL, server_chunked_hundler, NULL, NULL);
+
+        for (i = 0; i < G_N_ELEMENTS (tests); i++) {
+                GSocketClient *client;
+                GSocketConnection *conn;
+                GInputStream *input;
+                GOutputStream *output;
+                char *request;
+                char buffer[4096];
+                gssize nread;
+                GError *error = NULL;
+
+                debug_printf (1, "  %s\n", tests[i].description);
+
+                client = g_socket_client_new ();
+                conn = g_socket_client_connect_to_host (client, g_uri_get_host (sd->base_uri), g_uri_get_port (sd->base_uri), NULL, &error);
+                g_assert_no_error (error);
+
+                g_assert_no_error (error);
+
+                request = g_strdup_printf (CHUNKED_FORMAT_REQUEST, tests[i].test);
+
+                output = g_io_stream_get_output_stream (G_IO_STREAM (conn));
+                g_output_stream_write_all (output, request, strlen (request), NULL, NULL, NULL);
+                g_output_stream_close (output, NULL, NULL);
+                g_socket_shutdown (g_socket_connection_get_socket (G_SOCKET_CONNECTION (conn)), FALSE, TRUE, &error);
+
+                input = g_io_stream_get_input_stream (G_IO_STREAM (conn));
+                do {
+                        nread = g_input_stream_read (input, buffer, sizeof(buffer), NULL, NULL);
+                } while (nread > 0);
+
+                g_free (request);
+                g_object_unref (conn);
+                g_object_unref (client);
+        }
+}
+
                 g_main_context_iteration (NULL, FALSE);
 }
 
@@ -1385,6 +1453,9 @@ main (int argc, char **argv)
 		    server_setup_nohandler, do_fail_404_test, server_teardown);
 	g_test_add ("/server/fail/500", ServerData, GINT_TO_POINTER (FALSE),
 		    server_setup_nohandler, do_fail_500_test, server_teardown);
+        g_test_add ("/server/chunked", ServerData, NULL,
+                    NULL, do_chunked_test, server_teardown);
+
 	g_test_add ("/server/fail/500-pause", ServerData, GINT_TO_POINTER (TRUE),
 		    server_setup_nohandler, do_fail_500_test, server_teardown);
 	g_test_add ("/server/early/stream", ServerData, NULL,
-- 
2.45.4

