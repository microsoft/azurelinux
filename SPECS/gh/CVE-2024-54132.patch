From 8da27d2c8ac8b781cf34a5e04ed57cfe4b68fa55 Mon Sep 17 00:00:00 2001
From: Andy Feller <andyfeller@github.com>
Date: Tue, 19 Nov 2024 17:55:18 -0500
Subject: [PATCH 1/5] Second attempt to address exploit

This builds off suggestion to reuse logic used already within `gh run download` for detecting path traversals.

This largely works but runs into an issue where detection logic doesn't handle non-separated traversal.

From 83cf41155646380d3df4037d3f2ac683147f194a Mon Sep 17 00:00:00 2001
From: Tyler McGoffin <jtmcg@github.com>
Date: Tue, 19 Nov 2024 16:08:31 -0800
Subject: [PATCH 2/5] Improve test names so there is no repetition

From e7c5706336d851b39930c7315132f89b25e77d4d Mon Sep 17 00:00:00 2001
From: Andy Feller <andyfeller@github.com>
Date: Thu, 21 Nov 2024 17:02:20 -0500
Subject: [PATCH 3/5] Refactor download testing, simpler file descends

This incorporates the work done by @williammartin to improve reasoning about `gh run download` behavior through testing while verifying a simpler solution to checking if a path is contained within a directory.

From cdfc12caf52754ea4026d5338a56ad4e6f822105 Mon Sep 17 00:00:00 2001
From: Andy Feller <andyfeller@github.com>
Date: Fri, 22 Nov 2024 15:26:11 -0500
Subject: [PATCH 4/5] Expand logic and tests to handle edge cases

This commit expands filepathDescendsFrom(string, string) to handle edge cases such as mixing absolute and relative paths or artifact name edge cases.

Additionally, tests for filepathDescendsFrom() and downloadrun() have been expanded to verify additional use cases.

From 8720479b0bfc95450abb2ba88489f2893e4838a9 Mon Sep 17 00:00:00 2001
From: Andy Feller <andyfeller@github.com>
Date: Tue, 3 Dec 2024 13:33:00 -0500
Subject: [PATCH 5/5] Consolidate logic for isolating artifacts


Modified patch 1136764c369aaf0cae4ec2ee09dc35d871076932 to apply to CBL-Mariner
Modified-by: Sandeep Karambelkar <skarambelkar@microsoft.com>
---
 pkg/cmd/run/download/download.go      |  37 +-
 pkg/cmd/run/download/download_test.go | 613 ++++++++++++++++++++------
 pkg/cmd/run/download/zip.go           |  24 +-
 pkg/cmd/run/download/zip_test.go      |  80 ++++
 4 files changed, 622 insertions(+), 132 deletions(-)
 mode change 100644 => 100755 pkg/cmd/run/download/download_test.go


diff --git a/pkg/cmd/run/download/download.go b/pkg/cmd/run/download/download.go
index 86e6127..454356e 100644
--- a/pkg/cmd/run/download/download.go
+++ b/pkg/cmd/run/download/download.go
@@ -145,8 +145,10 @@ func runDownload(opts *DownloadOptions) error {
 	opts.IO.StartProgressIndicator()
 	defer opts.IO.StopProgressIndicator()
 
-	// track downloaded artifacts and avoid re-downloading any of the same name
+	// track downloaded artifacts and avoid re-downloading any of the same name, isolate if multiple artifacts
 	downloaded := set.NewStringSet()
+	isolateArtifacts := isolateArtifacts(wantNames, wantPatterns)
+
 	for _, a := range artifacts {
 		if a.Expired {
 			continue
@@ -159,10 +161,16 @@ func runDownload(opts *DownloadOptions) error {
 				continue
 			}
 		}
+
 		destDir := opts.DestinationDir
-		if len(wantPatterns) != 0 || len(wantNames) != 1 {
+		if isolateArtifacts {
 			destDir = filepath.Join(destDir, a.Name)
 		}
+
+		if !filepathDescendsFrom(destDir, opts.DestinationDir) {
+			return fmt.Errorf("error downloading %s: would result in path traversal", a.Name)
+		}
+
 		err := opts.Platform.Download(a.DownloadURL, destDir)
 		if err != nil {
 			return fmt.Errorf("error downloading %s: %w", a.Name, err)
@@ -177,6 +185,25 @@ func runDownload(opts *DownloadOptions) error {
 	return nil
 }
 
+func isolateArtifacts(wantNames []string, wantPatterns []string) bool {
+	if len(wantPatterns) > 0 {
+		// Patterns can match multiple artifacts
+		return true
+	}
+
+	if len(wantNames) == 0 {
+		// All artifacts wanted regardless what they are named
+		return true
+	}
+
+	if len(wantNames) > 1 {
+		// Multiple, specific artifacts wanted
+		return true
+	}
+
+	return false
+}
+
 func matchAnyName(names []string, name string) bool {
 	for _, n := range names {
 		if name == n {
diff --git a/pkg/cmd/run/download/download_test.go b/pkg/cmd/run/download/download_test.go
old mode 100644
new mode 100755
index 10c7bbe..0e21207
--- a/pkg/cmd/run/download/download_test.go
+++ b/pkg/cmd/run/download/download_test.go
@@ -2,8 +2,10 @@ package download
 
 import (
 	"bytes"
+	"errors"
 	"io"
 	"net/http"
+	"os"
 	"path/filepath"
 	"testing"
 
@@ -142,146 +144,481 @@ func Test_NewCmdDownload(t *testing.T) {
 	}
 }
 
+type testArtifact struct {
+	artifact shared.Artifact
+	files    []string
+}
+type fakePlatform struct {
+	runArtifacts map[string][]testArtifact
+}
+
+func (f *fakePlatform) List(runID string) ([]shared.Artifact, error) {
+	var runIds []string
+	if runID != "" {
+		runIds = []string{runID}
+	} else {
+		for k := range f.runArtifacts {
+			runIds = append(runIds, k)
+		}
+	}
+	var artifacts []shared.Artifact
+	for _, id := range runIds {
+		for _, a := range f.runArtifacts[id] {
+			artifacts = append(artifacts, a.artifact)
+		}
+	}
+	return artifacts, nil
+}
+func (f *fakePlatform) Download(url string, dir string) error {
+	if err := os.MkdirAll(dir, 0755); err != nil {
+		return err
+	}
+	// Now to be consistent, we find the artifact with the provided URL.
+	// It's a bit janky to iterate the runs, to find the right artifact
+	// rather than keying directly to it, but it allows the setup of the
+	// fake platform to be declarative rather than imperative.
+	// Think fakePlatform { artifacts: ... } rather than fakePlatform.makeArtifactAvailable()
+	for _, testArtifacts := range f.runArtifacts {
+		for _, testArtifact := range testArtifacts {
+			if testArtifact.artifact.DownloadURL == url {
+				for _, file := range testArtifact.files {
+					path := filepath.Join(dir, file)
+					return os.WriteFile(path, []byte{}, 0600)
+				}
+			}
+		}
+	}
+	return errors.New("no artifact matches the provided URL")
+}
+
 func Test_runDownload(t *testing.T) {
 	tests := []struct {
-		name       string
-		opts       DownloadOptions
-		mockAPI    func(*mockPlatform)
-		mockPrompt func(*mockPrompter)
-		wantErr    string
+		name          string
+		opts          DownloadOptions
+		platform      *fakePlatform
+		promptStubs   func(*mockPrompter)
+		expectedFiles []string
+		wantErr       string
 	}{
 		{
-			name: "download non-expired",
+			name: "download non-expired to relative directory",
 			opts: DownloadOptions{
 				RunID:          "2345",
 				DestinationDir: "./tmp",
-				Names:          []string(nil),
 			},
-			mockAPI: func(p *mockPlatform) {
-				p.On("List", "2345").Return([]shared.Artifact{
-					{
-						Name:        "artifact-1",
-						DownloadURL: "http://download.com/artifact1.zip",
-						Expired:     false,
-					},
-					{
-						Name:        "expired-artifact",
-						DownloadURL: "http://download.com/expired.zip",
-						Expired:     true,
+			platform: &fakePlatform{
+				runArtifacts: map[string][]testArtifact{
+					"2345": {
+						{
+							artifact: shared.Artifact{
+								Name:        "artifact-1",
+								DownloadURL: "http://download.com/artifact1.zip",
+								Expired:     false,
+							},
+							files: []string{
+								"artifact-1-file",
+							},
+						},
+						{
+							artifact: shared.Artifact{
+								Name:        "expired-artifact",
+								DownloadURL: "http://download.com/expired.zip",
+								Expired:     true,
+							},
+							files: []string{
+								"expired",
+							},
+						},
+						{
+							artifact: shared.Artifact{
+								Name:        "artifact-2",
+								DownloadURL: "http://download.com/artifact2.zip",
+								Expired:     false,
+							},
+							files: []string{
+								"artifact-2-file",
+							},
+						},
 					},
-					{
-						Name:        "artifact-2",
-						DownloadURL: "http://download.com/artifact2.zip",
-						Expired:     false,
-					},
-				}, nil)
-				p.On("Download", "http://download.com/artifact1.zip", filepath.FromSlash("tmp/artifact-1")).Return(nil)
-				p.On("Download", "http://download.com/artifact2.zip", filepath.FromSlash("tmp/artifact-2")).Return(nil)
+				},
+			},
+			expectedFiles: []string{
+				filepath.Join("artifact-1", "artifact-1-file"),
+				filepath.Join("artifact-2", "artifact-2-file"),
 			},
 		},
 		{
-			name: "no valid artifacts",
+			name: "download non-expired to absolute directory",
 			opts: DownloadOptions{
 				RunID:          "2345",
-				DestinationDir: ".",
-				Names:          []string(nil),
+				DestinationDir: "/tmp",
 			},
-			mockAPI: func(p *mockPlatform) {
-				p.On("List", "2345").Return([]shared.Artifact{
-					{
-						Name:        "artifact-1",
-						DownloadURL: "http://download.com/artifact1.zip",
-						Expired:     true,
+			platform: &fakePlatform{
+				runArtifacts: map[string][]testArtifact{
+					"2345": {
+						{
+							artifact: shared.Artifact{
+								Name:        "artifact-1",
+								DownloadURL: "http://download.com/artifact1.zip",
+								Expired:     false,
+							},
+							files: []string{
+								"artifact-1-file",
+							},
+						},
+						{
+							artifact: shared.Artifact{
+								Name:        "expired-artifact",
+								DownloadURL: "http://download.com/expired.zip",
+								Expired:     true,
+							},
+							files: []string{
+								"expired",
+							},
+						},
+						{
+							artifact: shared.Artifact{
+								Name:        "artifact-2",
+								DownloadURL: "http://download.com/artifact2.zip",
+								Expired:     false,
+							},
+							files: []string{
+								"artifact-2-file",
+							},
+						},
 					},
-					{
-						Name:        "artifact-2",
-						DownloadURL: "http://download.com/artifact2.zip",
-						Expired:     true,
+				},
+			},
+			expectedFiles: []string{
+				filepath.Join("artifact-1", "artifact-1-file"),
+				filepath.Join("artifact-2", "artifact-2-file"),
+			},
+		},
+		{
+			name: "all artifacts are expired",
+			opts: DownloadOptions{
+				RunID: "2345",
+			},
+			platform: &fakePlatform{
+				runArtifacts: map[string][]testArtifact{
+					"2345": {
+						{
+							artifact: shared.Artifact{
+								Name:        "artifact-1",
+								DownloadURL: "http://download.com/artifact1.zip",
+								Expired:     true,
+							},
+							files: []string{
+								"artifact-1-file",
+							},
+						},
+						{
+							artifact: shared.Artifact{
+								Name:        "artifact-2",
+								DownloadURL: "http://download.com/artifact2.zip",
+								Expired:     true,
+							},
+							files: []string{
+								"artifact-2-file",
+							},
+						},
 					},
-				}, nil)
+				},
 			},
-			wantErr: "no valid artifacts found to download",
+			expectedFiles: []string{},
+			wantErr:       "no valid artifacts found to download",
 		},
 		{
 			name: "no name matches",
 			opts: DownloadOptions{
-				RunID:          "2345",
-				DestinationDir: ".",
-				Names:          []string{"artifact-3"},
-			},
-			mockAPI: func(p *mockPlatform) {
-				p.On("List", "2345").Return([]shared.Artifact{
-					{
-						Name:        "artifact-1",
-						DownloadURL: "http://download.com/artifact1.zip",
-						Expired:     false,
+				RunID: "2345",
+				Names: []string{"artifact-3"},
+			},
+			platform: &fakePlatform{
+				runArtifacts: map[string][]testArtifact{
+					"2345": {
+						{
+							artifact: shared.Artifact{
+								Name:        "artifact-1",
+								DownloadURL: "http://download.com/artifact1.zip",
+								Expired:     false,
+							},
+							files: []string{
+								"artifact-1-file",
+							},
+						},
+						{
+							artifact: shared.Artifact{
+								Name:        "artifact-2",
+								DownloadURL: "http://download.com/artifact2.zip",
+								Expired:     false,
+							},
+							files: []string{
+								"artifact-2-file",
+							},
+						},
 					},
-					{
-						Name:        "artifact-2",
-						DownloadURL: "http://download.com/artifact2.zip",
-						Expired:     false,
+				},
+			},
+			expectedFiles: []string{},
+			wantErr:       "no artifact matches any of the names or patterns provided",
+		},
+		{
+			name: "pattern matches",
+			opts: DownloadOptions{
+				RunID:        "2345",
+				FilePatterns: []string{"artifact-*"},
+			},
+			platform: &fakePlatform{
+				runArtifacts: map[string][]testArtifact{
+					"2345": {
+						{
+							artifact: shared.Artifact{
+								Name:        "artifact-1",
+								DownloadURL: "http://download.com/artifact1.zip",
+								Expired:     false,
+							},
+							files: []string{
+								"artifact-1-file",
+							},
+						},
+						{
+							artifact: shared.Artifact{
+								Name:        "non-artifact-2",
+								DownloadURL: "http://download.com/non-artifact-2.zip",
+								Expired:     false,
+							},
+							files: []string{
+								"non-artifact-2-file",
+							},
+						},
+						{
+							artifact: shared.Artifact{
+								Name:        "artifact-3",
+								DownloadURL: "http://download.com/artifact3.zip",
+								Expired:     false,
+							},
+							files: []string{
+								"artifact-3-file",
+							},
+						},
 					},
-				}, nil)
+				},
+			},
+			expectedFiles: []string{
+				filepath.Join("artifact-1", "artifact-1-file"),
+				filepath.Join("artifact-3", "artifact-3-file"),
 			},
-			wantErr: "no artifact matches any of the names or patterns provided",
 		},
 		{
 			name: "no pattern matches",
 			opts: DownloadOptions{
-				RunID:          "2345",
-				DestinationDir: ".",
-				FilePatterns:   []string{"artifiction-*"},
-			},
-			mockAPI: func(p *mockPlatform) {
-				p.On("List", "2345").Return([]shared.Artifact{
-					{
-						Name:        "artifact-1",
-						DownloadURL: "http://download.com/artifact1.zip",
-						Expired:     false,
+				RunID:        "2345",
+				FilePatterns: []string{"artifiction-*"},
+			},
+			platform: &fakePlatform{
+				runArtifacts: map[string][]testArtifact{
+					"2345": {
+						{
+							artifact: shared.Artifact{
+								Name:        "artifact-1",
+								DownloadURL: "http://download.com/artifact1.zip",
+								Expired:     false,
+							},
+							files: []string{
+								"artifact-1-file",
+							},
+						},
+						{
+							artifact: shared.Artifact{
+								Name:        "artifact-2",
+								DownloadURL: "http://download.com/artifact2.zip",
+								Expired:     false,
+							},
+							files: []string{
+								"artifact-2-file",
+							},
+						},
 					},
-					{
-						Name:        "artifact-2",
-						DownloadURL: "http://download.com/artifact2.zip",
-						Expired:     false,
+				},
+			},
+			expectedFiles: []string{},
+			wantErr:       "no artifact matches any of the names or patterns provided",
+		},
+		{
+			name: "want specific single artifact",
+			opts: DownloadOptions{
+				RunID: "2345",
+				Names: []string{"non-artifact-2"},
+			},
+			platform: &fakePlatform{
+				runArtifacts: map[string][]testArtifact{
+					"2345": {
+						{
+							artifact: shared.Artifact{
+								Name:        "artifact-1",
+								DownloadURL: "http://download.com/artifact1.zip",
+								Expired:     false,
+							},
+							files: []string{
+								"artifact-1-file",
+							},
+						},
+						{
+							artifact: shared.Artifact{
+								Name:        "non-artifact-2",
+								DownloadURL: "http://download.com/non-artifact-2.zip",
+								Expired:     false,
+							},
+							files: []string{
+								"non-artifact-2-file",
+							},
+						},
+						{
+							artifact: shared.Artifact{
+								Name:        "artifact-3",
+								DownloadURL: "http://download.com/artifact3.zip",
+								Expired:     false,
+							},
+							files: []string{
+								"artifact-3-file",
+							},
+						},
 					},
-				}, nil)
+				},
+			},
+			expectedFiles: []string{
+				filepath.Join("non-artifact-2-file"),
 			},
-			wantErr: "no artifact matches any of the names or patterns provided",
 		},
 		{
-			name: "prompt to select artifact",
+			name: "want specific multiple artifacts",
 			opts: DownloadOptions{
-				RunID:          "",
-				DoPrompt:       true,
-				DestinationDir: ".",
-				Names:          []string(nil),
+				RunID: "2345",
+				Names: []string{"artifact-1", "artifact-3"},
 			},
-			mockAPI: func(p *mockPlatform) {
-				p.On("List", "").Return([]shared.Artifact{
-					{
-						Name:        "artifact-1",
-						DownloadURL: "http://download.com/artifact1.zip",
-						Expired:     false,
+			platform: &fakePlatform{
+				runArtifacts: map[string][]testArtifact{
+					"2345": {
+						{
+							artifact: shared.Artifact{
+								Name:        "artifact-1",
+								DownloadURL: "http://download.com/artifact1.zip",
+								Expired:     false,
+							},
+							files: []string{
+								"artifact-1-file",
+							},
+						},
+						{
+							artifact: shared.Artifact{
+								Name:        "non-artifact-2",
+								DownloadURL: "http://download.com/non-artifact-2.zip",
+								Expired:     false,
+							},
+							files: []string{
+								"non-artifact-2-file",
+							},
+						},
+						{
+							artifact: shared.Artifact{
+								Name:        "artifact-3",
+								DownloadURL: "http://download.com/artifact3.zip",
+								Expired:     false,
+							},
+							files: []string{
+								"artifact-3-file",
+							},
+						},
 					},
-					{
-						Name:        "expired-artifact",
-						DownloadURL: "http://download.com/expired.zip",
-						Expired:     true,
+				},
+			},
+			expectedFiles: []string{
+				filepath.Join("artifact-1", "artifact-1-file"),
+				filepath.Join("artifact-3", "artifact-3-file"),
+			},
+		},
+		{
+			name: "avoid redownloading files of the same name",
+			opts: DownloadOptions{
+				RunID: "2345",
+			},
+			platform: &fakePlatform{
+				runArtifacts: map[string][]testArtifact{
+					"2345": {
+						{
+							artifact: shared.Artifact{
+								Name:        "artifact-1",
+								DownloadURL: "http://download.com/artifact1.zip",
+								Expired:     false,
+							},
+							files: []string{
+								"artifact-1-file",
+							},
+						},
+						{
+							artifact: shared.Artifact{
+								Name:        "artifact-1",
+								DownloadURL: "http://download.com/artifact2.zip",
+								Expired:     false,
+							},
+							files: []string{
+								"artifact-2-file",
+							},
+						},
 					},
-					{
-						Name:        "artifact-2",
-						DownloadURL: "http://download.com/artifact2.zip",
-						Expired:     false,
+				},
+			},
+			expectedFiles: []string{
+				filepath.Join("artifact-1", "artifact-1-file"),
+			},
+		},
+		{
+			name: "prompt to select artifact",
+			opts: DownloadOptions{
+				RunID:    "",
+				DoPrompt: true,
+				Names:    []string(nil),
+			},
+			platform: &fakePlatform{
+				runArtifacts: map[string][]testArtifact{
+					"2345": {
+						{
+							artifact: shared.Artifact{
+								Name:        "artifact-1",
+								DownloadURL: "http://download.com/artifact1.zip",
+								Expired:     false,
+							},
+							files: []string{
+								"artifact-1-file",
+							},
+						},
+						{
+							artifact: shared.Artifact{
+								Name:        "expired-artifact",
+								DownloadURL: "http://download.com/expired.zip",
+								Expired:     true,
+							},
+							files: []string{
+								"expired",
+							},
+						},
 					},
-					{
-						Name:        "artifact-2",
-						DownloadURL: "http://download.com/artifact2.also.zip",
-						Expired:     false,
+					"6789": {
+						{
+							artifact: shared.Artifact{
+								Name:        "artifact-2",
+								DownloadURL: "http://download.com/artifact2.zip",
+								Expired:     false,
+							},
+							files: []string{
+								"artifact-2-file",
+							},
+						},
 					},
-				}, nil)
-				p.On("Download", "http://download.com/artifact2.zip", ".").Return(nil)
+				},
 			},
-			mockPrompt: func(p *mockPrompter) {
+			promptStubs: func(p *mockPrompter) {
 				p.On("Prompt", "Select artifacts to download:", []string{"artifact-1", "artifact-2"}, mock.AnythingOfType("*[]string")).
 					Run(func(args mock.Arguments) {
 						result := args.Get(2).(*[]string)
@@ -289,15 +626,48 @@ func Test_runDownload(t *testing.T) {
 					}).
 					Return(nil)
 			},
+			expectedFiles: []string{
+				filepath.Join("artifact-2-file"),
+			},
+		},
+		{
+			name: "handling artifact name with path traversal exploit",
+			opts: DownloadOptions{
+				RunID: "2345",
+			},
+			platform: &fakePlatform{
+				runArtifacts: map[string][]testArtifact{
+					"2345": {
+						{
+							artifact: shared.Artifact{
+								Name:        "..",
+								DownloadURL: "http://download.com/artifact1.zip",
+								Expired:     false,
+							},
+							files: []string{
+								"etc/passwd",
+							},
+						},
+					},
+				},
+			},
+			expectedFiles: []string{},
+			wantErr:       "error downloading ..: would result in path traversal",
 		},
 	}
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
 			opts := &tt.opts
+			if opts.DestinationDir == "" {
+				opts.DestinationDir = t.TempDir()
+			} else {
+				opts.DestinationDir = filepath.Join(t.TempDir(), opts.DestinationDir)
+			}
+
 			ios, _, stdout, stderr := iostreams.Test()
 			opts.IO = ios
-			opts.Platform = newMockPlatform(t, tt.mockAPI)
-			opts.Prompter = newMockPrompter(t, tt.mockPrompt)
+			opts.Platform = tt.platform
+			opts.Prompter = newMockPrompter(t, tt.promptStubs)
 
 			err := runDownload(opts)
 			if tt.wantErr != "" {
@@ -305,6 +675,13 @@ func Test_runDownload(t *testing.T) {
 			} else {
 				require.NoError(t, err)
 			}
+			// Check that the exact number of files exist
+			require.Equal(t, len(tt.expectedFiles), countFilesInDirRecursively(t, opts.DestinationDir))
+
+			// Then check that the exact files are correct
+			for _, name := range tt.expectedFiles {
+				require.FileExists(t, filepath.Join(opts.DestinationDir, name))
+			}
 
 			assert.Equal(t, "", stdout.String())
 			assert.Equal(t, "", stderr.String())
@@ -312,30 +689,18 @@ func Test_runDownload(t *testing.T) {
 	}
 }
 
-type mockPlatform struct {
-	mock.Mock
-}
-
-func newMockPlatform(t *testing.T, config func(*mockPlatform)) *mockPlatform {
-	m := &mockPlatform{}
-	m.Test(t)
-	t.Cleanup(func() {
-		m.AssertExpectations(t)
-	})
-	if config != nil {
-		config(m)
-	}
-	return m
-}
-
-func (p *mockPlatform) List(runID string) ([]shared.Artifact, error) {
-	args := p.Called(runID)
-	return args.Get(0).([]shared.Artifact), args.Error(1)
-}
+func countFilesInDirRecursively(t *testing.T, dir string) int {
+	t.Helper()
 
-func (p *mockPlatform) Download(url string, dir string) error {
-	args := p.Called(url, dir)
-	return args.Error(0)
+	count := 0
+	require.NoError(t, filepath.Walk(dir, func(_ string, info os.FileInfo, err error) error {
+		require.NoError(t, err)
+		if !info.IsDir() {
+			count++
+		}
+		return nil
+	}))
+	return count
 }
 
 type mockPrompter struct {
diff --git a/pkg/cmd/run/download/zip.go b/pkg/cmd/run/download/zip.go
index bf56ea0..9f3f1eb 100644
--- a/pkg/cmd/run/download/zip.go
+++ b/pkg/cmd/run/download/zip.go
@@ -64,13 +64,25 @@ func getPerm(m os.FileMode) os.FileMode {
 }
 
 func filepathDescendsFrom(p, dir string) bool {
+	// Regardless of the logic below, `p` is never allowed to be current directory `.` or parent directory `..`
+	// however we check explicitly here before filepath.Rel() which doesn't cover all cases.
 	p = filepath.Clean(p)
-	dir = filepath.Clean(dir)
-	if dir == "." && !filepath.IsAbs(p) {
-		return !strings.HasPrefix(p, ".."+string(filepath.Separator))
+
+	if p == "." || p == ".." {
+		return false
 	}
-	if !strings.HasSuffix(dir, string(filepath.Separator)) {
-		dir += string(filepath.Separator)
+
+	// filepathDescendsFrom() takes advantage of filepath.Rel() to determine if `p` is descended from `dir`:
+	//
+	// 1. filepath.Rel() calculates a path to traversal from fictious `dir` to `p`.
+	// 2. filepath.Rel() errors in a handful of cases where absolute and relative paths are compared as well as certain traversal edge cases
+	//    For more information, https://github.com/golang/go/blob/00709919d09904b17cfe3bfeb35521cbd3fb04f8/src/path/filepath/path_test.go#L1510-L1515
+	// 3. If the path to traverse `dir` to `p` requires `..`, then we know it is not descend from / contained in `dir`
+	//
+	// As-is, this function requires the caller to ensure `p` and `dir` are either 1) both relative or 2) both absolute.
+	relativePath, err := filepath.Rel(dir, p)
+	if err != nil {
+		return false
 	}
-	return strings.HasPrefix(p, dir)
+	return !strings.HasPrefix(relativePath, "..")
 }
diff --git a/pkg/cmd/run/download/zip_test.go b/pkg/cmd/run/download/zip_test.go
index 97861b1..2497926 100644
--- a/pkg/cmd/run/download/zip_test.go
+++ b/pkg/cmd/run/download/zip_test.go
@@ -137,6 +137,86 @@ func Test_filepathDescendsFrom(t *testing.T) {
 			},
 			want: false,
 		},
+		{
+			name: "deny parent directory filename (`..`) escaping absolute directory",
+			args: args{
+				p:   filepath.FromSlash(".."),
+				dir: filepath.FromSlash("/var/logs/"),
+			},
+			want: false,
+		},
+		{
+			name: "deny parent directory filename (`..`) escaping current directory",
+			args: args{
+				p:   filepath.FromSlash(".."),
+				dir: filepath.FromSlash("."),
+			},
+			want: false,
+		},
+		{
+			name: "deny parent directory filename (`..`) escaping parent directory",
+			args: args{
+				p:   filepath.FromSlash(".."),
+				dir: filepath.FromSlash(".."),
+			},
+			want: false,
+		},
+		{
+			name: "deny parent directory filename (`..`) escaping relative directory",
+			args: args{
+				p:   filepath.FromSlash(".."),
+				dir: filepath.FromSlash("relative-dir"),
+			},
+			want: false,
+		},
+		{
+			name: "deny current directory filename (`.`) in absolute directory",
+			args: args{
+				p:   filepath.FromSlash("."),
+				dir: filepath.FromSlash("/var/logs/"),
+			},
+			want: false,
+		},
+		{
+			name: "deny current directory filename (`.`) in current directory",
+			args: args{
+				p:   filepath.FromSlash("."),
+				dir: filepath.FromSlash("."),
+			},
+			want: false,
+		},
+		{
+			name: "deny current directory filename (`.`) in parent directory",
+			args: args{
+				p:   filepath.FromSlash("."),
+				dir: filepath.FromSlash(".."),
+			},
+			want: false,
+		},
+		{
+			name: "deny current directory filename (`.`) in relative directory",
+			args: args{
+				p:   filepath.FromSlash("."),
+				dir: filepath.FromSlash("relative-dir"),
+			},
+			want: false,
+		},
+		{
+			name: "relative path, absolute dir",
+			args: args{
+				p:   filepath.FromSlash("whatever"),
+				dir: filepath.FromSlash("/a/b/c"),
+			},
+			want: false,
+		},
+		{
+			name: "absolute path, relative dir",
+			args: args{
+				p:   filepath.FromSlash("/a/b/c"),
+				dir: filepath.FromSlash("whatever"),
+			},
+			want: false,
+		},
 	}
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
