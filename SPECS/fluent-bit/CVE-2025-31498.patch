From 1e22415e5fe183d2d80dbc99b9e44b94138cb689 Mon Sep 17 00:00:00 2001
From: Ankita Pareek <ankitapareek@microsoft.com>
Date: Fri, 11 Apr 2025 11:05:50 +0530
Subject: [PATCH] fluent-bit: Add patch for addressing CVE-2025-31498

Upstream reference: https://github.com/c-ares/c-ares/compare/69e1ad5..82489f2

Signed-off-by: Ankita Pareek <ankitapareek@microsoft.com>
---
 .../src/lib/ares__close_sockets.c             |   2 +-
 lib/c-ares-1.33.1/src/lib/ares_cookie.c       |   7 +-
 lib/c-ares-1.33.1/src/lib/ares_private.h      |   6 +-
 lib/c-ares-1.33.1/src/lib/ares_process.c      | 139 ++++++++++++++----
 lib/c-ares-1.33.1/src/lib/dsa/ares__array.c   |  15 ++
 lib/c-ares-1.33.1/src/lib/dsa/ares__array.h   |  14 ++
 lib/c-ares-1.33.1/test/ares-test-mock-ai.cc   |  94 ++++++++++++
 lib/c-ares-1.33.1/test/ares-test-mock.cc      |  60 ++++++++
 lib/c-ares-1.33.1/test/ares-test.cc           |  27 +++-
 lib/c-ares-1.33.1/test/ares-test.h            |  22 +++
 10 files changed, 354 insertions(+), 32 deletions(-)

diff --git a/lib/c-ares-1.33.1/src/lib/ares__close_sockets.c b/lib/c-ares-1.33.1/src/lib/ares__close_sockets.c
index 71c7e64..545edb7 100644
--- a/lib/c-ares-1.33.1/src/lib/ares__close_sockets.c
+++ b/lib/c-ares-1.33.1/src/lib/ares__close_sockets.c
@@ -37,7 +37,7 @@ static void ares__requeue_queries(ares_conn_t  *conn,
   ares__tvnow(&now);
 
   while ((query = ares__llist_first_val(conn->queries_to_conn)) != NULL) {
-    ares__requeue_query(query, &now, requeue_status, ARES_TRUE, NULL);
+    ares__requeue_query(query, &now, requeue_status, ARES_TRUE, NULL, NULL);
   }
 }
 
diff --git a/lib/c-ares-1.33.1/src/lib/ares_cookie.c b/lib/c-ares-1.33.1/src/lib/ares_cookie.c
index bf9d1ba..1915c0b 100644
--- a/lib/c-ares-1.33.1/src/lib/ares_cookie.c
+++ b/lib/c-ares-1.33.1/src/lib/ares_cookie.c
@@ -369,7 +369,8 @@ ares_status_t ares_cookie_apply(ares_dns_record_t *dnsrec, ares_conn_t *conn,
 
 ares_status_t ares_cookie_validate(ares_query_t            *query,
                                    const ares_dns_record_t *dnsresp,
-                                   ares_conn_t *conn, const ares_timeval_t *now)
+                                   ares_conn_t *conn, const ares_timeval_t *now,
+                                   ares__array_t **requeue)
 {
   ares_server_t           *server = conn->server;
   ares_cookie_t           *cookie = &server->cookie;
@@ -427,8 +428,8 @@ ares_status_t ares_cookie_validate(ares_query_t            *query,
     /* Resend the request, hopefully it will work the next time as we should
      * have recorded a server cookie */
     ares__requeue_query(query, now, ARES_SUCCESS,
-                        ARES_FALSE /* Don't increment try count */,
-                        NULL);
+                        ARES_FALSE /* Don't increment try count */, NULL,
+                        requeue);
 
     /* Parent needs to drop this response */
     return ARES_EBADRESP;
diff --git a/lib/c-ares-1.33.1/src/lib/ares_private.h b/lib/c-ares-1.33.1/src/lib/ares_private.h
index 263c2a6..2605c9e 100644
--- a/lib/c-ares-1.33.1/src/lib/ares_private.h
+++ b/lib/c-ares-1.33.1/src/lib/ares_private.h
@@ -466,7 +466,8 @@ ares_status_t ares__requeue_query(ares_query_t            *query,
                                   const ares_timeval_t    *now,
                                   ares_status_t            status,
                                   ares_bool_t              inc_try_count,
-                                  const ares_dns_record_t *dnsrec);
+                                  const ares_dns_record_t *dnsrec,
+                                  ares__array_t           **requeue);
 
 /*! Count the number of labels (dots+1) in a domain */
 size_t ares__name_label_cnt(const char *name);
@@ -782,7 +783,8 @@ ares_status_t ares_cookie_apply(ares_dns_record_t *dnsrec, ares_conn_t *conn,
 ares_status_t ares_cookie_validate(ares_query_t            *query,
                                    const ares_dns_record_t *dnsresp,
                                    ares_conn_t             *conn,
-                                   const ares_timeval_t    *now);
+                                   const ares_timeval_t    *now,
+                                   ares__array_t           **requeue);
 
 ares_status_t ares__channel_threading_init(ares_channel_t *channel);
 void          ares__channel_threading_destroy(ares_channel_t *channel);
diff --git a/lib/c-ares-1.33.1/src/lib/ares_process.c b/lib/c-ares-1.33.1/src/lib/ares_process.c
index f05f67d..e84c36a 100644
--- a/lib/c-ares-1.33.1/src/lib/ares_process.c
+++ b/lib/c-ares-1.33.1/src/lib/ares_process.c
@@ -55,7 +55,8 @@ static void          process_timeouts(ares_channel_t       *channel,
 static ares_status_t process_answer(ares_channel_t      *channel,
                                     const unsigned char *abuf, size_t alen,
                                     ares_conn_t *conn, ares_bool_t tcp,
-                                    const ares_timeval_t *now);
+                                    const ares_timeval_t *now,
+                                    ares__array_t        **requeue);
 static void handle_conn_error(ares_conn_t *conn, ares_bool_t critical_failure,
                               ares_status_t failure_status);
 
@@ -299,6 +300,34 @@ static void write_tcp_data(ares_channel_t *channel, fd_set *write_fds,
   }
 }
 
+/* Simple data structure to store a query that needs to be requeued with
+ * optional server */
+typedef struct {
+  unsigned short qid;
+  ares_server_t *server; /* optional */
+} ares_requeue_t;
+
+static ares_status_t ares_append_requeue(ares__array_t **requeue,
+                                         ares_query_t *query,
+                                         ares_server_t *server)
+{
+  ares_requeue_t entry;
+
+  if (*requeue == NULL) {
+    *requeue = ares__array_create(sizeof(ares_requeue_t), NULL);
+    if (*requeue == NULL) {
+      return ARES_ENOMEM;
+    }
+  }
+
+  ares__query_disassociate_from_conn(query);
+
+  entry.qid    = query->qid;
+  entry.server = server;
+  return ares__array_insertdata_last(*requeue, &entry);
+}
+
+
 /* If any TCP socket selects true for reading, read some data,
  * allocate a buffer if we finish reading the length word, and process
  * a packet if we finish reading one.
@@ -306,8 +335,10 @@ static void write_tcp_data(ares_channel_t *channel, fd_set *write_fds,
 static void read_tcp_data(ares_channel_t *channel, ares_conn_t *conn,
                           const ares_timeval_t *now)
 {
-  ares_ssize_t   count;
-  ares_server_t *server = conn->server;
+  ares_ssize_t    count;
+  ares_server_t  *server = conn->server;
+  ares_status_t   status;
+  ares__array_t  *requeue = NULL;
 
   /* Fetch buffer to store data we are reading */
   size_t         ptr_len = 65535;
@@ -340,7 +371,6 @@ static void read_tcp_data(ares_channel_t *channel, ares_conn_t *conn,
     unsigned short       dns_len  = 0;
     const unsigned char *data     = NULL;
     size_t               data_len = 0;
-    ares_status_t        status;
 
     /* Tag so we can roll back */
     ares__buf_tag(server->tcp_parser);
@@ -369,15 +399,39 @@ static void read_tcp_data(ares_channel_t *channel, ares_conn_t *conn,
     data_len -= 2;
 
     /* We finished reading this answer; process it */
-    status = process_answer(channel, data, data_len, conn, ARES_TRUE, now);
+    status = process_answer(channel, data, data_len, conn, ARES_TRUE, now,
+                            &requeue);
     if (status != ARES_SUCCESS) {
       handle_conn_error(conn, ARES_TRUE, status);
-      return;
+      goto cleanup;
     }
 
     /* Since we processed the answer, clear the tag so space can be reclaimed */
     ares__buf_tag_clear(server->tcp_parser);
   }
+
+cleanup:
+
+  /* Flush requeue */
+  while (ares__array_len(requeue) > 0) {
+    ares_query_t  *query;
+    ares_requeue_t entry;
+    ares_status_t  internal_status;
+
+    internal_status = ares__array_claim_at(&entry, sizeof(entry), requeue, 0);
+    if (internal_status != ARES_SUCCESS) {
+      break;
+    }
+
+    /* Query disappeared */
+    query = ares__htable_szvp_get_direct(channel->queries_by_qid, entry.qid);
+    if (query == NULL) {
+      continue;
+    }
+
+    ares__send_query(query, now);
+  }
+  ares__array_destroy(requeue);
 }
 
 static ares_socket_t *channel_socket_list(const ares_channel_t *channel,
@@ -423,8 +477,9 @@ static ares_socket_t *channel_socket_list(const ares_channel_t *channel,
 static void read_udp_packets_fd(ares_channel_t *channel, ares_conn_t *conn,
                                 const ares_timeval_t *now)
 {
-  ares_ssize_t  read_len;
-  unsigned char buf[MAXENDSSZ + 1];
+  ares_ssize_t   read_len;
+  unsigned char  buf[MAXENDSSZ + 1];
+  ares__array_t *requeue = NULL;
 
 #ifdef HAVE_RECVFROM
   ares_socklen_t fromlen;
@@ -464,7 +519,7 @@ static void read_udp_packets_fd(ares_channel_t *channel, ares_conn_t *conn,
       }
 
       handle_conn_error(conn, ARES_TRUE, ARES_ECONNREFUSED);
-      return;
+      goto cleanup;
 #ifdef HAVE_RECVFROM
     } else if (!same_address(&from.sa, &conn->server->addr)) {
       /* The address the response comes from does not match the address we
@@ -474,12 +529,36 @@ static void read_udp_packets_fd(ares_channel_t *channel, ares_conn_t *conn,
 #endif
 
     } else {
-      process_answer(channel, buf, (size_t)read_len, conn, ARES_FALSE, now);
+      process_answer(channel, buf, (size_t)read_len, conn, ARES_FALSE, now,
+                     &requeue);
     }
 
     /* Try to read again only if *we* set up the socket, otherwise it may be
      * a blocking socket and would cause recvfrom to hang. */
   } while (read_len >= 0 && channel->sock_funcs == NULL);
+
+cleanup:
+
+  /* Flush requeue */
+  while (ares__array_len(requeue) > 0) {
+    ares_query_t  *query;
+    ares_requeue_t entry;
+    ares_status_t  internal_status;
+
+    internal_status = ares__array_claim_at(&entry, sizeof(entry), requeue, 0);
+    if (internal_status != ARES_SUCCESS) {
+      break;
+    }
+
+    /* Query disappeared */
+    query = ares__htable_szvp_get_direct(channel->queries_by_qid, entry.qid);
+    if (query == NULL) {
+      continue;
+    }
+
+    ares__send_query(query, now);
+  }
+  ares__array_destroy(requeue);
 }
 
 static void read_packets(ares_channel_t *channel, fd_set *read_fds,
@@ -571,7 +650,7 @@ static void process_timeouts(ares_channel_t *channel, const ares_timeval_t *now)
 
     conn = query->conn;
     server_increment_failures(conn->server, query->using_tcp);
-    ares__requeue_query(query, now, ARES_ETIMEOUT, ARES_TRUE, NULL);
+    ares__requeue_query(query, now, ARES_ETIMEOUT, ARES_TRUE, NULL, NULL);
   }
 }
 
@@ -608,7 +687,8 @@ done:
 static ares_status_t process_answer(ares_channel_t      *channel,
                                     const unsigned char *abuf, size_t alen,
                                     ares_conn_t *conn, ares_bool_t tcp,
-                                    const ares_timeval_t *now)
+                                    const ares_timeval_t *now,
+                                    ares__array_t        **requeue)
 {
   ares_query_t      *query;
   /* Cache these as once ares__send_query() gets called, it may end up
@@ -647,7 +727,8 @@ static ares_status_t process_answer(ares_channel_t      *channel,
 
   /* Validate DNS cookie in response. This function may need to requeue the
    * query. */
-  if (ares_cookie_validate(query, rdnsrec, conn, now) != ARES_SUCCESS) {
+  if (ares_cookie_validate(query, rdnsrec, conn, now, requeue)
+      != ARES_SUCCESS) {
     /* Drop response and return */
     status = ARES_SUCCESS;
     goto cleanup;
@@ -672,8 +753,8 @@ static ares_status_t process_answer(ares_channel_t      *channel,
       goto cleanup;
     }
 
-    ares__send_query(query, now);
-    status = ARES_SUCCESS;
+    /* Requeue to same server */
+    status = ares_append_requeue(requeue, query, server);
     goto cleanup;
   }
 
@@ -684,8 +765,9 @@ static ares_status_t process_answer(ares_channel_t      *channel,
   if (ares_dns_record_get_flags(rdnsrec) & ARES_FLAG_TC && !tcp &&
       !(channel->flags & ARES_FLAG_IGNTC)) {
     query->using_tcp = ARES_TRUE;
-    ares__send_query(query, now);
-    status = ARES_SUCCESS; /* Switched to TCP is ok */
+    status = ares_append_requeue(requeue, query, NULL);
+    /* Status will reflect success except on memory error, which is good since
+     * requeuing to TCP is ok */
     goto cleanup;
   }
 
@@ -711,11 +793,14 @@ static ares_status_t process_answer(ares_channel_t      *channel,
       }
 
       server_increment_failures(server, query->using_tcp);
-      ares__requeue_query(query, now, status, ARES_TRUE, rdnsrec);
+      status = ares__requeue_query(query, now, status, ARES_TRUE, rdnsrec,
+                                   requeue);
 
-      /* Should any of these cause a connection termination?
-       * Maybe SERVER_FAILURE? */
-      status = ARES_SUCCESS;
+      if (status != ARES_ENOMEM) {
+        /* Should any of these cause a connection termination?
+         * Maybe SERVER_FAILURE? */
+        status = ARES_SUCCESS;
+      }
       goto cleanup;
     }
   }
@@ -760,7 +845,8 @@ ares_status_t ares__requeue_query(ares_query_t            *query,
                                   const ares_timeval_t    *now,
                                   ares_status_t            status,
                                   ares_bool_t              inc_try_count,
-                                  const ares_dns_record_t *dnsrec)
+                                  const ares_dns_record_t *dnsrec,
+                                  ares__array_t           **requeue)
 {
   ares_channel_t *channel = query->channel;
   size_t max_tries        = ares__slist_len(channel->servers) * channel->tries;
@@ -776,6 +862,9 @@ ares_status_t ares__requeue_query(ares_query_t            *query,
   }
 
   if (query->try_count < max_tries && !query->no_retries) {
+    if (requeue != NULL) {
+      return ares_append_requeue(requeue, query, NULL);
+    }
     return ares__send_query(query, now);
   }
 
@@ -1079,7 +1168,7 @@ ares_status_t ares__send_query(ares_query_t *query, const ares_timeval_t *now)
       case ARES_ECONNREFUSED:
       case ARES_EBADFAMILY:
         server_increment_failures(server, query->using_tcp);
-        return ares__requeue_query(query, now, status, ARES_TRUE, NULL);
+        return ares__requeue_query(query, now, status, ARES_TRUE, NULL, NULL);
 
       /* Anything else is not retryable, likely ENOMEM */
       default:
@@ -1105,7 +1194,7 @@ ares_status_t ares__send_query(ares_query_t *query, const ares_timeval_t *now)
     case ARES_ECONNREFUSED:
     case ARES_EBADFAMILY:
       handle_conn_error(conn, ARES_TRUE, status);
-      status = ares__requeue_query(query, now, status, ARES_TRUE, NULL);
+      status = ares__requeue_query(query, now, status, ARES_TRUE, NULL, NULL);
       if (status == ARES_ETIMEOUT) {
         status = ARES_ECONNREFUSED;
       }
@@ -1115,7 +1204,7 @@ ares_status_t ares__send_query(ares_query_t *query, const ares_timeval_t *now)
      * just requeue to a different server/connection. */
     default:
       server_increment_failures(server, query->using_tcp);
-      status = ares__requeue_query(query, now, status, ARES_TRUE, NULL);
+      status = ares__requeue_query(query, now, status, ARES_TRUE, NULL, NULL);
       return status;
   }
 
diff --git a/lib/c-ares-1.33.1/src/lib/dsa/ares__array.c b/lib/c-ares-1.33.1/src/lib/dsa/ares__array.c
index 0c72424..7568b07 100644
--- a/lib/c-ares-1.33.1/src/lib/dsa/ares__array.c
+++ b/lib/c-ares-1.33.1/src/lib/dsa/ares__array.c
@@ -265,6 +265,21 @@ ares_status_t ares__array_insert_first(void **elem_ptr, ares__array_t *arr)
   return ares__array_insert_at(elem_ptr, arr, 0);
 }
 
+ares_status_t ares__array_insertdata_last(ares__array_t *arr,
+                                          const void   *data_ptr)
+{
+  ares_status_t status;
+  void         *ptr = NULL;
+
+  status = ares__array_insert_last(&ptr, arr);
+  if (status != ARES_SUCCESS) {
+    return status;
+  }
+  memcpy(ptr, data_ptr, arr->member_size);
+  return ARES_SUCCESS;
+}
+
+
 void *ares__array_first(ares__array_t *arr)
 {
   return ares__array_at(arr, 0);
diff --git a/lib/c-ares-1.33.1/src/lib/dsa/ares__array.h b/lib/c-ares-1.33.1/src/lib/dsa/ares__array.h
index 6fa1c0e..ab0271d 100644
--- a/lib/c-ares-1.33.1/src/lib/dsa/ares__array.h
+++ b/lib/c-ares-1.33.1/src/lib/dsa/ares__array.h
@@ -218,6 +218,20 @@ ares_status_t  ares__array_remove_first(ares__array_t *arr);
  */
 ares_status_t  ares__array_remove_last(ares__array_t *arr);
 
+/*! Insert a new array member at the end of the array and copy the data pointed
+ *  to by the data pointer into the array.  This will copy member_size bytes
+ *  from the provided pointer, this may not be safe for some data types
+ *  that may have a smaller size than the provided member_size which includes
+ *  padding as discussed in ares_array_create().
+ *
+ *  \param[in]  arr      Initialized array object.
+ *  \param[in]  data_ptr Pointer to data to copy into array.
+ *  \return ARES_SUCCESS on success, ARES_EFORMERR on bad index or null data
+ * ptr, ARES_ENOMEM on out of memory.
+ */
+CARES_EXTERN ares_status_t ares__array_insertdata_last(ares__array_t *arr,
+                                                       const void   *data_ptr);
+
 /*! @} */
 
 #endif /* __ARES__ARRAY_H */
diff --git a/lib/c-ares-1.33.1/test/ares-test-mock-ai.cc b/lib/c-ares-1.33.1/test/ares-test-mock-ai.cc
index b4a4f99..ad61b04 100644
--- a/lib/c-ares-1.33.1/test/ares-test-mock-ai.cc
+++ b/lib/c-ares-1.33.1/test/ares-test-mock-ai.cc
@@ -713,6 +713,100 @@ TEST_P(MockChannelTestAI, FamilyUnspecified) {
   EXPECT_THAT(result.ai_, IncludesV6Address("2121:0000:0000:0000:0000:0000:0000:0303"));
 }
 
+
+TEST_P(MockChannelTestAI, TriggerResendThenConnFailSERVFAIL) {
+  // Set up the server response. The server always returns SERVFAIL.
+  DNSPacket badrsp4;
+  badrsp4.set_response().set_aa().set_rcode(SERVFAIL)
+    .add_question(new DNSQuestion("www.google.com", T_A));
+  DNSPacket goodrsp4;
+  goodrsp4.set_response().set_aa()
+    .add_question(new DNSQuestion("www.google.com", T_A))
+    .add_answer(new DNSARR("www.google.com", 0x0100, {0x01, 0x02, 0x03, 0x04}));
+
+  DNSPacket goodrsp6;
+  goodrsp6.set_response().set_aa()
+    .add_question(new DNSQuestion("www.google.com", T_AAAA))
+    .add_answer(new DNSAaaaRR("www.google.com", 100,
+                              {0x21, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03}));
+
+  EXPECT_CALL(server_, OnRequest("www.google.com", T_A))
+    .WillOnce(SetReplyAndFailSend(&server_, &badrsp4))
+    .WillOnce(SetReply(&server_, &goodrsp4));
+
+  EXPECT_CALL(server_, OnRequest("www.google.com", T_AAAA))
+    .WillRepeatedly(SetReply(&server_, &goodrsp6));
+
+  ares_socket_functions sock_funcs;
+  memset(&sock_funcs, 0, sizeof(sock_funcs));
+
+  sock_funcs.asendv = ares_sendv_fail;
+
+  ares_set_socket_functions(channel_, &sock_funcs, NULL);
+
+  AddrInfoResult result;
+  struct ares_addrinfo_hints hints = {0, 0, 0, 0};
+  hints.ai_family = AF_UNSPEC;
+  hints.ai_flags = ARES_AI_NOSORT;
+  ares_getaddrinfo(channel_, "www.google.com.", NULL, &hints,
+                   AddrInfoCallback, &result);
+
+  Process();
+  EXPECT_TRUE(result.done_);
+  EXPECT_TRUE(result.done_);
+  EXPECT_THAT(result.ai_, IncludesNumAddresses(2));
+  EXPECT_THAT(result.ai_, IncludesV4Address("1.2.3.4"));
+  EXPECT_THAT(result.ai_, IncludesV6Address("2121:0000:0000:0000:0000:0000:0000:0303"));
+}
+
+TEST_P(MockUDPChannelTestAI, TriggerResendThenConnFailEDNS) {
+  // Set up the server response to simulate an EDNS failure
+ DNSPacket badrsp4;
+  badrsp4.set_response().set_aa().set_rcode(FORMERR)
+    .add_question(new DNSQuestion("www.google.com", T_A));
+  DNSPacket goodrsp4;
+  goodrsp4.set_response().set_aa()
+    .add_question(new DNSQuestion("www.google.com", T_A))
+    .add_answer(new DNSARR("www.google.com", 0x0100, {0x01, 0x02, 0x03, 0x04}));
+  DNSPacket goodrsp6;
+  goodrsp6.set_response().set_aa()
+    .add_question(new DNSQuestion("www.google.com", T_AAAA))
+    .add_answer(new DNSAaaaRR("www.google.com", 100,
+                              {0x21, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03}));
+
+  EXPECT_CALL(server_, OnRequest("www.google.com", T_A))
+    .WillOnce(SetReplyAndFailSend(&server_, &badrsp4))
+    .WillOnce(SetReply(&server_, &goodrsp4));
+
+  EXPECT_CALL(server_, OnRequest("www.google.com", T_AAAA))
+    .WillRepeatedly(SetReply(&server_, &goodrsp6));
+
+  ares_socket_functions sock_funcs;
+  memset(&sock_funcs, 0, sizeof(sock_funcs));
+
+  sock_funcs.asendv = ares_sendv_fail;
+
+  ares_set_socket_functions(channel_, &sock_funcs, NULL);
+
+  AddrInfoResult result;
+  struct ares_addrinfo_hints hints = {0, 0, 0, 0};
+  hints.ai_family = AF_UNSPEC;
+  hints.ai_flags = ARES_AI_NOSORT;
+  ares_getaddrinfo(channel_, "www.google.com.", NULL, &hints,
+                   AddrInfoCallback, &result);
+
+  Process();
+  EXPECT_TRUE(result.done_);
+  EXPECT_TRUE(result.done_);
+  EXPECT_THAT(result.ai_, IncludesNumAddresses(2));
+  EXPECT_THAT(result.ai_, IncludesV4Address("1.2.3.4"));
+  EXPECT_THAT(result.ai_, IncludesV6Address("2121:0000:0000:0000:0000:0000:0000:0303"));
+}
+
+
+
 class MockEDNSChannelTestAI : public MockFlagsChannelOptsTestAI {
  public:
   MockEDNSChannelTestAI() : MockFlagsChannelOptsTestAI(ARES_FLAG_EDNS) {}
diff --git a/lib/c-ares-1.33.1/test/ares-test-mock.cc b/lib/c-ares-1.33.1/test/ares-test-mock.cc
index 46a5780..920d322 100644
--- a/lib/c-ares-1.33.1/test/ares-test-mock.cc
+++ b/lib/c-ares-1.33.1/test/ares-test-mock.cc
@@ -1598,6 +1598,66 @@ TEST_P(MockChannelTest, GetHostByAddrDestroy) {
   EXPECT_EQ(0, result.timeouts_);
 }
 
+TEST_P(MockChannelTest, TriggerResendThenConnFailSERVFAIL) {
+  // Set up the server response. The server always returns SERVFAIL.
+  DNSPacket badrsp;
+  badrsp.set_response().set_aa().set_rcode(SERVFAIL)
+    .add_question(new DNSQuestion("www.google.com", T_A));
+  DNSPacket goodrsp;
+  goodrsp.set_response().set_aa()
+    .add_question(new DNSQuestion("www.google.com", T_A))
+    .add_answer(new DNSARR("www.google.com", 0x0100, {0x01, 0x02, 0x03, 0x04}));
+  EXPECT_CALL(server_, OnRequest("www.google.com", T_A))
+    .WillOnce(SetReplyAndFailSend(&server_, &badrsp))
+    .WillOnce(SetReply(&server_, &goodrsp));
+
+  ares_socket_functions sock_funcs;
+  memset(&sock_funcs, 0, sizeof(sock_funcs));
+
+  sock_funcs.asendv = ares_sendv_fail;
+
+  ares_set_socket_functions(channel_, &sock_funcs, NULL);
+
+  HostResult result;
+  ares_gethostbyname(channel_, "www.google.com.", AF_INET, HostCallback,
+                     &result);
+  Process();
+  EXPECT_TRUE(result.done_);
+  std::stringstream ss;
+  ss << result.host_;
+  EXPECT_EQ("{'www.google.com' aliases=[] addrs=[1.2.3.4]}", ss.str());
+}
+
+TEST_P(MockUDPChannelTest, TriggerResendThenConnFailEDNS) {
+  // Set up the server response to simulate an EDNS failure
+  DNSPacket badrsp;
+  badrsp.set_response().set_aa().set_rcode(FORMERR)
+    .add_question(new DNSQuestion("www.google.com", T_A));
+  DNSPacket goodrsp;
+  goodrsp.set_response().set_aa()
+    .add_question(new DNSQuestion("www.google.com", T_A))
+    .add_answer(new DNSARR("www.google.com", 0x0100, {0x01, 0x02, 0x03, 0x04}));
+  EXPECT_CALL(server_, OnRequest("www.google.com", T_A))
+    .WillOnce(SetReplyAndFailSend(&server_, &badrsp))
+    .WillOnce(SetReply(&server_, &goodrsp));
+
+  ares_socket_functions sock_funcs;
+  memset(&sock_funcs, 0, sizeof(sock_funcs));
+
+  sock_funcs.asendv = ares_sendv_fail;
+
+  ares_set_socket_functions(channel_, &sock_funcs, NULL);
+
+  HostResult result;
+  ares_gethostbyname(channel_, "www.google.com.", AF_INET, HostCallback,
+                     &result);
+  Process();
+  EXPECT_TRUE(result.done_);
+  std::stringstream ss;
+  ss << result.host_;
+  EXPECT_EQ("{'www.google.com' aliases=[] addrs=[1.2.3.4]}", ss.str());
+}
+
 static const unsigned char *
   fetch_server_cookie(const ares_dns_record_t *dnsrec, size_t *len)
 {
diff --git a/lib/c-ares-1.33.1/test/ares-test.cc b/lib/c-ares-1.33.1/test/ares-test.cc
index 99ab0a0..12563ee 100644
--- a/lib/c-ares-1.33.1/test/ares-test.cc
+++ b/lib/c-ares-1.33.1/test/ares-test.cc
@@ -250,6 +250,7 @@ std::vector<std::pair<int, bool>> families_modes = both_families_both_modes;
 unsigned long long LibraryTest::fails_ = 0;
 std::map<size_t, int> LibraryTest::size_fails_;
 std::mutex            LibraryTest::lock_;
+bool LibraryTest::failsend_ = false;
 
 void ares_sleep_time(unsigned int ms)
 {
@@ -340,7 +341,29 @@ void ProcessWork(ares_channel_t *channel,
 }
 
 
+void LibraryTest::SetFailSend() {
+  failsend_ = true;
+}
+
 // static
+ares_ssize_t LibraryTest::ares_sendv_fail(ares_socket_t socket, const struct iovec *vec, int len, void *user_data)
+{
+  (void)user_data;
+
+  if (failsend_) {
+#ifdef USE_WINSOCK
+    WSASetLastError(WSAECONNREFUSED);
+#else
+    errno = ECONNREFUSED;
+#endif
+    failsend_ = false;
+    return -1;
+  }
+
+  return send(socket, (const char *)vec[0].iov_base, vec[0].iov_len, 0);
+}
+
+
 void LibraryTest::SetAllocFail(int nth) {
   lock_.lock();
   assert(nth > 0);
@@ -684,6 +707,7 @@ void MockServer::ProcessRequest(ares_socket_t fd, struct sockaddr_storage* addr,
   /* DNS 0x20 will mix case, do case-insensitive matching of name in request */
   char lower_name[256];
   int flags = 0;
+
   arestest_strtolower(lower_name, name, sizeof(lower_name));
 
   // Before processing, let gMock know the request is happening.
@@ -745,10 +769,11 @@ void MockServer::ProcessRequest(ares_socket_t fd, struct sockaddr_storage* addr,
 #endif
 
   ares_ssize_t rc = (ares_ssize_t)sendto(fd, BYTE_CAST reply.data(), (SEND_TYPE_ARG3)reply.size(), flags,
-                  (struct sockaddr *)addr, addrlen);
+                                         (struct sockaddr *)addr, addrlen);
   if (rc < static_cast<ares_ssize_t>(reply.size())) {
     std::cerr << "Failed to send full reply, rc=" << rc << std::endl;
   }
+
 }
 
 // static
diff --git a/lib/c-ares-1.33.1/test/ares-test.h b/lib/c-ares-1.33.1/test/ares-test.h
index 7342daa..583c4ea 100644
--- a/lib/c-ares-1.33.1/test/ares-test.h
+++ b/lib/c-ares-1.33.1/test/ares-test.h
@@ -51,6 +51,16 @@
 #include <vector>
 #include <chrono>
 
+#ifndef HAVE_WRITEV
+extern "C" {
+/* Structure for scatter/gather I/O. */
+struct iovec {
+  void  *iov_base; /* Pointer to data. */
+  size_t iov_len;  /* Length of data.  */
+};
+};
+#endif
+
 namespace ares {
 
 typedef unsigned char byte;
@@ -130,11 +140,17 @@ public:
   static void *arealloc(void *ptr, size_t size);
   static void  afree(void *ptr);
 
+  static void SetFailSend(void);
+  static ares_ssize_t ares_sendv_fail(ares_socket_t socket, const struct iovec *vec, int len,
+                                      void *user_data);
+
+
 private:
   static bool                  ShouldAllocFail(size_t size);
   static unsigned long long    fails_;
   static std::map<size_t, int> size_fails_;
   static std::mutex            lock_;
+  static bool                  failsend_;
 };
 
 // Test fixture that uses a default channel.
@@ -436,6 +452,12 @@ ACTION_P2(SetReplyData, mockserver, data)
   mockserver->SetReplyData(data);
 }
 
+ACTION_P2(SetReplyAndFailSend, mockserver, reply)
+{
+  mockserver->SetReply(reply);
+  LibraryTest::SetFailSend();
+}
+
 ACTION_P2(SetReply, mockserver, reply)
 {
   mockserver->SetReply(reply);
-- 
2.34.1

