From 714bf5675c541bd1e668a8db8e67ce012651e618 Mon Sep 17 00:00:00 2001
From: Brad House <brad@brad-house.com>
Date: Mon, 8 Dec 2025 10:12:08 -0500
Subject: [PATCH] Merge commit from fork

* reproducer test case

* enqueue callbacks to be processed within process_answer rather than calling directly as that may lead to the connection being destroyed

* combine requeue and endqueue into a single queue with a flag to simplify the implementation

* add back queue notification

Modified to apply to Azure Linux
Upstream Patch Reference: https://github.com/c-ares/c-ares/commit/714bf5675c541bd1e668a8db8e67ce012651e618.patch
---
 lib/c-ares-1.33.1/src/lib/ares_private.h    | 10 +--
 lib/c-ares-1.33.1/src/lib/ares_process.c    | 97 ++++++++++++++++-----
 lib/c-ares-1.33.1/src/lib/ares_qcache.c     | 20 +++--
 lib/c-ares-1.33.1/test/ares-test-mock-ai.cc | 32 +++++++
 4 files changed, 125 insertions(+), 34 deletions(-)

diff --git a/lib/c-ares-1.33.1/src/lib/ares_private.h b/lib/c-ares-1.33.1/src/lib/ares_private.h
index 2605c9e..c1bf536 100644
--- a/lib/c-ares-1.33.1/src/lib/ares_private.h
+++ b/lib/c-ares-1.33.1/src/lib/ares_private.h
@@ -466,7 +466,7 @@ ares_status_t ares__requeue_query(ares_query_t            *query,
                                   const ares_timeval_t    *now,
                                   ares_status_t            status,
                                   ares_bool_t              inc_try_count,
-                                  const ares_dns_record_t *dnsrec,
+                                  ares_dns_record_t       *dnsrec,
                                   ares__array_t           **requeue);
 
 /*! Count the number of labels (dots+1) in a domain */
@@ -764,10 +764,10 @@ ares_status_t ares__qcache_create(ares_rand_state *rand_state,
                                   unsigned int     max_ttl,
                                   ares__qcache_t **cache_out);
 void          ares__qcache_flush(ares__qcache_t *cache);
-ares_status_t ares_qcache_insert(ares_channel_t       *channel,
-                                 const ares_timeval_t *now,
-                                 const ares_query_t   *query,
-                                 ares_dns_record_t    *dnsrec);
+ares_status_t ares_qcache_insert(ares_channel_t          *channel,
+                                 const ares_timeval_t    *now,
+                                 const ares_query_t      *query,
+                                 const ares_dns_record_t *dnsrec);
 ares_status_t ares_qcache_fetch(ares_channel_t           *channel,
                                 const ares_timeval_t     *now,
                                 const ares_dns_record_t  *dnsrec,
diff --git a/lib/c-ares-1.33.1/src/lib/ares_process.c b/lib/c-ares-1.33.1/src/lib/ares_process.c
index e84c36a..fa042dd 100644
--- a/lib/c-ares-1.33.1/src/lib/ares_process.c
+++ b/lib/c-ares-1.33.1/src/lib/ares_process.c
@@ -66,7 +66,8 @@ static ares_bool_t same_address(const struct sockaddr  *sa,
                                 const struct ares_addr *aa);
 static void        end_query(ares_channel_t *channel, ares_server_t *server,
                              ares_query_t *query, ares_status_t status,
-                             const ares_dns_record_t *dnsrec);
+                             ares_dns_record_t *dnsrec,
+                             ares__array_t **requeue);
 
 static void        ares__query_disassociate_from_conn(ares_query_t *query)
 {
@@ -300,16 +301,27 @@ static void write_tcp_data(ares_channel_t *channel, fd_set *write_fds,
   }
 }
 
+typedef enum {
+  REQUEUE_REQUEUE  = 1,
+  REQUEUE_ENDQUERY = 2
+} requeue_type_t;
+
 /* Simple data structure to store a query that needs to be requeued with
  * optional server */
 typedef struct {
-  unsigned short qid;
-  ares_server_t *server; /* optional */
+  requeue_type_t     type;   /* type of entry, requeue or endquery */
+  unsigned short     qid;    /* query id */
+  ares_server_t     *server; /* requeue only: optional */
+  ares_status_t      status; /* endquery only */
+  ares_dns_record_t *dnsrec; /* endquery only: optional */
 } ares_requeue_t;
 
-static ares_status_t ares_append_requeue(ares__array_t **requeue,
-                                         ares_query_t *query,
-                                         ares_server_t *server)
+static ares_status_t ares_append_requeue_int(ares__array_t     **requeue,
+                                             requeue_type_t     type,
+                                             ares_query_t      *query,
+                                             ares_server_t     *server,
+                                             ares_status_t      status,
+                                             ares_dns_record_t *dnsrec)
 {
   ares_requeue_t entry;
 
@@ -322,11 +334,30 @@ static ares_status_t ares_append_requeue(ares__array_t **requeue,
 
   ares__query_disassociate_from_conn(query);
 
+  entry.type   = type;
   entry.qid    = query->qid;
   entry.server = server;
+  entry.status = status;
+  entry.dnsrec = dnsrec;
   return ares__array_insertdata_last(*requeue, &entry);
 }
 
+static ares_status_t ares_append_requeue(ares__array_t **requeue,
+                                         ares_query_t  *query,
+                                         ares_server_t *server)
+{
+  return ares_append_requeue_int(requeue, REQUEUE_REQUEUE, query, server, 0,
+    NULL);
+}
+
+static ares_status_t ares_append_endqueue(ares__array_t     **requeue,
+                                          ares_query_t      *query,
+                                          ares_status_t      status,
+                                          ares_dns_record_t *dnsrec)
+{
+  return ares_append_requeue_int(requeue, REQUEUE_ENDQUERY, query, NULL, status,
+    dnsrec);
+}
 
 /* If any TCP socket selects true for reading, read some data,
  * allocate a buffer if we finish reading the length word, and process
@@ -423,13 +454,24 @@ cleanup:
       break;
     }
 
-    /* Query disappeared */
     query = ares__htable_szvp_get_direct(channel->queries_by_qid, entry.qid);
-    if (query == NULL) {
-      continue;
+    if (entry.type == REQUEUE_REQUEUE) {
+      /* query disappeared */
+      if (query == NULL) {
+        continue;
+      }
+      ares__send_query(query, now);
+    } else { /* REQUEUE_ENDQUERY */
+      if (query != NULL) {
+        query->callback(query->arg, entry.status, query->timeouts, entry.dnsrec);
+        ares__free_query(query);
+      }
+      ares_dns_record_destroy(entry.dnsrec);
     }
-
-    ares__send_query(query, now);
+  }
+  /* Don't forget to send notification if queue emptied */
+  if (requeue != NULL) {
+    ares_queue_notify_empty(channel);
   }
   ares__array_destroy(requeue);
 }
@@ -749,7 +791,7 @@ static ares_status_t process_answer(ares_channel_t      *channel,
       ares_dns_get_opt_rr_const(rdnsrec) == NULL) {
     status = rewrite_without_edns(query);
     if (status != ARES_SUCCESS) {
-      end_query(channel, server, query, status, NULL);
+      end_query(channel, server, query, status, NULL, NULL);
       goto cleanup;
     }
 
@@ -795,6 +837,7 @@ static ares_status_t process_answer(ares_channel_t      *channel,
       server_increment_failures(server, query->using_tcp);
       status = ares__requeue_query(query, now, status, ARES_TRUE, rdnsrec,
                                    requeue);
+      rdnsrec = NULL; /* Free'd by ares_requeue_query() */
 
       if (status != ARES_ENOMEM) {
         /* Should any of these cause a connection termination?
@@ -807,12 +850,11 @@ static ares_status_t process_answer(ares_channel_t      *channel,
 
   /* If cache insertion was successful, it took ownership.  We ignore
    * other cache insertion failures. */
-  if (ares_qcache_insert(channel, now, query, rdnsrec) == ARES_SUCCESS) {
-    is_cached = ARES_TRUE;
-  }
+  ares_qcache_insert(channel, now, query, rdnsrec);
 
   server_set_good(server, query->using_tcp);
-  end_query(channel, server, query, ARES_SUCCESS, rdnsrec);
+  end_query(channel, server, query, ARES_SUCCESS, rdnsrec, requeue);
+  rdnsrec = NULL; /* Free'd by the requeue */
 
   status = ARES_SUCCESS;
 
@@ -845,7 +887,7 @@ ares_status_t ares__requeue_query(ares_query_t            *query,
                                   const ares_timeval_t    *now,
                                   ares_status_t            status,
                                   ares_bool_t              inc_try_count,
-                                  const ares_dns_record_t *dnsrec,
+                                  ares_dns_record_t       *dnsrec,
                                   ares__array_t           **requeue)
 {
   ares_channel_t *channel = query->channel;
@@ -862,6 +904,7 @@ ares_status_t ares__requeue_query(ares_query_t            *query,
   }
 
   if (query->try_count < max_tries && !query->no_retries) {
+    ares_dns_record_destroy(dnsrec);
     if (requeue != NULL) {
       return ares_append_requeue(requeue, query, NULL);
     }
@@ -873,7 +916,7 @@ ares_status_t ares__requeue_query(ares_query_t            *query,
     query->error_status = ARES_ETIMEOUT;
   }
 
-  end_query(channel, NULL, query, query->error_status, dnsrec);
+  end_query(channel, NULL, query, query->error_status, dnsrec, requeue);
   return ARES_ETIMEOUT;
 }
 
@@ -1151,7 +1194,7 @@ ares_status_t ares__send_query(ares_query_t *query, const ares_timeval_t *now)
   }
 
   if (server == NULL) {
-    end_query(channel, server, query, ARES_ENOSERVER /* ? */, NULL);
+    end_query(channel, server, query, ARES_ENOSERVER /* ? */, NULL, NULL);
     return ARES_ENOSERVER;
   }
 
@@ -1172,7 +1215,7 @@ ares_status_t ares__send_query(ares_query_t *query, const ares_timeval_t *now)
 
       /* Anything else is not retryable, likely ENOMEM */
       default:
-        end_query(channel, server, query, status, NULL);
+        end_query(channel, server, query, status, NULL, NULL);
         return status;
     }
   }
@@ -1186,7 +1229,7 @@ ares_status_t ares__send_query(ares_query_t *query, const ares_timeval_t *now)
 
     case ARES_ENOMEM:
       /* Not retryable */
-      end_query(channel, server, query, status, NULL);
+      end_query(channel, server, query, status, NULL, NULL);
       return status;
 
     /* These conditions are retryable as they are server-specific
@@ -1220,7 +1263,7 @@ ares_status_t ares__send_query(ares_query_t *query, const ares_timeval_t *now)
     ares__slist_insert(channel->queries_by_timeout, query);
   if (!query->node_queries_by_timeout) {
     /* LCOV_EXCL_START: OutOfMemory */
-    end_query(channel, server, query, ARES_ENOMEM, NULL);
+    end_query(channel, server, query, ARES_ENOMEM, NULL, NULL);
     return ARES_ENOMEM;
     /* LCOV_EXCL_STOP */
   }
@@ -1233,7 +1276,7 @@ ares_status_t ares__send_query(ares_query_t *query, const ares_timeval_t *now)
 
   if (query->node_queries_to_conn == NULL) {
     /* LCOV_EXCL_START: OutOfMemory */
-    end_query(channel, server, query, ARES_ENOMEM, NULL);
+    end_query(channel, server, query, ARES_ENOMEM, NULL, NULL);
     return ARES_ENOMEM;
     /* LCOV_EXCL_STOP */
   }
@@ -1344,10 +1387,16 @@ static void ares_detach_query(ares_query_t *query)
 
 static void end_query(ares_channel_t *channel, ares_server_t *server,
                       ares_query_t *query, ares_status_t status,
-                      const ares_dns_record_t *dnsrec)
+                      ares_dns_record_t *dnsrec, ares__array_t **requeue)
 {
   ares_metrics_record(query, server, status, dnsrec);
 
+  /* Delay calling the query callback */
+  if (requeue != NULL) {
+    ares_append_endqueue(requeue, query, status, dnsrec);
+    return;
+  }
+
   /* Invoke the callback. */
   query->callback(query->arg, status, query->timeouts, dnsrec);
   ares__free_query(query);
diff --git a/lib/c-ares-1.33.1/src/lib/ares_qcache.c b/lib/c-ares-1.33.1/src/lib/ares_qcache.c
index 9725212..8a5b4b0 100644
--- a/lib/c-ares-1.33.1/src/lib/ares_qcache.c
+++ b/lib/c-ares-1.33.1/src/lib/ares_qcache.c
@@ -422,10 +422,20 @@ done:
   return status;
 }
 
-ares_status_t ares_qcache_insert(ares_channel_t       *channel,
-                                 const ares_timeval_t *now,
-                                 const ares_query_t   *query,
-                                 ares_dns_record_t    *dnsrec)
+ares_status_t ares_qcache_insert(ares_channel_t          *channel,
+                                 const ares_timeval_t    *now,
+                                 const ares_query_t      *query,
+                                 const ares_dns_record_t *dnsrec)
 {
-  return ares__qcache_insert(channel->qcache, dnsrec, query->query, now);
+  ares_dns_record_t *dupdns = ares_dns_record_duplicate(dnsrec);
+  ares_status_t      status;
+
+  if (dupdns == NULL) {
+    return ARES_ENOMEM;
+  }
+  status = ares_qcache_insert(channel->qcache, dupdns, query->query, now);
+  if (status != ARES_SUCCESS) {
+    ares_dns_record_destroy(dupdns);
+  }
+  return status;
 }
diff --git a/lib/c-ares-1.33.1/test/ares-test-mock-ai.cc b/lib/c-ares-1.33.1/test/ares-test-mock-ai.cc
index ad61b04..9771a21 100644
--- a/lib/c-ares-1.33.1/test/ares-test-mock-ai.cc
+++ b/lib/c-ares-1.33.1/test/ares-test-mock-ai.cc
@@ -805,7 +805,39 @@ TEST_P(MockUDPChannelTestAI, TriggerResendThenConnFailEDNS) {
   EXPECT_THAT(result.ai_, IncludesV6Address("2121:0000:0000:0000:0000:0000:0000:0303"));
 }
 
+TEST_P(MockUDPChannelTestAI, ConnectionRefusedOnSearchDomainRetry) {
+  DNSPacket badrsp4;
+  badrsp4.set_response().set_aa()
+    .add_question(new DNSQuestion("www.google.com", T_A))
+    .set_rcode(NXDOMAIN);
+
+  EXPECT_CALL(server_, OnRequest("www.google.com", T_A))
+    .WillOnce(SetReplyAndFailSend(&server_, &badrsp4));
+
+  DNSPacket goodrsp4;
+  goodrsp4.set_response().set_aa()
+    .add_question(new DNSQuestion("www.google.com.first.com", T_A))
+    .add_answer(new DNSARR("www.google.com.first.com", 0x0100, {0x01, 0x02, 0x03, 0x04}));
+
+  EXPECT_CALL(server_, OnRequest("www.google.com.first.com", T_A))
+    .WillOnce(SetReply(&server_, &goodrsp4));
+
+  ares_socket_functions sock_funcs;
+  memset(&sock_funcs, 0, sizeof(sock_funcs));
 
+  sock_funcs.asendv = ares_sendv_fail;
+
+  ares_set_socket_functions(channel_, &sock_funcs, NULL);
+
+  AddrInfoResult result;
+  struct ares_addrinfo_hints hints = {0, 0, 0, 0};
+  hints.ai_family = AF_INET;
+  hints.ai_flags = ARES_AI_NOSORT;
+  ares_getaddrinfo(channel_, "www.google.com", NULL, &hints,
+                   AddrInfoCallback, &result);
+
+  Process();
+}
 
 class MockEDNSChannelTestAI : public MockFlagsChannelOptsTestAI {
  public:
-- 
2.43.0

