From 44fae91040634e51ef99b4a2fca154132aa4bf35 Mon Sep 17 00:00:00 2001
From: rpm-build <rpm-build>
Date: Wed, 12 Nov 2025 23:21:13 +0000
Subject: [PATCH] Force FIPS Mode for AZL3

---
 crypto/provider_conf.c | 120 ++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 119 insertions(+), 1 deletion(-)

diff --git a/crypto/provider_conf.c b/crypto/provider_conf.c
index 70c9729..5b39131 100644
--- a/crypto/provider_conf.c
+++ b/crypto/provider_conf.c
@@ -10,6 +10,7 @@
 #include <string.h>
 #include <openssl/trace.h>
 #include <openssl/err.h>
+#include <openssl/evp.h>
 #include <openssl/conf.h>
 #include <openssl/safestack.h>
 #include <openssl/provider.h>
@@ -237,7 +238,9 @@ static int provider_conf_activate(OSSL_LIB_CTX *libctx, const char *name,
         if (path != NULL)
             ossl_provider_set_module_path(prov, path);
 
-        ok = provider_conf_params(prov, NULL, NULL, value, cnf);
+        // AZL Note: This comes directly from the upstream patch
+        // https://src.fedoraproject.org/rpms/openssl/blob/f39/f/0032-Force-fips.patch
+        ok = cnf ? provider_conf_params(prov, NULL, NULL, value, cnf) : 1;
 
         if (ok == 1) {
             if (!ossl_provider_activate(prov, 1, 0)) {
@@ -396,6 +399,40 @@ static int provider_conf_load(OSSL_LIB_CTX *libctx, const char *name,
     return ok >= 0;
 }
 
+// Loads a FIPS-certified provider if available.
+// Returns non-zero if the provider was successfully loaded and 0 if it was not.
+static int load_fips_certified_provider(OSSL_LIB_CTX *libctx,
+                                        const char * provider_name,
+                                        const char * provider_config_path,
+                                        const char * provider_config_section,
+                                        int try_load_if_no_config) {
+    // See if the provider is installed.
+    if (access(provider_config_path, R_OK) == 0) {
+        // Attempt to load normally, through config.
+        CONF *prov_conf = NCONF_new_ex(libctx, NCONF_default());
+        if (NCONF_load(prov_conf, provider_config_path, NULL) <= 0) {
+            return 0;
+        }
+
+        if (provider_conf_load(libctx, provider_name, provider_config_section, prov_conf) != 1) {
+            NCONF_free(prov_conf);
+            return 0;
+        }
+
+        NCONF_free(prov_conf);
+
+        // We successfully loaded the SymCrypt provider.
+        return 1;
+    } else if (try_load_if_no_config != 0) {
+        // If requested by the caller, fall back to just loading by name.
+        if (provider_conf_activate(libctx, provider_name, NULL, NULL, 0, NULL) == 1) {
+            return 1;
+        }
+    }
+
+    return 0;
+}
+
 static int provider_conf_init(CONF_IMODULE *md, const CONF *cnf)
 {
     STACK_OF(CONF_VALUE) *elist;
@@ -420,6 +457,87 @@ static int provider_conf_init(CONF_IMODULE *md, const CONF *cnf)
             return 0;
     }
 
+    // AZL3 Note: This is a combination of the original AZL3 patch
+    //      https://github.com/microsoft/azurelinux/blob/092d8e60c72ce15f37681a32de0f31bab18a488c/SPECS/openssl/0032-Force-fips.patch
+    //      And the upstream patch
+    //      https://src.fedoraproject.org/rpms/openssl/blob/f39/f/0032-Force-fips.patch
+    //
+    // We load a FIPS-certified provider as needed, according to these rules.
+    //  1. On a NON-FIPS system:
+    //      1A. If the SymCrypt provider is available, load it.
+    //      1B. Else, do nothing and let OpenSSL load its default provider(s).
+    //  2. On a FIPS system:
+    //      2A. If the SymCrypt provider is available, load it.
+    //      2B. Else if the OpenSSL fips provider is available, load it.
+    //      2C. Else fail.
+    //
+    //  We use the presence of the configuration files to determine if a given provider is present.
+    //  In the FIPS case, we will also try to load the provider even if a configuration file is not present.
+
+    // Config file paths
+#  define SYMCRYPT_PROV_CONF           OPENSSLDIR "/symcrypt_prov.cnf"
+    // Upstream uses fips_local.cnf, we use fips_prov.cnf since we don't use crypto policies.
+#  define FIPS_PROV_CONF              OPENSSLDIR "/fips_prov.cnf"
+
+    // Context and configuration variables.
+    OSSL_LIB_CTX *libctx = NCONF_get0_libctx((CONF *)cnf);
+    PROVIDER_CONF_GLOBAL *pcgbl
+        = ossl_lib_ctx_get_data(libctx, OSSL_LIB_CTX_PROVIDER_CONF_INDEX);
+
+    // Trying to activate a provider after it's already been activated can fail, so get the current state of the relevant providers.
+    if (pcgbl == NULL || !CRYPTO_THREAD_write_lock(pcgbl->lock)) {
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+    int symcrypt_prov_activated = prov_already_activated("symcryptprovider", pcgbl->activated_providers);
+    // The original AZL3 patch has this, but never uses the variable. Just in case there are side-effects,
+    // we leave the function call in but don't assign to a variable to avoid warnings.
+    (void)prov_already_activated("default", pcgbl->activated_providers);
+    int fips_prov_activated = prov_already_activated("fips", pcgbl->activated_providers);
+    int base_prov_activated = prov_already_activated("base", pcgbl->activated_providers);
+    CRYPTO_THREAD_unlock(pcgbl->lock);
+
+    // Get the kernel FIPS mode. This also takes into account the FIPS override variable OPENSSL_FORCE_FIPS_MODE.
+    int kernel_fips_mode = ossl_get_kernel_fips_flag();
+
+    // We only need to do anything special if neither FIPS-certified providers.
+    if (symcrypt_prov_activated == 0 && fips_prov_activated == 0) {
+        if (kernel_fips_mode == 0) {
+            // If the system is in NON-FIPS mode, try to load the SymCrypt provider.
+            // This is best-effort based on the availability of the provider and does not affect the return value.
+            (void)load_fips_certified_provider(libctx, "symcryptprovider", SYMCRYPT_PROV_CONF, "symcrypt_prov_sect", 0);
+        } else {
+            // If the system is in FIPS mode, first try to load the SymCrypt provider and then fall back to the OpenSSL FIPS provider.
+            // If neither is available, fail.
+            symcrypt_prov_activated = load_fips_certified_provider(libctx, "symcryptprovider", SYMCRYPT_PROV_CONF, "symcrypt_prov_sect", 1);
+            if (symcrypt_prov_activated == 0) {
+                fips_prov_activated = load_fips_certified_provider(libctx, "fips", FIPS_PROV_CONF, "fips_prov_sect", 1);
+            }
+
+            // If we still don't have a FIPS-certified provider, fail.
+            if (symcrypt_prov_activated == 0 && fips_prov_activated == 0) {
+                return 0;
+            }
+        }
+
+        // If we somewhere along the line activated the OpenSSL FIPS provider, also activate
+        // the base provider and set the fips flag, per upstream patch.
+        if (fips_prov_activated != 0) {
+            // Activate the base provider if not already done.
+            if (base_prov_activated == 0) {
+                if (provider_conf_activate(libctx, "base", NULL, NULL, 0, NULL) != 1) {
+                    return 0;
+                }
+            }
+
+            // Set the FIPS mode flag in the library context.
+            if (EVP_default_properties_enable_fips(libctx, 1) != 1) {
+                return 0;
+            }
+        }
+    }
+
+
     return 1;
 }
 
-- 
2.45.4

