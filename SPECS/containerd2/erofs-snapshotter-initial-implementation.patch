From f0f8799ce24f75fc34128bd0cc89b4ea2db346dd Mon Sep 17 00:00:00 2001
From: Gao Xiang <hsiangkao@linux.alibaba.com>
Date: Tue, 3 Sep 2024 20:19:27 +0800
Subject: [PATCH 01/16] Introduce EROFS differ

The EROFS differ only applies to EROFS layers which are marked by
a special file `.erofslayer` generated by the EROFS snapshotter.

Why it's needed?  Since we'd like to parse []mount.Mount directly
without actual mounting and convert OCI layers into EROFS blobs,
`.erofslayer` gives a hint that the active snapshotter supports
the output blob generated by the EROFS differ.

I'd suggest it could be read together with the next commit.

Signed-off-by: cardy.tang <zuniorone@gmail.com>
Signed-off-by: Gao Xiang <hsiangkao@linux.alibaba.com>
---
 cmd/containerd/builtins/builtins_linux.go |   1 +
 plugins/diff/erofs/differ_linux.go        | 189 ++++++++++++++++++++++
 plugins/diff/erofs/plugin/plugin_linux.go |  63 ++++++++
 3 files changed, 253 insertions(+)
 create mode 100644 plugins/diff/erofs/differ_linux.go
 create mode 100644 plugins/diff/erofs/plugin/plugin_linux.go

diff --git a/cmd/containerd/builtins/builtins_linux.go b/cmd/containerd/builtins/builtins_linux.go
index deed083b8..02577bc4e 100644
--- a/cmd/containerd/builtins/builtins_linux.go
+++ b/cmd/containerd/builtins/builtins_linux.go
@@ -20,6 +20,7 @@ import (
 	_ "github.com/containerd/containerd/api/types/runc/options"
 	_ "github.com/containerd/containerd/v2/core/metrics/cgroups"
 	_ "github.com/containerd/containerd/v2/core/metrics/cgroups/v2"
+	_ "github.com/containerd/containerd/v2/plugins/diff/erofs/plugin"
 	_ "github.com/containerd/containerd/v2/plugins/diff/walking/plugin"
 	_ "github.com/containerd/containerd/v2/plugins/snapshots/blockfile/plugin"
 	_ "github.com/containerd/containerd/v2/plugins/snapshots/native/plugin"
diff --git a/plugins/diff/erofs/differ_linux.go b/plugins/diff/erofs/differ_linux.go
new file mode 100644
index 000000000..5686435f0
--- /dev/null
+++ b/plugins/diff/erofs/differ_linux.go
@@ -0,0 +1,189 @@
+/*
+   Copyright The containerd Authors.
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+*/
+
+package erofs
+
+import (
+	"context"
+	"fmt"
+	"io"
+	"os"
+	"os/exec"
+	"path"
+	"path/filepath"
+	"strings"
+	"time"
+
+	"github.com/containerd/containerd/v2/core/content"
+	"github.com/containerd/containerd/v2/core/diff"
+	"github.com/containerd/containerd/v2/core/images"
+	"github.com/containerd/containerd/v2/core/mount"
+	"github.com/containerd/errdefs"
+	"github.com/containerd/log"
+	digest "github.com/opencontainers/go-digest"
+	ocispec "github.com/opencontainers/image-spec/specs-go/v1"
+)
+
+var emptyDesc = ocispec.Descriptor{}
+
+type differ interface {
+	diff.Applier
+	diff.Comparer
+}
+
+// erofsDiff does erofs comparison and application
+type erofsDiff struct {
+	store         content.Store
+	mkfsExtraOpts []string
+}
+
+func NewErofsDiffer(store content.Store, mkfsExtraOpts []string) differ {
+	return &erofsDiff{
+		store:         store,
+		mkfsExtraOpts: mkfsExtraOpts,
+	}
+}
+
+// Compare creates a diff between the given mounts and uploads the result
+// to the content store.
+func (s erofsDiff) Compare(ctx context.Context, lower, upper []mount.Mount, opts ...diff.Opt) (d ocispec.Descriptor, err error) {
+	return emptyDesc, fmt.Errorf("erofsDiff does not implement Compare method: %w", errdefs.ErrNotImplemented)
+}
+
+func convertTarErofs(ctx context.Context, r io.Reader, layerPath string, mkfsExtraOpts []string) error {
+	args := append([]string{"--tar=f", "--aufs", "--quiet", "-Enoinline_data"}, mkfsExtraOpts...)
+	args = append(args, layerPath)
+	cmd := exec.CommandContext(ctx, "mkfs.erofs", args...)
+	cmd.Stdin = r
+	out, err := cmd.CombinedOutput()
+	if err != nil {
+		return fmt.Errorf("erofs apply failed: %s: %w", out, err)
+	}
+	log.G(ctx).Debugf("running %s %s %v", cmd.Path, cmd.Args, string(out))
+	return nil
+}
+
+// Get the snapshot layer directory in order to generate EROFS-formatted blobs;
+//
+// If mount[0].Type is `bind` or `erofs`, it just tries the source dir; Or if
+// mount[0].Type is `overlayfs`, it tries the parent of the upperdir;
+//
+// The candidate will be checked with ".erofslayer" to make sure this active
+// snapshot is really generated by the EROFS snapshotter instead of others.
+func mountsToLayer(mounts []mount.Mount) (string, error) {
+	var layer string
+	mnt := mounts[0]
+	if mnt.Type == "bind" || mnt.Type == "erofs" {
+		layer = filepath.Dir(mnt.Source)
+	} else if mnt.Type == "overlay" {
+		layer = ""
+		for _, o := range mnt.Options {
+			if strings.HasPrefix(o, "upperdir=") {
+				layer = filepath.Dir(strings.TrimPrefix(o, "upperdir="))
+			}
+		}
+		if layer == "" {
+			return "", fmt.Errorf("unsupported overlay layer for erofs differ: %w", errdefs.ErrNotImplemented)
+		}
+	} else {
+		return "", fmt.Errorf("invalid filesystem type for erofs differ: %w", errdefs.ErrNotImplemented)
+	}
+	// If the layer is not prepared by the EROFS snapshotter, fall back to the next differ
+	if _, err := os.Stat(filepath.Join(layer, ".erofslayer")); err != nil {
+		return "", fmt.Errorf("mount layer type must be erofs-layer: %w", errdefs.ErrNotImplemented)
+	}
+	return layer, nil
+}
+
+func (s erofsDiff) Apply(ctx context.Context, desc ocispec.Descriptor, mounts []mount.Mount, opts ...diff.ApplyOpt) (d ocispec.Descriptor, err error) {
+	t1 := time.Now()
+	defer func() {
+		if err == nil {
+			log.G(ctx).WithFields(log.Fields{
+				"d":      time.Since(t1),
+				"digest": desc.Digest,
+				"size":   desc.Size,
+				"media":  desc.MediaType,
+			}).Debugf("diff applied")
+		}
+	}()
+
+	if _, err := images.DiffCompression(ctx, desc.MediaType); err != nil {
+		return emptyDesc, fmt.Errorf("currently unsupported media type: %s", desc.MediaType)
+	}
+
+	var config diff.ApplyConfig
+	for _, o := range opts {
+		if err := o(ctx, desc, &config); err != nil {
+			return emptyDesc, fmt.Errorf("failed to apply config opt: %w", err)
+		}
+	}
+
+	layer, err := mountsToLayer(mounts)
+	if err != nil {
+		return emptyDesc, err
+	}
+
+	ra, err := s.store.ReaderAt(ctx, desc)
+	if err != nil {
+		return emptyDesc, fmt.Errorf("failed to get reader from content store: %w", err)
+	}
+	defer ra.Close()
+
+	processor := diff.NewProcessorChain(desc.MediaType, content.NewReader(ra))
+	for {
+		if processor, err = diff.GetProcessor(ctx, processor, config.ProcessorPayloads); err != nil {
+			return emptyDesc, fmt.Errorf("failed to get stream processor for %s: %w", desc.MediaType, err)
+		}
+		if processor.MediaType() == ocispec.MediaTypeImageLayer {
+			break
+		}
+	}
+	defer processor.Close()
+
+	digester := digest.Canonical.Digester()
+	rc := &readCounter{
+		r: io.TeeReader(processor, digester.Hash()),
+	}
+
+	layerBlobPath := path.Join(layer, "layer.erofs")
+	err = convertTarErofs(ctx, rc, layerBlobPath, s.mkfsExtraOpts)
+	if err != nil {
+		return emptyDesc, fmt.Errorf("failed to convert erofs: %w", err)
+	}
+
+	// Read any trailing data
+	if _, err := io.Copy(io.Discard, rc); err != nil {
+		return emptyDesc, err
+	}
+
+	return ocispec.Descriptor{
+		MediaType: ocispec.MediaTypeImageLayer,
+		Size:      rc.c,
+		Digest:    digester.Digest(),
+	}, nil
+}
+
+type readCounter struct {
+	r io.Reader
+	c int64
+}
+
+func (rc *readCounter) Read(p []byte) (n int, err error) {
+	n, err = rc.r.Read(p)
+	rc.c += int64(n)
+	return
+}
diff --git a/plugins/diff/erofs/plugin/plugin_linux.go b/plugins/diff/erofs/plugin/plugin_linux.go
new file mode 100644
index 000000000..735afd131
--- /dev/null
+++ b/plugins/diff/erofs/plugin/plugin_linux.go
@@ -0,0 +1,63 @@
+/*
+   Copyright The containerd Authors.
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+*/
+
+package plugin
+
+import (
+	"fmt"
+	"os/exec"
+
+	"github.com/containerd/containerd/v2/core/metadata"
+	"github.com/containerd/containerd/v2/plugins"
+	"github.com/containerd/containerd/v2/plugins/diff/erofs"
+	"github.com/containerd/platforms"
+	"github.com/containerd/plugin"
+	"github.com/containerd/plugin/registry"
+)
+
+// Config represents configuration for the erofs plugin.
+type Config struct {
+	// MkfsOptions are extra options used for the applier
+	MkfsOptions []string `toml:"mkfs_options"`
+}
+
+func init() {
+	registry.Register(&plugin.Registration{
+		Type: plugins.DiffPlugin,
+		ID:   "erofs",
+		Requires: []plugin.Type{
+			plugins.MetadataPlugin,
+		},
+		Config: &Config{},
+		InitFn: func(ic *plugin.InitContext) (interface{}, error) {
+			_, err := exec.LookPath("mkfs.erofs")
+			if err != nil {
+				return nil, fmt.Errorf("could not find mkfs.erofs: %v: %w", err, plugin.ErrSkipPlugin)
+			}
+
+			md, err := ic.GetSingle(plugins.MetadataPlugin)
+			if err != nil {
+				return nil, err
+			}
+
+			ic.Meta.Platforms = append(ic.Meta.Platforms, platforms.DefaultSpec())
+			cs := md.(*metadata.DB).ContentStore()
+			config := ic.Config.(*Config)
+
+			return erofs.NewErofsDiffer(cs, config.MkfsOptions), nil
+		},
+	})
+}
-- 
2.45.3


From 38e34b674e2646e2ccd8b61de2ab9030868a005f Mon Sep 17 00:00:00 2001
From: Gao Xiang <hsiangkao@linux.alibaba.com>
Date: Wed, 18 Sep 2024 18:48:54 +0800
Subject: [PATCH 02/16] Introduce EROFS Snapshotter

It allows us to mount each EROFS blob layer (generated by the EROFS
differ) independently, or use the "unpacked" fs/ directories (if
some other differ is used.)

Currently, it's somewhat like the overlay snapshotter, but I tend
to separate the new EROFS logic into a self-contained component,
rather than keeping it tangled in the very beginning.

Existing users who use the overlay snapshotter won't be impacted
at all but they have a chance to use this new snapshotter to
leverage the EROFS filesystem.

Signed-off-by: cardy.tang <zuniorone@gmail.com>
Signed-off-by: Gao Xiang <hsiangkao@linux.alibaba.com>
---
 cmd/containerd/builtins/builtins_linux.go     |   1 +
 plugins/diff/erofs/differ_linux.go            |  54 +-
 plugins/snapshots/erofs/erofs_linux.go        | 538 ++++++++++++++++++
 .../snapshots/erofs/erofsutils/mount_linux.go |  88 +++
 .../snapshots/erofs/plugin/plugin_linux.go    |  65 +++
 5 files changed, 695 insertions(+), 51 deletions(-)
 create mode 100644 plugins/snapshots/erofs/erofs_linux.go
 create mode 100644 plugins/snapshots/erofs/erofsutils/mount_linux.go
 create mode 100644 plugins/snapshots/erofs/plugin/plugin_linux.go

diff --git a/cmd/containerd/builtins/builtins_linux.go b/cmd/containerd/builtins/builtins_linux.go
index 02577bc4e..19e762090 100644
--- a/cmd/containerd/builtins/builtins_linux.go
+++ b/cmd/containerd/builtins/builtins_linux.go
@@ -23,6 +23,7 @@ import (
 	_ "github.com/containerd/containerd/v2/plugins/diff/erofs/plugin"
 	_ "github.com/containerd/containerd/v2/plugins/diff/walking/plugin"
 	_ "github.com/containerd/containerd/v2/plugins/snapshots/blockfile/plugin"
+	_ "github.com/containerd/containerd/v2/plugins/snapshots/erofs/plugin"
 	_ "github.com/containerd/containerd/v2/plugins/snapshots/native/plugin"
 	_ "github.com/containerd/containerd/v2/plugins/snapshots/overlay/plugin"
 )
diff --git a/plugins/diff/erofs/differ_linux.go b/plugins/diff/erofs/differ_linux.go
index 5686435f0..52f9fa0bf 100644
--- a/plugins/diff/erofs/differ_linux.go
+++ b/plugins/diff/erofs/differ_linux.go
@@ -20,17 +20,14 @@ import (
 	"context"
 	"fmt"
 	"io"
-	"os"
-	"os/exec"
 	"path"
-	"path/filepath"
-	"strings"
 	"time"
 
 	"github.com/containerd/containerd/v2/core/content"
 	"github.com/containerd/containerd/v2/core/diff"
 	"github.com/containerd/containerd/v2/core/images"
 	"github.com/containerd/containerd/v2/core/mount"
+	"github.com/containerd/containerd/v2/plugins/snapshots/erofs/erofsutils"
 	"github.com/containerd/errdefs"
 	"github.com/containerd/log"
 	digest "github.com/opencontainers/go-digest"
@@ -63,51 +60,6 @@ func (s erofsDiff) Compare(ctx context.Context, lower, upper []mount.Mount, opts
 	return emptyDesc, fmt.Errorf("erofsDiff does not implement Compare method: %w", errdefs.ErrNotImplemented)
 }
 
-func convertTarErofs(ctx context.Context, r io.Reader, layerPath string, mkfsExtraOpts []string) error {
-	args := append([]string{"--tar=f", "--aufs", "--quiet", "-Enoinline_data"}, mkfsExtraOpts...)
-	args = append(args, layerPath)
-	cmd := exec.CommandContext(ctx, "mkfs.erofs", args...)
-	cmd.Stdin = r
-	out, err := cmd.CombinedOutput()
-	if err != nil {
-		return fmt.Errorf("erofs apply failed: %s: %w", out, err)
-	}
-	log.G(ctx).Debugf("running %s %s %v", cmd.Path, cmd.Args, string(out))
-	return nil
-}
-
-// Get the snapshot layer directory in order to generate EROFS-formatted blobs;
-//
-// If mount[0].Type is `bind` or `erofs`, it just tries the source dir; Or if
-// mount[0].Type is `overlayfs`, it tries the parent of the upperdir;
-//
-// The candidate will be checked with ".erofslayer" to make sure this active
-// snapshot is really generated by the EROFS snapshotter instead of others.
-func mountsToLayer(mounts []mount.Mount) (string, error) {
-	var layer string
-	mnt := mounts[0]
-	if mnt.Type == "bind" || mnt.Type == "erofs" {
-		layer = filepath.Dir(mnt.Source)
-	} else if mnt.Type == "overlay" {
-		layer = ""
-		for _, o := range mnt.Options {
-			if strings.HasPrefix(o, "upperdir=") {
-				layer = filepath.Dir(strings.TrimPrefix(o, "upperdir="))
-			}
-		}
-		if layer == "" {
-			return "", fmt.Errorf("unsupported overlay layer for erofs differ: %w", errdefs.ErrNotImplemented)
-		}
-	} else {
-		return "", fmt.Errorf("invalid filesystem type for erofs differ: %w", errdefs.ErrNotImplemented)
-	}
-	// If the layer is not prepared by the EROFS snapshotter, fall back to the next differ
-	if _, err := os.Stat(filepath.Join(layer, ".erofslayer")); err != nil {
-		return "", fmt.Errorf("mount layer type must be erofs-layer: %w", errdefs.ErrNotImplemented)
-	}
-	return layer, nil
-}
-
 func (s erofsDiff) Apply(ctx context.Context, desc ocispec.Descriptor, mounts []mount.Mount, opts ...diff.ApplyOpt) (d ocispec.Descriptor, err error) {
 	t1 := time.Now()
 	defer func() {
@@ -132,7 +84,7 @@ func (s erofsDiff) Apply(ctx context.Context, desc ocispec.Descriptor, mounts []
 		}
 	}
 
-	layer, err := mountsToLayer(mounts)
+	layer, err := erofsutils.MountsToLayer(mounts)
 	if err != nil {
 		return emptyDesc, err
 	}
@@ -160,7 +112,7 @@ func (s erofsDiff) Apply(ctx context.Context, desc ocispec.Descriptor, mounts []
 	}
 
 	layerBlobPath := path.Join(layer, "layer.erofs")
-	err = convertTarErofs(ctx, rc, layerBlobPath, s.mkfsExtraOpts)
+	err = erofsutils.ConvertTarErofs(ctx, rc, layerBlobPath, s.mkfsExtraOpts)
 	if err != nil {
 		return emptyDesc, fmt.Errorf("failed to convert erofs: %w", err)
 	}
diff --git a/plugins/snapshots/erofs/erofs_linux.go b/plugins/snapshots/erofs/erofs_linux.go
new file mode 100644
index 000000000..224418e59
--- /dev/null
+++ b/plugins/snapshots/erofs/erofs_linux.go
@@ -0,0 +1,538 @@
+/*
+   Copyright The containerd Authors.
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+*/
+
+package erofs
+
+import (
+	"bytes"
+	"context"
+	"fmt"
+	"os"
+	"path/filepath"
+	"strings"
+	"syscall"
+
+	"github.com/containerd/containerd/v2/core/mount"
+	"github.com/containerd/containerd/v2/core/snapshots"
+	"github.com/containerd/containerd/v2/core/snapshots/storage"
+	"github.com/containerd/containerd/v2/plugins/snapshots/erofs/erofsutils"
+	"github.com/containerd/continuity/fs"
+	"github.com/containerd/log"
+	"github.com/containerd/plugin"
+	"golang.org/x/sys/unix"
+)
+
+// SnapshotterConfig is used to configure the erofs snapshotter instance
+type SnapshotterConfig struct {
+	// ovlOptions are the base options added to the overlayfs mount (defaults to [""])
+	ovlOptions []string
+}
+
+// Opt is an option to configure the erofs snapshotter
+type Opt func(config *SnapshotterConfig)
+
+// WithOvlOptions defines the extra mount options for overlayfs
+func WithOvlOptions(options []string) Opt {
+	return func(config *SnapshotterConfig) {
+		config.ovlOptions = options
+	}
+}
+
+type MetaStore interface {
+	TransactionContext(ctx context.Context, writable bool) (context.Context, storage.Transactor, error)
+	WithTransaction(ctx context.Context, writable bool, fn storage.TransactionCallback) error
+	Close() error
+}
+
+type snapshotter struct {
+	root       string
+	ms         *storage.MetaStore
+	ovlOptions []string
+}
+
+// check if EROFS kernel filesystem is registered or not
+func findErofs() bool {
+	fs, err := os.ReadFile("/proc/filesystems")
+	if err != nil {
+		return false
+	}
+	return bytes.Contains(fs, []byte("\terofs\n"))
+}
+
+// we have to claim it as uint32, otherwise s390x CI will complain.. :(
+const erofsSuperMagic = uint32(0xE0F5E1E2)
+
+// Check if a directory is actually an EROFS mount, which is used to setup or
+// recover EROFS mounts for lowerdirs.
+func isErofs(dir string) bool {
+	var st unix.Statfs_t
+	if err := unix.Statfs(dir, &st); err != nil {
+		return false
+	}
+	return uint32(st.Type) == erofsSuperMagic
+}
+
+// NewSnapshotter returns a Snapshotter which uses EROFS+OverlayFS. The layers
+// are stored under the provided root. A metadata file is stored under the root.
+func NewSnapshotter(root string, opts ...Opt) (snapshots.Snapshotter, error) {
+	var config SnapshotterConfig
+	for _, opt := range opts {
+		opt(&config)
+	}
+
+	if err := os.MkdirAll(root, 0700); err != nil {
+		return nil, err
+	}
+	supportsDType, err := fs.SupportsDType(root)
+	if err != nil {
+		return nil, err
+	}
+	if !supportsDType {
+		return nil, fmt.Errorf("%s does not support d_type. If the backing filesystem is xfs, please reformat with ftype=1 to enable d_type support", root)
+	}
+
+	if !findErofs() {
+		return nil, fmt.Errorf("EROFS unsupported, please `modprobe erofs`: %w", plugin.ErrSkipPlugin)
+	}
+
+	ms, err := storage.NewMetaStore(filepath.Join(root, "metadata.db"))
+	if err != nil {
+		return nil, err
+	}
+
+	if err := os.Mkdir(filepath.Join(root, "snapshots"), 0700); err != nil && !os.IsExist(err) {
+		return nil, err
+	}
+
+	return &snapshotter{
+		root:       root,
+		ms:         ms,
+		ovlOptions: config.ovlOptions,
+	}, nil
+}
+
+// Close closes the snapshotter
+func (s *snapshotter) Close() error {
+	return s.ms.Close()
+}
+
+func (s *snapshotter) upperPath(id string) string {
+	return filepath.Join(s.root, "snapshots", id, "fs")
+}
+
+func (s *snapshotter) workPath(id string) string {
+	return filepath.Join(s.root, "snapshots", id, "work")
+}
+
+// A committed layer blob generated by the EROFS differ
+func (s *snapshotter) layerBlobPath(id string) string {
+	return filepath.Join(s.root, "snapshots", id, "layer.erofs")
+}
+
+func (s *snapshotter) lowerPath(id string) (mount.Mount, string, error) {
+	layerBlob := s.layerBlobPath(id)
+	if _, err := os.Stat(layerBlob); err != nil {
+		return mount.Mount{}, "", fmt.Errorf("failed to find valid erofs layer blob: %w", err)
+	}
+
+	return mount.Mount{
+		Source:  layerBlob,
+		Type:    "erofs",
+		Options: []string{"ro"},
+	}, s.upperPath(id), nil
+}
+
+func (s *snapshotter) prepareDirectory(ctx context.Context, snapshotDir string, kind snapshots.Kind) (string, error) {
+	td, err := os.MkdirTemp(snapshotDir, "new-")
+	if err != nil {
+		return "", fmt.Errorf("failed to create temp dir: %w", err)
+	}
+
+	if err := os.Mkdir(filepath.Join(td, "fs"), 0755); err != nil {
+		return td, err
+	}
+
+	if kind == snapshots.KindActive {
+		if err := os.Mkdir(filepath.Join(td, "work"), 0711); err != nil {
+			return td, err
+		}
+	}
+	// Create a special file for the EROFS differ to indicate it will be
+	// prepared as an EROFS layer by the EROFS snapshotter.
+	if err := os.WriteFile(filepath.Join(td, ".erofslayer"), []byte{}, 0644); err != nil {
+		return td, err
+	}
+	return td, nil
+}
+
+func (s *snapshotter) mounts(snap storage.Snapshot, info snapshots.Info) ([]mount.Mount, error) {
+	var options []string
+
+	if len(snap.ParentIDs) == 0 {
+		// If the EROFS layer blob is valid, only snapshots.KindView is allowed.
+		m, _, err := s.lowerPath(snap.ID)
+		if err == nil {
+			if snap.Kind != snapshots.KindView {
+				return nil, fmt.Errorf("only works for snapshots.KindView on a committed snapshot: %w", err)
+			}
+			// We have to force a loop device here since mount[] is static.
+			m.Options = append(m.Options, "loop")
+			return []mount.Mount{m}, nil
+		}
+		// if we only have one layer/no parents then just return a bind mount as overlay
+		// will not work
+		roFlag := "rw"
+		if snap.Kind == snapshots.KindView {
+			roFlag = "ro"
+		}
+		return []mount.Mount{
+			{
+				Source: s.upperPath(snap.ID),
+				Type:   "bind",
+				Options: append(options,
+					roFlag,
+					"rbind",
+				),
+			},
+		}, nil
+	}
+
+	if snap.Kind == snapshots.KindActive {
+		options = append(options,
+			fmt.Sprintf("workdir=%s", s.workPath(snap.ID)),
+			fmt.Sprintf("upperdir=%s", s.upperPath(snap.ID)),
+		)
+	} else if len(snap.ParentIDs) == 1 {
+		m, _, err := s.lowerPath(snap.ParentIDs[0])
+		if err != nil {
+			return nil, err
+		}
+		return []mount.Mount{m}, nil
+	}
+
+	var lowerdirs []string
+	for i := range snap.ParentIDs {
+		m, mntpoint, err := s.lowerPath(snap.ParentIDs[i])
+		if err != nil {
+			return nil, err
+		}
+
+		// If the lowerdir is actually an EROFS committed layer but
+		// doesn't have an EROFS mount.  Let's recover now.
+		if mntpoint != m.Source && !isErofs(mntpoint) {
+			err := m.Mount(mntpoint)
+			// Use loop if the current kernel (6.12+) doesn't support file-backed mount
+			if err == unix.ENOTBLK {
+				m.Options = append(m.Options, "loop")
+				err = m.Mount(mntpoint)
+			}
+			if err != nil {
+				return nil, err
+			}
+		}
+		lowerdirs = append(lowerdirs, mntpoint)
+	}
+	options = append(options, fmt.Sprintf("lowerdir=%s", strings.Join(lowerdirs, ":")))
+	options = append(options, s.ovlOptions...)
+
+	return []mount.Mount{{
+		Type:    "overlay",
+		Source:  "overlay",
+		Options: options,
+	}}, nil
+}
+
+func (s *snapshotter) createSnapshot(ctx context.Context, kind snapshots.Kind, key, parent string, opts []snapshots.Opt) (_ []mount.Mount, err error) {
+	var (
+		snap     storage.Snapshot
+		td, path string
+		info     snapshots.Info
+	)
+
+	defer func() {
+		if err != nil {
+			if td != "" {
+				if err1 := os.RemoveAll(td); err1 != nil {
+					log.G(ctx).WithError(err1).Warn("failed to cleanup temp snapshot directory")
+				}
+			}
+			if path != "" {
+				if err1 := os.RemoveAll(path); err1 != nil {
+					log.G(ctx).WithError(err1).WithField("path", path).Error("failed to reclaim snapshot directory, directory may need removal")
+					err = fmt.Errorf("failed to remove path: %v: %w", err1, err)
+				}
+			}
+		}
+	}()
+
+	if err := s.ms.WithTransaction(ctx, true, func(ctx context.Context) (err error) {
+		snapshotDir := filepath.Join(s.root, "snapshots")
+		td, err = s.prepareDirectory(ctx, snapshotDir, kind)
+		if err != nil {
+			return fmt.Errorf("failed to create prepare snapshot dir: %w", err)
+		}
+
+		snap, err = storage.CreateSnapshot(ctx, kind, key, parent, opts...)
+		if err != nil {
+			return fmt.Errorf("failed to create snapshot: %w", err)
+		}
+
+		_, info, _, err = storage.GetInfo(ctx, key)
+		if err != nil {
+			return fmt.Errorf("failed to get snapshot info: %w", err)
+		}
+
+		if len(snap.ParentIDs) > 0 {
+			st, err := os.Stat(s.upperPath(snap.ParentIDs[0]))
+			if err != nil {
+				return fmt.Errorf("failed to stat parent: %w", err)
+			}
+
+			stat := st.Sys().(*syscall.Stat_t)
+			if err := os.Lchown(filepath.Join(td, "fs"), int(stat.Uid), int(stat.Gid)); err != nil {
+				return fmt.Errorf("failed to chown: %w", err)
+			}
+		}
+
+		path = filepath.Join(snapshotDir, snap.ID)
+		if err = os.Rename(td, path); err != nil {
+			return fmt.Errorf("failed to rename: %w", err)
+		}
+		td = ""
+
+		return nil
+	}); err != nil {
+		return nil, err
+	}
+	return s.mounts(snap, info)
+}
+
+func (s *snapshotter) Prepare(ctx context.Context, key, parent string, opts ...snapshots.Opt) ([]mount.Mount, error) {
+	return s.createSnapshot(ctx, snapshots.KindActive, key, parent, opts)
+}
+
+func (s *snapshotter) View(ctx context.Context, key, parent string, opts ...snapshots.Opt) ([]mount.Mount, error) {
+	return s.createSnapshot(ctx, snapshots.KindView, key, parent, opts)
+}
+
+func (s *snapshotter) Commit(ctx context.Context, name, key string, opts ...snapshots.Opt) error {
+	var layerBlob, upperDir string
+
+	// Apply the overlayfs upperdir (generated by non-EROFS differs) into a EROFS blob
+	// in a read transaction first since conversion could be slow.
+	err := s.ms.WithTransaction(ctx, false, func(ctx context.Context) error {
+		id, _, _, err := storage.GetInfo(ctx, key)
+		if err != nil {
+			return err
+		}
+
+		// If the layer blob doesn't exist, which means this layer wasn't applied by
+		// the EROFS differ (possibly the walking differ), convert the upperdir instead.
+		layerBlob = s.layerBlobPath(id)
+		if _, err := os.Stat(layerBlob); err != nil {
+			upperDir = s.upperPath(id)
+			err = erofsutils.ConvertErofs(ctx, layerBlob, upperDir, nil)
+			if err != nil {
+				return err
+			}
+
+			// Remove all sub-directories in the overlayfs upperdir.  Leave the
+			// overlayfs upperdir itself since it's used for Lchown.
+			fd, err := os.Open(upperDir)
+			if err != nil {
+				return err
+			}
+			defer fd.Close()
+
+			dirs, err := fd.Readdirnames(0)
+			if err != nil {
+				return err
+			}
+
+			for _, d := range dirs {
+				dir := filepath.Join(upperDir, d)
+				if err := os.RemoveAll(dir); err != nil {
+					log.G(ctx).WithError(err).WithField("path", dir).Warn("failed to remove directory")
+				}
+			}
+		}
+		return nil
+	})
+
+	if err != nil {
+		return err
+	}
+	return s.ms.WithTransaction(ctx, true, func(ctx context.Context) error {
+		if _, err := os.Stat(layerBlob); err != nil {
+			return fmt.Errorf("failed to get the converted erofs blob: %w", err)
+		}
+
+		usage, err := fs.DiskUsage(ctx, layerBlob)
+		if err != nil {
+			return err
+		}
+		if _, err = storage.CommitActive(ctx, key, name, snapshots.Usage(usage), opts...); err != nil {
+			return fmt.Errorf("failed to commit snapshot %s: %w", key, err)
+		}
+		return nil
+	})
+}
+
+func (s *snapshotter) Mounts(ctx context.Context, key string) (_ []mount.Mount, err error) {
+	var snap storage.Snapshot
+	var info snapshots.Info
+	if err := s.ms.WithTransaction(ctx, false, func(ctx context.Context) error {
+		snap, err = storage.GetSnapshot(ctx, key)
+		if err != nil {
+			return fmt.Errorf("failed to get active mount: %w", err)
+		}
+
+		_, info, _, err = storage.GetInfo(ctx, key)
+		if err != nil {
+			return fmt.Errorf("failed to get snapshot info: %w", err)
+		}
+		return nil
+	}); err != nil {
+		return nil, err
+	}
+	return s.mounts(snap, info)
+}
+
+func (s *snapshotter) getCleanupDirectories(ctx context.Context) ([]string, error) {
+	ids, err := storage.IDMap(ctx)
+	if err != nil {
+		return nil, err
+	}
+
+	snapshotDir := filepath.Join(s.root, "snapshots")
+	fd, err := os.Open(snapshotDir)
+	if err != nil {
+		return nil, err
+	}
+	defer fd.Close()
+
+	dirs, err := fd.Readdirnames(0)
+	if err != nil {
+		return nil, err
+	}
+
+	cleanup := []string{}
+	for _, d := range dirs {
+		if _, ok := ids[d]; ok {
+			continue
+		}
+		cleanup = append(cleanup, filepath.Join(snapshotDir, d))
+	}
+
+	return cleanup, nil
+}
+
+// Remove abandons the snapshot identified by key. The snapshot will
+// immediately become unavailable and unrecoverable. Disk space will
+// be freed up on the next call to `Cleanup`.
+func (s *snapshotter) Remove(ctx context.Context, key string) (err error) {
+	var removals []string
+	var id string
+	// Remove directories after the transaction is closed, failures must not
+	// return error since the transaction is committed with the removal
+	// key no longer available.
+	defer func() {
+		if err == nil {
+			if err := mount.UnmountAll(s.upperPath(id), 0); err != nil {
+				log.G(ctx).Warnf("failed to unmount EROFS mount for %v", id)
+			}
+
+			for _, dir := range removals {
+				if err := os.RemoveAll(dir); err != nil {
+					log.G(ctx).WithError(err).WithField("path", dir).Warn("failed to remove directory")
+				}
+			}
+		}
+	}()
+	return s.ms.WithTransaction(ctx, true, func(ctx context.Context) error {
+		id, _, err = storage.Remove(ctx, key)
+		if err != nil {
+			return fmt.Errorf("failed to remove snapshot %s: %w", key, err)
+		}
+
+		removals, err = s.getCleanupDirectories(ctx)
+		if err != nil {
+			return fmt.Errorf("unable to get directories for removal: %w", err)
+		}
+		return nil
+	})
+}
+
+func (s *snapshotter) Stat(ctx context.Context, key string) (info snapshots.Info, err error) {
+	err = s.ms.WithTransaction(ctx, false, func(ctx context.Context) error {
+		_, info, _, err = storage.GetInfo(ctx, key)
+		return err
+	})
+	if err != nil {
+		return snapshots.Info{}, err
+	}
+
+	return info, nil
+}
+
+func (s *snapshotter) Update(ctx context.Context, info snapshots.Info, fieldpaths ...string) (_ snapshots.Info, err error) {
+	err = s.ms.WithTransaction(ctx, true, func(ctx context.Context) error {
+		info, err = storage.UpdateInfo(ctx, info, fieldpaths...)
+		return err
+	})
+	if err != nil {
+		return snapshots.Info{}, err
+	}
+
+	return info, nil
+}
+
+func (s *snapshotter) Walk(ctx context.Context, fn snapshots.WalkFunc, fs ...string) error {
+	return s.ms.WithTransaction(ctx, false, func(ctx context.Context) error {
+		return storage.WalkInfo(ctx, fn, fs...)
+	})
+}
+
+// Usage returns the resources taken by the snapshot identified by key.
+//
+// For active snapshots, this will scan the usage of the overlay "diff" (aka
+// "upper") directory and may take some time.
+//
+// For committed snapshots, the value is returned from the metadata database.
+func (s *snapshotter) Usage(ctx context.Context, key string) (_ snapshots.Usage, err error) {
+	var (
+		usage snapshots.Usage
+		info  snapshots.Info
+		id    string
+	)
+	if err := s.ms.WithTransaction(ctx, false, func(ctx context.Context) error {
+		id, info, usage, err = storage.GetInfo(ctx, key)
+		return err
+	}); err != nil {
+		return usage, err
+	}
+
+	if info.Kind == snapshots.KindActive {
+		upperPath := s.upperPath(id)
+		du, err := fs.DiskUsage(ctx, upperPath)
+		if err != nil {
+			// TODO(stevvooe): Consider not reporting an error in this case.
+			return snapshots.Usage{}, err
+		}
+		usage = snapshots.Usage(du)
+	}
+	return usage, nil
+}
diff --git a/plugins/snapshots/erofs/erofsutils/mount_linux.go b/plugins/snapshots/erofs/erofsutils/mount_linux.go
new file mode 100644
index 000000000..583c32a15
--- /dev/null
+++ b/plugins/snapshots/erofs/erofsutils/mount_linux.go
@@ -0,0 +1,88 @@
+/*
+   Copyright The containerd Authors.
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+*/
+
+package erofsutils
+
+import (
+	"context"
+	"fmt"
+	"io"
+	"os"
+	"os/exec"
+	"path/filepath"
+	"strings"
+
+	"github.com/containerd/containerd/v2/core/mount"
+	"github.com/containerd/errdefs"
+	"github.com/containerd/log"
+)
+
+func ConvertTarErofs(ctx context.Context, r io.Reader, layerPath string, mkfsExtraOpts []string) error {
+	args := append([]string{"--tar=f", "--aufs", "--quiet", "-Enoinline_data"}, mkfsExtraOpts...)
+	args = append(args, layerPath)
+	cmd := exec.CommandContext(ctx, "mkfs.erofs", args...)
+	cmd.Stdin = r
+	out, err := cmd.CombinedOutput()
+	if err != nil {
+		return fmt.Errorf("erofs apply failed: %s: %w", out, err)
+	}
+	log.G(ctx).Infof("running %s %s %v", cmd.Path, cmd.Args, string(out))
+	return nil
+}
+
+func ConvertErofs(ctx context.Context, layerPath string, srcDir string, mkfsExtraOpts []string) error {
+	args := append([]string{"--quiet", "-Enoinline_data"}, mkfsExtraOpts...)
+	args = append(args, layerPath, srcDir)
+	cmd := exec.CommandContext(ctx, "mkfs.erofs", args...)
+	out, err := cmd.CombinedOutput()
+	if err != nil {
+		return fmt.Errorf("erofs apply failed: %s: %w", out, err)
+	}
+	log.G(ctx).Infof("running %s %s %v", cmd.Path, cmd.Args, string(out))
+	return nil
+}
+
+// Get the snapshot layer directory in order to generate EROFS-formatted blobs;
+//
+// If mount[0].Type is `bind` or `erofs`, it just tries the source dir; Or if
+// mount[0].Type is `overlayfs`, it tries the parent of the upperdir;
+//
+// The candidate will be checked with ".erofslayer" to make sure this active
+// snapshot is really generated by the EROFS snapshotter instead of others.
+func MountsToLayer(mounts []mount.Mount) (string, error) {
+	var layer string
+	mnt := mounts[0]
+	if mnt.Type == "bind" || mnt.Type == "erofs" {
+		layer = filepath.Dir(mnt.Source)
+	} else if mnt.Type == "overlay" {
+		layer = ""
+		for _, o := range mnt.Options {
+			if strings.HasPrefix(o, "upperdir=") {
+				layer = filepath.Dir(strings.TrimPrefix(o, "upperdir="))
+			}
+		}
+		if layer == "" {
+			return "", fmt.Errorf("unsupported overlay layer for erofs differ: %w", errdefs.ErrNotImplemented)
+		}
+	} else {
+		return "", fmt.Errorf("invalid filesystem type for erofs differ: %w", errdefs.ErrNotImplemented)
+	}
+	// If the layer is not prepared by the EROFS snapshotter, fall back to the next differ
+	if _, err := os.Stat(filepath.Join(layer, ".erofslayer")); err != nil {
+		return "", fmt.Errorf("mount layer type must be erofs-layer: %w", errdefs.ErrNotImplemented)
+	}
+	return layer, nil
+}
diff --git a/plugins/snapshots/erofs/plugin/plugin_linux.go b/plugins/snapshots/erofs/plugin/plugin_linux.go
new file mode 100644
index 000000000..8263d5dc1
--- /dev/null
+++ b/plugins/snapshots/erofs/plugin/plugin_linux.go
@@ -0,0 +1,65 @@
+/*
+   Copyright The containerd Authors.
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+*/
+
+package plugin
+
+import (
+	"errors"
+
+	"github.com/containerd/containerd/v2/plugins"
+	"github.com/containerd/containerd/v2/plugins/snapshots/erofs"
+	"github.com/containerd/platforms"
+	"github.com/containerd/plugin"
+	"github.com/containerd/plugin/registry"
+)
+
+// Config represents configuration for the native plugin.
+type Config struct {
+	// Root directory for the plugin
+	RootPath string `toml:"root_path"`
+
+	// MountOptions are options used for the EROFS overlayfs mount
+	OvlOptions []string `toml:"ovl_mount_options"`
+}
+
+func init() {
+	registry.Register(&plugin.Registration{
+		Type:   plugins.SnapshotPlugin,
+		ID:     "erofs",
+		Config: &Config{},
+		InitFn: func(ic *plugin.InitContext) (interface{}, error) {
+			ic.Meta.Platforms = append(ic.Meta.Platforms, platforms.DefaultSpec())
+
+			config, ok := ic.Config.(*Config)
+			if !ok {
+				return nil, errors.New("invalid erofs configuration")
+			}
+
+			var opts []erofs.Opt
+			root := ic.Properties[plugins.PropertyRootDir]
+			if len(config.RootPath) != 0 {
+				root = config.RootPath
+			}
+
+			if len(config.OvlOptions) > 0 {
+				opts = append(opts, erofs.WithOvlOptions(config.OvlOptions))
+			}
+
+			ic.Meta.Exports[plugins.SnapshotterRootDir] = root
+			return erofs.NewSnapshotter(root, opts...)
+		},
+	})
+}
-- 
2.45.3


From 499b1f289284d645854599462494a4b3b6319689 Mon Sep 17 00:00:00 2001
From: Gao Xiang <hsiangkao@linux.alibaba.com>
Date: Tue, 17 Dec 2024 16:54:51 +0800
Subject: [PATCH 03/16] Add tests for EROFS snapshotter

Some basic tests for now.

Signed-off-by: Gao Xiang <hsiangkao@linux.alibaba.com>
---
 plugins/snapshots/erofs/erofs_linux_test.go | 53 +++++++++++++++++++++
 1 file changed, 53 insertions(+)
 create mode 100644 plugins/snapshots/erofs/erofs_linux_test.go

diff --git a/plugins/snapshots/erofs/erofs_linux_test.go b/plugins/snapshots/erofs/erofs_linux_test.go
new file mode 100644
index 000000000..5e66274b4
--- /dev/null
+++ b/plugins/snapshots/erofs/erofs_linux_test.go
@@ -0,0 +1,53 @@
+/*
+   Copyright The containerd Authors.
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+*/
+
+package erofs
+
+import (
+	"context"
+	"os/exec"
+	"testing"
+
+	"github.com/containerd/containerd/v2/core/snapshots"
+	"github.com/containerd/containerd/v2/core/snapshots/testsuite"
+	"github.com/containerd/containerd/v2/pkg/testutil"
+)
+
+func newSnapshotter(t *testing.T) func(ctx context.Context, root string) (snapshots.Snapshotter, func() error, error) {
+	_, err := exec.LookPath("mkfs.erofs")
+	if err != nil {
+		t.Skipf("could not find mkfs.erofs: %v", err)
+	}
+
+	if !findErofs() {
+		t.Skip("check for erofs kernel support failed, skipping test")
+	}
+	return func(ctx context.Context, root string) (snapshots.Snapshotter, func() error, error) {
+		var opts []Opt
+
+		snapshotter, err := NewSnapshotter(root, opts...)
+		if err != nil {
+			return nil, nil, err
+		}
+
+		return snapshotter, func() error { return snapshotter.Close() }, nil
+	}
+}
+
+func TestErofs(t *testing.T) {
+	testutil.RequiresRoot(t)
+	testsuite.SnapshotterSuite(t, "erofs", newSnapshotter(t))
+}
-- 
2.45.3


From ea325dbfd1349e4ba06de95512cb69f85d43a98a Mon Sep 17 00:00:00 2001
From: Gao Xiang <hsiangkao@linux.alibaba.com>
Date: Thu, 19 Sep 2024 10:55:10 +0800
Subject: [PATCH 04/16] Add EROFS snapshotter documentation

Signed-off-by: Gao Xiang <hsiangkao@linux.alibaba.com>
---
 docs/snapshotters/README.md |   1 +
 docs/snapshotters/erofs.md  | 143 ++++++++++++++++++++++++++++++++++++
 2 files changed, 144 insertions(+)
 create mode 100644 docs/snapshotters/erofs.md

diff --git a/docs/snapshotters/README.md b/docs/snapshotters/README.md
index 96d143970..05bf326df 100644
--- a/docs/snapshotters/README.md
+++ b/docs/snapshotters/README.md
@@ -17,6 +17,7 @@ Block-based:
 Filesystem-specific:
 - `btrfs`: btrfs. Needs the plugin root (`/var/lib/containerd/io.containerd.snapshotter.v1.btrfs`) to be mounted as btrfs.
 - `zfs`: ZFS. Needs the plugin root (`/var/lib/containerd/io.containerd.snapshotter.v1.zfs`) to be mounted as ZFS. See also https://github.com/containerd/zfs .
+- `erofs`: EROFS. `OverlayFS` kernel module needs to be enabled for active snapshots. See also [`erofs.md`](./erofs.md).
 
 [Deprecated](https://github.com/containerd/containerd/blob/main/RELEASES.md#deprecated-features):
 - `aufs`: AUFS. Deprecated since containerd 1.5. Removed in containerd 2.0. See also https://github.com/containerd/aufs .
diff --git a/docs/snapshotters/erofs.md b/docs/snapshotters/erofs.md
new file mode 100644
index 000000000..d6871bc13
--- /dev/null
+++ b/docs/snapshotters/erofs.md
@@ -0,0 +1,143 @@
+# EROFS Snapshotter
+
+The [EROFS](https://erofs.docs.kernel.org) snapshotter is an experimental
+feature, which is able to leverage EROFS-formatted blobs for each committed
+snapshot and prepares an EROFS + OverlayFS mount for each active snapshot.
+
+In order to leverage EROFS-formatted blobs, the EROFS differ is needed to be
+used together to apply image layers.  Otherwise, the EROFS snapshotter will
+just behave as the existing OverlayFS snapshotter: the default applier will
+unpack the image layer into the active EROFS snapshot, and commit it.
+
+Although it sounds somewhat similar to an enhanced OverlayFS snapshotter but
+I believe there are clear differences if looking into `s.mount()` and it highly
+tightens to the EROFS internals.  Currently, it's not quite clear to form an
+enhanced OverlayFS snapshotter directly, and (I think) it's not urgent since
+in the very beginning, it'd be better to be left as an independent snapshotter
+so that existing overlayfs users won't be impacted by the new behaviors and
+users could have a chance to try and develop the related ecosystems (such as
+ComposeFS, confidential containers, gVisor, Kata, gVisor, and more) together.
+
+## Use Cases
+
+The EROFS snapshotter can benefit to several use cases:
+
+For runC containers, instead of unpacking individual files into a directory
+on the backing filesystem, it applies OCI layers into EROFS blobs, therefore:
+
+ - Improved image unpacking performance (~14% for WordPress image with the
+   latest erofs-utils 1.8.2) due to reduced metadata overhead;
+
+ - Full data protection for each snapshot using the S_IMMUTABLE file attribute
+   or fsverity. Currently, fsverity can only protect blob data in the content
+   store;
+
+ - Parallel unpacking can be supported in a more reliable way (fsync) compared
+   to the overlayfs snapshotter (syncfs);
+
+ - Native EROFS layers can be pulled from registries without conversion.
+
+For VM containers, the EROFS snapshotter can efficiently pass through and share
+image layers, offering several advantages (e.g. better performance and smaller
+memory footprints) over [virtiofs](https://virtio-fs.gitlab.io) or
+[9p](https://www.kernel.org/doc/Documentation/filesystems/9p.txt).  Besides,
+the popular application kernel [gVisor](https://gvisor.dev/) also supports
+[EROFS](https://github.com/google/gvisor/pull/9486) for efficient image
+pass-through.
+
+## Usage
+
+### Checking if the EROFS snapshotter and differ are available
+
+To check if the EROFS snapshotter is available, run the following command:
+
+```bash
+$ ctr plugins ls | grep erofs
+```
+
+The following message will be shown like below:
+```
+io.containerd.snapshotter.v1           erofs                    linux/amd64    ok
+io.containerd.differ.v1                erofs                    linux/amd64    ok
+```
+
+### Ensure that EROFS is available
+
+On newer Ubuntu/Debian systems, it can be installed directly using the apt
+command, and on Fedora it can be installed directly using the dnf command.
+
+# Debian/Ubuntu
+$ apt install erofs-utils
+# Fedora
+$ dnf install erofs-utils
+
+Make sure that erofs-utils version is 1.7 or higher.
+
+Before using EROFS snapshotter, also make sure the _EROFS kernel module_ is
+loaded: it can be loaded with `modprobe erofs`.
+
+### Configuration
+
+The following configuration can be used in your containerd `config.toml`. Don't
+forget to restart containerd after changing the configuration.
+
+```
+  [plugins."io.containerd.service.v1.diff-service"]
+    default = ["erofs","walking"]
+```
+
+### Running a container
+
+To run a container using the EROFS snapshotter, it needs to be explicitly
+specified:
+
+```bash
+$ # ensure that the image we are using exists; it is a regular OCI image
+$ ctr image pull docker.io/library/busybox:latest
+$ # run the container with the provides snapshotter
+$ ctr run -rm -t --snapshotter erofs docker.io/library/busybox:latest hello sh
+```
+
+## How It Works
+
+For each layer, the EROFS snapshotter prepares a directory containing the
+following items:
+
+```
+  .erofslayer
+  fs
+  work
+```
+
+`.erofslayer` file is used to indicate that the layer is prepared by the EROFS
+snapshotter.
+
+If the EROFS differ is also enabled, the differ will check for the existence
+of `.erofslayer` and convert the image content blob (e.g., an OCI layer) into
+an EROFS layer blob.
+
+In this case, the snapshot layer directory will look like this:
+```
+  .erofslayer
+  fs
+  layer.erofs
+  work
+```
+
+Then the EROFS snapshotter will check for the existence of `layer.erofs`: it
+will mount the EROFS layer blob to `fs/` and return a valid overlayfs mount
+with all parent layers.
+
+If other differs (not the EROFS differ) are used, the EROFS snapshotter will
+convert the flat directory into an EROFS layer blob on Commit instead.
+
+In other words, the EROFS differ can only be used with the EROFS snapshotter;
+otherwise, it will skip to the next differ.  The EROFS snapshotter can work
+with or without the EROFS differ.
+
+
+## TODO
+
+The EROFS Fsmerge feature is NOT supported in the current implementation
+because it was somewhat unclean (relying on `containerd.io/snapshot.ref`).
+It needs to be reconsidered later.
-- 
2.45.3


From 50de8c0c4af7f7b690f635121530f30fd54a9aba Mon Sep 17 00:00:00 2001
From: ChengyuZhu6 <hudson@cyzhu.com>
Date: Fri, 7 Feb 2025 15:41:03 +0800
Subject: [PATCH 05/16] erofs-snapshotter: add fsverity support

Add fsverity support to erofs snapshotter to enable data integrity
verification for erofs layers:

- Add an config option `EnableFsverity` for erofs snapshotter
- Add fsverity verification during mount operations
- Enable fsverity on erofs layers during commit
- Add documentation for fsverity support in erofs snapshotter.
- Add TestErofsFsverity to verify fsverity enablement and data protection

The feature can be enabled via config.toml, such as:
```toml
[plugins.'io.containerd.snapshotter.v1.erofs']
    root_path = ''
    ovl_mount_options = []
    enable_fsverity = true
```

Signed-off-by: ChengyuZhu6 <hudson@cyzhu.com>
---
 docs/snapshotters/erofs.md                    | 14 ++++
 plugins/snapshots/erofs/erofs_linux.go        | 64 +++++++++++++--
 plugins/snapshots/erofs/erofs_linux_test.go   | 80 +++++++++++++++++++
 .../snapshots/erofs/plugin/plugin_linux.go    |  7 ++
 4 files changed, 158 insertions(+), 7 deletions(-)

diff --git a/docs/snapshotters/erofs.md b/docs/snapshotters/erofs.md
index d6871bc13..427c3501b 100644
--- a/docs/snapshotters/erofs.md
+++ b/docs/snapshotters/erofs.md
@@ -82,6 +82,13 @@ The following configuration can be used in your containerd `config.toml`. Don't
 forget to restart containerd after changing the configuration.
 
 ```
+  [plugins."io.containerd.snapshotter.v1.erofs"]
+      # Enable fsverity support for EROFS layers, default is false
+      enable_fsverity = true
+
+      # Optional: Additional mount options for overlayfs
+      ovl_mount_options = []
+
   [plugins."io.containerd.service.v1.diff-service"]
     default = ["erofs","walking"]
 ```
@@ -135,6 +142,13 @@ In other words, the EROFS differ can only be used with the EROFS snapshotter;
 otherwise, it will skip to the next differ.  The EROFS snapshotter can work
 with or without the EROFS differ.
 
+## Data Integrity with fsverity
+
+The EROFS snapshotter supports fsverity for data integrity verification of EROFS layers.
+When enabled via `enable_fsverity = true`, the snapshotter will:
+- Enable fsverity on EROFS layers during commit
+- Verify fsverity status before mounting layers
+- Skip fsverity if the filesystem or kernel does not support it
 
 ## TODO
 
diff --git a/plugins/snapshots/erofs/erofs_linux.go b/plugins/snapshots/erofs/erofs_linux.go
index 224418e59..67645f69c 100644
--- a/plugins/snapshots/erofs/erofs_linux.go
+++ b/plugins/snapshots/erofs/erofs_linux.go
@@ -28,6 +28,7 @@ import (
 	"github.com/containerd/containerd/v2/core/mount"
 	"github.com/containerd/containerd/v2/core/snapshots"
 	"github.com/containerd/containerd/v2/core/snapshots/storage"
+	"github.com/containerd/containerd/v2/internal/fsverity"
 	"github.com/containerd/containerd/v2/plugins/snapshots/erofs/erofsutils"
 	"github.com/containerd/continuity/fs"
 	"github.com/containerd/log"
@@ -39,6 +40,8 @@ import (
 type SnapshotterConfig struct {
 	// ovlOptions are the base options added to the overlayfs mount (defaults to [""])
 	ovlOptions []string
+	// enableFsverity enables fsverity for EROFS layers
+	enableFsverity bool
 }
 
 // Opt is an option to configure the erofs snapshotter
@@ -51,6 +54,13 @@ func WithOvlOptions(options []string) Opt {
 	}
 }
 
+// WithFsverity enables fsverity for EROFS layers
+func WithFsverity() Opt {
+	return func(config *SnapshotterConfig) {
+		config.enableFsverity = true
+	}
+}
+
 type MetaStore interface {
 	TransactionContext(ctx context.Context, writable bool) (context.Context, storage.Transactor, error)
 	WithTransaction(ctx context.Context, writable bool, fn storage.TransactionCallback) error
@@ -58,9 +68,10 @@ type MetaStore interface {
 }
 
 type snapshotter struct {
-	root       string
-	ms         *storage.MetaStore
-	ovlOptions []string
+	root           string
+	ms             *storage.MetaStore
+	ovlOptions     []string
+	enableFsverity bool
 }
 
 // check if EROFS kernel filesystem is registered or not
@@ -108,6 +119,17 @@ func NewSnapshotter(root string, opts ...Opt) (snapshots.Snapshotter, error) {
 		return nil, fmt.Errorf("EROFS unsupported, please `modprobe erofs`: %w", plugin.ErrSkipPlugin)
 	}
 
+	// Check fsverity support if enabled
+	if config.enableFsverity {
+		supported, err := fsverity.IsSupported(root)
+		if err != nil {
+			return nil, fmt.Errorf("failed to check fsverity support on %q: %w", root, err)
+		}
+		if !supported {
+			return nil, fmt.Errorf("fsverity is not supported on the filesystem of %q", root)
+		}
+	}
+
 	ms, err := storage.NewMetaStore(filepath.Join(root, "metadata.db"))
 	if err != nil {
 		return nil, err
@@ -118,9 +140,10 @@ func NewSnapshotter(root string, opts ...Opt) (snapshots.Snapshotter, error) {
 	}
 
 	return &snapshotter{
-		root:       root,
-		ms:         ms,
-		ovlOptions: config.ovlOptions,
+		root:           root,
+		ms:             ms,
+		ovlOptions:     config.ovlOptions,
+		enableFsverity: config.enableFsverity,
 	}, nil
 }
 
@@ -182,12 +205,16 @@ func (s *snapshotter) mounts(snap storage.Snapshot, info snapshots.Info) ([]moun
 	var options []string
 
 	if len(snap.ParentIDs) == 0 {
-		// If the EROFS layer blob is valid, only snapshots.KindView is allowed.
 		m, _, err := s.lowerPath(snap.ID)
 		if err == nil {
 			if snap.Kind != snapshots.KindView {
 				return nil, fmt.Errorf("only works for snapshots.KindView on a committed snapshot: %w", err)
 			}
+			if s.enableFsverity {
+				if err := s.verifyFsverity(m.Source); err != nil {
+					return nil, err
+				}
+			}
 			// We have to force a loop device here since mount[] is static.
 			m.Options = append(m.Options, "loop")
 			return []mount.Mount{m}, nil
@@ -369,6 +396,14 @@ func (s *snapshotter) Commit(ctx context.Context, name, key string, opts ...snap
 				}
 			}
 		}
+
+		// Enable fsverity on the EROFS layer if configured
+		if s.enableFsverity {
+			if err := fsverity.Enable(layerBlob); err != nil {
+				return fmt.Errorf("failed to enable fsverity: %w", err)
+			}
+		}
+
 		return nil
 	})
 
@@ -536,3 +571,18 @@ func (s *snapshotter) Usage(ctx context.Context, key string) (_ snapshots.Usage,
 	}
 	return usage, nil
 }
+
+// Add a method to verify fsverity
+func (s *snapshotter) verifyFsverity(path string) error {
+	if !s.enableFsverity {
+		return nil
+	}
+	enabled, err := fsverity.IsEnabled(path)
+	if err != nil {
+		return fmt.Errorf("failed to check fsverity status: %w", err)
+	}
+	if !enabled {
+		return fmt.Errorf("fsverity is not enabled on %s", path)
+	}
+	return nil
+}
diff --git a/plugins/snapshots/erofs/erofs_linux_test.go b/plugins/snapshots/erofs/erofs_linux_test.go
index 5e66274b4..195cc41c9 100644
--- a/plugins/snapshots/erofs/erofs_linux_test.go
+++ b/plugins/snapshots/erofs/erofs_linux_test.go
@@ -18,11 +18,16 @@ package erofs
 
 import (
 	"context"
+	"os"
 	"os/exec"
+	"path/filepath"
 	"testing"
 
+	"github.com/containerd/containerd/v2/core/mount"
 	"github.com/containerd/containerd/v2/core/snapshots"
+	"github.com/containerd/containerd/v2/core/snapshots/storage"
 	"github.com/containerd/containerd/v2/core/snapshots/testsuite"
+	"github.com/containerd/containerd/v2/internal/fsverity"
 	"github.com/containerd/containerd/v2/pkg/testutil"
 )
 
@@ -51,3 +56,78 @@ func TestErofs(t *testing.T) {
 	testutil.RequiresRoot(t)
 	testsuite.SnapshotterSuite(t, "erofs", newSnapshotter(t))
 }
+
+func TestErofsFsverity(t *testing.T) {
+	testutil.RequiresRoot(t)
+	ctx := context.Background()
+
+	root := t.TempDir()
+
+	// Skip if fsverity is not supported
+	supported, err := fsverity.IsSupported(root)
+	if !supported || err != nil {
+		t.Skip("fsverity not supported, skipping test")
+	}
+
+	// Create snapshotter with fsverity enabled
+	s, err := NewSnapshotter(root, WithFsverity())
+	if err != nil {
+		t.Fatal(err)
+	}
+	defer s.Close()
+
+	// Create a test snapshot
+	key := "test-snapshot"
+	mounts, err := s.Prepare(ctx, key, "")
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	target := filepath.Join(root, key)
+	if err := os.MkdirAll(target, 0755); err != nil {
+		t.Fatal(err)
+	}
+	if err := mount.All(mounts, target); err != nil {
+		t.Fatal(err)
+	}
+	defer testutil.Unmount(t, target)
+
+	// Write test data
+	if err := os.WriteFile(filepath.Join(target, "foo"), []byte("test data"), 0777); err != nil {
+		t.Fatal(err)
+	}
+
+	// Commit the snapshot
+	commitKey := "test-commit"
+	if err := s.Commit(ctx, commitKey, key); err != nil {
+		t.Fatal(err)
+	}
+
+	snap := s.(*snapshotter)
+
+	// Get the internal ID from the snapshotter
+	var id string
+	if err := snap.ms.WithTransaction(ctx, false, func(ctx context.Context) error {
+		id, _, _, err = storage.GetInfo(ctx, commitKey)
+		return err
+	}); err != nil {
+		t.Fatal(err)
+	}
+
+	// Verify fsverity is enabled on the EROFS layer
+
+	layerPath := snap.layerBlobPath(id)
+
+	enabled, err := fsverity.IsEnabled(layerPath)
+	if err != nil {
+		t.Fatalf("Failed to check fsverity status: %v", err)
+	}
+	if !enabled {
+		t.Fatal("Expected fsverity to be enabled on committed layer")
+	}
+
+	// Try to modify the layer file directly (should fail)
+	if err := os.WriteFile(layerPath, []byte("tampered data"), 0666); err == nil {
+		t.Fatal("Expected direct write to fsverity-enabled layer to fail")
+	}
+}
diff --git a/plugins/snapshots/erofs/plugin/plugin_linux.go b/plugins/snapshots/erofs/plugin/plugin_linux.go
index 8263d5dc1..5fb524138 100644
--- a/plugins/snapshots/erofs/plugin/plugin_linux.go
+++ b/plugins/snapshots/erofs/plugin/plugin_linux.go
@@ -33,6 +33,9 @@ type Config struct {
 
 	// MountOptions are options used for the EROFS overlayfs mount
 	OvlOptions []string `toml:"ovl_mount_options"`
+
+	// EnableFsverity enables fsverity for EROFS layers
+	EnableFsverity bool `toml:"enable_fsverity"`
 }
 
 func init() {
@@ -58,6 +61,10 @@ func init() {
 				opts = append(opts, erofs.WithOvlOptions(config.OvlOptions))
 			}
 
+			if config.EnableFsverity {
+				opts = append(opts, erofs.WithFsverity())
+			}
+
 			ic.Meta.Exports[plugins.SnapshotterRootDir] = root
 			return erofs.NewSnapshotter(root, opts...)
 		},
-- 
2.45.3


From 50d1d8fb847173c1e34968f33d7228fd6a90b90b Mon Sep 17 00:00:00 2001
From: Gao Xiang <hsiangkao@linux.alibaba.com>
Date: Mon, 3 Mar 2025 20:11:48 +0800
Subject: [PATCH 06/16] erofs-snapshotter: protect layer blobs with
 FS_IMMUTABLE_FL

As documented in ioctl_iflags(2):
```
 FS_IMMUTABLE_FL
  The file is immutable: no changes are permitted to the file contents
  or metadata (permissions, timestamps, ownership, link count, and so
  on).  (This restriction applies even to the superuser.)
```

For example, any user cannot delete/move layer blobs when
FS_IMMUTABLE_FL is set:
``` sh
 # cd /var/lib/containerd/io.containerd.snapshotter.v1.erofs/snapshots/4
 # mv layer{,1}.erofs
 mv: cannot move 'layer.erofs' to 'layer1.erofs': Operation not permitted
 # rm layer.erofs
 rm: cannot remove 'layer.erofs': Operation not permitted
```

Note that it's a best-effort approach for data loss prevention.  IOWs,
just warn out if FS_IMMUTABLE_FL cannot be set anyway (e.g., due to lack
of support in the underlying filesystem.)

Signed-off-by: Gao Xiang <hsiangkao@linux.alibaba.com>
---
 docs/snapshotters/erofs.md             |  9 ++++---
 plugins/snapshots/erofs/erofs_linux.go | 35 +++++++++++++++++++++++++-
 2 files changed, 40 insertions(+), 4 deletions(-)

diff --git a/docs/snapshotters/erofs.md b/docs/snapshotters/erofs.md
index 427c3501b..4e026e35f 100644
--- a/docs/snapshotters/erofs.md
+++ b/docs/snapshotters/erofs.md
@@ -28,9 +28,12 @@ on the backing filesystem, it applies OCI layers into EROFS blobs, therefore:
  - Improved image unpacking performance (~14% for WordPress image with the
    latest erofs-utils 1.8.2) due to reduced metadata overhead;
 
- - Full data protection for each snapshot using the S_IMMUTABLE file attribute
-   or fsverity. Currently, fsverity can only protect blob data in the content
-   store;
+ - Full data protection for each snapshot using the FS_IMMUTABLE_FL file
+   attribute and fsverity.  EROFS uses FS_IMMUTABLE_FL and fsverity to protect
+   each EROFS layer blob, ensuring the mounted tree remains immutable.  However,
+   since FS_IMMUTABLE_FL and fsverity protect individual files rather than a
+   sub-filesystem tree, other snapshotter implementations like the overlayfs
+   snapshotter are not quite applicable due to less efficiency at least;
 
  - Parallel unpacking can be supported in a more reliable way (fsync) compared
    to the overlayfs snapshotter (syncfs);
diff --git a/plugins/snapshots/erofs/erofs_linux.go b/plugins/snapshots/erofs/erofs_linux.go
index 67645f69c..96fe533c8 100644
--- a/plugins/snapshots/erofs/erofs_linux.go
+++ b/plugins/snapshots/erofs/erofs_linux.go
@@ -355,6 +355,31 @@ func (s *snapshotter) View(ctx context.Context, key, parent string, opts ...snap
 	return s.createSnapshot(ctx, snapshots.KindView, key, parent, opts)
 }
 
+func setImmutable(path string, enable bool) error {
+	//nolint:revive	// silence "don't use ALL_CAPS in Go names; use CamelCase"
+	const (
+		FS_IMMUTABLE_FL = 0x10
+	)
+	f, err := os.Open(path)
+	if err != nil {
+		return fmt.Errorf("failed to open: %w", err)
+	}
+	defer f.Close()
+
+	oldattr, err := unix.IoctlGetInt(int(f.Fd()), unix.FS_IOC_GETFLAGS)
+	if err != nil {
+		return fmt.Errorf("error getting inode flags: %w", err)
+	}
+	newattr := oldattr | FS_IMMUTABLE_FL
+	if !enable {
+		newattr ^= FS_IMMUTABLE_FL
+	}
+	if newattr == oldattr {
+		return nil
+	}
+	return unix.IoctlSetPointerInt(int(f.Fd()), unix.FS_IOC_SETFLAGS, newattr)
+}
+
 func (s *snapshotter) Commit(ctx context.Context, name, key string, opts ...snapshots.Opt) error {
 	var layerBlob, upperDir string
 
@@ -403,7 +428,10 @@ func (s *snapshotter) Commit(ctx context.Context, name, key string, opts ...snap
 				return fmt.Errorf("failed to enable fsverity: %w", err)
 			}
 		}
-
+		// Set IMMUTABLE_FL on the EROFS layer to avoid artificial data loss
+		if err := setImmutable(layerBlob, true); err != nil {
+			log.G(ctx).WithError(err).Warnf("failed to set IMMUTABLE_FL for %s", layerBlob)
+		}
 		return nil
 	})
 
@@ -507,6 +535,11 @@ func (s *snapshotter) Remove(ctx context.Context, key string) (err error) {
 		if err != nil {
 			return fmt.Errorf("unable to get directories for removal: %w", err)
 		}
+		// Clear IMMUTABLE_FL before removal, since this flag avoids it.
+		err = setImmutable(s.layerBlobPath(id), false)
+		if err != nil {
+			return fmt.Errorf("failed to clear IMMUTABLE_FL: %w", err)
+		}
 		return nil
 	})
 }
-- 
2.45.3


From 8570dfd133b0f410f3bf8c8b071f997181a18937 Mon Sep 17 00:00:00 2001
From: Gao Xiang <hsiangkao@linux.alibaba.com>
Date: Wed, 26 Feb 2025 11:10:39 +0800
Subject: [PATCH 07/16] erofs-snapshotter: force the use of loop devices for
 single-layer images

Currently, containerd cannot dynamically select between EROFS block
or file-based mounting approaches based on the specific runtime (or
the Linux kernel version of the runtime) due to its static mount
structure.

For example, the EROFS snapshotter fails on Linux 5.4 (Ubuntu 20.04)
with `bin/nerdctl run --net=host --snapshotter=erofs busybox:latest`:

FATA[0005] failed to mount {Type:erofs Source:/var/lib/containerd/
io.containerd.snapshotter.v1.erofs/snapshots/1/layer.erofs Target:
Options:[ro]} on "/tmp/initialC1374142795": block device required

Temporarily fix this by appending `-oloop` for single-layer images.
The upcoming mount manager will make it better [1].

[1] https://github.com/containerd/containerd/issues/11303
Signed-off-by: Gao Xiang <hsiangkao@linux.alibaba.com>
---
 docs/snapshotters/erofs.md             | 10 ++++++----
 plugins/snapshots/erofs/erofs_linux.go |  2 ++
 2 files changed, 8 insertions(+), 4 deletions(-)

diff --git a/docs/snapshotters/erofs.md b/docs/snapshotters/erofs.md
index 4e026e35f..a1097f9f1 100644
--- a/docs/snapshotters/erofs.md
+++ b/docs/snapshotters/erofs.md
@@ -64,20 +64,22 @@ io.containerd.snapshotter.v1           erofs                    linux/amd64    o
 io.containerd.differ.v1                erofs                    linux/amd64    ok
 ```
 
-### Ensure that EROFS is available
+### Ensure that EROFS filesystem is available
 
-On newer Ubuntu/Debian systems, it can be installed directly using the apt
-command, and on Fedora it can be installed directly using the dnf command.
+On newer Ubuntu/Debian systems, erofs-utils can be installed directly using the
+apt command, and on Fedora it can be installed directly using the dnf command.
 
+```bash
 # Debian/Ubuntu
 $ apt install erofs-utils
 # Fedora
 $ dnf install erofs-utils
+```
 
 Make sure that erofs-utils version is 1.7 or higher.
 
 Before using EROFS snapshotter, also make sure the _EROFS kernel module_ is
-loaded: it can be loaded with `modprobe erofs`.
+loaded (Linux 5.4 or later is required): it can be loaded with `modprobe erofs`.
 
 ### Configuration
 
diff --git a/plugins/snapshots/erofs/erofs_linux.go b/plugins/snapshots/erofs/erofs_linux.go
index 96fe533c8..0fcab9d5d 100644
--- a/plugins/snapshots/erofs/erofs_linux.go
+++ b/plugins/snapshots/erofs/erofs_linux.go
@@ -247,6 +247,8 @@ func (s *snapshotter) mounts(snap storage.Snapshot, info snapshots.Info) ([]moun
 		if err != nil {
 			return nil, err
 		}
+		// We have to force a loop device here too since mount[] is static.
+		m.Options = append(m.Options, "loop")
 		return []mount.Mount{m}, nil
 	}
 
-- 
2.45.3


From 3460695631ab75cae3028cc49fbdb8ed2ee6011c Mon Sep 17 00:00:00 2001
From: Gao Xiang <hsiangkao@linux.alibaba.com>
Date: Tue, 4 Mar 2025 23:17:32 +0800
Subject: [PATCH 08/16] erofs-snapshotter: clear IMMUTABLE_FL only for
 committed snapshots

Otherwise, the following error avoids snapshot GC:
level=warning msg="snapshot garbage collection failed" error="failed
to clear IMMUTABLE_FL: failed to open: open /var/lib/containerd/io.
containerd.snapshotter.v1.erofs/snapshots/2/layer.erofs: no such file
or directory

Fixes: b477cf8e97b6 ("erofs-snapshotter: protect layer blobs with FS_IMMUTABLE_FL")
Signed-off-by: Gao Xiang <hsiangkao@linux.alibaba.com>
---
 plugins/snapshots/erofs/erofs_linux.go | 15 ++++++++++-----
 1 file changed, 10 insertions(+), 5 deletions(-)

diff --git a/plugins/snapshots/erofs/erofs_linux.go b/plugins/snapshots/erofs/erofs_linux.go
index 0fcab9d5d..8e76d94ab 100644
--- a/plugins/snapshots/erofs/erofs_linux.go
+++ b/plugins/snapshots/erofs/erofs_linux.go
@@ -528,7 +528,9 @@ func (s *snapshotter) Remove(ctx context.Context, key string) (err error) {
 		}
 	}()
 	return s.ms.WithTransaction(ctx, true, func(ctx context.Context) error {
-		id, _, err = storage.Remove(ctx, key)
+		var k snapshots.Kind
+
+		id, k, err = storage.Remove(ctx, key)
 		if err != nil {
 			return fmt.Errorf("failed to remove snapshot %s: %w", key, err)
 		}
@@ -537,10 +539,13 @@ func (s *snapshotter) Remove(ctx context.Context, key string) (err error) {
 		if err != nil {
 			return fmt.Errorf("unable to get directories for removal: %w", err)
 		}
-		// Clear IMMUTABLE_FL before removal, since this flag avoids it.
-		err = setImmutable(s.layerBlobPath(id), false)
-		if err != nil {
-			return fmt.Errorf("failed to clear IMMUTABLE_FL: %w", err)
+		// The layer blob is only persisted for committed snapshots.
+		if k == snapshots.KindCommitted {
+			// Clear IMMUTABLE_FL before removal, since this flag avoids it.
+			err = setImmutable(s.layerBlobPath(id), false)
+			if err != nil {
+				return fmt.Errorf("failed to clear IMMUTABLE_FL: %w", err)
+			}
 		}
 		return nil
 	})
-- 
2.45.3


From ebe02451ac843dea1516fa83c47ff4911d6395af Mon Sep 17 00:00:00 2001
From: Gao Xiang <xiang@kernel.org>
Date: Tue, 25 Mar 2025 21:27:54 +0800
Subject: [PATCH 09/16] erofs-differ: implement fast differ with
 DiffDirChanges()

Unlike the walking differ, which implements a generic method to
accommodate all kinds of snapshotters, the EROFS differ is just
implemented for EROFS and EROFS snapshotter so it can utilize the
recent DiffDirChanges() [1] to avoid traversing the entire rootfs
directory in order to improve `nerdctl commit` performance.

Additionally, I think `baseDir` is unnecessary too (in principle,
only `upperdir` is useful for OCI format convention).  However,
addressing this requires more work, so left as is for now.

It's also useful to implement a customized Compare() method for
EROFS differ so that we can dump the native EROFS-formatted blob
to the content store later.

[1] https://github.com/containerd/continuity/pull/145
Signed-off-by: Gao Xiang <xiang@kernel.org>
---
 plugins/diff/erofs/differ_linux.go            | 160 +++++++++++++++++-
 .../snapshots/erofs/erofsutils/mount_linux.go |   9 +-
 2 files changed, 166 insertions(+), 3 deletions(-)

diff --git a/plugins/diff/erofs/differ_linux.go b/plugins/diff/erofs/differ_linux.go
index 52f9fa0bf..b173bb9b3 100644
--- a/plugins/diff/erofs/differ_linux.go
+++ b/plugins/diff/erofs/differ_linux.go
@@ -18,16 +18,24 @@ package erofs
 
 import (
 	"context"
+	"crypto/rand"
+	"encoding/base64"
 	"fmt"
 	"io"
 	"path"
+	"path/filepath"
 	"time"
 
 	"github.com/containerd/containerd/v2/core/content"
 	"github.com/containerd/containerd/v2/core/diff"
 	"github.com/containerd/containerd/v2/core/images"
 	"github.com/containerd/containerd/v2/core/mount"
+	"github.com/containerd/containerd/v2/pkg/archive"
+	"github.com/containerd/containerd/v2/pkg/archive/compression"
+	"github.com/containerd/containerd/v2/pkg/epoch"
+	"github.com/containerd/containerd/v2/pkg/labels"
 	"github.com/containerd/containerd/v2/plugins/snapshots/erofs/erofsutils"
+	"github.com/containerd/continuity/fs"
 	"github.com/containerd/errdefs"
 	"github.com/containerd/log"
 	digest "github.com/opencontainers/go-digest"
@@ -54,10 +62,152 @@ func NewErofsDiffer(store content.Store, mkfsExtraOpts []string) differ {
 	}
 }
 
+func writeDiff(ctx context.Context, w io.Writer, lower []mount.Mount, upperRoot string) error {
+	var opts []archive.ChangeWriterOpt
+
+	return mount.WithTempMount(ctx, lower, func(lowerRoot string) error {
+		cw := archive.NewChangeWriter(w, upperRoot, opts...)
+		err := fs.DiffDirChanges(ctx, lowerRoot, upperRoot, fs.DiffSourceOverlayFS, cw.HandleChange)
+		if err != nil {
+			return fmt.Errorf("failed to create diff tar stream: %w", err)
+		}
+		return cw.Close()
+	})
+}
+
 // Compare creates a diff between the given mounts and uploads the result
 // to the content store.
 func (s erofsDiff) Compare(ctx context.Context, lower, upper []mount.Mount, opts ...diff.Opt) (d ocispec.Descriptor, err error) {
-	return emptyDesc, fmt.Errorf("erofsDiff does not implement Compare method: %w", errdefs.ErrNotImplemented)
+	layer, err := erofsutils.MountsToLayer(upper)
+	if err != nil {
+		return emptyDesc, fmt.Errorf("unsupported layer for erofsDiff Compare method: %w", err)
+	}
+
+	var config diff.Config
+	for _, opt := range opts {
+		if err := opt(&config); err != nil {
+			return emptyDesc, err
+		}
+	}
+	if tm := epoch.FromContext(ctx); tm != nil && config.SourceDateEpoch == nil {
+		config.SourceDateEpoch = tm
+	}
+
+	if config.MediaType == "" {
+		config.MediaType = ocispec.MediaTypeImageLayerGzip
+	}
+
+	var compressionType compression.Compression
+	switch config.MediaType {
+	case ocispec.MediaTypeImageLayer:
+		compressionType = compression.Uncompressed
+	case ocispec.MediaTypeImageLayerGzip:
+		compressionType = compression.Gzip
+	case ocispec.MediaTypeImageLayerZstd:
+		compressionType = compression.Zstd
+	default:
+		return emptyDesc, fmt.Errorf("unsupported diff media type: %v: %w", config.MediaType, errdefs.ErrNotImplemented)
+	}
+
+	var newReference bool
+	if config.Reference == "" {
+		newReference = true
+		config.Reference = uniqueRef()
+	}
+
+	cw, err := s.store.Writer(ctx,
+		content.WithRef(config.Reference),
+		content.WithDescriptor(ocispec.Descriptor{
+			MediaType: config.MediaType, // most contentstore implementations just ignore this
+		}))
+	if err != nil {
+		return emptyDesc, fmt.Errorf("failed to open writer: %w", err)
+	}
+
+	// errOpen is set when an error occurs while the content writer has not been
+	// committed or closed yet to force a cleanup
+	var errOpen error
+	defer func() {
+		if errOpen != nil {
+			cw.Close()
+			if newReference {
+				if abortErr := s.store.Abort(ctx, config.Reference); abortErr != nil {
+					log.G(ctx).WithError(abortErr).WithField("ref", config.Reference).Warnf("failed to delete diff upload")
+				}
+			}
+		}
+	}()
+	if !newReference {
+		if errOpen = cw.Truncate(0); errOpen != nil {
+			return emptyDesc, errOpen
+		}
+	}
+
+	upperRoot := filepath.Join(layer, "fs")
+	if compressionType != compression.Uncompressed {
+		dgstr := digest.SHA256.Digester()
+		var compressed io.WriteCloser
+		if config.Compressor != nil {
+			compressed, errOpen = config.Compressor(cw, config.MediaType)
+			if errOpen != nil {
+				return emptyDesc, fmt.Errorf("failed to get compressed stream: %w", errOpen)
+			}
+		} else {
+			compressed, errOpen = compression.CompressStream(cw, compressionType)
+			if errOpen != nil {
+				return emptyDesc, fmt.Errorf("failed to get compressed stream: %w", errOpen)
+			}
+		}
+		errOpen = writeDiff(ctx, io.MultiWriter(compressed, dgstr.Hash()), lower, upperRoot)
+		compressed.Close()
+		if errOpen != nil {
+			return emptyDesc, fmt.Errorf("failed to write compressed diff: %w", errOpen)
+		}
+
+		if config.Labels == nil {
+			config.Labels = map[string]string{}
+		}
+		config.Labels[labels.LabelUncompressed] = dgstr.Digest().String()
+	} else {
+		err := writeDiff(ctx, cw, lower, upperRoot)
+		if err != nil {
+			return emptyDesc, fmt.Errorf("failed to create diff tar stream: %w", err)
+		}
+	}
+
+	var commitopts []content.Opt
+	if config.Labels != nil {
+		commitopts = append(commitopts, content.WithLabels(config.Labels))
+	}
+
+	dgst := cw.Digest()
+	if errOpen = cw.Commit(ctx, 0, dgst, commitopts...); errOpen != nil {
+		if !errdefs.IsAlreadyExists(errOpen) {
+			return emptyDesc, fmt.Errorf("failed to commit: %w", errOpen)
+		}
+		errOpen = nil
+	}
+
+	info, err := s.store.Info(ctx, dgst)
+	if err != nil {
+		return emptyDesc, fmt.Errorf("failed to get info from content store: %w", err)
+	}
+	if info.Labels == nil {
+		info.Labels = make(map[string]string)
+	}
+	// Set "containerd.io/uncompressed" label if digest already existed without label
+	if _, ok := info.Labels[labels.LabelUncompressed]; !ok {
+		info.Labels[labels.LabelUncompressed] = config.Labels[labels.LabelUncompressed]
+		if _, err := s.store.Update(ctx, info, "labels."+labels.LabelUncompressed); err != nil {
+			return emptyDesc, fmt.Errorf("error setting uncompressed label: %w", err)
+		}
+	}
+
+	return ocispec.Descriptor{
+		MediaType: config.MediaType,
+		Size:      info.Size,
+		Digest:    info.Digest,
+	}, nil
 }
 
 func (s erofsDiff) Apply(ctx context.Context, desc ocispec.Descriptor, mounts []mount.Mount, opts ...diff.ApplyOpt) (d ocispec.Descriptor, err error) {
@@ -139,3 +289,11 @@ func (rc *readCounter) Read(p []byte) (n int, err error) {
 	rc.c += int64(n)
 	return
 }
+
+func uniqueRef() string {
+	t := time.Now()
+	var b [3]byte
+	// Ignore read failures, just decreases uniqueness
+	rand.Read(b[:])
+	return fmt.Sprintf("%d-%s", t.UnixNano(), base64.URLEncoding.EncodeToString(b[:]))
+}
diff --git a/plugins/snapshots/erofs/erofsutils/mount_linux.go b/plugins/snapshots/erofs/erofsutils/mount_linux.go
index 583c32a15..b1a0a1a9d 100644
--- a/plugins/snapshots/erofs/erofsutils/mount_linux.go
+++ b/plugins/snapshots/erofs/erofsutils/mount_linux.go
@@ -68,14 +68,19 @@ func MountsToLayer(mounts []mount.Mount) (string, error) {
 	if mnt.Type == "bind" || mnt.Type == "erofs" {
 		layer = filepath.Dir(mnt.Source)
 	} else if mnt.Type == "overlay" {
-		layer = ""
+		toplower := ""
 		for _, o := range mnt.Options {
 			if strings.HasPrefix(o, "upperdir=") {
 				layer = filepath.Dir(strings.TrimPrefix(o, "upperdir="))
+			} else if strings.HasPrefix(o, "lowerdir=") {
+				toplower = filepath.Dir(strings.Split(strings.TrimPrefix(o, "lowerdir="), ":")[0])
 			}
 		}
 		if layer == "" {
-			return "", fmt.Errorf("unsupported overlay layer for erofs differ: %w", errdefs.ErrNotImplemented)
+			if toplower == "" {
+				return "", fmt.Errorf("unsupported overlay layer for erofs differ: %w", errdefs.ErrNotImplemented)
+			}
+			layer = toplower
 		}
 	} else {
 		return "", fmt.Errorf("invalid filesystem type for erofs differ: %w", errdefs.ErrNotImplemented)
-- 
2.45.3


From 2486c285ff0ea597bbb6deefe2d89a4f235a5b2a Mon Sep 17 00:00:00 2001
From: Sebastiaan van Stijn <github@gone.nl>
Date: Sat, 19 Apr 2025 16:58:08 +0200
Subject: [PATCH 10/16] erofsutils: MountsToLayer slight optimizations

follow-up to 09f34d18b7ae46e0aa9f49b17c91531c72759782

- Use strings.Cut instead of trimming prefixes and strings.Split
  to reduce allocations
- Use a switch for mount-type for slightly better readability
  than if / else if / else.
- Fix GoDoc to start with the function name.

Signed-off-by: Sebastiaan van Stijn <github@gone.nl>
---
 .../snapshots/erofs/erofsutils/mount_linux.go | 29 +++++++++++--------
 1 file changed, 17 insertions(+), 12 deletions(-)

diff --git a/plugins/snapshots/erofs/erofsutils/mount_linux.go b/plugins/snapshots/erofs/erofsutils/mount_linux.go
index b1a0a1a9d..a2e95f04e 100644
--- a/plugins/snapshots/erofs/erofsutils/mount_linux.go
+++ b/plugins/snapshots/erofs/erofsutils/mount_linux.go
@@ -55,7 +55,8 @@ func ConvertErofs(ctx context.Context, layerPath string, srcDir string, mkfsExtr
 	return nil
 }
 
-// Get the snapshot layer directory in order to generate EROFS-formatted blobs;
+// MountsToLayer returns the snapshot layer directory in order to generate
+// EROFS-formatted blobs;
 //
 // If mount[0].Type is `bind` or `erofs`, it just tries the source dir; Or if
 // mount[0].Type is `overlayfs`, it tries the parent of the upperdir;
@@ -64,25 +65,29 @@ func ConvertErofs(ctx context.Context, layerPath string, srcDir string, mkfsExtr
 // snapshot is really generated by the EROFS snapshotter instead of others.
 func MountsToLayer(mounts []mount.Mount) (string, error) {
 	var layer string
-	mnt := mounts[0]
-	if mnt.Type == "bind" || mnt.Type == "erofs" {
+	switch mnt := mounts[0]; mnt.Type {
+	case "bind", "erofs":
 		layer = filepath.Dir(mnt.Source)
-	} else if mnt.Type == "overlay" {
-		toplower := ""
+	case "overlay":
+		var topLower string
 		for _, o := range mnt.Options {
-			if strings.HasPrefix(o, "upperdir=") {
-				layer = filepath.Dir(strings.TrimPrefix(o, "upperdir="))
-			} else if strings.HasPrefix(o, "lowerdir=") {
-				toplower = filepath.Dir(strings.Split(strings.TrimPrefix(o, "lowerdir="), ":")[0])
+			if k, v, ok := strings.Cut(o, "="); ok {
+				switch k {
+				case "upperdir":
+					layer = filepath.Dir(v)
+				case "lowerdir":
+					dir, _, _ := strings.Cut(v, ":")
+					topLower = filepath.Dir(dir)
+				}
 			}
 		}
 		if layer == "" {
-			if toplower == "" {
+			if topLower == "" {
 				return "", fmt.Errorf("unsupported overlay layer for erofs differ: %w", errdefs.ErrNotImplemented)
 			}
-			layer = toplower
+			layer = topLower
 		}
-	} else {
+	default:
 		return "", fmt.Errorf("invalid filesystem type for erofs differ: %w", errdefs.ErrNotImplemented)
 	}
 	// If the layer is not prepared by the EROFS snapshotter, fall back to the next differ
-- 
2.45.3


From b5a44094565bdc29855bcb459fa946282d3b6eed Mon Sep 17 00:00:00 2001
From: Derek McGowan <derek@mcg.dev>
Date: Mon, 21 Apr 2025 16:00:26 -0700
Subject: [PATCH 11/16] Move erofsutils to internal

Avoid introducing utils package outside of internal. This package
should not be imported by other modules.

Signed-off-by: Derek McGowan <derek@mcg.dev>
---
 .../erofs => internal}/erofsutils/mount_linux.go    |  0
 plugins/diff/erofs/differ_linux.go                  | 13 +++++++------
 plugins/snapshots/erofs/erofs_linux.go              | 11 ++++++-----
 3 files changed, 13 insertions(+), 11 deletions(-)
 rename {plugins/snapshots/erofs => internal}/erofsutils/mount_linux.go (100%)

diff --git a/plugins/snapshots/erofs/erofsutils/mount_linux.go b/internal/erofsutils/mount_linux.go
similarity index 100%
rename from plugins/snapshots/erofs/erofsutils/mount_linux.go
rename to internal/erofsutils/mount_linux.go
diff --git a/plugins/diff/erofs/differ_linux.go b/plugins/diff/erofs/differ_linux.go
index b173bb9b3..99178685a 100644
--- a/plugins/diff/erofs/differ_linux.go
+++ b/plugins/diff/erofs/differ_linux.go
@@ -26,20 +26,21 @@ import (
 	"path/filepath"
 	"time"
 
+	"github.com/containerd/continuity/fs"
+	"github.com/containerd/errdefs"
+	"github.com/containerd/log"
+	digest "github.com/opencontainers/go-digest"
+	ocispec "github.com/opencontainers/image-spec/specs-go/v1"
+
 	"github.com/containerd/containerd/v2/core/content"
 	"github.com/containerd/containerd/v2/core/diff"
 	"github.com/containerd/containerd/v2/core/images"
 	"github.com/containerd/containerd/v2/core/mount"
+	"github.com/containerd/containerd/v2/internal/erofsutils"
 	"github.com/containerd/containerd/v2/pkg/archive"
 	"github.com/containerd/containerd/v2/pkg/archive/compression"
 	"github.com/containerd/containerd/v2/pkg/epoch"
 	"github.com/containerd/containerd/v2/pkg/labels"
-	"github.com/containerd/containerd/v2/plugins/snapshots/erofs/erofsutils"
-	"github.com/containerd/continuity/fs"
-	"github.com/containerd/errdefs"
-	"github.com/containerd/log"
-	digest "github.com/opencontainers/go-digest"
-	ocispec "github.com/opencontainers/image-spec/specs-go/v1"
 )
 
 var emptyDesc = ocispec.Descriptor{}
diff --git a/plugins/snapshots/erofs/erofs_linux.go b/plugins/snapshots/erofs/erofs_linux.go
index 8e76d94ab..66a9d0b1d 100644
--- a/plugins/snapshots/erofs/erofs_linux.go
+++ b/plugins/snapshots/erofs/erofs_linux.go
@@ -25,15 +25,16 @@ import (
 	"strings"
 	"syscall"
 
-	"github.com/containerd/containerd/v2/core/mount"
-	"github.com/containerd/containerd/v2/core/snapshots"
-	"github.com/containerd/containerd/v2/core/snapshots/storage"
-	"github.com/containerd/containerd/v2/internal/fsverity"
-	"github.com/containerd/containerd/v2/plugins/snapshots/erofs/erofsutils"
 	"github.com/containerd/continuity/fs"
 	"github.com/containerd/log"
 	"github.com/containerd/plugin"
 	"golang.org/x/sys/unix"
+
+	"github.com/containerd/containerd/v2/core/mount"
+	"github.com/containerd/containerd/v2/core/snapshots"
+	"github.com/containerd/containerd/v2/core/snapshots/storage"
+	"github.com/containerd/containerd/v2/internal/erofsutils"
+	"github.com/containerd/containerd/v2/internal/fsverity"
 )
 
 // SnapshotterConfig is used to configure the erofs snapshotter instance
-- 
2.45.3


From 3a446399487a391ff2378396a1053a238de5852b Mon Sep 17 00:00:00 2001
From: Gao Xiang <hsiangkao@linux.alibaba.com>
Date: Tue, 22 Apr 2025 09:23:26 +0800
Subject: [PATCH 12/16] erofs-differ: support EROFS native image layers

If the layer media type is expected as an EROFS native layer (ending
with `.erofs`), copy the content as the layer blob.

Signed-off-by: Gao Xiang <hsiangkao@linux.alibaba.com>
---
 plugins/diff/erofs/differ_linux.go | 40 ++++++++++++++++++++++++++++--
 1 file changed, 38 insertions(+), 2 deletions(-)

diff --git a/plugins/diff/erofs/differ_linux.go b/plugins/diff/erofs/differ_linux.go
index 99178685a..83cb9f844 100644
--- a/plugins/diff/erofs/differ_linux.go
+++ b/plugins/diff/erofs/differ_linux.go
@@ -22,8 +22,10 @@ import (
 	"encoding/base64"
 	"fmt"
 	"io"
+	"os"
 	"path"
 	"path/filepath"
+	"strings"
 	"time"
 
 	"github.com/containerd/continuity/fs"
@@ -63,6 +65,24 @@ func NewErofsDiffer(store content.Store, mkfsExtraOpts []string) differ {
 	}
 }
 
+// A valid EROFS native layer media type should end with ".erofs".
+//
+// Please avoid using any +suffix to list the algorithms used inside EROFS
+// blobs, since:
+//   - Each EROFS layer can use multiple compression algorithms;
+//   - The suffixes should only indicate the corresponding preprocessor for
+//     `images.DiffCompression`.
+//
+// Since `images.DiffCompression` doesn't support arbitrary media types,
+// disallow non-empty suffixes for now.
+func isErofsMediaType(mt string) bool {
+	mediaType, ext, ok := strings.Cut(mt, "+")
+	if !ok || ext != "" {
+		return false
+	}
+	return strings.HasSuffix(mediaType, ".erofs")
+}
+
 func writeDiff(ctx context.Context, w io.Writer, lower []mount.Mount, upperRoot string) error {
 	var opts []archive.ChangeWriterOpt
 
@@ -224,7 +244,10 @@ func (s erofsDiff) Apply(ctx context.Context, desc ocispec.Descriptor, mounts []
 		}
 	}()
 
-	if _, err := images.DiffCompression(ctx, desc.MediaType); err != nil {
+	native := false
+	if isErofsMediaType(desc.MediaType) {
+		native = true
+	} else if _, err := images.DiffCompression(ctx, desc.MediaType); err != nil {
 		return emptyDesc, fmt.Errorf("currently unsupported media type: %s", desc.MediaType)
 	}
 
@@ -246,6 +269,20 @@ func (s erofsDiff) Apply(ctx context.Context, desc ocispec.Descriptor, mounts []
 	}
 	defer ra.Close()
 
+	layerBlobPath := path.Join(layer, "layer.erofs")
+	if native {
+		f, err := os.Create(layerBlobPath)
+		if err != nil {
+			return emptyDesc, err
+		}
+		_, err = io.Copy(f, content.NewReader(ra))
+		f.Close()
+		if err != nil {
+			return emptyDesc, err
+		}
+		return desc, nil
+	}
+
 	processor := diff.NewProcessorChain(desc.MediaType, content.NewReader(ra))
 	for {
 		if processor, err = diff.GetProcessor(ctx, processor, config.ProcessorPayloads); err != nil {
@@ -262,7 +299,6 @@ func (s erofsDiff) Apply(ctx context.Context, desc ocispec.Descriptor, mounts []
 		r: io.TeeReader(processor, digester.Hash()),
 	}
 
-	layerBlobPath := path.Join(layer, "layer.erofs")
 	err = erofsutils.ConvertTarErofs(ctx, rc, layerBlobPath, s.mkfsExtraOpts)
 	if err != nil {
 		return emptyDesc, fmt.Errorf("failed to convert erofs: %w", err)
-- 
2.45.3


From 4abe1213446303dfab3421a58641c9f8a8003364 Mon Sep 17 00:00:00 2001
From: Gao Xiang <xiang@kernel.org>
Date: Tue, 13 May 2025 23:57:39 +0800
Subject: [PATCH 13/16] erofs-differ: fix EROFS native image support

A dumb bug was just found after I worked out a usable native
converter [1], instead of relying on some prebuilt image..

[1] https://github.com/erofs/erofs-container-toolkit
Signed-off-by: Gao Xiang <xiang@kernel.org>
---
 plugins/diff/erofs/differ_linux.go | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/plugins/diff/erofs/differ_linux.go b/plugins/diff/erofs/differ_linux.go
index 83cb9f844..f84115258 100644
--- a/plugins/diff/erofs/differ_linux.go
+++ b/plugins/diff/erofs/differ_linux.go
@@ -76,8 +76,8 @@ func NewErofsDiffer(store content.Store, mkfsExtraOpts []string) differ {
 // Since `images.DiffCompression` doesn't support arbitrary media types,
 // disallow non-empty suffixes for now.
 func isErofsMediaType(mt string) bool {
-	mediaType, ext, ok := strings.Cut(mt, "+")
-	if !ok || ext != "" {
+	mediaType, _, hasExt := strings.Cut(mt, "+")
+	if hasExt {
 		return false
 	}
 	return strings.HasSuffix(mediaType, ".erofs")
-- 
2.45.3


From 93b0ced04bef54dab9e8af61d98f36552d9f9bd9 Mon Sep 17 00:00:00 2001
From: Gao Xiang <xiang@kernel.org>
Date: Wed, 14 May 2025 00:11:07 +0800
Subject: [PATCH 14/16] docs/snapshotters/erofs.md: a tip for improved
 performance

It's preferred to use `--sort=none` to avoid tar data twice due to
stricter data ordering.

Link: https://git.kernel.org/xiang/erofs-utils/c/e97530622872
Signed-off-by: Gao Xiang <xiang@kernel.org>
---
 docs/snapshotters/erofs.md | 11 ++++++++++-
 1 file changed, 10 insertions(+), 1 deletion(-)

diff --git a/docs/snapshotters/erofs.md b/docs/snapshotters/erofs.md
index a1097f9f1..87ac51d13 100644
--- a/docs/snapshotters/erofs.md
+++ b/docs/snapshotters/erofs.md
@@ -86,7 +86,7 @@ loaded (Linux 5.4 or later is required): it can be loaded with `modprobe erofs`.
 The following configuration can be used in your containerd `config.toml`. Don't
 forget to restart containerd after changing the configuration.
 
-```
+``` toml
   [plugins."io.containerd.snapshotter.v1.erofs"]
       # Enable fsverity support for EROFS layers, default is false
       enable_fsverity = true
@@ -98,6 +98,15 @@ forget to restart containerd after changing the configuration.
     default = ["erofs","walking"]
 ```
 
+Note that if erofs-utils is 1.8.2 or higher, it's preferred to add
+`--sort=none` to the differ's `mkfs_options` to avoid unnecessary tar data
+reordering for improved performance, as shown below:
+
+``` toml
+  [plugins."io.containerd.differ.v1.erofs"]
+    mkfs_options = ["--sort=none"]
+```
+
 ### Running a container
 
 To run a container using the EROFS snapshotter, it needs to be explicitly
-- 
2.45.3


From 8c97d2b4f7009861eafe50491125dd6336c94734 Mon Sep 17 00:00:00 2001
From: ningmingxiao <ning.mingxiao@zte.com.cn>
Date: Thu, 15 May 2025 09:31:28 +0800
Subject: [PATCH 15/16] client:improve mount error message

Signed-off-by: ningmingxiao <ning.mingxiao@zte.com.cn>
---
 core/mount/mount_linux.go | 13 ++++++++++---
 1 file changed, 10 insertions(+), 3 deletions(-)

diff --git a/core/mount/mount_linux.go b/core/mount/mount_linux.go
index a14d545fd..a0e7f1e77 100644
--- a/core/mount/mount_linux.go
+++ b/core/mount/mount_linux.go
@@ -458,7 +458,11 @@ func optionsSize(opts []string) int {
 
 func mountAt(chdir string, source, target, fstype string, flags uintptr, data string) error {
 	if chdir == "" {
-		return unix.Mount(source, target, fstype, flags, data)
+		err := unix.Mount(source, target, fstype, flags, data)
+		if err != nil {
+			return fmt.Errorf("mount source: %q, target: %q, fstype: %s, flags: %d, data: %q, err: %w", source, target, fstype, flags, data, err)
+		}
+		return nil
 	}
 
 	ch := make(chan error, 1)
@@ -480,8 +484,11 @@ func mountAt(chdir string, source, target, fstype string, flags uintptr, data st
 			ch <- err
 			return
 		}
-
-		ch <- unix.Mount(source, target, fstype, flags, data)
+		err := unix.Mount(source, target, fstype, flags, data)
+		if err != nil {
+			err = fmt.Errorf("mount source: %q, target: %q, fstype: %s, flags: %d, data: %q, err: %w", source, target, fstype, flags, data, err)
+		}
+		ch <- err
 	}()
 	return <-ch
 }
-- 
2.45.3


From 345e5e42b9b6c3c97bca27dcc3aecdfbcd532073 Mon Sep 17 00:00:00 2001
From: Gao Xiang <hsiangkao@linux.alibaba.com>
Date: Wed, 4 Jun 2025 06:51:45 +0800
Subject: [PATCH 16/16] erofs-snapshotter: fix to work with wrapped errors

Commit fb6dd2cf15fa ("client:improve mount error message") changed
the return value into a wraped error message, which causes the
ENOTBLK check doesn't work.

Reported-by: Aadhar Agarwal <aadagarwal@microsoft.com>
Fixes: https://github.com/containerd/containerd/pull/11861
Signed-off-by: Gao Xiang <hsiangkao@linux.alibaba.com>
---
 plugins/snapshots/erofs/erofs_linux.go | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/plugins/snapshots/erofs/erofs_linux.go b/plugins/snapshots/erofs/erofs_linux.go
index 66a9d0b1d..3993b3261 100644
--- a/plugins/snapshots/erofs/erofs_linux.go
+++ b/plugins/snapshots/erofs/erofs_linux.go
@@ -19,6 +19,7 @@ package erofs
 import (
 	"bytes"
 	"context"
+	"errors"
 	"fmt"
 	"os"
 	"path/filepath"
@@ -265,7 +266,7 @@ func (s *snapshotter) mounts(snap storage.Snapshot, info snapshots.Info) ([]moun
 		if mntpoint != m.Source && !isErofs(mntpoint) {
 			err := m.Mount(mntpoint)
 			// Use loop if the current kernel (6.12+) doesn't support file-backed mount
-			if err == unix.ENOTBLK {
+			if errors.Is(err, unix.ENOTBLK) {
 				m.Options = append(m.Options, "loop")
 				err = m.Mount(mntpoint)
 			}
-- 
2.45.3

