From b1207905f9194d5bfa17393e605987f158e9448b Mon Sep 17 00:00:00 2001
From: AllSpark <allspark@microsoft.com>
Date: Thu, 11 Sep 2025 16:00:02 +0000
Subject: [PATCH] CVE-2025-8277: Avoid leaking ECDH keys and free previous
 DH/ECDH contexts; adjust packet filter for DH-GEX guess; free previously
 allocated pubkeys

Signed-off-by: Azure Linux Security Servicing Account <azurelinux-security@microsoft.com>
Upstream-reference: AI Backport of https://git.libssh.org/projects/libssh.git/patch/?id=1c763e29d138db87665e98983f468d2dd0f286c1 https://git.libssh.org/projects/libssh.git/patch/?id=8e4d67aa9eda455bfad9ac610e54b7a548d0aa08 https://git.libssh.org/projects/libssh.git/patch/?id=266174a6d36687b65cf90174f06af90b8b27c65f https://git.libssh.org/projects/libssh.git/patch/?id=87db2659ec608a977a63eea529f17b9168388d73
---
 src/dh_crypto.c       |  5 +++++
 src/dh_key.c          |  5 +++++
 src/ecdh_crypto.c     | 13 +++++++++++++
 src/ecdh_gcrypt.c     |  8 ++++++++
 src/ecdh_mbedcrypto.c |  7 +++++++
 src/packet.c          |  2 ++
 src/wrapper.c         |  5 ++++-
 7 files changed, 44 insertions(+), 1 deletion(-)

diff --git a/src/dh_crypto.c b/src/dh_crypto.c
index 4dd9b50..cedfbc8 100644
--- a/src/dh_crypto.c
+++ b/src/dh_crypto.c
@@ -407,6 +407,11 @@ int ssh_dh_init_common(struct ssh_crypto_struct *crypto)
     struct dh_ctx *ctx = NULL;
     int rc;
 
+    /* Cleanup any previously allocated dh_ctx */
+    if (crypto->dh_ctx != NULL) {
+        ssh_dh_cleanup(crypto);
+    }
+
     ctx = calloc(1, sizeof(*ctx));
     if (ctx == NULL) {
         return SSH_ERROR;
diff --git a/src/dh_key.c b/src/dh_key.c
index 20d24a3..d9743ce 100644
--- a/src/dh_key.c
+++ b/src/dh_key.c
@@ -237,6 +237,11 @@ int ssh_dh_init_common(struct ssh_crypto_struct *crypto)
     struct dh_ctx *ctx = NULL;
     int rc;
 
+    /* Cleanup any previously allocated dh_ctx */
+    if (crypto->dh_ctx != NULL) {
+        ssh_dh_cleanup(crypto);
+    }
+
     ctx = calloc(1, sizeof(*ctx));
     if (ctx == NULL) {
         return SSH_ERROR;
diff --git a/src/ecdh_crypto.c b/src/ecdh_crypto.c
index 521ec53..621c950 100644
--- a/src/ecdh_crypto.c
+++ b/src/ecdh_crypto.c
@@ -219,7 +219,20 @@ int ssh_client_ecdh_init(ssh_session session){
       return SSH_ERROR;
   }
 
+  /* Free any previously allocated privkey */
+#if OPENSSL_VERSION_NUMBER < 0x30000000L
+  if (session->next_crypto->ecdh_privkey != NULL) {
+      EC_KEY_free(session->next_crypto->ecdh_privkey);
+      session->next_crypto->ecdh_privkey = NULL;
+  }
+#else
+  if (session->next_crypto->ecdh_privkey != NULL) {
+      EVP_PKEY_free(session->next_crypto->ecdh_privkey);
+      session->next_crypto->ecdh_privkey = NULL;
+  }
+#endif
   session->next_crypto->ecdh_privkey = key;
+  ssh_string_free(session->next_crypto->ecdh_client_pubkey);
   session->next_crypto->ecdh_client_pubkey = client_pubkey;
 
   /* register the packet callbacks */
diff --git a/src/ecdh_gcrypt.c b/src/ecdh_gcrypt.c
index a8a8c37..88e2820 100644
--- a/src/ecdh_gcrypt.c
+++ b/src/ecdh_gcrypt.c
@@ -101,8 +101,16 @@ int ssh_client_ecdh_init(ssh_session session)
         goto out;
     }
 
+    /* Free any previously allocated privkey */
+    if (session->next_crypto->ecdh_privkey != NULL) {
+        gcry_sexp_release(session->next_crypto->ecdh_privkey);
+        session->next_crypto->ecdh_privkey = NULL;
+    }
+
     session->next_crypto->ecdh_privkey = key;
     key = NULL;
+
+    SSH_STRING_FREE(session->next_crypto->ecdh_client_pubkey);
     session->next_crypto->ecdh_client_pubkey = client_pubkey;
     client_pubkey = NULL;
 
diff --git a/src/ecdh_mbedcrypto.c b/src/ecdh_mbedcrypto.c
index dda7392..351aa65 100644
--- a/src/ecdh_mbedcrypto.c
+++ b/src/ecdh_mbedcrypto.c
@@ -70,6 +70,12 @@ int ssh_client_ecdh_init(ssh_session session)
         return SSH_ERROR;
     }
 
+    /* Free any previously allocated privkey */
+    if (session->next_crypto->ecdh_privkey != NULL) {
+        mbedtls_ecp_keypair_free(session->next_crypto->ecdh_privkey);
+        SAFE_FREE(session->next_crypto->ecdh_privkey);
+    }
+
     session->next_crypto->ecdh_privkey = malloc(sizeof(mbedtls_ecp_keypair));
     if (session->next_crypto->ecdh_privkey == NULL) {
         return SSH_ERROR;
@@ -110,6 +116,7 @@ int ssh_client_ecdh_init(ssh_session session)
         goto out;
     }
 
+    SSH_STRING_FREE(session->next_crypto->ecdh_client_pubkey);
     session->next_crypto->ecdh_client_pubkey = client_pubkey;
     client_pubkey = NULL;
 
diff --git a/src/packet.c b/src/packet.c
index 4b4d0dc..3240e43 100644
--- a/src/packet.c
+++ b/src/packet.c
@@ -294,6 +294,7 @@ static enum ssh_packet_filter_result_e ssh_packet_incoming_filter(ssh_session se
          *   or session_state == SSH_SESSION_STATE_INITIAL_KEX
          * - dh_handshake_state == DH_STATE_INIT
          *   or dh_handshake_state == DH_STATE_INIT_SENT (re-exchange)
+         *   or dh_handshake_state == DH_STATE_REQUEST_SENT (dh-gex)
          *   or dh_handshake_state == DH_STATE_FINISHED (re-exchange)
          *
          * Transitions:
@@ -313,6 +314,7 @@ static enum ssh_packet_filter_result_e ssh_packet_incoming_filter(ssh_session se
 
         if ((session->dh_handshake_state != DH_STATE_INIT) &&
             (session->dh_handshake_state != DH_STATE_INIT_SENT) &&
+            (session->dh_handshake_state != DH_STATE_REQUEST_SENT) &&
             (session->dh_handshake_state != DH_STATE_FINISHED))
         {
             rc = SSH_PACKET_DENIED;
diff --git a/src/wrapper.c b/src/wrapper.c
index 43bf213..5f1c0e2 100644
--- a/src/wrapper.c
+++ b/src/wrapper.c
@@ -190,7 +190,10 @@ void crypto_free(struct ssh_crypto_struct *crypto)
 #endif /* OPENSSL_VERSION_NUMBER */
 #elif defined HAVE_GCRYPT_ECC
         gcry_sexp_release(crypto->ecdh_privkey);
-#endif
+#elif defined HAVE_LIBMBEDCRYPTO
+        mbedtls_ecp_keypair_free(crypto->ecdh_privkey);
+        SAFE_FREE(crypto->ecdh_privkey);
+#endif /* HAVE_LIBGCRYPT */
         crypto->ecdh_privkey = NULL;
     }
 #endif
-- 
2.45.4

