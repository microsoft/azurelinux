From b7d9b7aa47627b31e4b50795284408ab6de98660 Mon Sep 17 00:00:00 2001
From: s1awwhy <seawwhy@163.com>
Date: Sun, 24 Aug 2025 21:17:55 +0800
Subject: [PATCH] Address CVE-2025-61099
[PATCH 1/4] ospfd: Add null check for vty_out in check_tlv_size
[PATCH 2/4] ospfd: Fix NULL Pointer Deference when dumping link info
[PATCH 3/4] ospfd: skip subsequent tlvs after invalid length
[PATCH 4/4] ospfd: reformat check_tlv_size macro

Upstream Patch Reference: https://patch-diff.githubusercontent.com/raw/FRRouting/frr/pull/19983.patch
---
 ospfd/ospf_ext.c | 334 +++++++++++++++++++++++++++++++++++------------
 ospfd/ospf_ri.c  |  23 ++--
 ospfd/ospf_te.c  |  23 ++--
 3 files changed, 278 insertions(+), 102 deletions(-)

diff --git a/ospfd/ospf_ext.c b/ospfd/ospf_ext.c
index 1288686..2e013fd 100644
--- a/ospfd/ospf_ext.c
+++ b/ospfd/ospf_ext.c
@@ -44,6 +44,7 @@
 #include "network.h"
 #include "if.h"
 #include "libospf.h" /* for ospf interface types */
+#include <lib/json.h>
 
 #include "ospfd/ospfd.h"
 #include "ospfd/ospf_interface.h"
@@ -1717,111 +1718,222 @@ static void ospf_ext_lsa_schedule(struct ext_itf *exti, enum lsa_opcode op)
  * ------------------------------------
  */
 
-#define check_tlv_size(size, msg)                                              \
-	do {                                                                   \
-		if (ntohs(tlvh->length) != size) {                             \
-			vty_out(vty, "  Wrong %s TLV size: %d(%d). Abort!\n",  \
-				msg, ntohs(tlvh->length), size);               \
-			return size + TLV_HDR_SIZE;                            \
-		}                                                              \
+/* Check NULL for vty. If vty is not available, dump info via zlog */
+#define check_tlv_size(size, msg)                                                                           \
+	do {                                                                                                \
+		if (ntohs(tlvh->length) != size) {                                                          \
+			if (vty != NULL)                                                                    \
+				vty_out(vty,                                                                \
+					"  Wrong %s TLV size: %d(expected %d). Skip subsequent TLVs!\n",    \
+					msg, ntohs(tlvh->length), size);                                    \
+			else                                                                                \
+				zlog_debug("    Wrong %s TLV size: %d(expected %d). Skip subsequent TLVs!", \
+					   msg, ntohs(tlvh->length), size);                                 \
+			return OSPF_MAX_LSA_SIZE + 1;                                                       \
+		}                                                                                           \
 	} while (0)
 
 /* Cisco experimental SubTLV */
 static uint16_t show_vty_ext_link_rmt_itf_addr(struct vty *vty,
-					       struct tlv_header *tlvh)
+					       struct tlv_header *tlvh, json_object *json)
 {
 	struct ext_subtlv_rmt_itf_addr *top =
 		(struct ext_subtlv_rmt_itf_addr *)tlvh;
 
 	check_tlv_size(EXT_SUBTLV_RMT_ITF_ADDR_SIZE, "Remote Itf. Address");
 
-	vty_out(vty,
-		"  Remote Interface Address Sub-TLV: Length %u\n	Address: %pI4\n",
-		ntohs(top->header.length), &top->value);
-
+	if (!json)
+		if (vty != NULL) {
+			vty_out(vty,
+				"  Remote Interface Address Sub-TLV: Length %u\n	Address: %pI4\n",
+				ntohs(top->header.length), &top->value);
+		} else {
+			zlog_debug("  Remote Interface Address Sub-TLV: Length %u",
+				   ntohs(top->header.length));
+			zlog_debug("  Address: %pI4", &top->value);
+		}
+	else
+		json_object_string_addf(json, "remoteInterfaceAddress", "%pI4",
+					&top->value);
 	return TLV_SIZE(tlvh);
 }
 
 /* Adjacency SID SubTLV */
 static uint16_t show_vty_ext_link_adj_sid(struct vty *vty,
-					  struct tlv_header *tlvh)
+					  struct tlv_header *tlvh, json_object *json)
 {
 	struct ext_subtlv_adj_sid *top = (struct ext_subtlv_adj_sid *)tlvh;
 
 	check_tlv_size(EXT_SUBTLV_ADJ_SID_SIZE, "Adjacency SID");
 
-	vty_out(vty,
-		"  Adj-SID Sub-TLV: Length %u\n\tFlags: 0x%x\n\tMT-ID:0x%x\n\tWeight: 0x%x\n\t%s: %u\n",
-		ntohs(top->header.length), top->flags, top->mtid, top->weight,
-		CHECK_FLAG(top->flags, EXT_SUBTLV_LINK_ADJ_SID_VFLG) ? "Label"
-								     : "Index",
-		CHECK_FLAG(top->flags, EXT_SUBTLV_LINK_ADJ_SID_VFLG)
-			? GET_LABEL(ntohl(top->value))
-			: ntohl(top->value));
+	if (!json) {
+		/* Add security check for vty_out. If vty is not available, dump info via zlog.*/
+		if (vty != NULL)
+			vty_out(vty,
+				"  Adj-SID Sub-TLV: Length %u\n\tFlags: 0x%x\n\tMT-ID:0x%x\n\tWeight: 0x%x\n\t%s: %u\n",
+				ntohs(top->header.length), top->flags, top->mtid, top->weight,
+				CHECK_FLAG(top->flags, EXT_SUBTLV_LINK_ADJ_SID_VFLG) ? "Label"
+										     : "Index",
+				CHECK_FLAG(top->flags, EXT_SUBTLV_LINK_ADJ_SID_VFLG)
+					? GET_LABEL(ntohl(top->value))
+					: ntohl(top->value));
+		else {
+			zlog_debug("  Adj-SID Sub-TLV: Length %u", ntohs(top->header.length));
+			zlog_debug("    Flags: 0x%x", top->flags);
+			zlog_debug("    MT-ID:0x%x", top->mtid);
+			zlog_debug("    Weight: 0x%x", top->weight);
+			zlog_debug("    %s: %u",
+				   CHECK_FLAG(top->flags, EXT_SUBTLV_LINK_ADJ_SID_VFLG) ? "Label"
+											: "Index",
+				   CHECK_FLAG(top->flags, EXT_SUBTLV_LINK_ADJ_SID_VFLG)
+					   ? GET_LABEL(ntohl(top->value))
+					   : ntohl(top->value));
+		}
+	} else {
+		json_object_string_addf(json, "flags", "0x%x", top->flags);
+		json_object_string_addf(json, "mtID", "0x%x", top->mtid);
+		json_object_string_addf(json, "weight", "0x%x", top->weight);
+		if (CHECK_FLAG(top->flags, EXT_SUBTLV_LINK_ADJ_SID_VFLG))
+			json_object_int_add(json, "label",
+					    GET_LABEL(ntohl(top->value)));
+		else
+			json_object_int_add(json, "index", ntohl(top->value));
+	}
 
 	return TLV_SIZE(tlvh);
 }
 
 /* LAN Adjacency SubTLV */
 static uint16_t show_vty_ext_link_lan_adj_sid(struct vty *vty,
-					      struct tlv_header *tlvh)
+					      struct tlv_header *tlvh, json_object *json)
 {
 	struct ext_subtlv_lan_adj_sid *top =
 		(struct ext_subtlv_lan_adj_sid *)tlvh;
 
 	check_tlv_size(EXT_SUBTLV_LAN_ADJ_SID_SIZE, "Lan-Adjacency SID");
 
-	vty_out(vty,
-		"  LAN-Adj-SID Sub-TLV: Length %u\n\tFlags: 0x%x\n\tMT-ID:0x%x\n\tWeight: 0x%x\n\tNeighbor ID: %pI4\n\t%s: %u\n",
-		ntohs(top->header.length), top->flags, top->mtid, top->weight,
-		&top->neighbor_id,
-		CHECK_FLAG(top->flags, EXT_SUBTLV_LINK_ADJ_SID_VFLG) ? "Label"
-								     : "Index",
-		CHECK_FLAG(top->flags, EXT_SUBTLV_LINK_ADJ_SID_VFLG)
-			? GET_LABEL(ntohl(top->value))
-			: ntohl(top->value));
+	if (!json) {
+		/* Add security check for vty_out. If vty is not available, dump info via zlog. */
+		if (vty != NULL) {
+			vty_out(vty,
+				"  LAN-Adj-SID Sub-TLV: Length %u\n\tFlags: 0x%x\n\tMT-ID:0x%x\n\tWeight: 0x%x\n\tNeighbor ID: %pI4\n\t%s: %u\n",
+				ntohs(top->header.length), top->flags, top->mtid, top->weight,
+				&top->neighbor_id,
+				CHECK_FLAG(top->flags, EXT_SUBTLV_LINK_ADJ_SID_VFLG) ? "Label"
+										     : "Index",
+				CHECK_FLAG(top->flags, EXT_SUBTLV_LINK_ADJ_SID_VFLG)
+					? GET_LABEL(ntohl(top->value))
+					: ntohl(top->value));
+		} else {
+			zlog_debug("  LAN-Adj-SID Sub-TLV: Length %u", ntohs(top->header.length));
+			zlog_debug("    Flags: 0x%x", top->flags);
+			zlog_debug("    MT-ID:0x%x", top->mtid);
+			zlog_debug("    Weight: 0x%x", top->weight);
+			zlog_debug("    Neighbor ID: %pI4", &top->neighbor_id);
+			zlog_debug("    %s: %u",
+				   CHECK_FLAG(top->flags, EXT_SUBTLV_LINK_ADJ_SID_VFLG) ? "Label"
+											: "Index",
+				   CHECK_FLAG(top->flags, EXT_SUBTLV_LINK_ADJ_SID_VFLG)
+					   ? GET_LABEL(ntohl(top->value))
+					   : ntohl(top->value));
+		}
+	} else {
+		json_object_string_addf(json, "flags", "0x%x", top->flags);
+		json_object_string_addf(json, "mtID", "0x%x", top->mtid);
+		json_object_string_addf(json, "weight", "0x%x", top->weight);
+		json_object_string_addf(json, "neighborID", "%pI4",
+					&top->neighbor_id);
+		if (CHECK_FLAG(top->flags, EXT_SUBTLV_LINK_ADJ_SID_VFLG))
+			json_object_int_add(json, "label",
+					    GET_LABEL(ntohl(top->value)));
+		else
+			json_object_int_add(json, "index", ntohl(top->value));
+	}
 
 	return TLV_SIZE(tlvh);
 }
 
 static uint16_t show_vty_unknown_tlv(struct vty *vty, struct tlv_header *tlvh,
-				     size_t buf_size)
+				     size_t buf_size, json_object *json)
 {
+	json_object *obj;
+
+	/* Add security check for vty_out. If vty is not available, dump info via zlog. */
 	if (TLV_SIZE(tlvh) > buf_size) {
-		vty_out(vty, "    TLV size %d exceeds buffer size. Abort!",
-			TLV_SIZE(tlvh));
+		if (vty != NULL)
+			vty_out(vty, "    TLV size %d exceeds buffer size. Abort!", TLV_SIZE(tlvh));
+		else
+			zlog_debug("    TLV size %d exceeds buffer size. Abort!", TLV_SIZE(tlvh));
+
 		return buf_size;
 	}
-
-	vty_out(vty, "    Unknown TLV: [type(0x%x), length(0x%x)]\n",
-		ntohs(tlvh->type), ntohs(tlvh->length));
+	if (!json)
+		if (vty != NULL) {
+			vty_out(vty, "    Unknown TLV: [type(0x%x), length(0x%x)]\n",
+				ntohs(tlvh->type), ntohs(tlvh->length));
+		} else {
+			zlog_debug("    Unknown TLV: [type(0x%x), length(0x%x)]",
+				   ntohs(tlvh->type), ntohs(tlvh->length));
+		}
+	else {
+		obj = json_object_new_object();
+		json_object_string_addf(obj, "type", "0x%x",
+					ntohs(tlvh->type));
+		json_object_string_addf(obj, "length", "0x%x",
+					ntohs(tlvh->length));
+		json_object_object_add(json, "unknownTLV", obj);
+	}
 
 	return TLV_SIZE(tlvh);
 }
 
 /* Extended Link Sub TLVs */
 static uint16_t show_vty_link_info(struct vty *vty, struct tlv_header *ext,
-				   size_t buf_size)
+				   size_t buf_size, json_object *json)
 {
 	struct ext_tlv_link *top = (struct ext_tlv_link *)ext;
 	struct tlv_header *tlvh;
 	uint16_t length = ntohs(top->header.length);
 	uint16_t sum = 0;
+	json_object *jadj = NULL, *obj = NULL;
 
 	/* Verify that TLV length is valid against remaining buffer size */
 	if (length > buf_size) {
-		vty_out(vty,
-			"  Extended Link TLV size %d exceeds buffer size. Abort!\n",
-			length);
+		/* Add security check for vty_out. If vty is not available, dump info via zlog. */
+		if (vty != NULL) {
+			vty_out(vty, "  Extended Link TLV size %d exceeds buffer size. Abort!\n",
+				length);
+		} else {
+			zlog_debug("  Extended Link TLV size %d exceeds buffer size. Abort!",
+				   length);
+		}
 		return buf_size;
 	}
 
-	vty_out(vty,
-		"  Extended Link TLV: Length %u\n	Link Type: 0x%x\n"
-		"	Link ID: %pI4\n",
-		ntohs(top->header.length), top->link_type,
-		&top->link_id);
-	vty_out(vty, "	Link data: %pI4\n", &top->link_data);
+	if (!json) {
+		/* Add security check for vty_out. If vty is not available, dump info via zlog. */
+		if (vty != NULL) {
+			vty_out(vty,
+				"  Extended Link TLV: Length %u\n	Link Type: 0x%x\n"
+				"	Link ID: %pI4\n",
+				ntohs(top->header.length), top->link_type, &top->link_id);
+			vty_out(vty, "	Link data: %pI4\n", &top->link_data);
+		} else {
+			zlog_debug("  Extended Link TLV: Length %u", ntohs(top->header.length));
+			zlog_debug("    Link Type: 0x%x", top->link_type);
+			zlog_debug("    Link ID: %pI4", &top->link_id);
+			zlog_debug("    Link data: %pI4", &top->link_data);
+		}
+	} else {
+		json_object_string_addf(json, "linkType", "0x%x",
+					top->link_type);
+		json_object_string_addf(json, "linkID", "%pI4", &top->link_id);
+		json_object_string_addf(json, "linkData", "%pI4",
+					&top->link_data);
+		jadj = json_object_new_array();
+		json_object_object_add(json, "adjacencySID", jadj);
+	}
+
 
 	/* Skip Extended TLV and parse sub-TLVs */
 	length -= EXT_TLV_LINK_SIZE;
@@ -1830,16 +1942,26 @@ static uint16_t show_vty_link_info(struct vty *vty, struct tlv_header *ext,
 	for (; sum < length && tlvh; tlvh = TLV_HDR_NEXT(tlvh)) {
 		switch (ntohs(tlvh->type)) {
 		case EXT_SUBTLV_ADJ_SID:
-			sum += show_vty_ext_link_adj_sid(vty, tlvh);
+			if (json) {
+				obj = json_object_new_object();
+				json_object_array_add(jadj, obj);
+			} else
+				obj = NULL;
+			sum += show_vty_ext_link_adj_sid(vty, tlvh, obj);
 			break;
 		case EXT_SUBTLV_LAN_ADJ_SID:
-			sum += show_vty_ext_link_lan_adj_sid(vty, tlvh);
+			if (json) {
+				obj = json_object_new_object();
+				json_object_array_add(jadj, obj);
+			} else
+				obj = NULL;
+			sum += show_vty_ext_link_lan_adj_sid(vty, tlvh, obj);
 			break;
 		case EXT_SUBTLV_RMT_ITF_ADDR:
-			sum += show_vty_ext_link_rmt_itf_addr(vty, tlvh);
+			sum += show_vty_ext_link_rmt_itf_addr(vty, tlvh, json);
 			break;
 		default:
-			sum += show_vty_unknown_tlv(vty, tlvh, length - sum);
+			sum += show_vty_unknown_tlv(vty, tlvh, length - sum, json);
 			break;
 		}
 	}
@@ -1854,9 +1976,12 @@ static void ospf_ext_link_show_info(struct vty *vty, struct json_object *json,
 	struct lsa_header *lsah = lsa->data;
 	struct tlv_header *tlvh;
 	uint16_t length = 0, sum = 0;
+	json_object *jlink = NULL;
 
-	if (json)
-		return;
+	if (json) {
+		jlink = json_object_new_object();
+		json_object_object_add(json, "extendedLink", jlink);
+	}
 
 	/* Initialize TLV browsing */
 	length = lsa->size - OSPF_LSA_HEADER_SIZE;
@@ -1865,10 +1990,10 @@ static void ospf_ext_link_show_info(struct vty *vty, struct json_object *json,
 	     tlvh = TLV_HDR_NEXT(tlvh)) {
 		switch (ntohs(tlvh->type)) {
 		case EXT_TLV_LINK:
-			sum += show_vty_link_info(vty, tlvh, length - sum);
+			sum += show_vty_link_info(vty, tlvh, length - sum, jlink);
 			break;
 		default:
-			sum += show_vty_unknown_tlv(vty, tlvh, length - sum);
+			sum += show_vty_unknown_tlv(vty, tlvh, length - sum, jlink);
 			break;
 		}
 	}
@@ -1876,48 +2001,94 @@ static void ospf_ext_link_show_info(struct vty *vty, struct json_object *json,
 
 /* Prefix SID SubTLV */
 static uint16_t show_vty_ext_pref_pref_sid(struct vty *vty,
-					   struct tlv_header *tlvh)
+					   struct tlv_header *tlvh, json_object *json)
 {
 	struct ext_subtlv_prefix_sid *top =
 		(struct ext_subtlv_prefix_sid *)tlvh;
 
 	check_tlv_size(EXT_SUBTLV_PREFIX_SID_SIZE, "Prefix SID");
 
-	vty_out(vty,
-		"  Prefix SID Sub-TLV: Length %u\n\tAlgorithm: %u\n\tFlags: 0x%x\n\tMT-ID:0x%x\n\t%s: %u\n",
-		ntohs(top->header.length), top->algorithm, top->flags,
-		top->mtid,
-		CHECK_FLAG(top->flags, EXT_SUBTLV_PREFIX_SID_VFLG) ? "Label"
-								   : "Index",
-		CHECK_FLAG(top->flags, EXT_SUBTLV_PREFIX_SID_VFLG)
-			? GET_LABEL(ntohl(top->value))
-			: ntohl(top->value));
+	if (!json) {
+		if (vty != NULL) {
+			vty_out(vty,
+				"  Prefix SID Sub-TLV: Length %u\n\tAlgorithm: %u\n\tFlags: 0x%x\n\tMT-ID:0x%x\n\t%s: %u\n",
+				ntohs(top->header.length), top->algorithm, top->flags, top->mtid,
+				CHECK_FLAG(top->flags, EXT_SUBTLV_PREFIX_SID_VFLG) ? "Label"
+										   : "Index",
+				CHECK_FLAG(top->flags, EXT_SUBTLV_PREFIX_SID_VFLG)
+					? GET_LABEL(ntohl(top->value))
+					: ntohl(top->value));
+		} else {
+			zlog_debug("  Prefix SID Sub-TLV: Length %u", ntohs(top->header.length));
+			zlog_debug("    Algorithm: %u", top->algorithm);
+			zlog_debug("    Flags: 0x%x", top->flags);
+			zlog_debug("    MT-ID:0x%x", top->mtid);
+			zlog_debug("    %s: %u",
+				   CHECK_FLAG(top->flags, EXT_SUBTLV_PREFIX_SID_VFLG) ? "Label"
+										      : "Index",
+				   CHECK_FLAG(top->flags, EXT_SUBTLV_PREFIX_SID_VFLG)
+					   ? GET_LABEL(ntohl(top->value))
+					   : ntohl(top->value));
+		}
+	} else {
+		json_object_int_add(json, "algorithm", top->algorithm);
+		json_object_string_addf(json, "flags", "0x%x", top->flags);
+		json_object_string_addf(json, "mtID", "0x%x", top->mtid);
+		if (CHECK_FLAG(top->flags, EXT_SUBTLV_PREFIX_SID_VFLG))
+			json_object_int_add(json, "label",
+					    GET_LABEL(ntohl(top->value)));
+		else
+			json_object_int_add(json, "index", ntohl(top->value));
+	}
 
 	return TLV_SIZE(tlvh);
 }
 
 /* Extended Prefix SubTLVs */
 static uint16_t show_vty_pref_info(struct vty *vty, struct tlv_header *ext,
-				   size_t buf_size)
+				   size_t buf_size, json_object *json)
 {
 	struct ext_tlv_prefix *top = (struct ext_tlv_prefix *)ext;
 	struct tlv_header *tlvh;
 	uint16_t length = ntohs(top->header.length);
 	uint16_t sum = 0;
+	json_object *jsid = NULL;
 
 	/* Verify that TLV length is valid against remaining buffer size */
 	if (length > buf_size) {
-		vty_out(vty,
-			"  Extended Link TLV size %d exceeds buffer size. Abort!\n",
-			length);
+		if (vty != NULL) {
+			vty_out(vty, "  Extended Link TLV size %d exceeds buffer size. Abort!\n",
+				length);
+		} else {
+			zlog_debug("  Extended Link TLV size %d exceeds buffer size. Abort!",
+				   length);
+		}
 		return buf_size;
 	}
 
-	vty_out(vty,
-		"  Extended Prefix TLV: Length %u\n\tRoute Type: %u\n"
-		"\tAddress Family: 0x%x\n\tFlags: 0x%x\n\tAddress: %pI4/%u\n",
-		ntohs(top->header.length), top->route_type, top->af, top->flags,
-		&top->address, top->pref_length);
+	if (!json) {
+		if (vty != NULL) {
+			vty_out(vty,
+				"  Extended Prefix TLV: Length %u\n\tRoute Type: %u\n"
+				"\tAddress Family: 0x%x\n\tFlags: 0x%x\n\tAddress: %pI4/%u\n",
+				ntohs(top->header.length), top->route_type, top->af, top->flags,
+				&top->address, top->pref_length);
+		} else {
+			zlog_debug("  Extended Prefix TLV: Length %u", ntohs(top->header.length));
+			zlog_debug("    Route Type: %u", top->route_type);
+			zlog_debug("    Address Family: 0x%x", top->af);
+			zlog_debug("    Flags: 0x%x", top->flags);
+			zlog_debug("    Address: %pI4/%u", &top->address, top->pref_length);
+		}
+	} else {
+		json_object_int_add(json, "routeType", top->route_type);
+		json_object_string_addf(json, "addressFamily", "0x%x", top->af);
+		json_object_string_addf(json, "flags", "0x%x", top->flags);
+		json_object_string_addf(json, "address", "%pI4", &top->address);
+		json_object_int_add(json, "prefixLength", top->pref_length);
+		jsid = json_object_new_object();
+		json_object_object_add(json, "prefixSID", jsid);
+	}
 
 	/* Skip Extended Prefix TLV and parse sub-TLVs */
 	length -= EXT_TLV_PREFIX_SIZE;
@@ -1926,10 +2097,10 @@ static uint16_t show_vty_pref_info(struct vty *vty, struct tlv_header *ext,
 	for (; sum < length && tlvh; tlvh = TLV_HDR_NEXT(tlvh)) {
 		switch (ntohs(tlvh->type)) {
 		case EXT_SUBTLV_PREFIX_SID:
-			sum += show_vty_ext_pref_pref_sid(vty, tlvh);
+			sum += show_vty_ext_pref_pref_sid(vty, tlvh, jsid);
 			break;
 		default:
-			sum += show_vty_unknown_tlv(vty, tlvh, length - sum);
+			sum += show_vty_unknown_tlv(vty, tlvh, length - sum, json);
 			break;
 		}
 	}
@@ -1944,9 +2115,12 @@ static void ospf_ext_pref_show_info(struct vty *vty, struct json_object *json,
 	struct lsa_header *lsah = lsa->data;
 	struct tlv_header *tlvh;
 	uint16_t length = 0, sum = 0;
+	json_object *jpref = NULL;
 
-	if (json)
-		return;
+	if (json) {
+		jpref = json_object_new_object();
+		json_object_object_add(json, "extendedPrefix", jpref);
+	}
 
 	/* Initialize TLV browsing */
 	length = lsa->size - OSPF_LSA_HEADER_SIZE;
@@ -1955,10 +2129,10 @@ static void ospf_ext_pref_show_info(struct vty *vty, struct json_object *json,
 	     tlvh = TLV_HDR_NEXT(tlvh)) {
 		switch (ntohs(tlvh->type)) {
 		case EXT_TLV_PREFIX:
-			sum += show_vty_pref_info(vty, tlvh, length - sum);
+			sum += show_vty_pref_info(vty, tlvh, length - sum, jpref);
 			break;
 		default:
-			sum += show_vty_unknown_tlv(vty, tlvh, length - sum);
+			sum += show_vty_unknown_tlv(vty, tlvh, length - sum, jpref);
 			break;
 		}
 	}
diff --git a/ospfd/ospf_ri.c b/ospfd/ospf_ri.c
index e227a31..099ccf3 100644
--- a/ospfd/ospf_ri.c
+++ b/ospfd/ospf_ri.c
@@ -1226,17 +1226,18 @@ static int ospf_router_info_lsa_update(struct ospf_lsa *lsa)
  * Following are vty session control functions.
  *------------------------------------------------------------------------*/
 
-#define check_tlv_size(size, msg)                                              \
-	do {                                                                   \
-		if (ntohs(tlvh->length) > size) {                              \
-			if (vty != NULL)                                       \
-				vty_out(vty, "  Wrong %s TLV size: %d(%d)\n",  \
-					msg, ntohs(tlvh->length), size);       \
-			else                                                   \
-				zlog_debug("    Wrong %s TLV size: %d(%d)",    \
-					   msg, ntohs(tlvh->length), size);    \
-			return size + TLV_HDR_SIZE;                            \
-		}                                                              \
+#define check_tlv_size(size, msg)                                                                           \
+	do {                                                                                                \
+		if (ntohs(tlvh->length) > size) {                                                           \
+			if (vty != NULL)                                                                    \
+				vty_out(vty,                                                                \
+					"  Wrong %s TLV size: %d(expected %d). Skip subsequent TLVs!\n",    \
+					msg, ntohs(tlvh->length), size);                                    \
+			else                                                                                \
+				zlog_debug("    Wrong %s TLV size: %d(expected %d). Skip subsequent TLVs!", \
+					   msg, ntohs(tlvh->length), size);                                 \
+			return OSPF_MAX_LSA_SIZE + 1;                                                       \
+		}                                                                                           \
 	} while (0)
 
 static uint16_t show_vty_router_cap(struct vty *vty, struct tlv_header *tlvh)
diff --git a/ospfd/ospf_te.c b/ospfd/ospf_te.c
index ffea80c..acfb8d7 100644
--- a/ospfd/ospf_te.c
+++ b/ospfd/ospf_te.c
@@ -3213,17 +3213,18 @@ static void ospf_te_init_ted(struct ls_ted *ted, struct ospf *ospf)
 /*------------------------------------------------------------------------*
  * Following are vty session control functions.
  *------------------------------------------------------------------------*/
-#define check_tlv_size(size, msg)                                              \
-	do {                                                                   \
-		if (ntohs(tlvh->length) > size) {                              \
-			if (vty != NULL)                                       \
-				vty_out(vty, "  Wrong %s TLV size: %d(%d)\n",  \
-					msg, ntohs(tlvh->length), size);       \
-			else                                                   \
-				zlog_debug("    Wrong %s TLV size: %d(%d)",    \
-					   msg, ntohs(tlvh->length), size);    \
-			return size + TLV_HDR_SIZE;                            \
-		}                                                              \
+ #define check_tlv_size(size, msg)                                                                           \
+	do {                                                                                                \
+		if (ntohs(tlvh->length) > size) {                                                           \
+			if (vty != NULL)                                                                    \
+				vty_out(vty,                                                                \
+					"  Wrong %s TLV size: %d(expected %d). Skip subsequent TLVs!\n",    \
+					msg, ntohs(tlvh->length), size);                                    \
+			else                                                                                \
+				zlog_debug("    Wrong %s TLV size: %d(expected %d). Skip subsequent TLVs!", \
+					   msg, ntohs(tlvh->length), size);                                 \
+			return OSPF_MAX_LSA_SIZE + 1;                                                       \
+		}                                                                                           \
 	} while (0)
 
 static uint16_t show_vty_router_addr(struct vty *vty, struct tlv_header *tlvh)
-- 
2.45.4

