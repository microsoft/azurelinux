From d39079225d8ed2a88e1490c77df0891243045092 Mon Sep 17 00:00:00 2001
From: AllSpark <allspark@microsoft.com>
Date: Mon, 18 Aug 2025 06:20:35 +0000
Subject: [PATCH] src/ogg: better error checking for vorbis and opus, adjust
 ogg_write_page to return -1 on error; fixes #1035

Signed-off-by: Azure Linux Security Servicing Account <azurelinux-security@microsoft.com>
Upstream Patch Reference: AI Backport of https://github.com/libsndfile/libsndfile/commit/4755f5bd7854611d92ad0f1295587b439f9950ba.patch:
---
 src/ogg.c        | 12 ++++++----
 src/ogg_opus.c   | 17 ++++++++------
 src/ogg_vorbis.c | 60 ++++++++++++++++++++++++++++++++++++------------
 3 files changed, 63 insertions(+), 26 deletions(-)

diff --git a/src/ogg.c b/src/ogg.c
index 7a4a167..c6e76e3 100644
--- a/src/ogg.c
+++ b/src/ogg.c
@@ -209,12 +209,16 @@ ogg_read_first_page (SF_PRIVATE *psf, OGG_PRIVATE *odata)
 
 int
 ogg_write_page (SF_PRIVATE *psf, ogg_page *page)
-{	int bytes ;
+{	int n ;
 
-	bytes = psf_fwrite (page->header, 1, page->header_len, psf) ;
-	bytes += psf_fwrite (page->body, 1, page->body_len, psf) ;
+	n = psf_fwrite (page->header, 1, page->header_len, psf) ;
+	if (n == page->header_len)
+		n += psf_fwrite (page->body, 1, page->body_len, psf) ;
 
-	return bytes == page->header_len + page->body_len ;
+	if (n != page->body_len + page->header_len)
+		return -1 ;
+
+	return n ;
 } /* ogg_write_page */
 
 sf_count_t
diff --git a/src/ogg_opus.c b/src/ogg_opus.c
index 9be6e91..004c906 100644
--- a/src/ogg_opus.c
+++ b/src/ogg_opus.c
@@ -815,15 +815,16 @@ ogg_opus_write_header (SF_PRIVATE *psf, int UNUSED (calc_length))
 
 	/* The first page MUST only contain the header, so flush it out now */
 	ogg_stream_packetin (&odata->ostream, &op) ;
-	for ( ; (nn = ogg_stream_flush (&odata->ostream, &odata->opage)) ; )
-	{	if (! (nn = ogg_write_page (psf, &odata->opage)))
+	while (ogg_stream_flush (&odata->ostream, &odata->opage))
+	{	nn = ogg_write_page (psf, &odata->opage) ;
+		if (nn < 0)
 		{	psf_log_printf (psf, "Opus : Failed to write header!\n") ;
 			if (psf->error)
 				return psf->error ;
 			return SFE_INTERNAL ;
 			} ;
 		psf->dataoffset += nn ;
-		}
+		} ;
 
 	/*
 	** Metadata Tags (manditory)
@@ -838,15 +839,16 @@ ogg_opus_write_header (SF_PRIVATE *psf, int UNUSED (calc_length))
 	vorbiscomment_write_tags (psf, &op, &opustags_ident, opus_get_version_string (), - (OGG_OPUS_COMMENT_PAD)) ;
 	op.packetno = 2 ;
 	ogg_stream_packetin (&odata->ostream, &op) ;
-	for ( ; (nn = ogg_stream_flush (&odata->ostream, &odata->opage)) ; )
-	{	if (! (nn = ogg_write_page (psf, &odata->opage)))
+	while (ogg_stream_flush (&odata->ostream, &odata->opage))
+	{	nn = ogg_write_page (psf, &odata->opage) ;
+		if (nn < 0)
 		{	psf_log_printf (psf, "Opus : Failed to write comments!\n") ;
 			if (psf->error)
 				return psf->error ;
 			return SFE_INTERNAL ;
 			} ;
 		psf->dataoffset += nn ;
-		}
+		} ;
 
 	return 0 ;
 } /* ogg_opus_write_header */
@@ -1124,7 +1126,8 @@ ogg_opus_write_out (SF_PRIVATE *psf, OGG_PRIVATE *odata, OPUS_PRIVATE *oopus)
 			*/
 			oopus->u.encode.last_segments -= odata->opage.header [26] ;
 			oopus->pg_pos = oopus->pkt_pos ;
-			ogg_write_page (psf, &odata->opage) ;
+			if (ogg_write_page (psf, &odata->opage) < 0)
+				return -1 ;
 			}
 		else
 			break ;
diff --git a/src/ogg_vorbis.c b/src/ogg_vorbis.c
index 5f53651..b8c77c7 100644
--- a/src/ogg_vorbis.c
+++ b/src/ogg_vorbis.c
@@ -98,6 +98,23 @@ static sf_count_t	vorbis_write_d (SF_PRIVATE *psf, const double *ptr, sf_count_t
 static sf_count_t	vorbis_read_sample (SF_PRIVATE *psf, void *ptr, sf_count_t lens, convert_func *transfn) ;
 static int	vorbis_rnull (SF_PRIVATE *psf, int samples, void *vptr, int off , int channels, float **pcm) ;
 
+static int	vorbis_write_samples (SF_PRIVATE *psf, OGG_PRIVATE *odata, VORBIS_PRIVATE *vdata, int in_frames) ;
+static void	vorbis_log_error (SF_PRIVATE *psf, int error) ;
+
+static void
+vorbis_log_error (SF_PRIVATE *psf, int error)
+{	switch (error)
+	{ case 0: return ;
+		case OV_EIMPL:		psf->error = SFE_UNIMPLEMENTED ; break ;
+		case OV_ENOTVORBIS:	psf->error = SFE_MALFORMED_FILE ; break ;
+		case OV_EBADHEADER:	psf->error = SFE_MALFORMED_FILE ; break ;
+		case OV_EVERSION:	psf->error = SFE_UNSUPPORTED_ENCODING ; break ;
+		case OV_EFAULT:
+		case OV_EINVAL:
+		default: psf->error = SFE_INTERNAL ;
+			} ;
+} ;
+
 typedef struct
 {	int id ;
 	const char *name ;
@@ -386,7 +403,6 @@ vorbis_write_header (SF_PRIVATE *psf, int UNUSED (calc_length))
 	{	ogg_packet header ;
 		ogg_packet header_comm ;
 		ogg_packet header_code ;
-		int result ;
 
 		vorbis_analysis_headerout (&vdata->vdsp, &vdata->vcomment, &header, &header_comm, &header_code) ;
 		ogg_stream_packetin (&odata->ostream, &header) ; /* automatically placed in its own page */
@@ -396,9 +412,9 @@ vorbis_write_header (SF_PRIVATE *psf, int UNUSED (calc_length))
 		/* This ensures the actual
 		 * audio data will start on a new page, as per spec
 		 */
-		while ((result = ogg_stream_flush (&odata->ostream, &odata->opage)) != 0)
-		{	ogg_write_page (psf, &odata->opage) ;
-			} ;
+		while (ogg_stream_flush (&odata->ostream, &odata->opage))
+			if (ogg_write_page (psf, &odata->opage) < 0)
+				return -1 ;
 	}
 
 	return 0 ;
@@ -686,36 +702,50 @@ vorbis_read_d (SF_PRIVATE *psf, double *ptr, sf_count_t lens)
 /*==============================================================================
 */
 
-static void
+static int
 vorbis_write_samples (SF_PRIVATE *psf, OGG_PRIVATE *odata, VORBIS_PRIVATE *vdata, int in_frames)
-{
-	vorbis_analysis_wrote (&vdata->vdsp, in_frames) ;
+{	int ret ;
+
+	if ((ret = vorbis_analysis_wrote (&vdata->vdsp, in_frames)) != 0)
+		return ret ;
 
 	/*
 	**	Vorbis does some data preanalysis, then divvies up blocks for
 	**	more involved (potentially parallel) processing. Get a single
 	**	block for encoding now.
 	*/
-	while (vorbis_analysis_blockout (&vdata->vdsp, &vdata->vblock) == 1)
+	while ((ret = vorbis_analysis_blockout (&vdata->vdsp, &vdata->vblock)) == 1)
 	{
 		/* analysis, assume we want to use bitrate management */
-		vorbis_analysis (&vdata->vblock, NULL) ;
-		vorbis_bitrate_addblock (&vdata->vblock) ;
+		if ((ret = vorbis_analysis (&vdata->vblock, NULL)) != 0)
+			return ret ;
+		if ((ret = vorbis_bitrate_addblock (&vdata->vblock)) != 0)
+			return ret ;
 
-		while (vorbis_bitrate_flushpacket (&vdata->vdsp, &odata->opacket))
+		while ((ret = vorbis_bitrate_flushpacket (&vdata->vdsp, &odata->opacket)) == 1)
 		{
 			/* weld the packet into the bitstream */
-			ogg_stream_packetin (&odata->ostream, &odata->opacket) ;
+			if ((ret = ogg_stream_packetin (&odata->ostream, &odata->opacket)) != 0)
+				return ret ;
 
 			/* write out pages (if any) */
 			while (!odata->eos)
-			{	int result = ogg_stream_pageout (&odata->ostream, &odata->opage) ;
-				if (result == 0)
+			{	ret = ogg_stream_pageout (&odata->ostream, &odata->opage) ;
+				if (ret == 0)
 					break ;
-				ogg_write_page (psf, &odata->opage) ;
+
+				if (ogg_write_page (psf, &odata->opage) < 0)
+					return -1 ;
 
 				/*	This could be set above, but for illustrative purposes, I do
 				**	it here (to show that vorbis does know where the stream ends) */
+				} ;
+			} ;
+		} ;
+	vdata->loc += in_frames ;
+
+	return 0 ;
+} /* vorbis_write_data */
 				if (ogg_page_eos (&odata->opage))
 					odata->eos = 1 ;
 				} ;
-- 
2.45.4

