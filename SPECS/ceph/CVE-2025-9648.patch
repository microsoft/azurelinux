From 72fb60683f2f8f2cd253213bb0cc275bca323c64 Mon Sep 17 00:00:00 2001
From: AllSpark <allspark@microsoft.com>
Date: Fri, 3 Oct 2025 06:15:09 +0000
Subject: [PATCH] Make parsing of URL encoded forms more robust: reject invalid
 control characters in mg_url_decode; abort form processing on decode errors;
 add abort_read control in URL-encoded POST handling; update copyrights

Signed-off-by: Azure Linux Security Servicing Account <azurelinux-security@microsoft.com>
Upstream-reference: AI Backport of https://github.com/civetweb/civetweb/commit/782e18903515f43bafbf2e668994e82bdfa51133.patch
---
 src/civetweb/src/civetweb.c      |  8 ++++++-
 src/civetweb/src/handle_form.inl | 40 ++++++++++++++++++++++++++------
 2 files changed, 40 insertions(+), 8 deletions(-)

diff --git a/src/civetweb/src/civetweb.c b/src/civetweb/src/civetweb.c
index 76f097ac1..7066b31b8 100644
--- a/src/civetweb/src/civetweb.c
+++ b/src/civetweb/src/civetweb.c
@@ -1,4 +1,4 @@
-﻿/* Copyright (c) 2013-2017 the Civetweb developers
+﻿/* Copyright (c) 2013-2025 the Civetweb developers
  * Copyright (c) 2004-2013 Sergey Lyubka
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
@@ -6368,6 +6368,8 @@ mg_url_decode(const char *src,
 #define HEXTOI(x) (isdigit(x) ? (x - '0') : (x - 'W'))
 
 	for (i = j = 0; (i < src_len) && (j < (dst_len - 1)); i++, j++) {
+
+
 		if ((i < src_len - 2) && (src[i] == '%')
 		    && isxdigit(*(const unsigned char *)(src + i + 1))
 		    && isxdigit(*(const unsigned char *)(src + i + 2))) {
@@ -6377,11 +6379,15 @@ mg_url_decode(const char *src,
 			i += 2;
 		} else if (is_form_url_encoded && (src[i] == '+')) {
 			dst[j] = ' ';
+		} else if (((unsigned char)src[i]) <= ' ') {
+			return -1; /* invalid character */
 		} else {
 			dst[j] = src[i];
 		}
 	}
 
+	#undef HEXTOI
+
 	dst[j] = '\0'; /* Null-terminate the destination */
 
 	return (i >= src_len) ? j : -1;
diff --git a/src/civetweb/src/handle_form.inl b/src/civetweb/src/handle_form.inl
index 2a213ade5..5fe6f4369 100644
--- a/src/civetweb/src/handle_form.inl
+++ b/src/civetweb/src/handle_form.inl
@@ -1,4 +1,4 @@
-/* Copyright (c) 2016-2017 the Civetweb developers
+/* Copyright (c) 2016-2025 the Civetweb developers
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -40,7 +40,7 @@ url_encoded_field_found(const struct mg_connection *conn,
 	    mg_url_decode(key, (int)key_len, key_dec, (int)sizeof(key_dec), 1);
 
 	if (((size_t)key_dec_len >= (size_t)sizeof(key_dec)) || (key_dec_len < 0)) {
-		return FORM_FIELD_STORAGE_SKIP;
+		return FORM_FIELD_STORAGE_ABORT;
 	}
 
 	if (filename) {
@@ -52,9 +52,9 @@ url_encoded_field_found(const struct mg_connection *conn,
 
 		if (((size_t)filename_dec_len >= (size_t)sizeof(filename_dec))
 		    || (filename_dec_len < 0)) {
-			/* Log error message and skip this field. */
+			/* Log error message and abort this request. */
 			mg_cry(conn, "%s: Cannot decode filename", __func__);
-			return FORM_FIELD_STORAGE_SKIP;
+			return FORM_FIELD_STORAGE_ABORT;
 		}
 	} else {
 		filename_dec[0] = 0;
@@ -89,6 +89,7 @@ url_encoded_field_get(const struct mg_connection *conn,
                       struct mg_form_data_handler *fdh)
 {
 	char key_dec[1024];
+	int key_dec_len;
 
 	char *value_dec = (char *)mg_malloc_ctx(value_len + 1, conn->ctx);
 	int value_dec_len, ret;
@@ -102,11 +103,16 @@ url_encoded_field_get(const struct mg_connection *conn,
 		return FORM_FIELD_STORAGE_ABORT;
 	}
 
-	mg_url_decode(key, (int)key_len, key_dec, (int)sizeof(key_dec), 1);
+	key_dec_len = mg_url_decode(key, (int)key_len, key_dec, (int)sizeof(key_dec), 1);
 
 	value_dec_len =
 	    mg_url_decode(value, (int)value_len, value_dec, (int)value_len + 1, 1);
 
+	if ((key_dec_len < 0) || (value_dec_len < 0)) {
+		mg_free(value_dec);
+		return FORM_FIELD_STORAGE_ABORT;
+	}
+
 	ret = fdh->field_get(key_dec,
 	                     value_dec,
 	                     (size_t)value_dec_len,
@@ -127,9 +133,13 @@ unencoded_field_get(const struct mg_connection *conn,
                     struct mg_form_data_handler *fdh)
 {
 	char key_dec[1024];
+	int key_dec_len;
 	(void)conn;
 
-	mg_url_decode(key, (int)key_len, key_dec, (int)sizeof(key_dec), 1);
+	key_dec_len = mg_url_decode(key, (int)key_len, key_dec, (int)sizeof(key_dec), 1);
+	if (key_dec_len < 0) {
+		return FORM_FIELD_STORAGE_ABORT;
+	}
 
 	return fdh->field_get(key_dec, value, value_len, fdh->user_data);
 }
@@ -340,13 +350,14 @@ mg_handle_form_request(struct mg_connection *conn,
 		/* The form data is in the request body data, encoded in key/value
 		 * pairs. */
 		int all_data_read = 0;
+		int abort_read = 0;
 
 		/* Read body data and split it in keys and values.
 		 * The encoding is like in the "GET" case above: a=1&b&c=3&c=4.
 		 * Here we use "POST", and read the data from the request body.
 		 * The data read on the fly, so it is not required to buffer the
 		 * entire request in memory before processing it. */
-		for (;;) {
+		while (!abort_read) {
 			const char *val;
 			const char *next;
 			ptrdiff_t keylen, vallen;
@@ -397,6 +408,12 @@ mg_handle_form_request(struct mg_connection *conn,
 			                                        sizeof(path) - 1,
 			                                        fdh);
 
+			if ((field_storage & FORM_FIELD_STORAGE_ABORT) == FORM_FIELD_STORAGE_ABORT) {
+				/* Stop parsing the request */
+				abort_read = 1;
+				break;
+			}
+
 			if ((field_storage & FORM_FIELD_STORAGE_ABORT)
 			    == FORM_FIELD_STORAGE_ABORT) {
 				/* Stop parsing the request */
@@ -407,6 +424,15 @@ mg_handle_form_request(struct mg_connection *conn,
 				if (mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &fstore) == 0) {
 					fstore.access.fp = NULL;
 				}
+					/* Avoid DoS attacks by having a zero byte in the middle of
+					 * a request that is supposed to be URL encoded. Since this
+					 * request is certainly invalid, according to the protocol
+					 * specification, stop processing it. */
+					if ((buf + buf_fill) > (val + vallen)) {
+						abort_read = 1;
+						break;
+					}
+
 				file_size = 0;
 				if (!fstore.access.fp) {
 					mg_cry(conn, "%s: Cannot create file %s", __func__, path);
-- 
2.45.4

