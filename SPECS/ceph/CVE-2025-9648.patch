From 72fb60683f2f8f2cd253213bb0cc275bca323c64 Mon Sep 17 00:00:00 2001
From: AllSpark <allspark@microsoft.com>
Date: Fri, 3 Oct 2025 06:15:09 +0000
Subject: [PATCH] Make parsing of URL encoded forms more robust: reject invalid
 control characters in mg_url_decode; abort form processing on decode errors;
 add abort_read control in URL-encoded POST handling; update copyrights

Signed-off-by: Azure Linux Security Servicing Account <azurelinux-security@microsoft.com>

Modified to apply to Azure Linux
Modified by: BinduSri-6522866 <v-badabala@microsoft.com>
Upstream Patch Reference: https://github.com/civetweb/civetweb/commit/782e18903515f43bafbf2e668994e82bdfa51133.patch
---
 src/civetweb/include/civetweb.h  |   2 +
 src/civetweb/src/civetweb.c      |   7 +-
 src/civetweb/src/handle_form.inl | 127 +++++++++++++++++++++++++++----
 3 files changed, 119 insertions(+), 17 deletions(-)

diff --git a/src/civetweb/include/civetweb.h b/src/civetweb/include/civetweb.h
index 6ddde4f2f..e0a2382e8 100644
--- a/src/civetweb/include/civetweb.h
+++ b/src/civetweb/include/civetweb.h
@@ -1109,6 +1109,8 @@ enum {
 	MG_FORM_FIELD_STORAGE_GET = 0x1,
 	/* Store the field value into a file. */
 	MG_FORM_FIELD_STORAGE_STORE = 0x2,
+	/* Handle the next field */
+	MG_FORM_FIELD_STORAGE_NEXT = 0x8,
 	/* Stop parsing this request. Skip the remaining fields. */
 	MG_FORM_FIELD_STORAGE_ABORT = 0x10
 };
diff --git a/src/civetweb/src/civetweb.c b/src/civetweb/src/civetweb.c
index 76f097ac1..508a910ac 100644
--- a/src/civetweb/src/civetweb.c
+++ b/src/civetweb/src/civetweb.c
@@ -1,4 +1,4 @@
-﻿/* Copyright (c) 2013-2017 the Civetweb developers
+﻿/* Copyright (c) 2013-2025 the Civetweb developers
  * Copyright (c) 2004-2013 Sergey Lyubka
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
@@ -6365,6 +6365,7 @@ mg_url_decode(const char *src,
               int is_form_url_encoded)
 {
 	int i, j, a, b;
+
 #define HEXTOI(x) (isdigit(x) ? (x - '0') : (x - 'W'))
 
 	for (i = j = 0; (i < src_len) && (j < (dst_len - 1)); i++, j++) {
@@ -6377,11 +6378,15 @@ mg_url_decode(const char *src,
 			i += 2;
 		} else if (is_form_url_encoded && (src[i] == '+')) {
 			dst[j] = ' ';
+		} else if ((unsigned char)src[i] <= ' ') {
+			return -1; /* invalid character */
 		} else {
 			dst[j] = src[i];
 		}
 	}
 
+#undef HEXTOI
+
 	dst[j] = '\0'; /* Null-terminate the destination */
 
 	return (i >= src_len) ? j : -1;
diff --git a/src/civetweb/src/handle_form.inl b/src/civetweb/src/handle_form.inl
index 2a213ade5..a805ccafa 100644
--- a/src/civetweb/src/handle_form.inl
+++ b/src/civetweb/src/handle_form.inl
@@ -1,4 +1,4 @@
-/* Copyright (c) 2016-2017 the Civetweb developers
+/* Copyright (c) 2016-2025 the Civetweb developers
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -40,7 +40,7 @@ url_encoded_field_found(const struct mg_connection *conn,
 	    mg_url_decode(key, (int)key_len, key_dec, (int)sizeof(key_dec), 1);
 
 	if (((size_t)key_dec_len >= (size_t)sizeof(key_dec)) || (key_dec_len < 0)) {
-		return FORM_FIELD_STORAGE_SKIP;
+		return FORM_FIELD_STORAGE_ABORT;
 	}
 
 	if (filename) {
@@ -54,7 +54,7 @@ url_encoded_field_found(const struct mg_connection *conn,
 		    || (filename_dec_len < 0)) {
 			/* Log error message and skip this field. */
 			mg_cry(conn, "%s: Cannot decode filename", __func__);
-			return FORM_FIELD_STORAGE_SKIP;
+			return FORM_FIELD_STORAGE_ABORT;
 		}
 	} else {
 		filename_dec[0] = 0;
@@ -89,6 +89,7 @@ url_encoded_field_get(const struct mg_connection *conn,
                       struct mg_form_data_handler *fdh)
 {
 	char key_dec[1024];
+	int key_dec_len;
 
 	char *value_dec = (char *)mg_malloc_ctx(value_len + 1, conn->ctx);
 	int value_dec_len, ret;
@@ -102,11 +103,18 @@ url_encoded_field_get(const struct mg_connection *conn,
 		return FORM_FIELD_STORAGE_ABORT;
 	}
 
-	mg_url_decode(key, (int)key_len, key_dec, (int)sizeof(key_dec), 1);
+	key_dec_len = mg_url_decode(
+	    key, (int)key_len, key_dec, (int)sizeof(key_dec), 1);
 
 	value_dec_len =
 	    mg_url_decode(value, (int)value_len, value_dec, (int)value_len + 1, 1);
 
+	if ((key_dec_len < 0) || (value_dec_len < 0)) {
+	    mg_free(value_dec);
+            return MG_FORM_FIELD_STORAGE_ABORT;
+	}
+
+
 	ret = fdh->field_get(key_dec,
 	                     value_dec,
 	                     (size_t)value_dec_len,
@@ -127,9 +135,13 @@ unencoded_field_get(const struct mg_connection *conn,
                     struct mg_form_data_handler *fdh)
 {
 	char key_dec[1024];
+	int key_dec_len;
 	(void)conn;
 
-	mg_url_decode(key, (int)key_len, key_dec, (int)sizeof(key_dec), 1);
+	key_dec_len = mg_url_decode(key, (int)key_len, key_dec, (int)sizeof(key_dec), 1);
+	if (key_dec_len < 0) {
+		return MG_FORM_FIELD_STORAGE_ABORT;
+	}
 
 	return fdh->field_get(key_dec, value, value_len, fdh->user_data);
 }
@@ -182,6 +194,7 @@ mg_handle_form_request(struct mg_connection *conn,
 	int buf_fill = 0;
 	int r;
 	int field_count = 0;
+	int abort_read = 0;
 	struct mg_file fstore = STRUCT_FILE_INITIALIZER;
 	int64_t file_size = 0; /* init here, to a avoid a false positive
 	                         "uninitialized variable used" warning */
@@ -264,9 +277,27 @@ mg_handle_form_request(struct mg_connection *conn,
 
 			if (field_storage == FORM_FIELD_STORAGE_GET) {
 				/* Call callback */
-				url_encoded_field_get(
+				r = url_encoded_field_get(
 				    conn, data, (size_t)keylen, val, (size_t)vallen, fdh);
+				if (r == MG_FORM_FIELD_STORAGE_ABORT) {
+					/* Stop request handling */
+					abort_read = 1;
+					break;
+				}
+				if (r == MG_FORM_FIELD_STORAGE_NEXT) {
+					/* Skip to next field */
+					field_storage = MG_FORM_FIELD_STORAGE_SKIP;
+				}
+
+			}
+
+			if (next) {
+			        next++;
+			} else {
+				/* vallen may have been modified by url_encoded_field_get */
+				next = val + vallen;
 			}
+
 			if (field_storage == FORM_FIELD_STORAGE_STORE) {
 				/* Store the content to a file */
 				if (mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &fstore) == 0) {
@@ -290,7 +321,12 @@ mg_handle_form_request(struct mg_connection *conn,
 						r = mg_fclose(&fstore.access);
 						if (r == 0) {
 							/* stored successfully */
-							field_stored(conn, path, file_size, fdh);
+							r = field_stored(conn, path, file_size, fdh);
+							if (r == MG_FORM_FIELD_STORAGE_ABORT) {
+								/* Stop request handling */
+								abort_read = 1;
+								break;
+							}
 						} else {
 							mg_cry(conn,
 							       "%s: Error saving file %s",
@@ -322,6 +358,7 @@ mg_handle_form_request(struct mg_connection *conn,
 			if ((field_storage & FORM_FIELD_STORAGE_ABORT)
 			    == FORM_FIELD_STORAGE_ABORT) {
 				/* Stop parsing the request */
+				abort_read = 1;
 				break;
 			}
 
@@ -346,7 +383,7 @@ mg_handle_form_request(struct mg_connection *conn,
 		 * Here we use "POST", and read the data from the request body.
 		 * The data read on the fly, so it is not required to buffer the
 		 * entire request in memory before processing it. */
-		for (;;) {
+		while (!abort_read) {
 			const char *val;
 			const char *next;
 			ptrdiff_t keylen, vallen;
@@ -400,6 +437,7 @@ mg_handle_form_request(struct mg_connection *conn,
 			if ((field_storage & FORM_FIELD_STORAGE_ABORT)
 			    == FORM_FIELD_STORAGE_ABORT) {
 				/* Stop parsing the request */
+				abort_read = 1;
 				break;
 			}
 
@@ -419,8 +457,15 @@ mg_handle_form_request(struct mg_connection *conn,
 				next = strchr(val, '&');
 				if (next) {
 					vallen = next - val;
-					next++;
-					end_of_key_value_pair_found = 1;
+					end_of_key_value_pair_found = all_data_read;
+					if ((buf + buf_fill) > (val + vallen)) {
+						/* Avoid DoS attacks by having a zero byte in the middle of
+						 * a request that is supposed to be URL encoded. Since this
+						 * request is certainly invalid, according to the protocol
+						 * specification, stop processing it. Fixes #1348 */
+						abort_read = 1;
+						break;
+					}
 				} else {
 					vallen = (ptrdiff_t)strlen(val);
 					next = val + vallen;
@@ -436,7 +481,7 @@ mg_handle_form_request(struct mg_connection *conn,
 #endif
 
 					/* Call callback */
-					url_encoded_field_get(conn,
+					r = url_encoded_field_get(conn,
 					                      ((get_block > 0) ? NULL : buf),
 					                      ((get_block > 0) ? 0
 					                                       : (size_t)keylen),
@@ -444,7 +489,23 @@ mg_handle_form_request(struct mg_connection *conn,
 					                      (size_t)vallen,
 					                      fdh);
 					get_block++;
+					if (r == MG_FORM_FIELD_STORAGE_ABORT) {
+						/* Stop request handling */
+						abort_read = 1;
+						break;
+					}
+					if (r == MG_FORM_FIELD_STORAGE_NEXT) {
+						/* Skip to next field */
+						field_storage = MG_FORM_FIELD_STORAGE_SKIP;
+					}
+				}
+				if (next) {
+					next++;
+				} else {
+					/* vallen may have been modified by url_encoded_field_get */
+					next = val + vallen;
 				}
+
 				if (fstore.access.fp) {
 					size_t n = (size_t)
 					    fwrite(val, 1, (size_t)vallen, fstore.access.fp);
@@ -489,14 +550,18 @@ mg_handle_form_request(struct mg_connection *conn,
 						val = buf;
 					}
 				}
-
 			} while (!end_of_key_value_pair_found);
 
 			if (fstore.access.fp) {
 				r = mg_fclose(&fstore.access);
 				if (r == 0) {
 					/* stored successfully */
-					field_stored(conn, path, file_size, fdh);
+					r = field_stored(conn, path, file_size, fdh);
+					if (r == MG_FORM_FIELD_STORAGE_ABORT) {
+						/* Stop request handling */
+						abort_read = 1;
+						break;
+					}
 				} else {
 					mg_cry(conn, "%s: Error saving file %s", __func__, path);
 					remove_bad_file(conn, path);
@@ -504,6 +569,11 @@ mg_handle_form_request(struct mg_connection *conn,
 				fstore.access.fp = NULL;
 			}
 
+			if ((all_data_read && (buf_fill == 0)) || abort_read) {
+				/* nothing more to process */
+				break;
+			}
+
 			/* Proceed to next entry */
 			used = next - buf;
 			memmove(buf, buf + (size_t)used, sizeof(buf) - (size_t)used);
@@ -829,7 +899,7 @@ mg_handle_form_request(struct mg_connection *conn,
 				towrite -= bl + 4;
 
 				if (field_storage == FORM_FIELD_STORAGE_GET) {
-					unencoded_field_get(conn,
+					r = unencoded_field_get(conn,
 					                    ((get_block > 0) ? NULL : nbeg),
 					                    ((get_block > 0)
 					                         ? 0
@@ -838,6 +908,15 @@ mg_handle_form_request(struct mg_connection *conn,
 					                    towrite,
 					                    fdh);
 					get_block++;
+					if (r == MG_FORM_FIELD_STORAGE_ABORT) {
+						/* Stop request handling */
+						abort_read = 1;
+						break;
+					}
+					if (r == MG_FORM_FIELD_STORAGE_NEXT) {
+						/* Skip to next field */
+						field_storage = MG_FORM_FIELD_STORAGE_SKIP;
+					}
 				}
 
 				if (field_storage == FORM_FIELD_STORAGE_STORE) {
@@ -880,19 +959,29 @@ mg_handle_form_request(struct mg_connection *conn,
 
 				/* Find boundary */
 				next = search_boundary(buf, (size_t)buf_fill, boundary, bl);
+
 			}
 
 			towrite = (size_t)(next - hend);
 
 			if (field_storage == FORM_FIELD_STORAGE_GET) {
 				/* Call callback */
-				unencoded_field_get(conn,
+				r = unencoded_field_get(conn,
 				                    ((get_block > 0) ? NULL : nbeg),
 				                    ((get_block > 0) ? 0
 				                                     : (size_t)(nend - nbeg)),
 				                    hend,
 				                    towrite,
 				                    fdh);
+			        if (r == MG_FORM_FIELD_STORAGE_ABORT) {
+					/* Stop request handling */
+					abort_read = 1;
+					break;
+				}
+				if (r == MG_FORM_FIELD_STORAGE_NEXT) {
+					/* Skip to next field */
+					field_storage = MG_FORM_FIELD_STORAGE_SKIP;
+				}
 			}
 
 			if (field_storage == FORM_FIELD_STORAGE_STORE) {
@@ -911,7 +1000,12 @@ mg_handle_form_request(struct mg_connection *conn,
 						r = mg_fclose(&fstore.access);
 						if (r == 0) {
 							/* stored successfully */
-							field_stored(conn, path, file_size, fdh);
+							r = field_stored(conn, path, file_size, fdh);
+							if (r == MG_FORM_FIELD_STORAGE_ABORT) {
+								/* Stop request handling */
+								abort_read = 1;
+								break;
+							}
 						} else {
 							mg_cry(conn,
 							       "%s: Error saving file %s",
@@ -927,6 +1021,7 @@ mg_handle_form_request(struct mg_connection *conn,
 			if ((field_storage & FORM_FIELD_STORAGE_ABORT)
 			    == FORM_FIELD_STORAGE_ABORT) {
 				/* Stop parsing the request */
+				abort_read = 1;
 				break;
 			}
 
-- 
2.45.4

