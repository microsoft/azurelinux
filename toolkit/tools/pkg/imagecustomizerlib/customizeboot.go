// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

package imagecustomizerlib

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/microsoft/CBL-Mariner/toolkit/tools/imagecustomizerapi"
	"github.com/microsoft/CBL-Mariner/toolkit/tools/imagegen/installutils"
	"github.com/microsoft/CBL-Mariner/toolkit/tools/internal/file"
	"github.com/microsoft/CBL-Mariner/toolkit/tools/internal/logger"
	"github.com/microsoft/CBL-Mariner/toolkit/tools/internal/safechroot"
)

var (
	// Regexes for finding information in the linux kernel-command line args in the grub.cfg file.
	// Note: These regexes assume that the grub.cfg file was generated by either the imager tool or the image customizer
	// tool. If the user manually modified the grub.cfg file, then they might not work correctly.
	linuxCommandLineRegex        = regexp.MustCompile(`(?m)^([\t ]*)linux .* (\$kernelopts)`)
	linuxCommandLineSELinuxRegex = regexp.MustCompile(`(?m)^[\t ]*linux .* (security=selinux selinux=1( enforcing=1)?) `)
	linuxCommandLineInsertRegex  = regexp.MustCompile(`(?m)^[\t ]*linux \$bootprefix/\$mariner_linux `)

	searchCommandRegex = regexp.MustCompile(`(?m)^([\t ]*)search .*`)
	linuxPathRegex     = regexp.MustCompile(`(?m)^[\t ]*linux[\t ]+(.*?)\s`)
	initPathRegex      = regexp.MustCompile(`(?m)^[\t ]*initrd[\t ]+(.*?)\s`)

	// Finds the SELinux mode line in the /etc/selinux/config file.
	selinuxConfigModeRegex = regexp.MustCompile(`(?m)^SELINUX=(\w+)$`)
)

const (
	// The start index of "$kernelopts".
	// Note: regexp returns index pairs. So, "2" is the start index of the 1st group,
	// "4" is the start of the 2nd group, and so on.
	linuxCommandLineRegexIndentStart     = 2
	linuxCommandLineRegexIndentEnd       = 3
	linuxCommandLineRegexKernelOptsStart = 4

	// The start/end indexes of the SELinux args.
	// Note: regexp returns index pairs. So, "2" and "3" are the start and end indexes respectively of the 1st
	// group.
	linuxCommandLineSELinuxRegexSELinuxArgsStart = 2
	linuxCommandLineSELinuxRegexSELinuxArgsEnd   = 3

	// The start index of the "enforcing=1" arg.
	// Note: regexp returns index pairs. So, "4" is start index of the 2nd group.
	linuxCommandLineSELinuxRegexEnforcingStart = 4

	// The index of the SELinux mode value.
	selinuxConfigModeRegexSELinuxMode = 1

	// The index of the search command indent portion
	searchCommandRegexIndentStart = 2
	searchCommandRegexIndentEnd   = 3

	// The start/end indexes of the kernel file path
	linuxPathRegexPathStart = 2
	linuxPathRegexPathEnd   = 3

	// The start/end indexes of the initrd image file
	initPathRegexPathStart    = 2
	initPathRegexPathIndexEnd = 3
)

func replaceSearchCommand(inputGrubCfgContent string, searchCommand string) (outputGrubCfgContent string, err error) {

	// Find the search command.
	match := searchCommandRegex.FindStringSubmatchIndex(inputGrubCfgContent)
	if match == nil {
		return "", fmt.Errorf("failed to find the 'search' command.")
	}
	indent := ""
	if len(match) > searchCommandRegexIndentEnd {
		start := match[searchCommandRegexIndentStart]
		end := match[searchCommandRegexIndentEnd]
		indent = inputGrubCfgContent[start:end]
	}
	// Replace the search command.
	start := match[0]
	end := match[1]
	outputGrubCfgContent = inputGrubCfgContent[:start] + indent + searchCommand + " " + inputGrubCfgContent[end:]

	return outputGrubCfgContent, nil
}

func replaceToken(inputGrubCfgContent string, oldToken string, newToken string) (outputGrubCfgContent string, err error) {

	// escape special characters that would interfer with defining the regular
	// expression correctly.
	tokenRegexpString := regexp.QuoteMeta(oldToken)

	// ensure the string is preceeded with separator (\t or a ' ') and create
	// a group.
	tokenRegexpString = "(?m)[\\t ](" + tokenRegexpString + ")[\\t ]"

	// create the regular expression
	tokenReplacementPath, err := regexp.Compile(tokenRegexpString)
	if err != nil {
		return "", fmt.Errorf("failed to compile regular expression (%s)", tokenRegexpString)
	}

	match := tokenReplacementPath.FindStringSubmatchIndex(inputGrubCfgContent)
	if match == nil {
		return inputGrubCfgContent, nil
	}
	for i := 2; i+1 < len(match); i = i + 2 {
		start := match[i]
		end := match[i+1]

		outputGrubCfgContent = inputGrubCfgContent[:start] + newToken + inputGrubCfgContent[end:]
	}
	return outputGrubCfgContent, nil
}

func setLinuxPath(inputGrubCfgContent string, linuxPath string) (outputGrubCfgContent string, oldKernelPath string, err error) {
	match := linuxPathRegex.FindStringSubmatchIndex(inputGrubCfgContent)
	if match == nil {
		return "", "", fmt.Errorf("failed to find kernel command line.")
	}
	if len(match) <= linuxPathRegexPathEnd {
		return "", "", fmt.Errorf("failed to find kernel command line path.")
	}

	start := match[linuxPathRegexPathStart]
	end := match[linuxPathRegexPathEnd]

	oldKernelPath = inputGrubCfgContent[start:end]
	outputGrubCfgContent = inputGrubCfgContent[:start] + linuxPath + inputGrubCfgContent[end:]

	return outputGrubCfgContent, oldKernelPath, nil
}

func setInitrdPath(inputGrubCfgContent string, initrdPath string) (outputGrubCfgContent string, oldInitrdPath string, err error) {
	match := initPathRegex.FindStringSubmatchIndex(inputGrubCfgContent)
	if match == nil {
		return "", "", fmt.Errorf("failed to find initrd command line.")
	}
	if len(match) <= initPathRegexPathIndexEnd {
		return "", "", fmt.Errorf("failed to find initrd command line path.")
	}

	start := match[initPathRegexPathStart]
	end := match[initPathRegexPathIndexEnd]

	oldInitrdPath = inputGrubCfgContent[start:end]
	outputGrubCfgContent = inputGrubCfgContent[:start] + initrdPath + inputGrubCfgContent[end:]

	return outputGrubCfgContent, oldInitrdPath, nil
}

func appendKernelCommandLineArguments(inputGrubCfgContent string, extraCommandLine string) (outputGrubCfgContent string, err error) {
	// Find the point where the new command line arguments should be inserted.
	match := linuxCommandLineRegex.FindStringSubmatchIndex(inputGrubCfgContent)
	if match == nil {
		return "", fmt.Errorf("failed to find Linux kernel command line params in grub2 config file")
	}
	if len(match) <= linuxCommandLineRegexKernelOptsStart {
		return "", fmt.Errorf("failed to find Linux kernel command line params in grub2 config file")
	}

	start := match[linuxCommandLineRegexKernelOptsStart]

	outputGrubCfgContent = inputGrubCfgContent[:start] + extraCommandLine + " " + inputGrubCfgContent[start:]

	return outputGrubCfgContent, nil
}

func replaceKernelCommandLineArgumentValue(inputGrubCfgContent string, name string, value string) (outputGrubCfgContent string, oldValue string, err error) {

	// just in case the input has some special characters
	escapedName := regexp.QuoteMeta(name)

	// construct the regular expression with one sub-group capturing the old
	// value
	argumentRegexString := "(?m)[\\t ]+linux[\\t ]+.*" + escapedName + "=(.*?)[\\t ]"
	argumentRegex, err := regexp.Compile(argumentRegexString)
	if err != nil {
		return "", "", fmt.Errorf("failed to compile regular expression (%s)", argumentRegexString)
	}

	argumentValueStart := 2
	argumentValueEnd := 3

	// try to find it
	match := argumentRegex.FindStringSubmatchIndex(inputGrubCfgContent)
	if match == nil {
		return "", "", fmt.Errorf("failed to find (%s) command line argument in grub2 config file", name)
	}
	if len(match) <= argumentValueEnd {
		return "", "", fmt.Errorf("failed to find value for (%s).", name)
	}

	start := match[argumentValueStart]
	end := match[argumentValueEnd]

	oldValue = inputGrubCfgContent[start:end]
	outputGrubCfgContent = inputGrubCfgContent[:start] + value + inputGrubCfgContent[end:]

	return outputGrubCfgContent, oldValue, nil
}

func handleKernelCommandLine(kernelExtraArguments imagecustomizerapi.KernelExtraArguments, imageChroot *safechroot.Chroot, partitionsCustomized bool) error {
	var err error

	if partitionsCustomized {
		// ExtraCommandLine was handled when the new image was created and the grub.cfg file was regenerated from
		// scatch.
		return nil
	}

	extraCommandLine := strings.TrimSpace(string(kernelExtraArguments))
	if extraCommandLine == "" {
		// Nothing to do.
		return nil
	}

	logger.Log.Infof("Setting KernelCommandLine.ExtraCommandLine")

	grub2ConfigFile, err := readGrub2ConfigFile(imageChroot)
	if err != nil {
		return err
	}

	newGrub2ConfigFile, err := appendKernelCommandLineArguments(grub2ConfigFile, extraCommandLine)
	if err != nil {
		return err
	}

	// Update grub.cfg file.
	err = writeGrub2ConfigFile(newGrub2ConfigFile, imageChroot)
	if err != nil {
		return err
	}

	return nil
}

// Updates the kernel command-line args with the new SELinux mode.
//
// See, installutils.setGrubCfgSELinux()
func updateSELinuxCommandLine(selinuxMode imagecustomizerapi.SELinux, imageChroot *safechroot.Chroot) error {
	logger.Log.Infof("Updating SELinux kernel command-line args")

	grub2Config, err := readGrub2ConfigFile(imageChroot)
	if err != nil {
		return err
	}

	// Try to find any existing SELinux args.
	selinuxArgsMatch := linuxCommandLineSELinuxRegex.FindStringSubmatchIndex(grub2Config)

	start := 0
	end := 0

	if selinuxArgsMatch == nil {
		// SELinux args are not in the grub.cfg file.
		if selinuxMode == imagecustomizerapi.SELinuxDisabled {
			// Nothing to do.
			return nil
		}

		insertLocationMatch := linuxCommandLineInsertRegex.FindStringIndex(grub2Config)
		if insertLocationMatch == nil {
			return fmt.Errorf("failed to find location to insert SELinux kernel command-line args")
		}

		// Use the end of the regex match as the point to do the insert at.
		start = insertLocationMatch[1]

		// -1 is a sneaky way of adding a whitespace character after the inserted SELinux args.
		end = start - 1
	} else {
		// Get the range of the existing SELinux args, so that they can be replaced with the new SELinux args.

		start = selinuxArgsMatch[linuxCommandLineSELinuxRegexSELinuxArgsStart]
		end = selinuxArgsMatch[linuxCommandLineSELinuxRegexSELinuxArgsEnd]
	}

	newSELinuxArgs := ""
	switch selinuxMode {
	case imagecustomizerapi.SELinuxForceEnforcing:
		newSELinuxArgs = installutils.CmdlineSELinuxForceEnforcing

	case imagecustomizerapi.SELinuxPermissive, imagecustomizerapi.SELinuxEnforcing:
		newSELinuxArgs = installutils.CmdlineSELinuxSettings

	case imagecustomizerapi.SELinuxDisabled:
		newSELinuxArgs = ""

	default:
		return fmt.Errorf("unknown SELinux mode (%s)", selinuxMode)
	}

	// Insert/replace/delete SELinux command-line arguments.
	newGrub2Config := grub2Config[:start] + newSELinuxArgs + grub2Config[end:]

	// Update grub.cfg file.
	err = writeGrub2ConfigFile(newGrub2Config, imageChroot)
	if err != nil {
		return err
	}

	return nil
}

func getCurrentSELinuxMode(imageChroot *safechroot.Chroot) (imagecustomizerapi.SELinux, error) {
	logger.Log.Debugf("Get existing SELinux mode")

	grub2Config, err := readGrub2ConfigFile(imageChroot)
	if err != nil {
		return imagecustomizerapi.SELinuxDefault, err
	}

	// Try to find any existing SELinux args.
	selinuxArgsMatch := linuxCommandLineSELinuxRegex.FindStringSubmatchIndex(grub2Config)
	if selinuxArgsMatch == nil {
		// SELinux not present in the kernel command-line.
		// Therefore, it is disabled.
		return imagecustomizerapi.SELinuxDisabled, nil
	}

	// Check if "enforcing=1" is present.
	// Note: A negative index means an optional sub-match is not present.
	if selinuxArgsMatch[linuxCommandLineSELinuxRegexEnforcingStart] >= 0 {
		return imagecustomizerapi.SELinuxForceEnforcing, nil
	}

	selinuxMode, err := getSELinuxModeFromConfigFile(imageChroot)
	if err != nil {
		return imagecustomizerapi.SELinuxDefault, err
	}

	return selinuxMode, nil
}

func getSELinuxModeFromConfigFile(imageChroot *safechroot.Chroot) (imagecustomizerapi.SELinux, error) {
	selinuxConfigFilePath := filepath.Join(imageChroot.RootDir(), installutils.SELinuxConfigFile)

	// Read the SELinux config file.
	selinuxConfig, err := file.Read(selinuxConfigFilePath)
	if err != nil {
		return imagecustomizerapi.SELinuxDefault, fmt.Errorf("failed to read SELinux config file (%s):\n%w",
			installutils.SELinuxConfigFile, err)
	}

	match := selinuxConfigModeRegex.FindStringSubmatch(selinuxConfig)
	if match == nil {
		return imagecustomizerapi.SELinuxDefault, fmt.Errorf("failed to find SELinux mode in (%s) file",
			installutils.SELinuxConfigFile)
	}

	selinuxConfigMode := match[selinuxConfigModeRegexSELinuxMode]

	switch selinuxConfigMode {
	case installutils.SELinuxConfigEnforcing:
		return imagecustomizerapi.SELinuxEnforcing, nil

	case installutils.SELinuxConfigPermissive:
		return imagecustomizerapi.SELinuxPermissive, nil

	case installutils.SELinuxConfigDisabled:
		return imagecustomizerapi.SELinuxDisabled, nil

	default:
		return imagecustomizerapi.SELinuxDefault, fmt.Errorf("unknown SELinux mode (%s) found in (%s) file",
			selinuxConfigMode, installutils.SELinuxConfigFile)
	}
}

func readGrub2ConfigFile(imageChroot *safechroot.Chroot) (string, error) {
	logger.Log.Debugf("Reading grub.cfg file")

	grub2ConfigFilePath := getGrub2ConfigFilePath(imageChroot)

	// Read the existing grub.cfg file.
	grub2Config, err := file.Read(grub2ConfigFilePath)
	if err != nil {
		return "", fmt.Errorf("failed to read existing grub2 config file (%s):\n%w", installutils.GrubCfgFile, err)
	}

	return grub2Config, nil
}

func writeGrub2ConfigFile(grub2Config string, imageChroot *safechroot.Chroot) error {
	logger.Log.Debugf("Writing grub.cfg file")

	grub2ConfigFilePath := getGrub2ConfigFilePath(imageChroot)

	// Update grub.cfg file.
	err := os.WriteFile(grub2ConfigFilePath, []byte(grub2Config), 0)
	if err != nil {
		return fmt.Errorf("failed to write new grub2 config file (%s):\n%w", installutils.GrubCfgFile, err)
	}

	return nil
}

func getGrub2ConfigFilePath(imageChroot *safechroot.Chroot) string {
	return filepath.Join(imageChroot.RootDir(), installutils.GrubCfgFile)
}
