// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

package imagecustomizerlib

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/microsoft/azurelinux/toolkit/tools/imagecustomizerapi"
	"github.com/microsoft/azurelinux/toolkit/tools/imagegen/installutils"
	"github.com/microsoft/azurelinux/toolkit/tools/internal/file"
	"github.com/microsoft/azurelinux/toolkit/tools/internal/logger"
	"github.com/microsoft/azurelinux/toolkit/tools/internal/safechroot"
)

var (
	// Regexes for finding information in the linux kernel-command line args in the grub.cfg file.
	// Note: These regexes assume that the grub.cfg file was generated by either the imager tool or the image customizer
	// tool. If the user manually modified the grub.cfg file, then they might not work correctly.
	linuxCommandLineRegex       = regexp.MustCompile(`(?m)^([\t ]*)linux .* (\$kernelopts)`)
	linuxCommandLineInsertRegex = regexp.MustCompile(`(?m)^[\t ]*linux \$bootprefix/\$mariner_linux `)

	searchCommandRegex = regexp.MustCompile(`(?m)^([\t ]*)search .*`)
	linuxPathRegex     = regexp.MustCompile(`(?m)^[\t ]*linux[\t ]+(.*?)\s`)
	initPathRegex      = regexp.MustCompile(`(?m)^[\t ]*initrd[\t ]+(.*?)\s`)

	// Finds the SELinux mode line in the /etc/selinux/config file.
	selinuxConfigModeRegex = regexp.MustCompile(`(?m)^SELINUX=(\w+)$`)
)

const (
	// The start index of "$kernelopts".
	// Note: regexp returns index pairs. So, "2" is the start index of the 1st group,
	// "4" is the start of the 2nd group, and so on.
	linuxCommandLineRegexIndentStart     = 2
	linuxCommandLineRegexIndentEnd       = 3
	linuxCommandLineRegexKernelOptsStart = 4

	// The index of the SELinux mode value.
	selinuxConfigModeRegexSELinuxMode = 1

	// The index of the search command indent portion
	searchCommandRegexIndentStart = 2
	searchCommandRegexIndentEnd   = 3

	// The start/end indexes of the kernel file path
	linuxPathRegexPathStart = 2
	linuxPathRegexPathEnd   = 3

	// The start/end indexes of the initrd image file
	initPathRegexPathStart    = 2
	initPathRegexPathIndexEnd = 3
)

func replaceSearchCommand(inputGrubCfgContent string, searchCommand string) (outputGrubCfgContent string, err error) {

	// Find the search command.
	match := searchCommandRegex.FindStringSubmatchIndex(inputGrubCfgContent)
	if match == nil {
		return "", fmt.Errorf("failed to find the 'search' command")
	}
	indent := ""
	if len(match) > searchCommandRegexIndentEnd {
		start := match[searchCommandRegexIndentStart]
		end := match[searchCommandRegexIndentEnd]
		indent = inputGrubCfgContent[start:end]
	}
	// Replace the search command.
	start := match[0]
	end := match[1]
	outputGrubCfgContent = inputGrubCfgContent[:start] + indent + searchCommand + " " + inputGrubCfgContent[end:]

	return outputGrubCfgContent, nil
}

func replaceToken(inputGrubCfgContent string, oldToken string, newToken string) (outputGrubCfgContent string, err error) {

	// escape special characters that would interfer with defining the regular
	// expression correctly.
	tokenRegexpString := regexp.QuoteMeta(oldToken)

	// ensure the string is preceeded with separator (\t or a ' ') and create
	// a group.
	tokenRegexpString = "(?m)[\\t ](" + tokenRegexpString + ")[\\t ]"

	// create the regular expression
	tokenReplacementPath, err := regexp.Compile(tokenRegexpString)
	if err != nil {
		return "", fmt.Errorf("failed to compile regular expression (%s)", tokenRegexpString)
	}

	match := tokenReplacementPath.FindStringSubmatchIndex(inputGrubCfgContent)
	if match == nil {
		return inputGrubCfgContent, nil
	}
	for i := 2; i+1 < len(match); i = i + 2 {
		start := match[i]
		end := match[i+1]

		outputGrubCfgContent = inputGrubCfgContent[:start] + newToken + inputGrubCfgContent[end:]
	}
	return outputGrubCfgContent, nil
}

func setLinuxPath(inputGrubCfgContent string, linuxPath string) (outputGrubCfgContent string, oldKernelPath string, err error) {
	match := linuxPathRegex.FindStringSubmatchIndex(inputGrubCfgContent)
	if match == nil {
		return "", "", fmt.Errorf("failed to find kernel command line")
	}
	if len(match) <= linuxPathRegexPathEnd {
		return "", "", fmt.Errorf("failed to find kernel command line path")
	}

	start := match[linuxPathRegexPathStart]
	end := match[linuxPathRegexPathEnd]

	oldKernelPath = inputGrubCfgContent[start:end]
	outputGrubCfgContent = inputGrubCfgContent[:start] + linuxPath + inputGrubCfgContent[end:]

	return outputGrubCfgContent, oldKernelPath, nil
}

func setInitrdPath(inputGrubCfgContent string, initrdPath string) (outputGrubCfgContent string, oldInitrdPath string, err error) {
	match := initPathRegex.FindStringSubmatchIndex(inputGrubCfgContent)
	if match == nil {
		return "", "", fmt.Errorf("failed to find initrd command line")
	}
	if len(match) <= initPathRegexPathIndexEnd {
		return "", "", fmt.Errorf("failed to find initrd command line's path arg")
	}

	start := match[initPathRegexPathStart]
	end := match[initPathRegexPathIndexEnd]

	oldInitrdPath = inputGrubCfgContent[start:end]
	outputGrubCfgContent = inputGrubCfgContent[:start] + initrdPath + inputGrubCfgContent[end:]

	return outputGrubCfgContent, oldInitrdPath, nil
}

func appendKernelCommandLineArguments(inputGrubCfgContent string, extraCommandLine string) (outputGrubCfgContent string, err error) {
	// Find the point where the new command line arguments should be inserted.
	match := linuxCommandLineRegex.FindStringSubmatchIndex(inputGrubCfgContent)
	if match == nil {
		return "", fmt.Errorf("failed to find Linux kernel command line params in grub2 config file")
	}
	if len(match) <= linuxCommandLineRegexKernelOptsStart {
		return "", fmt.Errorf("failed to find Linux kernel command line params in grub2 config file")
	}

	start := match[linuxCommandLineRegexKernelOptsStart]

	outputGrubCfgContent = inputGrubCfgContent[:start] + extraCommandLine + " " + inputGrubCfgContent[start:]

	return outputGrubCfgContent, nil
}

// Tries to find the specified kernel CLI arg. Does not fail if the arg is not found.
//
// Returns:
// - startIndex: The string index where the arg was found. Or -1 if not found.
// - endIndex: The string index of the end of the arg. Or -1 if not found.
// - value: The value of the arg. Or "" if not found.
func findKernelCommandLineArgumentArg(grub2Config string, name string) (int, int, string, error) {
	const (
		argGroupIndex      = 2
		argGroupStartIndex = argGroupIndex*2 + 0
		argGroupEndIndex   = argGroupIndex*2 + 1

		argValueGroupIndex      = 4
		argValueGroupStartIndex = argValueGroupIndex*2 + 0
		argValueGroupEndIndex   = argValueGroupIndex*2 + 1
	)

	escapedName := regexp.QuoteMeta(name)

	// "linux ... <name>=<value> ..."
	argumentRegexString := "(?m)[\\t ]+linux[\\t ](.*[\\t ])?(" + escapedName + "(=(\\S*)?)?)[\\t ]"
	argumentRegex, err := regexp.Compile(argumentRegexString)
	if err != nil {
		return 0, 0, "", fmt.Errorf("failed to compile regular expression to find (%s) kernel arg:\n%w", name, err)
	}

	match := argumentRegex.FindStringSubmatchIndex(grub2Config)
	if match == nil {
		// Arg not found.
		return -1, -1, "", nil
	}

	argValue := ""
	if len(match) > argValueGroupEndIndex {
		argValueStartIndex := match[argValueGroupStartIndex]
		argValueEndIndex := match[argValueGroupEndIndex]
		argValue = grub2Config[argValueStartIndex:argValueEndIndex]
	}

	argStartIndex := match[argGroupStartIndex]
	argEndIndex := match[argGroupEndIndex]

	return argStartIndex, argEndIndex, argValue, nil
}

func replaceKernelCommandLineArgumentValue(inputGrubCfgContent string, name string, value string,
) (outputGrubCfgContent string, oldValue string, err error) {
	// Search for the arg.
	start, end, oldValue, err := findKernelCommandLineArgumentArg(inputGrubCfgContent, name)
	if err != nil {
		return "", "", err
	}

	if start == -1 {
		return "", "", fmt.Errorf("failed to find kernel arg value for (%s)", name)
	}

	outputGrubCfgContent = fmt.Sprintf("%s%s=%s%s", inputGrubCfgContent[:start], name, value, inputGrubCfgContent[end:])

	return outputGrubCfgContent, oldValue, nil
}

// Tries to remove the specified kernel CLI arg from the grub file. Does not fail if the arg is not present.
//
// Returns:
// - outputGrubCfgContent: The resulting grub.cfg file.
// - index: The index in the grub.cfg where the arg was removed from. Or -1 if not found.
func tryRemoveKernelCommandLineArgumentValue(inputGrubCfgContent string, name string) (string, int, error) {
	// Search for the kernel CLI arg.
	start, end, _, err := findKernelCommandLineArgumentArg(inputGrubCfgContent, name)
	if err != nil {
		return "", 0, err
	}

	if start == -1 {
		// Arg not found.
		return inputGrubCfgContent, -1, nil
	}

	// Remove the arg.
	outputGrubCfgContent := inputGrubCfgContent[:start] + inputGrubCfgContent[end:]
	return outputGrubCfgContent, start, nil
}

func addKernelCommandLine(kernelExtraArguments imagecustomizerapi.KernelExtraArguments,
	imageChroot *safechroot.Chroot,
) error {
	var err error

	extraCommandLine := strings.TrimSpace(string(kernelExtraArguments))
	if extraCommandLine == "" {
		// Nothing to do.
		return nil
	}

	logger.Log.Infof("Setting KernelCommandLine.ExtraCommandLine")

	grub2ConfigFile, err := readGrub2ConfigFile(imageChroot)
	if err != nil {
		return err
	}

	newGrub2ConfigFile, err := appendKernelCommandLineArguments(grub2ConfigFile, extraCommandLine)
	if err != nil {
		return err
	}

	// Update grub.cfg file.
	err = writeGrub2ConfigFile(newGrub2ConfigFile, imageChroot)
	if err != nil {
		return err
	}

	return nil
}

// Updates the kernel command-line args with the new SELinux mode.
//
// See, installutils.setGrubCfgSELinux()
func updateSELinuxCommandLine(selinuxMode imagecustomizerapi.SELinuxMode, imageChroot *safechroot.Chroot) error {
	logger.Log.Infof("Updating SELinux kernel command-line args")

	grub2Config, err := readGrub2ConfigFile(imageChroot)
	if err != nil {
		return err
	}

	newGrub2Config, err := updateSELinuxCommandLineHelper(grub2Config, selinuxMode)
	if err != nil {
		return err
	}

	// Update grub.cfg file.
	err = writeGrub2ConfigFile(newGrub2Config, imageChroot)
	if err != nil {
		return err
	}

	return nil
}

func updateSELinuxCommandLineHelper(grub2Config string, selinuxMode imagecustomizerapi.SELinuxMode) (string, error) {
	// Remove all the existing SELinux args.
	grub2Config, securityIndex, err := tryRemoveKernelCommandLineArgumentValue(grub2Config, "security")
	if err != nil {
		return "", err
	}

	grub2Config, selinuxIndex, err := tryRemoveKernelCommandLineArgumentValue(grub2Config, "selinux")
	if err != nil {
		return "", err
	}

	grub2Config, enforcingIndex, err := tryRemoveKernelCommandLineArgumentValue(grub2Config, "enforcing")
	if err != nil {
		return "", err
	}

	if selinuxMode == imagecustomizerapi.SELinuxModeDisabled {
		// Don't need to insert any new args.
		return grub2Config, nil
	}

	// Find a location to add the new SELinux args.
	insertIndex := -1
	if insertIndex == -1 {
		insertIndex = enforcingIndex
	}

	if insertIndex == -1 {
		insertIndex = selinuxIndex
	}

	if insertIndex == -1 {
		insertIndex = securityIndex
	}

	if insertIndex == -1 {
		insertLocationMatch := linuxCommandLineInsertRegex.FindStringIndex(grub2Config)
		if insertLocationMatch == nil {
			return "", fmt.Errorf("failed to find location to insert SELinux kernel command-line args")
		}

		// Use the end of the regex match as the point to do the insert at.
		insertIndex = insertLocationMatch[1]
	}

	newSELinuxArgs := ""
	switch selinuxMode {
	case imagecustomizerapi.SELinuxModeForceEnforcing:
		newSELinuxArgs = installutils.CmdlineSELinuxForceEnforcing

	case imagecustomizerapi.SELinuxModePermissive, imagecustomizerapi.SELinuxModeEnforcing:
		newSELinuxArgs = installutils.CmdlineSELinuxSettings

	default:
		return "", fmt.Errorf("unknown SELinux mode (%s)", selinuxMode)
	}

	// Insert/replace/delete SELinux command-line arguments.
	grub2Config = fmt.Sprintf("%s %s %s", grub2Config[:insertIndex], newSELinuxArgs, grub2Config[insertIndex:])
	return grub2Config, nil
}

func getCurrentSELinuxMode(imageChroot *safechroot.Chroot) (imagecustomizerapi.SELinuxMode, error) {
	logger.Log.Debugf("Get existing SELinux mode")

	grub2Config, err := readGrub2ConfigFile(imageChroot)
	if err != nil {
		return imagecustomizerapi.SELinuxModeDefault, err
	}

	// Try to find any existing SELinux args.
	_, _, securityValue, err := findKernelCommandLineArgumentArg(grub2Config, "security")
	if err != nil {
		return imagecustomizerapi.SELinuxModeDefault, err
	}

	_, _, selinuxValue, err := findKernelCommandLineArgumentArg(grub2Config, "selinux")
	if err != nil {
		return imagecustomizerapi.SELinuxModeDefault, err
	}

	_, _, enforcingValue, err := findKernelCommandLineArgumentArg(grub2Config, "enforcing")
	if err != nil {
		return imagecustomizerapi.SELinuxModeDefault, err
	}

	// Check if SELinux is disabled.
	if securityValue != "selinux" || selinuxValue != "1" {
		return imagecustomizerapi.SELinuxModeDisabled, nil
	}

	// Check if SELinux is in forced enforcing mode.
	if enforcingValue == "1" {
		return imagecustomizerapi.SELinuxModeForceEnforcing, nil
	}

	selinuxMode, err := getSELinuxModeFromConfigFile(imageChroot)
	if err != nil {
		return imagecustomizerapi.SELinuxModeDefault, err
	}

	return selinuxMode, nil
}

func getSELinuxModeFromConfigFile(imageChroot *safechroot.Chroot) (imagecustomizerapi.SELinuxMode, error) {
	selinuxConfigFilePath := filepath.Join(imageChroot.RootDir(), installutils.SELinuxConfigFile)

	// Read the SELinux config file.
	selinuxConfig, err := file.Read(selinuxConfigFilePath)
	if err != nil {
		return imagecustomizerapi.SELinuxModeDefault, fmt.Errorf("failed to read SELinux config file (%s):\n%w",
			installutils.SELinuxConfigFile, err)
	}

	match := selinuxConfigModeRegex.FindStringSubmatch(selinuxConfig)
	if match == nil {
		return imagecustomizerapi.SELinuxModeDefault, fmt.Errorf("failed to find SELinux mode in (%s) file",
			installutils.SELinuxConfigFile)
	}

	selinuxConfigMode := match[selinuxConfigModeRegexSELinuxMode]

	switch selinuxConfigMode {
	case installutils.SELinuxConfigEnforcing:
		return imagecustomizerapi.SELinuxModeEnforcing, nil

	case installutils.SELinuxConfigPermissive:
		return imagecustomizerapi.SELinuxModePermissive, nil

	case installutils.SELinuxConfigDisabled:
		return imagecustomizerapi.SELinuxModeDisabled, nil

	default:
		return imagecustomizerapi.SELinuxModeDefault, fmt.Errorf("unknown SELinux mode (%s) found in (%s) file",
			selinuxConfigMode, installutils.SELinuxConfigFile)
	}
}

func readGrub2ConfigFile(imageChroot *safechroot.Chroot) (string, error) {
	logger.Log.Debugf("Reading grub.cfg file")

	grub2ConfigFilePath := getGrub2ConfigFilePath(imageChroot)

	// Read the existing grub.cfg file.
	grub2Config, err := file.Read(grub2ConfigFilePath)
	if err != nil {
		return "", fmt.Errorf("failed to read existing grub2 config file (%s):\n%w", installutils.GrubCfgFile, err)
	}

	return grub2Config, nil
}

func writeGrub2ConfigFile(grub2Config string, imageChroot *safechroot.Chroot) error {
	logger.Log.Debugf("Writing grub.cfg file")

	grub2ConfigFilePath := getGrub2ConfigFilePath(imageChroot)

	// Update grub.cfg file.
	err := os.WriteFile(grub2ConfigFilePath, []byte(grub2Config), 0)
	if err != nil {
		return fmt.Errorf("failed to write new grub2 config file (%s):\n%w", installutils.GrubCfgFile, err)
	}

	return nil
}

func getGrub2ConfigFilePath(imageChroot *safechroot.Chroot) string {
	return filepath.Join(imageChroot.RootDir(), installutils.GrubCfgFile)
}
