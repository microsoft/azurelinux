// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

package imagecustomizerlib

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/microsoft/CBL-Mariner/toolkit/tools/imagecustomizerapi"
	"github.com/microsoft/CBL-Mariner/toolkit/tools/imagegen/installutils"
	"github.com/microsoft/CBL-Mariner/toolkit/tools/internal/file"
	"github.com/microsoft/CBL-Mariner/toolkit/tools/internal/logger"
	"github.com/microsoft/CBL-Mariner/toolkit/tools/internal/safechroot"
)

var (
	// Regexes for finding information in the linux kernel-command line args in the grub.cfg file.
	// Note: These regexes assume that the grub.cfg file was generated by either the imager tool or the image customizer
	// tool. If the user manually modified the grub.cfg file, then they might not work correctly.
	linuxCommandLineRegex        = regexp.MustCompile(`\tlinux .* (\$kernelopts)`)
	linuxCommandLineSELinuxRegex = regexp.MustCompile(`\tlinux .* (security=selinux selinux=1( enforcing=1)?) `)
	linuxCommandLineInsertRegex  = regexp.MustCompile(`\tlinux \$bootprefix/\$mariner_linux `)

	// Finds the SELinux mode line in the /etc/selinux/config file.
	selinuxConfigModeRegex = regexp.MustCompile(`(?m)^SELINUX=(\w+)$`)
)

const (
	// The start index of "$kernelopts".
	// Note: regexp returns index pairs. So, "2" is the start index of the 1st group.
	linuxCommandLineRegexKernelOptsStart = 2

	// The start/end indexes of the SELinux args.
	// Note: regexp returns index pairs. So, "2" and "3" are the start and end indexes respectively of the 1st
	// group.
	linuxCommandLineSELinuxRegexSELinuxArgsStart = 2
	linuxCommandLineSELinuxRegexSELinuxArgsEnd   = 3

	// The start index of the "enforcing=1" arg.
	// Note: regexp returns index pairs. So, "4" is start index of the 2nd group.
	linuxCommandLineSELinuxRegexEnforcingStart = 4

	// The index of the SELinux mode value.
	selinuxConfigModeRegexSELinuxMode = 1
)

func handleKernelCommandLine(kernelExtraArguments imagecustomizerapi.KernelExtraArguments, imageChroot *safechroot.Chroot, partitionsCustomized bool) error {
	var err error

	if partitionsCustomized {
		// ExtraCommandLine was handled when the new image was created and the grub.cfg file was regenerated from
		// scatch.
		return nil
	}

	extraCommandLine := strings.TrimSpace(string(kernelExtraArguments))
	if extraCommandLine == "" {
		// Nothing to do.
		return nil
	}

	logger.Log.Infof("Setting KernelCommandLine.ExtraCommandLine")

	grub2ConfigFile, err := readGrub2ConfigFile(imageChroot)
	if err != nil {
		return err
	}

	// Find the point where the new command line arguments should be added.
	match := linuxCommandLineRegex.FindStringSubmatchIndex(grub2ConfigFile)
	if match == nil {
		return fmt.Errorf("failed to find Linux kernel command line params in grub2 config file")
	}

	// Get the location of "$kernelopts".
	insertIndex := match[linuxCommandLineRegexKernelOptsStart]

	// Insert new command line arguments.
	newGrub2ConfigFile := grub2ConfigFile[:insertIndex] + extraCommandLine + " " + grub2ConfigFile[insertIndex:]

	// Update grub.cfg file.
	err = writeGrub2ConfigFile(newGrub2ConfigFile, imageChroot)
	if err != nil {
		return err
	}

	return nil
}

// Updates the kernel command-line args with the new SELinux mode.
//
// See, installutils.setGrubCfgSELinux()
func updateSELinuxCommandLine(selinuxMode imagecustomizerapi.SELinux, imageChroot *safechroot.Chroot) error {
	logger.Log.Infof("Updating SELinux kernel command-line args")

	grub2Config, err := readGrub2ConfigFile(imageChroot)
	if err != nil {
		return err
	}

	// Try to find any existing SELinux args.
	selinuxArgsMatch := linuxCommandLineSELinuxRegex.FindStringSubmatchIndex(grub2Config)

	start := 0
	end := 0

	if selinuxArgsMatch == nil {
		// SELinux args are not in the grub.cfg file.
		if selinuxMode == imagecustomizerapi.SELinuxDisabled {
			// Nothing to do.
			return nil
		}

		insertLocationMatch := linuxCommandLineInsertRegex.FindStringIndex(grub2Config)
		if insertLocationMatch == nil {
			return fmt.Errorf("failed to find location to insert SELinux kernel command-line args")
		}

		// Use the end of the regex match as the point to do the insert at.
		start = insertLocationMatch[1]

		// -1 is a sneaky way of adding a whitespace character after the inserted SELinux args.
		end = start - 1
	} else {
		// Get the range of the existing SELinux args, so that they can be replaced with the new SELinux args.

		start = selinuxArgsMatch[linuxCommandLineSELinuxRegexSELinuxArgsStart]
		end = selinuxArgsMatch[linuxCommandLineSELinuxRegexSELinuxArgsEnd]
	}

	newSELinuxArgs := ""
	switch selinuxMode {
	case imagecustomizerapi.SELinuxForceEnforcing:
		newSELinuxArgs = installutils.CmdlineSELinuxForceEnforcing

	case imagecustomizerapi.SELinuxPermissive, imagecustomizerapi.SELinuxEnforcing:
		newSELinuxArgs = installutils.CmdlineSELinuxSettings

	case imagecustomizerapi.SELinuxDisabled:
		newSELinuxArgs = ""

	default:
		return fmt.Errorf("unknown SELinux mode (%s)", selinuxMode)
	}

	// Insert/replace/delete SELinux command-line arguments.
	newGrub2Config := grub2Config[:start] + newSELinuxArgs + grub2Config[end:]

	// Update grub.cfg file.
	err = writeGrub2ConfigFile(newGrub2Config, imageChroot)
	if err != nil {
		return err
	}

	return nil
}

func getCurrentSELinuxMode(imageChroot *safechroot.Chroot) (imagecustomizerapi.SELinux, error) {
	logger.Log.Debugf("Get existing SELinux mode")

	grub2Config, err := readGrub2ConfigFile(imageChroot)
	if err != nil {
		return imagecustomizerapi.SELinuxDefault, err
	}

	// Try to find any existing SELinux args.
	selinuxArgsMatch := linuxCommandLineSELinuxRegex.FindStringSubmatchIndex(grub2Config)
	if selinuxArgsMatch == nil {
		// SELinux not present in the kernel command-line.
		// Therefore, it is disabled.
		return imagecustomizerapi.SELinuxDisabled, nil
	}

	// Check if "enforcing=1" is present.
	// Note: A negative index means an optional sub-match is not present.
	if selinuxArgsMatch[linuxCommandLineSELinuxRegexEnforcingStart] >= 0 {
		return imagecustomizerapi.SELinuxForceEnforcing, nil
	}

	selinuxMode, err := getSELinuxModeFromConfigFile(imageChroot)
	if err != nil {
		return imagecustomizerapi.SELinuxDefault, err
	}

	return selinuxMode, nil
}

func getSELinuxModeFromConfigFile(imageChroot *safechroot.Chroot) (imagecustomizerapi.SELinux, error) {
	selinuxConfigFilePath := filepath.Join(imageChroot.RootDir(), installutils.SELinuxConfigFile)

	// Read the SELinux config file.
	selinuxConfig, err := file.Read(selinuxConfigFilePath)
	if err != nil {
		return imagecustomizerapi.SELinuxDefault, fmt.Errorf("failed to read SELinux config file (%s):\n%w",
			installutils.SELinuxConfigFile, err)
	}

	match := selinuxConfigModeRegex.FindStringSubmatch(selinuxConfig)
	if match == nil {
		return imagecustomizerapi.SELinuxDefault, fmt.Errorf("failed to find SELinux mode in (%s) file",
			installutils.SELinuxConfigFile)
	}

	selinuxConfigMode := match[selinuxConfigModeRegexSELinuxMode]

	switch selinuxConfigMode {
	case installutils.SELinuxConfigEnforcing:
		return imagecustomizerapi.SELinuxEnforcing, nil

	case installutils.SELinuxConfigPermissive:
		return imagecustomizerapi.SELinuxPermissive, nil

	case installutils.SELinuxConfigDisabled:
		return imagecustomizerapi.SELinuxDisabled, nil

	default:
		return imagecustomizerapi.SELinuxDefault, fmt.Errorf("unknown SELinux mode (%s) found in (%s) file",
			selinuxConfigMode, installutils.SELinuxConfigFile)
	}
}

func readGrub2ConfigFile(imageChroot *safechroot.Chroot) (string, error) {
	logger.Log.Debugf("Reading grub.cfg file")

	grub2ConfigFilePath := getGrub2ConfigFilePath(imageChroot)

	// Read the existing grub.cfg file.
	grub2Config, err := file.Read(grub2ConfigFilePath)
	if err != nil {
		return "", fmt.Errorf("failed to read existing grub2 config file (%s):\n%w", installutils.GrubCfgFile, err)
	}

	return grub2Config, nil
}

func writeGrub2ConfigFile(grub2Config string, imageChroot *safechroot.Chroot) error {
	logger.Log.Debugf("Writing grub.cfg file")

	grub2ConfigFilePath := getGrub2ConfigFilePath(imageChroot)

	// Update grub.cfg file.
	err := os.WriteFile(grub2ConfigFilePath, []byte(grub2Config), 0)
	if err != nil {
		return fmt.Errorf("failed to write new grub2 config file (%s):\n%w", installutils.GrubCfgFile, err)
	}

	return nil
}

func getGrub2ConfigFilePath(imageChroot *safechroot.Chroot) string {
	return filepath.Join(imageChroot.RootDir(), installutils.GrubCfgFile)
}
