# PRD: Agent Instructions and Skills for Azure Linux

Title: PRD: Agent Instructions and Skills for Azure Linux
Author: Daniel McIlvaney
Created: 2026-01-29
Updated: 2026-02-11
Status: Draft

## Overview

This PRD defines the foundation for AI agent support in the Azure Linux repository. The goal is to enable agents to effectively assist with component management workflows using the `azldev` tool, while maintaining code quality and repository hygiene standards.

**Related ideas:** None (greenfield)

## Problem Statement

Azure Linux component maintainers will benefit from AI agent assistance for common workflows:

- Adding new components to the distro
- Updating existing components (version bumps, dependency changes)
- Writing and debugging overlays (spec modifications)
- Maintaining repository hygiene (file organization, consistent patterns)

Without proper instructions, agents lack context about:

- The TOML-based metadata system (`*.comp.toml`, `*.distro.toml`)
- The overlay system for modifying upstream specs
- The `azldev` tool commands and workflows
- Repository conventions and hygiene requirements
- Component specific workflows

## Target Users

- **v1:** Azure Linux team members
- **Future:** External contributors (instructions should not assume internal-only context, referenced tools should be publicly available)

## Cross-Platform Compatibility Strategy

Instruction files should work across GitHub Copilot surfaces where possible: VS Code, Visual Studio, GitHub.com, and Copilot CLI. This PRD prefers GitHub-standard locations over tool-specific ones.

| Mechanism | Discovery | Supported Surfaces |
| --------- | --------- | ------------------ |
| `.github/copilot-instructions.md` | Auto | VS Code, Visual Studio, GitHub.com, Copilot CLI |
| `AGENTS.md` (root and subdirectories) | Auto | VS Code, Copilot CLI |
| Agent Skills (`.github/skills/*/SKILL.md`) | On-demand (description match) | VS Code, Copilot CLI, Copilot coding agent ([open standard](https://agentskills.io/)) |
| `.github/instructions/*.instructions.md` | Auto (via `applyTo` globs) | VS Code, Copilot CLI |
| `.github/agents/*.agent.md` | User-selected / inferred | VS Code, Copilot CLI |
| `.github/prompts/*.prompt.md` | User-invoked (`/command`) | VS Code only |
| `.vscode/mcp.json` | Auto | VS Code only |

**Guiding principles:**

1. **Passive context first.** Domain knowledge that agents need regularly (TOML structure, overlay types, component patterns) should live in always-available passive context (`copilot-instructions.md`, `AGENTS.md`, `.instructions.md`), not behind on-demand skill triggering. In practice, models often avoid triggering skills, while passive context is guaranteed to be loaded. Skills are best for explicit, multi-step task workflows.
2. **Cross-platform by default.** Most instruction file types are now cross-platform (Copilot CLI supports `copilot-instructions.md`, `AGENTS.md`, `.instructions.md`, agents, and skills). The main exception is `.prompt.md` files, which are VS Code only.
3. **Minimize context rot.** Keep always-loaded files (copilot-instructions.md, AGENTS.md) as lean as possible — guardrails and pointers, not reference manuals. Detailed content goes in `.instructions.md` (loaded by file type) or skills (loaded by task intent).

## Scope

### In Scope (v1)

1. **Repository-wide instructions** (`.github/copilot-instructions.md`) — *cross-platform*
   - Overview of Azure Linux architecture
   - Key directories and their purposes
   - Common workflows at a high level
   - Links to detailed guidance

2. **File-type specific instructions** (`.instructions.md` with `applyTo` globs) — *cross-platform (VS Code, Copilot CLI)*
   - `*.comp.toml` - Component definition files
   - `*.distro.toml` - Distro configuration files
   - `*.spec` - RPM spec files (hand-coded)
   - `generated/*.spec` - RPM spec files (generated by azldev, generated spec feature is undecided)

3. **Directory-specific instructions** (`AGENTS.md` files) — *cross-platform*
   - `AGENTS.md` (root) - Guardrails, conventions, skill pointers
   - `base/comps/AGENTS.md` - Component file organization rules, skill pointers
   - `distro/AGENTS.md` - Distro configuration guidance (build defaults, shared config)
   - **Design principle:** AGENTS.md files should be short guardrail documents — conventions and "do/don't" rules. Detailed workflows and examples belong in skills or `.instructions.md` files.

4. **Agent Skills** (`.github/skills/*/SKILL.md`) — *cross-platform ([open standard](https://agentskills.io/))*
   - `azl-add-component/SKILL.md` - Adding a new component to the distro
   - `azl-fix-overlay/SKILL.md` - Diagnosing and fixing overlay issues
   - `azl-build-component/SKILL.md` - Building, testing, and debugging components
   - `azl-mock/SKILL.md` - Testing and inspecting packages in mock chroots
   - `azl-review-component/SKILL.md` - Reviewing component definitions for hygiene and best practices
   - Each skill is a directory containing a `SKILL.md` (with required `name` and `description` YAML frontmatter) plus optional scripts, examples, and resources. Skills are discovered on-demand based on description matching.
   - **Design principle:** Skills are for explicit, multi-step task workflows — not general domain knowledge. Domain knowledge belongs in passive context (`.instructions.md`, `AGENTS.md`) where it's available without the agent needing to decide to load it. AGENTS.md files link to skills for discoverability, but links are not required for skill triggering.

5. **Experimental custom agents** (`.github/agents/*.agent.md`, 1-2 maximum) — *cross-platform (VS Code, Copilot CLI)*
   - Consider: Component reviewer agent, Overlay specialist agent
   - Agents use `.agent.md` files with optional YAML frontmatter (`description`, `tools`, `model`, `handoffs`)
   - Consider handoffs between agents for multi-step workflows (e.g., review → fix)
   - Copilot CLI discovers agents from `.github/agents/`, `~/.copilot/agents/`, and org-level locations

6. **Prompt templates** (`.github/prompts/*.prompt.md`) — *VS Code only*
   - `azl-add-component.prompt.md` - Guided workflow for adding a new component
   - `azl-update-component.prompt.md` - Guided workflow for updating an existing component
   - `azl-review-component.prompt.md` - Review a component for hygiene and best practices
   - `azl-debug-component.prompt.md` - Diagnose and fix overlay failures and build errors
   - `azl-migrate-component.prompt.md` - Migrate inline component to dedicated file
   - **Design principle:** Prompts follow a two-tier model. **Tier 1** (skill-backed): when a dedicated skill exists, the prompt is a thin wrapper that collects input and references the skill. **Tier 2** (orchestrator): when no dedicated skill exists, the prompt encodes its own workflow logic and references *multiple* existing skills and instruction files. This avoids creating skills just to back a prompt (YAGNI). Both tiers ensure Copilot CLI users get equivalent guidance via automatic skill discovery.
   - See the [VS Code prompt files documentation](https://code.visualstudio.com/docs/copilot/customization/prompt-files) for prompt file syntax and features.

### Out of Scope (v1)

- CI/CD integration (no meaningful CI exists yet)
  - Pre-commit hooks should be considered future work
- Full MCP server integration (partial support exists; see MCP Integration Roadmap section)
- External contributor onboarding flows
- Automated regeneration of agent instructions via `azldev`

## Technical Design

### Directory Structure

```text
azurelinux/
├── .github/
│   ├── copilot-instructions.md         # Repository-wide instructions (cross-platform)
│   ├── instructions/                    # File-type specific instructions (cross-platform)
│   │   ├── comp-toml.instructions.md
│   │   └── spec.instructions.md
│   ├── prompts/                         # Prompt templates (VS Code only)
│   │   ├── azl-add-component.prompt.md
│   │   └── ...
│   ├── agents/                          # Custom agents (cross-platform)
│   │   └── *.agent.md
│   └── skills/                          # Agent Skills (cross-platform, open standard)
│       ├── azl-add-component/
│       │   └── SKILL.md
│       ├── azl-fix-overlay/
│       │   └── SKILL.md
│       ├── azl-build-component/
│       │   └── SKILL.md
│       └── azl-mock/
│           └── SKILL.md
├── .vscode/
│   └── mcp.json                         # MCP tool configuration (VS Code)
├── base/
│   └── comps/
│       └── AGENTS.md                    # Component management guidance (cross-platform)
├── distro/
│   └── AGENTS.md                        # Distro configuration guidance (cross-platform)
└── AGENTS.md                            # General orientation (cross-platform)
```

**Skills discovery:** Agent Skills are discovered automatically via description matching (3-level progressive loading: metadata → instructions → resources). `AGENTS.md` files link to skills for discoverability.

### Content Placement Strategy

Based on research and practical experimentation, we use a passive-first approach: domain knowledge is placed where agents receive it automatically, while skills handle explicit task workflows.

| Content type | Mechanism | Why |
|---|---|---|
| Project overview, key concepts, CLI reference | `copilot-instructions.md` | Always needed; not in model training data |
| Guardrails ("overlays need descriptions", "don't edit build/") | `AGENTS.md` | Short rules, always enforced near relevant directories |
| Structural patterns (TOML syntax, valid overlay shapes, examples) | `.instructions.md` with `applyTo` globs | Passive context fired by file type — no agent decision point |
| Multi-step task workflows (add component, debug build, fix overlay) | Skills | On-demand, loaded when user intent matches, may be referenced in other files |
| Distro-wide build defaults, shared config | `distro/AGENTS.md` | Short, always-on, rarely changes |

**Why passive beats active for domain knowledge:** Agents don't reliably invoke skills for general knowledge. In skills are often not invoked. Passive context eliminates the decision point — the agent always has the information. Skills work well for explicit task workflows where the user's intent is clear ("add a component", "debug this build failure").

**Why not put everything in AGENTS.md:** Always-loaded context is a token tax paid on every interaction, even when irrelevant. `.instructions.md` files with `applyTo` globs provide a middle ground: passive (no agent decision) but scoped (only loaded when working with matching files). This keeps AGENTS.md lean while ensuring agents have structural knowledge when editing specific file types.

### Schema Reference

The authoritative schema for `.comp.toml` and `.distro.toml` files is at `external/schemas/azldev.schema.json`. Implementers should reference this for complete field definitions, overlay types, and validation rules.

**Note:** This schema is static, we need a way to keep it updated as azldev evolves (publish with azldev releases?).

### Human-Readable Policies

Agent instructions encode repository policies, but these policies should also be documented in human-readable form for contributors who aren't using AI agents.

**Recommended approach:**

- `CONTRIBUTING.md` - Main entry point for human contributors, should include or link to:
  - Repository hygiene rules (file organization, naming conventions)
  - Component contribution guidelines
  - Overlay best practices
  - Version update policies

**Single source of truth principle:**

To avoid drift between human docs and agent instructions, consider:

1. **Shared policy definitions** - Define policies in a canonical location (e.g., `docs/policies/`) that both CONTRIBUTING.md and agent instructions reference
2. **Regular alignment reviews** - Add to "Areas to Revisit Regularly" table
3. **Cross-references** - Agent instructions should link to human docs; human docs should note that agents follow the same rules
4. **AI driven PR gate that runs when doc files change** - Check for consistency between human-readable policies and agent instructions

**Open question:** Should policies be authored primarily for humans (with agents consuming them) or for agents (with human-readable summaries generated)? The former is more traditional; the latter may be more maintainable as agent usage grows.

### Repository-Wide Instructions

The main instructions file should cover:

1. **Project Overview**
   - Azure Linux is a TOML-based distro definition
   - Components are defined in `*.comp.toml` files
   - Overlays modify upstream specs without forking

2. **Key Concepts**
   - Components vs RPM packages (output artifacts)
   - Upstream distros (Fedora) and how specs are sourced
   - The overlay system and when to use it

3. **azldev Tool Reference**
   - Document key azldev subcommands for component management (list, query, add, build, etc.)
   - Implementer should reference `azldev --help` for up-to-date command syntax
   - Note: azldev is under active development; command syntax may change

4. **Repository Hygiene Rules**
   - Components defined as more than a single line with just the name SHOULD have their own `.comp.toml` file (guideline, not strict rule)
   - Overlays MUST include a `description` field
   - Component names should match upstream where possible

5. **Common Workflows** (summary, link to skills for details)

### File-Type Instructions

#### `*.comp.toml` Instructions

- Schema overview and required fields
- When to use inline vs file-based definitions
- Overlay syntax and common patterns
- How to validate component definitions using azldev

#### `*.distro.toml` Instructions

- Purpose: defining distro-level configuration
- Include directives and file organization
- Upstream distro references

#### `*.spec` Instructions (Hand-coded)

- When hand-coded specs are appropriate
- Azure Linux-specific macros and conventions
- Relationship to overlays (prefer overlays when possible)

#### `*.spec` Instructions (Generated)

- These are OUTPUT files, do not edit directly
- How to trace back to source component
- Useful for debugging overlay results

#### `*.kiwi` Instructions

- Purpose: defining image builds

### Skills Design

Each skill follows the [Agent Skills open standard](https://agentskills.io/): a directory containing a `SKILL.md` file with required YAML frontmatter (`name`, `description`) and an instruction body. Skills may also include scripts, examples, and other resources in the same directory.

**Skills are for task workflows, not domain knowledge.** General domain knowledge (TOML structure, overlay types, component patterns) belongs in passive context (`.instructions.md`, `AGENTS.md`). Skills cover explicit, multi-step workflows that a user actively requests.

Skills are loaded on-demand via progressive disclosure:

1. **Discovery** — Copilot reads skill `name` and `description` from frontmatter (lightweight, always available)
2. **Instructions** — When a request matches a skill's description, the `SKILL.md` body is loaded into context
3. **Resources** — Additional files in the skill directory are accessed only as needed

The `description` field is critical: write it to clearly describe both what the skill does and when to use it, so Copilot can match it to user requests. Include trigger phrases in the description — this is what causes skill loading. "When to use" guidance belongs in the description, not in the body (the body loads *after* triggering).

#### `azl-add-component/SKILL.md`

**Trigger:** User wants to add a new component

**Concepts to cover:**

- How to check if a component already exists
- "Inspect upstream spec first" workflow — add a bare inline entry, use `prep-sources --skip-overlays` to pull the spec (Fedora dist-git blocks direct web fetches), plan overlays, then create a dedicated file if needed
- Determining the appropriate source distro (usually Fedora) and upstream source options (default, pinned version, different `upstream-name`, local spec)
- When to use inline definition vs dedicated `.comp.toml` file
- Adding overlays when customizations are needed — tips: test incrementally, avoid renaming `Name:`, no `$schema` in TOML, no multi-line regex, prefer targeted overlay types over regex
- **Overlays vs forked spec**: overlays are vastly preferable; forked specs are a last resort, require explicit user sign-off, and commit to indefinite maintenance
- Validating the component definition (`prep-sources` pre/post diff → `comp build` → smoke test via `azl-mock`)

**Decision tree:**

- Simple import (no changes) → Add to `components.toml`
- Needs overlays or customizations → Create `<name>/<name>.comp.toml`
- Needs extensive changes that overlays can't handle → Forked local spec (last resort, requires user sign-off)

#### `azl-update-component/SKILL.md` — Not planned

Updating a component is primarily "edit a `.comp.toml` file" (structural knowledge provided by `comp-toml.instructions.md`), optionally combined with `azl-fix-overlay` (if overlays break) or `azl-build-component` (to test). A dedicated update skill may be added if a distinct workflow emerges that isn't covered by those mechanisms.

**Versioning and Compatibility Considerations** (to be incorporated into `comp-toml.instructions.md` or a future update skill):

When updating components, agents MUST be cautious about version changes:

- **Major version bumps** (e.g., 1.x → 2.x): High risk. May break API/ABI compatibility. Require explicit user approval and should note potential downstream impact.
- **Minor version bumps** (e.g., 1.2 → 1.3): Medium risk. Generally safe but may introduce new dependencies or deprecations.
- **Patch version bumps** (e.g., 1.2.3 → 1.2.4): Low risk. Usually safe for security fixes and bug fixes.

Agents should:

1. **Never assume backwards compatibility** - Check upstream release notes for breaking changes
2. **Flag soname changes** - Library packages with changed sonames may break dependent packages
3. **Note new dependencies** - Version updates may pull in new BuildRequires or Requires
4. **Examine existing overlays** - Ensure overlays still apply cleanly to new version. If an overlay fails, treat as a breaking change. If an overlay is no longer needed, recommend its removal.
5. **Warn about feature removal** - Upstream may remove features that Azure Linux depends on
6. **Summarize risks/changes** - Provide a summary of potential impacts of the version update

When in doubt, recommend the user review the upstream changelog before proceeding, with references if available.

#### `azl-fix-overlay/SKILL.md`

**Trigger:** Overlay errors during build or validation

**Concepts to cover:**

- Diagnosis workflow: reproduce with `prep-sources` pre/post diff (using a temp dir), inspect the pre-overlay output to see what the overlay is trying to modify
- Note that `prep-sources -o <dir>` writes to a user-specified directory (NOT `base/out/`)
- Reading and interpreting overlay error messages
- Understanding overlay type requirements and constraints
- Diagnosing `spec-*` overlay failures (section/tag existence)
- Diagnosing regex overlay failures (pattern matching, TOML literal strings, no multi-line regex)
- Diagnosing `file-*` overlay failures (file existence, glob support for `file-search-replace`)
- Overlay type quick reference table (all 12 types with key fields)
- Tips: test incrementally, minimize overlays, verify in chroot via `azl-mock`, follow inner loop from `azl-build-component`

**Common failure patterns:**

- `spec-add-tag`: "tag already exists" → use `spec-set-tag` or `spec-update-tag`
- `spec-search-replace`: no match → upstream changed, regex escaping, use TOML literal strings
- `spec-*-lines`: section not found → case sensitivity, renamed sections
- `file-*`: file not found → check pre-overlay dir listing
- Overlay applies but build still fails → compare post-overlay spec against expectations (regex matched wrong lines, replacement introduced syntax errors, missing dependency)

#### `azl-build-component/SKILL.md`

**Trigger:** Building components, debugging build failures, inspecting build environments

**Concepts to cover:**

- "Never install built RPMs on the host" — they target Azure Linux, not the dev machine. Use `azl-mock` instead.
- **Build Output Directories** table mapping `project.toml` keys (`output-dir`, `log-dir`, `work-dir`) → resolved paths (`base/out/`, `base/build/logs/`, `base/build/work/`). Note that `prep-sources -o <dir>` output is separate from these.
- Build sequence: single build, chained builds with `--local-repo-with-publish`, rebuild against local repo
- **Dev Inner Loop** as a formal table: investigate → compare → modify → verify → build → inspect
  - Use a temp dir for prep-sources output dirs — clean with `rm -rf` before each run (no `--force` flag)
- How to preserve build state on failure for inspection (`--preserve-buildenv`)
- Entering the mock shell environment for interactive debugging (cross-ref to `azl-mock`)
- Warning about `-p` flag meaning in `mock shell` vs `comp build` (different semantics)
- Per-component build overrides via `build.defines` (macros) and `build.without` (disable conditionals)
- Source inspection: comparing pre/post overlay sources with `prep-sources` + `diff -r`

**Key debugging locations:**

- RPM build output: `base/out/` (configured by `output-dir` in `project.toml`)
- Build logs: `base/build/logs/` (configured by `log-dir`)
- Per-component work dirs: `base/build/work/<name>/` (configured by `work-dir`)
- Mock chroot (when preserved with `--preserve-buildenv`)
- `prep-sources` output (user-specified dir, NOT in `base/out/`)

#### `azl-mock/SKILL.md`

**Trigger:** Testing built RPMs, inspecting dependencies, debugging runtime issues, verifying package contents

**Concepts to cover:**

- Resetting mock chroot (`mock --scrub=chroot` or `--scrub=all`) — `azldev` has no built-in reset
- Non-interactive chroot (preferred for agents): heredoc pattern with `azldev adv mock shell`
- Examine RPM contents on host: `rpm2cpio` extraction to `my/build/dir`
- Interactive chroot: step-by-step agent workflow (establish shared shell → user runs mock → agent sends commands in same terminal)
- Key flags: `-p`/`--add-package` (installs package), `--enable-network`
- Warning that `-p` means `--add-package` (not component name) — different from `comp build -p`

**Gotchas:**

- Don't mix `-p <name>` with `--add-package /path/to/rpm` for the same package (installs two conflicting builds)
- Mock chroot state is persistent between sessions — use `mock --scrub=chroot` to reset
- One mock session per terminal — run `exit` before starting another
- `advanced` (`adv`) is hidden from `azldev --help`

### Experimental Agents

Custom agents are `.agent.md` files with optional YAML frontmatter. Key frontmatter fields:

- `description` — shown as placeholder text in chat
- `tools` — restricts which tools are available (e.g., read-only for review agents)
- `model` — preferred AI model
- `handoffs` — suggested transitions to other agents after a response

Consider creating 1-2 specialized agents:

1. **Component Hygiene Agent** (`hygiene-review.agent.md`)
   - Reviews component definitions for hygiene violations
   - Suggests file organization improvements
   - Validates overlay descriptions exist
   - `tools`: limit to read-only tools to prevent accidental changes
   - `handoffs`: offer transition to implementation agent for fixes

2. **Overlay Specialist Agent** (`overlay-specialist.agent.md`)
   - Deep knowledge of overlay types and patterns
   - Can analyze upstream specs to suggest overlays
   - Helps debug complex overlay failures
   - `tools`: include file editing and terminal for testing fixes

### Prompts Design

Prompts are reusable, parameterized workflows that users can invoke directly via `/` in chat. They are `.prompt.md` files stored in `.github/prompts/`. **Prompts are VS Code only** — Copilot CLI does not currently support `/prompt` invocation.

**Key prompt file features:**

- **YAML frontmatter** — optional `description`, `agent`, `tools`, `model` fields
- **Input variables** — use `${input:variableName}` or `${input:variableName:placeholder}` for user-provided parameters
- **Built-in variables** — `${file}`, `${selection}`, `${workspaceFolder}`, etc.
- **Markdown links** — reference skill and instruction files using relative paths
- **Tool references** — use `#tool:<tool-name>` syntax to reference specific tools
- **Agent selection** — `agent:` frontmatter can route the prompt through a custom agent

**Critical design principle — two-tier prompt model:**

Prompts follow one of two tiers depending on whether a dedicated skill exists:

- **Tier 1 (skill-backed):** When a dedicated skill covers the workflow, the prompt is a thin wrapper. It collects user input via `${input:...}` variables, references the skill via a Markdown link (so the skill's instructions load into context), and adds VS Code-specific affordances (`agent:`, `tools:`, built-in variables). The prompt orchestrates the step-by-step sequence but delegates the "how" to the skill. Example: `azl-add-component.prompt.md` → `azl-add-component/SKILL.md`.

- **Tier 2 (orchestrator):** When no dedicated skill exists — because the workflow is a composition of existing skills, instruction files, and AGENTS.md content — the prompt encodes the workflow logic directly. It references *multiple* existing resources via Markdown links (e.g., `comp-toml.instructions.md` + `azl-fix-overlay/SKILL.md` + `azl-build-component/SKILL.md`). Creating a skill just to back a prompt violates YAGNI when the workflow is a straightforward composition. Example: `azl-update-component.prompt.md` combines structural knowledge from `comp-toml.instructions.md` with overlay repair from `azl-fix-overlay` and testing from `azl-build-component`.

Both tiers ensure Copilot CLI users get equivalent guidance: Tier 1 prompts have a directly matching skill, and Tier 2 prompts compose skills that are independently discoverable. See the [VS Code prompt files documentation](https://code.visualstudio.com/docs/copilot/customization/prompt-files) for prompt file syntax and features.

**Skills vs Prompts distinction:**

- **Skills** are **on-demand capabilities** loaded automatically when Copilot detects relevance. They provide comprehensive task workflow knowledge and can include scripts/resources. *Cross-platform.*
- **Prompts** are **user-invoked workflows** triggered explicitly via `/command`. They are streamlined action orchestrators that either wrap a single skill (Tier 1) or compose multiple existing resources (Tier 2). *VS Code only.*

Both cover similar topics but serve different purposes. Skills answer "how does this work?" while prompts answer "help me do this now."

#### `azl-add-component.prompt.md`

**Purpose:** Guided workflow for adding a new component to Azure Linux
**References:** `azl-add-component/SKILL.md` (linked via Markdown, provides domain knowledge)

**Input variables** (via `${input:...}` syntax):

- `${input:component_name:package name}` (required) - Name of the component to add
- `${input:source_distro:fedora}` (optional) - Upstream distro to source from
- `${input:project:base}` (optional) - Target project (base, extras, etc.)

**Workflow orchestration** (detailed guidance lives in the skill):

- Check for existing component
- Gather upstream spec information
- Determine customization needs
- Create component definition (inline or dedicated file)
- Add overlays with meaningful descriptions
- Validate and optionally test build

#### `azl-update-component.prompt.md` — Tier 2 (orchestrator)

**Purpose:** Guided workflow for updating an existing component
**References:** `comp-toml.instructions.md` (structural knowledge), `azl-fix-overlay/SKILL.md` (if overlays break), `azl-build-component/SKILL.md` (to test) — all linked via Markdown
**Tier rationale:** No dedicated update skill exists (see `azl-update-component — Not planned` above). The update workflow is a composition of structural editing (from `comp-toml.instructions.md`), overlay repair (from `azl-fix-overlay`), and build testing (from `azl-build-component`). The prompt encodes the meta-workflow that ties these together, including versioning risk assessment (update policy will be encoded in the components TOML if non-standard).

**Input variables:**

- `${input:component_name:package name}` (required) - Name of the component to update
- `${input:new_version:target version}` (optional) - Target version (if version bump)
- `${input:update_type:version|dependency|overlay|config}` (optional) - Type of update

**Workflow logic** (encoded directly in the prompt):

1. Query current state: `azldev comp query -p <name>`
2. Identify scope of update (version bump, dependency change, overlay edit, config tweak)
3. For version bumps: assess versioning risk (major/minor/patch), flag soname changes, note new dependencies, recommend upstream changelog review
4. Apply changes to `.comp.toml` (structural knowledge from `comp-toml.instructions.md`)
5. Verify overlays still apply: `prep-sources` pre/post diff (if overlays break, follow `azl-fix-overlay`)
6. Migrate to dedicated file if needed (see `migrate-component` prompt)
7. Build and test: follow `azl-build-component` inner loop

**Versioning risk assessment** (encoded in prompt body, sourced from the Versioning and Compatibility Considerations section of this PRD):

- **Major bumps** (1.x → 2.x): High risk — require explicit user approval
- **Minor bumps** (1.2 → 1.3): Medium risk — check for new dependencies/deprecations
- **Patch bumps** (1.2.3 → 1.2.4): Low risk — usually safe
- Always: check upstream release notes, flag soname changes, examine overlay compatibility, warn about feature removal, summarize risks

#### `azl-review-component.prompt.md` — Tier 1 (skill-backed)

**Purpose:** Review a component definition for hygiene and best practices
**References:** `azl-review-component/SKILL.md` (review checklist and workflow), plus `copilot-instructions.md` (hygiene rules), `base/comps/AGENTS.md` (file organization), `comp-toml.instructions.md` (overlay patterns) — all linked via Markdown
**Tier rationale:** Backed by the `azl-review-component` skill, which owns the canonical review checklist.

**Input variables:**

- `${input:component_name:package name}` (required) - Name of the component to review

**Review checklist** (encoded in prompt body):

- **File organization:** Is the component in the right location? Should an inline definition be a dedicated file? Does naming match upstream?
- **Overlay quality:** Do all overlays have `description` fields? Are targeted overlay types used over regex where possible? Are there unnecessary overlays? No multi-line regex?
- **Naming conventions:** Does the component name match the upstream package name? Is `upstream-name` used when they differ?
- **Build configuration:** Are `build.defines` and `build.without` used appropriately? Any missing or unnecessary build overrides?
- **Source configuration:** Is the spec source type appropriate (upstream default vs pinned vs local)?

**Output:** Structured report with findings and recommendations, grouped by severity

#### `azl-debug-component.prompt.md` — Tier 2 (multi-skill composition)

**Purpose:** Diagnose and fix component build failures, including overlay application errors
**References:** `azl-fix-overlay/SKILL.md` (overlay diagnosis), `azl-build-component/SKILL.md` (build debugging/inner loop), `azl-mock/SKILL.md` (chroot inspection) — all linked via Markdown
**Tier rationale:** This is a Tier 2 prompt that composes multiple skills. It triages the error type and routes to the appropriate skill's workflow.

**Input variables:**

- `${input:component_name:package name}` (required) - Name of the failing component
- `${input:error_context:paste error or describe issue}` (optional) - Error message or description from build/validation

**Triage logic** (encoded in prompt body):

1. If the error is an overlay application failure (overlay errors during `prep-sources` or early in build): follow `azl-fix-overlay` skill workflow — diff pre/post overlay output, diagnose pattern failures, suggest fixes
2. If the error is a build failure (compilation errors, missing dependencies, test failures): follow `azl-build-component` inner loop — check logs, preserve buildenv, inspect mock chroot
3. If the error is a runtime/packaging issue (wrong file permissions, missing files, dependency conflicts): follow `azl-mock` skill workflow — install in chroot, verify contents, check dependencies
4. When in doubt, start with `prep-sources` pre/post diff to determine if the issue is overlay-related or build-related

**Common diagnoses:**

- Overlay: upstream spec changed breaking pattern match, section renamed/removed, wrong overlay type
- Build: missing BuildRequires, incompatible compiler flags, test failures in mock
- Runtime: missing Requires, wrong file paths, permission issues

#### `azl-migrate-component.prompt.md` — Tier 2 (orchestrator)

**Purpose:** Migrate an inline component definition to a dedicated file
**References:** `comp-toml.instructions.md` (file organization patterns, inline vs dedicated), `base/comps/AGENTS.md` (file organization rules) — linked via Markdown
**Tier rationale:** No dedicated migration skill exists. The workflow is simple enough to encode directly — it's a mechanical file operation guided by existing structural knowledge.

**Input variables:**

- `${input:component_name:package name}` (required) - Name of the component to migrate

**When to use:**

- Adding first customization to a simple import
- Component definition is getting complex
- Adding overlays to an inline component

**Workflow logic** (encoded in prompt body):

1. Query the current inline definition: `azldev comp query -p <name>`
2. Extract the component's entry from `components.toml` (or whichever file contains the inline definition)
3. Create `<name>/<name>.comp.toml` with the extracted definition (follow patterns from `comp-toml.instructions.md`)
4. Replace the inline definition with an include directive or remove it (the dedicated file is auto-discovered via `**/*.comp.toml` glob in `components.toml`)
5. Validate: `azldev comp query -p <name>` — output should be identical to before migration
6. Optionally: add overlays or customizations that triggered the migration

## Implementation Plan

### Phase 1: Foundation (cross-platform)

- [x] Create `.github/copilot-instructions.md` with project overview, key concepts, CLI reference, hygiene rules
- [x] Create `AGENTS.md` (root) — lean: conventions, skill table, directory pointers
- [x] Create `base/comps/AGENTS.md` — lean: file organization rules, skill pointers
- [x] Create `distro/AGENTS.md` — build defaults, structure overview, shared config warning
- [x] Create skill stubs (`.github/skills/azl-{add-component,fix-overlay,build-component,mock,review-component}/SKILL.md`)

### Phase 2: Agent Skills (cross-platform, open standard)

Each skill is a directory with a `SKILL.md` file following the [Agent Skills standard](https://agentskills.io/). Include required `name` and `description` YAML frontmatter. Add scripts/examples/resources alongside `SKILL.md` as needed.

Skills are for explicit task workflows only — domain knowledge goes in passive context (Phase 1 + Phase 3).

- [x] Create `.github/skills/azl-build-component/SKILL.md` (full content)
- [x] Flesh out `.github/skills/azl-add-component/SKILL.md`
- [x] Flesh out `.github/skills/azl-fix-overlay/SKILL.md`
- [x] Create `.github/skills/azl-mock/SKILL.md` (mock chroot testing and inspection)
- [ ] Flesh out `.github/skills/azl-review-component/SKILL.md` (component hygiene review)
- [x] Write clear `description` fields with trigger phrases so Copilot can match skills to user requests
- [x] Link skills from `AGENTS.md` files for discoverability

### Phase 3: File-Type Instructions (cross-platform)

These `.instructions.md` files use `applyTo` globs for automatic context injection. Both VS Code and Copilot CLI support them. **This is the primary home for domain knowledge** — structural patterns, TOML syntax, valid overlay shapes, component definition examples. This content was deliberately removed from AGENTS.md to reduce always-on context tax, and placed here where it fires only when the agent is actually working with the relevant file type.

- [x] Create `.github/instructions/comp-toml.instructions.md` (`applyTo: "**/*.comp.toml"`)
  - Component definition patterns (inline vs dedicated, examples)
  - Overlay syntax and common patterns
  - Schema overview and required fields
  - When to use inline vs file-based definitions
- [x] Create `.github/instructions/spec.instructions.md` (`applyTo: "**/*.spec"`)
  - When hand-coded specs are appropriate (Azure Linux-originating packages only)
  - Relationship to `.comp.toml` and overlays (prefer overlays over forking)
  - Azure Linux conventions (dist tag, vendor, `%autorelease`, SPDX licenses)
  - How to inspect/debug specs via `prep-sources`
  - Note that specs in `prep-sources` output are generated — don't edit directly
- [ ] Create `.github/instructions/spec-generated.instructions.md` - pending directory structure
- [x] Create `.github/instructions/kiwi.instructions.md` (`applyTo: "**/*.kiwi"`) - image build definitions

### Phase 4: Prompts (VS Code only)

Prompts follow a two-tier model: **Tier 1** prompts are thin wrappers around existing skills, while **Tier 2** prompts encode their own workflow logic and compose multiple existing skills/instructions. Both tiers collect user input via `${input:...}` variables and use Markdown links to pull in domain knowledge. Use optional `agent:`/`tools:` frontmatter for VS Code-specific affordances. See the [VS Code prompt files documentation](https://code.visualstudio.com/docs/copilot/customization/prompt-files) for syntax reference.

- [x] Create `.github/prompts/azl-add-component.prompt.md` — Tier 1 (wraps `azl-add-component`)
- [x] Create `.github/prompts/azl-update-component.prompt.md` — Tier 2 (composes `comp-toml.instructions.md` + `azl-fix-overlay` + `azl-build-component`)
- [x] Create `.github/prompts/azl-review-component.prompt.md` — Tier 1 (wraps `azl-review-component`)
- [x] Create `.github/prompts/azl-debug-component.prompt.md` — Tier 2 (triages between `azl-fix-overlay` + `azl-build-component` + `azl-mock`)
- [x] Create `.github/prompts/azl-migrate-component.prompt.md` — Tier 2 (composes `comp-toml.instructions.md` + `base/comps/AGENTS.md`)

### Phase 5: Experimental Agents (cross-platform)

Agents are `.agent.md` files in `.github/agents/`. Both VS Code and Copilot CLI discover them. Use YAML frontmatter to restrict tools, set models, and define handoffs.

- [ ] Evaluate need for Component Hygiene agent (`hygiene-review.agent.md`)
- [ ] Evaluate need for Overlay Specialist agent (`overlay-specialist.agent.md`)
- [ ] Implement 0-2 agents based on evaluation
- [ ] If multiple agents, consider handoffs between them for workflow continuity

### Phase 6: MCP and VS Code Integration (VS Code only)

- [ ] Create `.vscode/mcp.json` configuration for azldev MCP tools
- [ ] Document MCP tool usage in instructions once end-to-end flow is complete
- [ ] If Copilot CLI gains MCP support, evaluate a cross-platform MCP config location

## Areas to Revisit Regularly

These aspects of the PRD should be reviewed and updated as the project evolves:

| Area | Trigger for Review | Notes |
| ---- | ------------------ | ----- |
| **azldev commands** | New azldev release | Command syntax or new features may change |
| **MCP integration** | MCP server available | Switch from shell to MCP tools in instructions |
| **CI/CD guidance** | CI pipeline added | Add validation/testing instructions |
| **Overlay patterns** | New overlay types | Document new overlay capabilities |
| **Hygiene rules** | Team feedback | Rules may need adjustment based on practice |
| **Skills coverage** | Common support requests | Add skills for frequently asked workflows |
| **Prompts coverage** | User feedback | Add prompts for common interactive workflows |
| **External contributors** | Public launch | Review for internal assumptions |
| **Policy alignment** | CONTRIBUTING.md updates | Ensure agent instructions match human-readable policies |
| **Cross-platform support** | New Copilot surfaces | Check if new GitHub Copilot surfaces support additional file types |

## Success Criteria

### Quantitative

- Agents can add a simple component with ≤2 human corrections
- Agents can diagnose common overlay errors and suggest fixes
- 95% of component definitions pass hygiene checks

### Qualitative

- Team members report agents are "helpful" for component workflows
- Reduced time spent explaining basic concepts to new contributors
- Overlay debugging is faster with agent assistance

## Open Questions

1. **Generated spec location:** Where will generated specs be stored (if implemented)? This affects file-type instruction placement.

2. **Hygiene enforcement:** Should agents enforce hygiene rules strictly, or just warn?
   - **Resolution:** Agents should warn and explain, not block. The goal is AI code reviewers flagging bad practices and ensuring new agent-written code is clean. Enforcement checks will be added incrementally over time.

3. **Skill naming convention:** Should skills be prefixed (`azl-`) or namespaced differently? The Agent Skills standard requires lowercase names with hyphens (max 64 chars).

4. **Agent scope:** Should experimental agents be repo-specific or potentially shared across Azure Linux repos? Should azldev have a command to install the resources into other repos?

5. **Prompts vs Skills overlap:** Some workflows exist as both skills and prompts (e.g., add-component). Should we consolidate, or keep both for different use cases (reference vs interactive)?
   - **Resolution:** Keep both, using a two-tier model. **Tier 1** prompts are thin wrappers around an existing skill (e.g., `add-component` → `azl-add-component`). **Tier 2** prompts encode their own workflow logic when no dedicated skill exists, composing multiple existing skills and instruction files (e.g., `update-component` composes `comp-toml.instructions.md` + `azl-fix-overlay` + `azl-build-component`). This avoids both knowledge duplication and creating skills just to satisfy a pattern (YAGNI). Copilot CLI users get equivalent guidance: Tier 1 skills are directly discoverable, and Tier 2 prompts compose independently discoverable skills.

6. **Passive vs active context balance:** Research shows passive context (AGENTS.md) dramatically outperforms skills for domain knowledge. But passive context is a per-interaction token tax. Our current split: lean AGENTS.md (guardrails) + `.instructions.md` (domain knowledge, scoped by file type) + skills (task workflows). This may need tuning based on real usage — if agents still miss domain knowledge when `.instructions.md` doesn't fire (e.g., asking about components without a `.comp.toml` open), we may need to move some content back to always-on AGENTS.md.

## Appendix: Key azldev Capabilities

**Note:** azldev is under active development. Command syntax may change. Always reference `azldev --help` for current usage.

**Core component operations:**

- Listing components in the project
- Querying component details and resolved spec information
- Adding new components from upstream
- Building components (produces RPMs via mock)
- Preparing sources with overlays applied
- Interactive debugging via mock shell

**Project operations:**

- Querying project-level configuration
- Managing distro definitions

## Appendix: Overlay Quick Reference

Overlays modify upstream specs without forking. Below are illustrative examples; see `external/schemas/azldev.schema.json` for the complete overlay type definitions and required fields. Also reference `overlays.toml` from `azldev` for up-to-date patterns.

### Example 1: Add a build dependency

```toml
[[components.mypackage.overlays]]
description = "Add missing build dependency"
type = "spec-add-tag"
tag = "BuildRequires"
value = "golang >= 1.21"
```

### Example 2: Regex replacement in spec

```toml
[[components.mypackage.overlays]]
description = "Customize vendor string"
type = "spec-search-replace"
regex = "VENDOR=upstream"
replacement = "VENDOR=azurelinux"
```

### Example 3: Append to a section

```toml
[[components.mypackage.overlays]]
description = "Add Azure Linux specific install step"
type = "spec-append-lines"
section = "%install"
lines = ["install -D -m 644 azl-config %{buildroot}/etc/mypackage/azl.conf"]
```

**Common overlay categories:**

- `spec-*` overlays: Modify RPM spec tags and sections
- `file-*` overlays: Add, remove, rename, or modify source files
