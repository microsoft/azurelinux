# PRD: Agent Instructions and Skills for Azure Linux

Title: PRD: Agent Instructions and Skills for Azure Linux
Author: Daniel McIlvaney
Created: 2026-01-29
Updated: 2026-02-09
Status: Draft

## Overview

This PRD defines the foundation for AI agent support in the Azure Linux repository. The goal is to enable agents to effectively assist with component management workflows using the `azldev` tool, while maintaining code quality and repository hygiene standards.

**Related ideas:** None (greenfield)

## Problem Statement

Azure Linux component maintainers will benefit from AI agent assistance for common workflows:

- Adding new components to the distro
- Updating existing components (version bumps, dependency changes)
- Writing and debugging overlays (spec modifications)
- Maintaining repository hygiene (file organization, consistent patterns)

Without proper instructions, agents lack context about:

- The TOML-based metadata system (`*.comp.toml`, `*.distro.toml`)
- The overlay system for modifying upstream specs
- The `azldev` tool commands and workflows
- Repository conventions and hygiene requirements
- Component specific workflows

## Target Users

- **v1:** Azure Linux team members
- **Future:** External contributors (instructions should not assume internal-only context, referenced tools should be publicly available)

## Cross-Platform Compatibility Strategy

Instruction files should work across GitHub Copilot surfaces where possible: VS Code, Visual Studio, GitHub.com, and Copilot CLI. This PRD prefers GitHub-standard locations over tool-specific ones.

| Mechanism | Discovery | Supported Surfaces |
| --------- | --------- | ------------------ |
| `.github/copilot-instructions.md` | Auto | VS Code, Visual Studio, GitHub.com, Copilot CLI |
| `AGENTS.md` (root and subdirectories) | Auto | VS Code, Copilot CLI |
| Agent Skills (`.github/skills/*/SKILL.md`) | On-demand (description match) | VS Code, Copilot CLI, Copilot coding agent ([open standard](https://agentskills.io/)) |
| `.github/instructions/*.instructions.md` | Auto (via `applyTo` globs) | VS Code, Copilot CLI |
| `.github/agents/*.agent.md` | User-selected / inferred | VS Code, Copilot CLI |
| `.github/prompts/*.prompt.md` | User-invoked (`/command`) | VS Code only |
| `.vscode/mcp.json` | Auto | VS Code only |

**Guiding principles:**

1. **Passive context first.** Domain knowledge that agents need regularly (TOML structure, overlay types, component patterns) should live in always-available passive context (`copilot-instructions.md`, `AGENTS.md`, `.instructions.md`), not behind on-demand skill triggering. In practice, models often avoid triggering skills, while passive context is guaranteed to be loaded. Skills are best for explicit, multi-step task workflows.
2. **Cross-platform by default.** Most instruction file types are now cross-platform (Copilot CLI supports `copilot-instructions.md`, `AGENTS.md`, `.instructions.md`, agents, and skills). The main exception is `.prompt.md` files, which are VS Code only.
3. **Minimize context rot.** Keep always-loaded files (copilot-instructions.md, AGENTS.md) as lean as possible — guardrails and pointers, not reference manuals. Detailed content goes in `.instructions.md` (loaded by file type) or skills (loaded by task intent).

## Scope

### In Scope (v1)

1. **Repository-wide instructions** (`.github/copilot-instructions.md`) — *cross-platform*
   - Overview of Azure Linux architecture
   - Key directories and their purposes
   - Common workflows at a high level
   - Links to detailed guidance

2. **File-type specific instructions** (`.instructions.md` with `applyTo` globs) — *cross-platform (VS Code, Copilot CLI)*
   - `*.comp.toml` - Component definition files
   - `*.distro.toml` - Distro configuration files
   - `*.spec` - RPM spec files (hand-coded)
   - `generated/*.spec` - RPM spec files (generated by azldev, generated spec feature is undecided)

3. **Directory-specific instructions** (`AGENTS.md` files) — *cross-platform*
   - `AGENTS.md` (root) - Guardrails, conventions, skill pointers
   - `base/comps/AGENTS.md` - Component file organization rules, skill pointers
   - `distro/AGENTS.md` - Distro configuration guidance (build defaults, shared config)
   - **Design principle:** AGENTS.md files should be short guardrail documents — conventions and "do/don't" rules. Detailed workflows and examples belong in skills or `.instructions.md` files.

4. **Agent Skills** (`.github/skills/*/SKILL.md`) — *cross-platform ([open standard](https://agentskills.io/))*
   - `azl-add-component/SKILL.md` - Adding a new component to the distro
   - `azl-fix-overlay/SKILL.md` - Diagnosing and fixing overlay issues
   - `azl-build-component/SKILL.md` - Building, testing, and debugging components
   - Each skill is a directory containing a `SKILL.md` (with required `name` and `description` YAML frontmatter) plus optional scripts, examples, and resources. Skills are discovered on-demand based on description matching.
   - **Design principle:** Skills are for explicit, multi-step task workflows — not general domain knowledge. Domain knowledge belongs in passive context (`.instructions.md`, `AGENTS.md`) where it's available without the agent needing to decide to load it. AGENTS.md files link to skills for discoverability, but links are not required for skill triggering.

5. **Experimental custom agents** (`.github/agents/*.agent.md`, 1-2 maximum) — *cross-platform (VS Code, Copilot CLI)*
   - Consider: Component reviewer agent, Overlay specialist agent
   - Agents use `.agent.md` files with optional YAML frontmatter (`description`, `tools`, `model`, `handoffs`)
   - Consider handoffs between agents for multi-step workflows (e.g., review → fix)
   - Copilot CLI discovers agents from `.github/agents/`, `~/.copilot/agents/`, and org-level locations

6. **Prompt templates** (`.github/prompts/*.prompt.md`) — *VS Code only*
   - `add-component.prompt.md` - Guided workflow for adding a new component
   - `update-component.prompt.md` - Guided workflow for updating an existing component
   - `review-component.prompt.md` - Review a component for hygiene and best practices
   - `debug-overlay.prompt.md` - Diagnose and fix overlay issues
   - `migrate-component.prompt.md` - Migrate inline component to dedicated file
   - **Design principle:** Prompts are thin wrappers — they collect user input and orchestrate the workflow, but reference the corresponding skill for domain knowledge. This ensures Copilot CLI users (who lack `/prompt` support) still get the same guidance via skills.

### Out of Scope (v1)

- CI/CD integration (no meaningful CI exists yet)
  - Pre-commit hooks should be considered future work
- Full MCP server integration (partial support exists; see MCP Integration Roadmap section)
- External contributor onboarding flows
- Automated regeneration of agent instructions via `azldev`

## Technical Design

### Directory Structure

```text
azurelinux/
├── .github/
│   ├── copilot-instructions.md         # Repository-wide instructions (cross-platform)
│   ├── instructions/                    # File-type specific instructions (cross-platform)
│   │   ├── comp-toml.instructions.md
│   │   └── spec.instructions.md
│   ├── prompts/                         # Prompt templates (VS Code only)
│   │   ├── add-component.prompt.md
│   │   └── ...
│   ├── agents/                          # Custom agents (cross-platform)
│   │   └── *.agent.md
│   └── skills/                          # Agent Skills (cross-platform, open standard)
│       ├── azl-add-component/
│       │   └── SKILL.md
│       ├── azl-fix-overlay/
│       │   └── SKILL.md
│       └── azl-build-component/
│           └── SKILL.md
├── .vscode/
│   └── mcp.json                         # MCP tool configuration (VS Code)
├── base/
│   └── comps/
│       └── AGENTS.md                    # Component management guidance (cross-platform)
├── distro/
│   └── AGENTS.md                        # Distro configuration guidance (cross-platform)
└── AGENTS.md                            # General orientation (cross-platform)
```

**Skills discovery:** Agent Skills are discovered automatically via description matching (3-level progressive loading: metadata → instructions → resources). `AGENTS.md` files link to skills for discoverability.

### Content Placement Strategy

Based on research and practical experimentation, we use a passive-first approach: domain knowledge is placed where agents receive it automatically, while skills handle explicit task workflows.

| Content type | Mechanism | Why |
|---|---|---|
| Project overview, key concepts, CLI reference | `copilot-instructions.md` | Always needed; not in model training data |
| Guardrails ("overlays need descriptions", "don't edit build/") | `AGENTS.md` | Short rules, always enforced near relevant directories |
| Structural patterns (TOML syntax, valid overlay shapes, examples) | `.instructions.md` with `applyTo` globs | Passive context fired by file type — no agent decision point |
| Multi-step task workflows (add component, debug build, fix overlay) | Skills | On-demand, loaded when user intent matches, may be referenced in other files |
| Distro-wide build defaults, shared config | `distro/AGENTS.md` | Short, always-on, rarely changes |

**Why passive beats active for domain knowledge:** Agents don't reliably invoke skills for general knowledge. In skills are often not invoked. Passive context eliminates the decision point — the agent always has the information. Skills work well for explicit task workflows where the user's intent is clear ("add a component", "debug this build failure").

**Why not put everything in AGENTS.md:** Always-loaded context is a token tax paid on every interaction, even when irrelevant. `.instructions.md` files with `applyTo` globs provide a middle ground: passive (no agent decision) but scoped (only loaded when working with matching files). This keeps AGENTS.md lean while ensuring agents have structural knowledge when editing specific file types.

### Schema Reference

The authoritative schema for `.comp.toml` and `.distro.toml` files is at `external/schemas/azldev.schema.json`. Implementers should reference this for complete field definitions, overlay types, and validation rules.

**Note:** This schema is static, we need a way to keep it updated as azldev evolves (publish with azldev releases?).

### Human-Readable Policies

Agent instructions encode repository policies, but these policies should also be documented in human-readable form for contributors who aren't using AI agents.

**Recommended approach:**

- `CONTRIBUTING.md` - Main entry point for human contributors, should include or link to:
  - Repository hygiene rules (file organization, naming conventions)
  - Component contribution guidelines
  - Overlay best practices
  - Version update policies

**Single source of truth principle:**

To avoid drift between human docs and agent instructions, consider:

1. **Shared policy definitions** - Define policies in a canonical location (e.g., `docs/policies/`) that both CONTRIBUTING.md and agent instructions reference
2. **Regular alignment reviews** - Add to "Areas to Revisit Regularly" table
3. **Cross-references** - Agent instructions should link to human docs; human docs should note that agents follow the same rules
4. **AI driven PR gate that runs when doc files change** - Check for consistency between human-readable policies and agent instructions

**Open question:** Should policies be authored primarily for humans (with agents consuming them) or for agents (with human-readable summaries generated)? The former is more traditional; the latter may be more maintainable as agent usage grows.

### Repository-Wide Instructions

The main instructions file should cover:

1. **Project Overview**
   - Azure Linux is a TOML-based distro definition
   - Components are defined in `*.comp.toml` files
   - Overlays modify upstream specs without forking

2. **Key Concepts**
   - Components vs RPM packages (output artifacts)
   - Upstream distros (Fedora) and how specs are sourced
   - The overlay system and when to use it

3. **azldev Tool Reference**
   - Document key azldev subcommands for component management (list, query, add, build, etc.)
   - Implementer should reference `azldev --help` for up-to-date command syntax
   - Note: azldev is under active development; command syntax may change

4. **Repository Hygiene Rules**
   - Components defined as more than a single line with just the name SHOULD have their own `.comp.toml` file (guideline, not strict rule)
   - Overlays MUST include a `description` field
   - Component names should match upstream where possible

5. **Common Workflows** (summary, link to skills for details)

### File-Type Instructions

#### `*.comp.toml` Instructions

- Schema overview and required fields
- When to use inline vs file-based definitions
- Overlay syntax and common patterns
- How to validate component definitions using azldev

#### `*.distro.toml` Instructions

- Purpose: defining distro-level configuration
- Include directives and file organization
- Upstream distro references

#### `*.spec` Instructions (Hand-coded)

- When hand-coded specs are appropriate
- Azure Linux-specific macros and conventions
- Relationship to overlays (prefer overlays when possible)

#### `*.spec` Instructions (Generated)

- These are OUTPUT files, do not edit directly
- How to trace back to source component
- Useful for debugging overlay results

#### `*.kiwi` Instructions

- Purpose: defining image builds

### Skills Design

Each skill follows the [Agent Skills open standard](https://agentskills.io/): a directory containing a `SKILL.md` file with required YAML frontmatter (`name`, `description`) and an instruction body. Skills may also include scripts, examples, and other resources in the same directory.

**Skills are for task workflows, not domain knowledge.** General domain knowledge (TOML structure, overlay types, component patterns) belongs in passive context (`.instructions.md`, `AGENTS.md`). Skills cover explicit, multi-step workflows that a user actively requests.

Skills are loaded on-demand via progressive disclosure:

1. **Discovery** — Copilot reads skill `name` and `description` from frontmatter (lightweight, always available)
2. **Instructions** — When a request matches a skill's description, the `SKILL.md` body is loaded into context
3. **Resources** — Additional files in the skill directory are accessed only as needed

The `description` field is critical: write it to clearly describe both what the skill does and when to use it, so Copilot can match it to user requests. Include trigger phrases in the description — this is what causes skill loading. "When to use" guidance belongs in the description, not in the body (the body loads *after* triggering).

#### `azl-add-component/SKILL.md`

**Trigger:** User wants to add a new component

**Concepts to cover:**

- How to check if a component already exists
- Determining the appropriate source distro (usually Fedora)
- When to use inline definition vs dedicated `.comp.toml` file
- Adding overlays when customizations are needed
- Validating the component definition
- Testing with a build

**Decision tree:**

- Simple import (no changes) → Add to `components.toml`
- Needs overlays or customizations → Create `<name>/<name>.comp.toml`

#### `azl-update-component/SKILL.md` — Not planned

Updating a component is primarily "edit a `.comp.toml` file" (structural knowledge provided by `comp-toml.instructions.md`), optionally combined with `azl-fix-overlay` (if overlays break) or `azl-build-component` (to test). A dedicated update skill may be added if a distinct workflow emerges that isn't covered by those mechanisms.

**Versioning and Compatibility Considerations** (to be incorporated into `comp-toml.instructions.md` or a future update skill):

When updating components, agents MUST be cautious about version changes:

- **Major version bumps** (e.g., 1.x → 2.x): High risk. May break API/ABI compatibility. Require explicit user approval and should note potential downstream impact.
- **Minor version bumps** (e.g., 1.2 → 1.3): Medium risk. Generally safe but may introduce new dependencies or deprecations.
- **Patch version bumps** (e.g., 1.2.3 → 1.2.4): Low risk. Usually safe for security fixes and bug fixes.

Agents should:

1. **Never assume backwards compatibility** - Check upstream release notes for breaking changes
2. **Flag soname changes** - Library packages with changed sonames may break dependent packages
3. **Note new dependencies** - Version updates may pull in new BuildRequires or Requires
4. **Examine existing overlays** - Ensure overlays still apply cleanly to new version. If an overlay fails, treat as a breaking change. If an overlay is no longer needed, recommend its removal.
5. **Warn about feature removal** - Upstream may remove features that Azure Linux depends on
6. **Summarize risks/changes** - Provide a summary of potential impacts of the version update

When in doubt, recommend the user review the upstream changelog before proceeding, with references if available.

#### `azl-fix-overlay/SKILL.md`

**Trigger:** Overlay errors during build or validation

**Concepts to cover:**

- Reading and interpreting overlay error messages
- Understanding overlay type requirements and constraints
- Diagnosing `spec-*` overlay failures (section/tag existence)
- Diagnosing regex overlay failures (pattern matching)
- Diagnosing `file-*` overlay failures (file existence)

**Common failure patterns:**

- Pattern doesn't match upstream (upstream changed)
- Tag already exists (use set instead of add)
- Section not found (case sensitivity, renamed sections)

#### `azl-build-component/SKILL.md`

**Trigger:** Building components, debugging build failures, inspecting build environments

**Concepts to cover:**

- Basic build sequence (build → createrepo → build dependents)
- How to preserve build state on failure for inspection
- Entering the mock shell environment for interactive debugging
- Key locations where build artifacts and logs are stored
- Iterative workflow: inspect → hypothesize → fix → retry
- Per-component build overrides via `build.defines`
- Source inspection: comparing pre/post overlay sources

**Key debugging locations:**

- Where to find the prepared sources with overlays applied
- RPM build output directories (`base/out/`)
- Build logs (`base/build/logs/`)
- Mock chroot (when preserved)

### Experimental Agents

Custom agents are `.agent.md` files with optional YAML frontmatter. Key frontmatter fields:

- `description` — shown as placeholder text in chat
- `tools` — restricts which tools are available (e.g., read-only for review agents)
- `model` — preferred AI model
- `handoffs` — suggested transitions to other agents after a response

Consider creating 1-2 specialized agents:

1. **Component Hygiene Agent** (`hygiene-review.agent.md`)
   - Reviews component definitions for hygiene violations
   - Suggests file organization improvements
   - Validates overlay descriptions exist
   - `tools`: limit to read-only tools to prevent accidental changes
   - `handoffs`: offer transition to implementation agent for fixes

2. **Overlay Specialist Agent** (`overlay-specialist.agent.md`)
   - Deep knowledge of overlay types and patterns
   - Can analyze upstream specs to suggest overlays
   - Helps debug complex overlay failures
   - `tools`: include file editing and terminal for testing fixes

### Prompts Design

Prompts are reusable, parameterized workflows that users can invoke directly via `/` in chat. They are `.prompt.md` files stored in `.github/prompts/`. **Prompts are VS Code only** — Copilot CLI does not currently support `/prompt` invocation.

**Key prompt file features:**

- **YAML frontmatter** — optional `description`, `agent`, `tools`, `model` fields
- **Input variables** — use `${input:variableName}` or `${input:variableName:placeholder}` for user-provided parameters
- **Built-in variables** — `${file}`, `${selection}`, `${workspaceFolder}`, etc.
- **Markdown links** — reference skill and instruction files using relative paths
- **Tool references** — use `#tool:<tool-name>` syntax to reference specific tools
- **Agent selection** — `agent:` frontmatter can route the prompt through a custom agent

**Critical design principle — prompts are thin wrappers around skills:**

Since prompts are VS Code only, all domain knowledge must live in skills (which are cross-platform). Each prompt should:

1. **Collect user input** via `${input:...}` variables
2. **Reference the corresponding skill** via a Markdown link (e.g., `[skill](../.github/skills/azl-add-component/SKILL.md)`), so the skill's instructions are loaded into context
3. **Orchestrate the workflow** — define the step-by-step sequence, but delegate the "how" to the skill
4. **Add VS Code-specific affordances** — use `agent:`, `tools:`, and built-in variables that only make sense in VS Code

This ensures Copilot CLI users get the same guidance via automatic skill discovery, even without `/prompt` support. If Copilot CLI adds prompt support in the future, the thin-wrapper design means prompts will work there too with minimal changes.

**Skills vs Prompts distinction:**

- **Skills** are **on-demand capabilities** loaded automatically when Copilot detects relevance. They provide comprehensive domain knowledge and can include scripts/resources. *Cross-platform.*
- **Prompts** are **user-invoked workflows** triggered explicitly via `/command`. They are streamlined action orchestrators. *VS Code only.*

Both cover similar topics but serve different purposes. Skills answer "how does this work?" while prompts answer "help me do this now."

#### `add-component.prompt.md`

**Purpose:** Guided workflow for adding a new component to Azure Linux
**References:** `azl-add-component/SKILL.md` (linked via Markdown, provides domain knowledge)

**Input variables** (via `${input:...}` syntax):

- `${input:component_name:package name}` (required) - Name of the component to add
- `${input:source_distro:fedora}` (optional) - Upstream distro to source from
- `${input:project:base}` (optional) - Target project (base, extras, etc.)

**Workflow orchestration** (detailed guidance lives in the skill):

- Check for existing component
- Gather upstream spec information
- Determine customization needs
- Create component definition (inline or dedicated file)
- Add overlays with meaningful descriptions
- Validate and optionally test build

#### `update-component.prompt.md`

**Purpose:** Guided workflow for updating an existing component
**References:** `azl-update-component/SKILL.md` (linked via Markdown, provides domain knowledge)

**Input variables:**

- `${input:component_name:package name}` (required) - Name of the component to update
- `${input:new_version:target version}` (optional) - Target version (if version bump)
- `${input:update_type:version|dependency|overlay|config}` (optional) - Type of update

**Workflow orchestration** (detailed guidance lives in the skill):

- Query current state before changes
- Identify scope of update
- Review upstream changes for version bumps
- Update component definition appropriately
- Migrate to dedicated file if needed
- Validate and test

#### `review-component.prompt.md`

**Purpose:** Review a component definition for hygiene and best practices
**References:** Hygiene rules from `copilot-instructions.md` and `base/comps/AGENTS.md` (linked via Markdown)

**Input variables:**

- `${input:component_name:package name}` (required) - Name of the component to review

**Review areas:**

- File organization and structure
- Overlay quality (descriptions, patterns)
- Naming conventions
- Dependency correctness
- Source accessibility

**Output:** Structured report with findings and recommendations

#### `debug-overlay.prompt.md`

**Purpose:** Diagnose and fix overlay application failures
**References:** `azl-fix-overlay/SKILL.md` (linked via Markdown, provides diagnostic knowledge)

**Input variables:**

- `${input:component_name:package name}` (required) - Name of the failing component
- `${input:error_message:paste error here}` (optional) - Error message from build/validation

**Diagnostic concepts:**

- Interpreting overlay error messages
- Comparing overlay expectations vs upstream spec content
- Identifying root causes (upstream drift, pattern issues, type mismatches)
- Suggesting appropriate fixes

**Common diagnoses:**

- Upstream spec changed, breaking pattern match
- Section or tag renamed/removed
- Wrong overlay type for the situation

#### `migrate-component.prompt.md`

**Purpose:** Migrate an inline component definition to a dedicated file
**References:** Migration guidance from `azl-update-component/SKILL.md` and `base/comps/AGENTS.md` (linked via Markdown)

**Input variables:**

- `${input:component_name:package name}` (required) - Name of the component to migrate

**When to use:**

- Adding first customization to a simple import
- Component definition is getting complex
- Adding overlays to an inline component

**Workflow concepts:**

- Extract current inline definition
- Create dedicated `<name>/<name>.comp.toml` file
- Update includes if needed
- Validate component resolution unchanged

## Implementation Plan

### Phase 1: Foundation (cross-platform)

- [x] Create `.github/copilot-instructions.md` with project overview, key concepts, CLI reference, hygiene rules
- [x] Create `AGENTS.md` (root) — lean: conventions, skill table, directory pointers
- [x] Create `base/comps/AGENTS.md` — lean: file organization rules, skill pointers
- [x] Create `distro/AGENTS.md` — build defaults, structure overview, shared config warning
- [x] Create skill stubs (`.github/skills/azl-{add-component,fix-overlay,build-component}/SKILL.md`)

### Phase 2: Agent Skills (cross-platform, open standard)

Each skill is a directory with a `SKILL.md` file following the [Agent Skills standard](https://agentskills.io/). Include required `name` and `description` YAML frontmatter. Add scripts/examples/resources alongside `SKILL.md` as needed.

Skills are for explicit task workflows only — domain knowledge goes in passive context (Phase 1 + Phase 3).

- [x] Create `.github/skills/azl-build-component/SKILL.md` (full content)
- [ ] Flesh out `.github/skills/azl-add-component/SKILL.md` (currently a stub)
- [ ] Flesh out `.github/skills/azl-fix-overlay/SKILL.md` (currently a stub)
- [ ] Write clear `description` fields with trigger phrases so Copilot can match skills to user requests
- [x] Link skills from `AGENTS.md` files for discoverability

### Phase 3: File-Type Instructions (cross-platform)

These `.instructions.md` files use `applyTo` globs for automatic context injection. Both VS Code and Copilot CLI support them. **This is the primary home for domain knowledge** — structural patterns, TOML syntax, valid overlay shapes, component definition examples. This content was deliberately removed from AGENTS.md to reduce always-on context tax, and placed here where it fires only when the agent is actually working with the relevant file type.

- [ ] Create `.github/instructions/comp-toml.instructions.md` (`applyTo: "**/*.comp.toml"`)
  - Component definition patterns (inline vs dedicated, examples)
  - Overlay syntax and common patterns
  - Schema overview and required fields
  - When to use inline vs file-based definitions
- [ ] Create `.github/instructions/spec-handcoded.instructions.md` (`applyTo: "**/*.spec"`)
- [ ] Create `.github/instructions/spec-generated.instructions.md` - pending directory structure
- [ ] Create `.github/instructions/kiwi.instructions.md` (`applyTo: "**/*.kiwi"`) - image build definitions

### Phase 4: Prompts (VS Code only)

Prompts are thin wrappers: they collect user input via `${input:...}` variables and reference the corresponding skill via Markdown links for domain knowledge. This ensures the same guidance is available to Copilot CLI users via automatic skill discovery. Use optional `agent:`/`tools:` frontmatter for VS Code-specific affordances.

- [ ] Create `.github/prompts/add-component.prompt.md`
- [ ] Create `.github/prompts/update-component.prompt.md`
- [ ] Create `.github/prompts/review-component.prompt.md`
- [ ] Create `.github/prompts/debug-overlay.prompt.md`
- [ ] Create `.github/prompts/debug-build.prompt.md` - Debug build failures using mock shell
- [ ] Create `.github/prompts/migrate-component.prompt.md`

### Phase 5: Experimental Agents (cross-platform)

Agents are `.agent.md` files in `.github/agents/`. Both VS Code and Copilot CLI discover them. Use YAML frontmatter to restrict tools, set models, and define handoffs.

- [ ] Evaluate need for Component Hygiene agent (`hygiene-review.agent.md`)
- [ ] Evaluate need for Overlay Specialist agent (`overlay-specialist.agent.md`)
- [ ] Implement 0-2 agents based on evaluation
- [ ] If multiple agents, consider handoffs between them for workflow continuity

### Phase 6: MCP and VS Code Integration (VS Code only)

- [ ] Create `.vscode/mcp.json` configuration for azldev MCP tools
- [ ] Document MCP tool usage in instructions once end-to-end flow is complete
- [ ] If Copilot CLI gains MCP support, evaluate a cross-platform MCP config location

## Areas to Revisit Regularly

These aspects of the PRD should be reviewed and updated as the project evolves:

| Area | Trigger for Review | Notes |
| ---- | ------------------ | ----- |
| **azldev commands** | New azldev release | Command syntax or new features may change |
| **MCP integration** | MCP server available | Switch from shell to MCP tools in instructions |
| **CI/CD guidance** | CI pipeline added | Add validation/testing instructions |
| **Overlay patterns** | New overlay types | Document new overlay capabilities |
| **Hygiene rules** | Team feedback | Rules may need adjustment based on practice |
| **Skills coverage** | Common support requests | Add skills for frequently asked workflows |
| **Prompts coverage** | User feedback | Add prompts for common interactive workflows |
| **External contributors** | Public launch | Review for internal assumptions |
| **Policy alignment** | CONTRIBUTING.md updates | Ensure agent instructions match human-readable policies |
| **Cross-platform support** | New Copilot surfaces | Check if new GitHub Copilot surfaces support additional file types |

## Success Criteria

### Quantitative

- Agents can add a simple component with ≤2 human corrections
- Agents can diagnose common overlay errors and suggest fixes
- 95% of component definitions pass hygiene checks

### Qualitative

- Team members report agents are "helpful" for component workflows
- Reduced time spent explaining basic concepts to new contributors
- Overlay debugging is faster with agent assistance

## Open Questions

1. **Generated spec location:** Where will generated specs be stored (if implemented)? This affects file-type instruction placement.

2. **Hygiene enforcement:** Should agents enforce hygiene rules strictly, or just warn?
   - **Resolution:** Agents should warn and explain, not block. The goal is AI code reviewers flagging bad practices and ensuring new agent-written code is clean. Enforcement checks will be added incrementally over time.

3. **Skill naming convention:** Should skills be prefixed (`azl-`) or namespaced differently? The Agent Skills standard requires lowercase names with hyphens (max 64 chars).

4. **Agent scope:** Should experimental agents be repo-specific or potentially shared across Azure Linux repos? Should azldev have a command to install the resources into other repos?

5. **Prompts vs Skills overlap:** Some workflows exist as both skills and prompts (e.g., add-component). Should we consolidate, or keep both for different use cases (reference vs interactive)?
   - **Resolution:** Keep both, but with a clear layering: skills hold task workflow knowledge (cross-platform), prompts are thin wrappers that reference skills and add VS Code-specific affordances (input variables, agent routing, tool selection). This avoids knowledge duplication and ensures Copilot CLI users get the same guidance via automatic skill discovery.

6. **Passive vs active context balance:** Research shows passive context (AGENTS.md) dramatically outperforms skills for domain knowledge. But passive context is a per-interaction token tax. Our current split: lean AGENTS.md (guardrails) + `.instructions.md` (domain knowledge, scoped by file type) + skills (task workflows). This may need tuning based on real usage — if agents still miss domain knowledge when `.instructions.md` doesn't fire (e.g., asking about components without a `.comp.toml` open), we may need to move some content back to always-on AGENTS.md.

## Appendix: Key azldev Capabilities

**Note:** azldev is under active development. Command syntax may change. Always reference `azldev --help` for current usage.

**Core component operations:**

- Listing components in the project
- Querying component details and resolved spec information
- Adding new components from upstream
- Building components (produces RPMs via mock)
- Preparing sources with overlays applied
- Interactive debugging via mock shell

**Project operations:**

- Querying project-level configuration
- Managing distro definitions

## Appendix: Overlay Quick Reference

Overlays modify upstream specs without forking. Below are illustrative examples; see `external/schemas/azldev.schema.json` for the complete overlay type definitions and required fields. Also reference `overlays.toml` from `azldev` for up-to-date patterns.

### Example 1: Add a build dependency

```toml
[[components.mypackage.overlays]]
description = "Add missing build dependency"
type = "spec-add-tag"
tag = "BuildRequires"
value = "golang >= 1.21"
```

### Example 2: Regex replacement in spec

```toml
[[components.mypackage.overlays]]
description = "Customize vendor string"
type = "spec-search-replace"
regex = "VENDOR=upstream"
replacement = "VENDOR=azurelinux"
```

### Example 3: Append to a section

```toml
[[components.mypackage.overlays]]
description = "Add Azure Linux specific install step"
type = "spec-append-lines"
section = "%install"
lines = "install -D -m 644 azl-config %{buildroot}/etc/mypackage/azl.conf"
```

**Common overlay categories:**

- `spec-*` overlays: Modify RPM spec tags and sections
- `file-*` overlays: Add, remove, rename, or modify source files
