# PRD: Agent Instructions and Skills for Azure Linux

Title: PRD: Agent Instructions and Skills for Azure Linux
Author: Daniel McIlvaney
Created: 2026-01-29
Updated: 2026-01-29
Status: Draft

## Overview

This PRD defines the foundation for AI agent support in the Azure Linux repository. The goal is to enable agents to effectively assist with component management workflows using the `azldev` tool, while maintaining code quality and repository hygiene standards.

**Related ideas:** None (greenfield)

## Problem Statement

Azure Linux component maintainers will benefit from AI agent assistance for common workflows:

- Adding new components to the distro
- Updating existing components (version bumps, dependency changes)
- Writing and debugging overlays (spec modifications)
- Maintaining repository hygiene (file organization, consistent patterns)

Without proper instructions, agents lack context about:

- The TOML-based metadata system (`*.comp.toml`, `*.distro.toml`)
- The overlay system for modifying upstream specs
- The `azldev` tool commands and workflows
- Repository conventions and hygiene requirements
- Component specific workflows

## Target Users

- **v1:** Azure Linux team members
- **Future:** External contributors (instructions should not assume internal-only context, referenced tools should be publicly available)

## Scope

### In Scope (v1)

1. **Repository-wide instructions** (`.github/copilot-instructions.md`)
   - Overview of Azure Linux architecture
   - Key directories and their purposes
   - Common workflows at a high level
   - Links to detailed guidance

2. **File-type specific instructions**
   - `*.comp.toml` - Component definition files
   - `*.distro.toml` - Distro configuration files
   - `*.spec` - RPM spec files (hand-coded)
   - `generated/*.spec` - RPM spec files (generated by azldev, generated spec feature is undecided)

3. **Directory-specific instructions** (where valuable)
   - `base/comps/` - Core component definitions
   - `distro/` - Distro configuration

4. **Copilot Skills** (`.github/skills/`)
   - `add-component.md` - Adding a new component to the distro
   - `update-component.md` - Updating an existing component
   - `fix-overlay.md` - Diagnosing and fixing overlay issues
   - `build-component.md` - How to build and test components

5. **Experimental custom agents** (`.github/agents/`, 1-2 maximum)
   - Consider: Component reviewer agent, Overlay specialist agent

6. **Prompt templates** (`.github/prompts/*.prompt.md`)
   - `add-component.prompt.md` - Guided workflow for adding a new component
   - `update-component.prompt.md` - Guided workflow for updating an existing component
   - `review-component.prompt.md` - Review a component for hygiene and best practices
   - `debug-overlay.prompt.md` - Diagnose and fix overlay issues
   - `migrate-component.prompt.md` - Migrate inline component to dedicated file

### Out of Scope (v1)

- CI/CD integration (no meaningful CI exists yet)
  - Pre-commit hooks should be considered future work
- Full MCP server integration (partial support exists; see MCP Integration Roadmap section)
- External contributor onboarding flows
- Automated regeneration of agent instructions via `azldev`

## Technical Design

### Directory Structure

```text
azurelinux/
├── .github/
│   ├── copilot-instructions.md         # Repository-wide instructions
│   ├── instructions/*.instructions.md  # File-type specific instructions
│   ├── prompts/*.prompt.md             # Prompt templates
│   └── skills/
│       ├── azl-add-component.md
│       ├── azl-update-component.md
│       └── azl-fix-overlay.md
├── .vscode/
│   ├── mcp.json                         # MCP tool configuration
│   └── (optional agent definitions)
├── base/
│   └── comps/
│       └── AGENTS.md                    # Component management guidance
├── distro/
│   └── AGENTS.md                        # Distro configuration guidance
└── AGENTS.md                            # General orientation
```

### Schema Reference

The authoritative schema for `.comp.toml` and `.distro.toml` files is at `external/schemas/azldev.schema.json`. Implementers should reference this for complete field definitions, overlay types, and validation rules.

**Note:** This schema is static, we need a way to keep it updated as azldev evolves (publish with azldev releases?).

### Human-Readable Policies

Agent instructions encode repository policies, but these policies should also be documented in human-readable form for contributors who aren't using AI agents.

**Recommended approach:**

- `CONTRIBUTING.md` - Main entry point for human contributors, should include or link to:
  - Repository hygiene rules (file organization, naming conventions)
  - Component contribution guidelines
  - Overlay best practices
  - Version update policies

**Single source of truth principle:**

To avoid drift between human docs and agent instructions, consider:

1. **Shared policy definitions** - Define policies in a canonical location (e.g., `docs/policies/`) that both CONTRIBUTING.md and agent instructions reference
2. **Regular alignment reviews** - Add to "Areas to Revisit Regularly" table
3. **Cross-references** - Agent instructions should link to human docs; human docs should note that agents follow the same rules

**Open question:** Should policies be authored primarily for humans (with agents consuming them) or for agents (with human-readable summaries generated)? The former is more traditional; the latter may be more maintainable as agent usage grows.

### Repository-Wide Instructions

The main instructions file should cover:

1. **Project Overview**
   - Azure Linux is a TOML-based distro definition
   - Components are defined in `*.comp.toml` files
   - Overlays modify upstream specs without forking

2. **Key Concepts**
   - Components vs RPM packages (output artifacts)
   - Upstream distros (Fedora) and how specs are sourced
   - The overlay system and when to use it

3. **azldev Tool Reference**
   - Document key azldev subcommands for component management (list, query, add, build, etc.)
   - Implementer should reference `azldev --help` for up-to-date command syntax
   - Note: azldev is under active development; command syntax may change

4. **Repository Hygiene Rules**
   - Components defined as more than a single line with just the name SHOULD have their own `.comp.toml` file (guideline, not strict rule)
   - Overlays MUST include a `description` field
   - Component names should match upstream where possible

5. **Common Workflows** (summary, link to skills for details)

### File-Type Instructions

#### `*.comp.toml` Instructions

- Schema overview and required fields
- When to use inline vs file-based definitions
- Overlay syntax and common patterns
- How to validate component definitions using azldev

#### `*.distro.toml` Instructions

- Purpose: defining distro-level configuration
- Include directives and file organization
- Upstream distro references

#### `*.spec` Instructions (Hand-coded)

- When hand-coded specs are appropriate
- Azure Linux-specific macros and conventions
- Relationship to overlays (prefer overlays when possible)

#### `*.spec` Instructions (Generated)

- These are OUTPUT files, do not edit directly
- How to trace back to source component
- Useful for debugging overlay results

#### `*.kiwi` Instructions

- Purpose: defining image builds

### Skills Design

#### `azl-add-component.md`

**Trigger:** User wants to add a new component

**Concepts to cover:**

- How to check if a component already exists
- Determining the appropriate source distro (usually Fedora)
- When to use inline definition vs dedicated `.comp.toml` file
- Adding overlays when customizations are needed
- Validating the component definition
- Testing with a build

**Decision tree:**

- Simple import (no changes) → Add to `components.toml`
- Needs overlays or customizations → Create `<name>/<name>.comp.toml`

#### `azl-update-component.md`

**Trigger:** User wants to update a component version or configuration

**Concepts to cover:**

- Querying current component state before making changes
- Identifying update type (version bump, dependency change, overlay modification)
- Making changes to component definitions
- When to migrate from inline to dedicated file
- Validation and test build workflow

**Versioning and Compatibility Considerations:**

When updating components, agents MUST be cautious about version changes:

- **Major version bumps** (e.g., 1.x → 2.x): High risk. May break API/ABI compatibility. Require explicit user approval and should note potential downstream impact.
- **Minor version bumps** (e.g., 1.2 → 1.3): Medium risk. Generally safe but may introduce new dependencies or deprecations.
- **Patch version bumps** (e.g., 1.2.3 → 1.2.4): Low risk. Usually safe for security fixes and bug fixes.
- `.toml` files will document the version change policy for each component.

Agents should:

1. **Never assume backwards compatibility** - Check upstream release notes for breaking changes
2. **Flag soname changes** - Library packages with changed sonames may break dependent packages
3. **Note new dependencies** - Version updates may pull in new BuildRequires or Requires
4. **Examine existing overlays** - Ensure overlays still apply cleanly to new version. If an overlay fails, treat as a breaking change. If an overlay is no longer needed, recommend its removal.
5. **Warn about feature removal** - Upstream may remove features that Azure Linux depends on
6. **Summarize risks/changes** - Provide a summary of potential impacts of the version update

When in doubt, recommend the user review the upstream changelog before proceeding, with references if available.

#### `azl-fix-overlay.md`

**Trigger:** Overlay errors during build or validation

**Concepts to cover:**

- Reading and interpreting overlay error messages
- Understanding overlay type requirements and constraints
- Diagnosing `spec-*` overlay failures (section/tag existence)
- Diagnosing regex overlay failures (pattern matching)
- Diagnosing `file-*` overlay failures (file existence)

**Common failure patterns:**

- Pattern doesn't match upstream (upstream changed)
- Tag already exists (use set instead of add)
- Section not found (case sensitivity, renamed sections)

#### `azl-debug-build.md`

**Trigger:** Build failures that require interactive debugging

**Concepts to cover:**

- How to preserve build state on failure for inspection
- Entering the mock shell environment for interactive debugging
- Key locations where build artifacts and logs are stored
- Iterative workflow: inspect → hypothesize → fix → retry

**Key debugging locations:**

- Where to find the prepared sources with overlays applied
- RPM build output directories
- Build logs in mock output

### Experimental Agents

Consider creating 1-2 specialized agents:

1. **Component Hygiene Agent**
   - Reviews component definitions for hygiene violations
   - Suggests file organization improvements
   - Validates overlay descriptions exist

2. **Overlay Specialist Agent**
   - Deep knowledge of overlay types and patterns
   - Can analyze upstream specs to suggest overlays
   - Helps debug complex overlay failures

### Prompts Design

Prompts are reusable, parameterized workflows that users can invoke directly.

**Skills vs Prompts distinction:**

- **Skills** are **reference documentation** for agents to consult passively. They provide comprehensive information about a topic.
- **Prompts** are **interactive workflows** that guide users through multi-step processes actively. They are streamlined action guides.

Both may cover similar topics but serve different purposes. Skills answer "how does this work?" while prompts answer "help me do this now."

#### `add-component.prompt.md`

**Purpose:** Guided workflow for adding a new component to Azure Linux

**Parameters:**

- `component_name` (required) - Name of the component to add
- `source_distro` (optional, default: fedora) - Upstream distro to source from
- `project` (optional, default: base) - Target project (base, extras, etc.)

**Workflow concepts:**

- Check for existing component
- Gather upstream spec information
- Determine customization needs
- Create component definition (inline or dedicated file)
- Add overlays with meaningful descriptions
- Validate and optionally test build

#### `update-component.prompt.md`

**Purpose:** Guided workflow for updating an existing component

**Parameters:**

- `component_name` (required) - Name of the component to update
- `new_version` (optional) - Target version (if version bump)
- `update_type` (optional) - Type: version, dependency, overlay, or config

**Workflow concepts:**

- Query current state before changes
- Identify scope of update
- Review upstream changes for version bumps
- Update component definition appropriately
- Migrate to dedicated file if needed
- Validate and test

#### `review-component.prompt.md`

**Purpose:** Review a component definition for hygiene and best practices

**Parameters:**

- `component_name` (required) - Name of the component to review

**Review areas:**

- File organization and structure
- Overlay quality (descriptions, patterns)
- Naming conventions
- Dependency correctness
- Source accessibility

**Output:** Structured report with findings and recommendations

#### `debug-overlay.prompt.md`

**Purpose:** Diagnose and fix overlay application failures

**Parameters:**

- `component_name` (required) - Name of the failing component
- `error_message` (optional) - Error message from build/validation

**Diagnostic concepts:**

- Interpreting overlay error messages
- Comparing overlay expectations vs upstream spec content
- Identifying root causes (upstream drift, pattern issues, type mismatches)
- Suggesting appropriate fixes

**Common diagnoses:**

- Upstream spec changed, breaking pattern match
- Section or tag renamed/removed
- Wrong overlay type for the situation

#### `migrate-component.prompt.md`

**Purpose:** Migrate an inline component definition to a dedicated file

**Parameters:**

- `component_name` (required) - Name of the component to migrate

**When to use:**

- Adding first customization to a simple import
- Component definition is getting complex
- Adding overlays to an inline component

**Workflow concepts:**

- Extract current inline definition
- Create dedicated `<name>/<name>.comp.toml` file
- Update includes if needed
- Validate component resolution unchanged

## Implementation Plan

### Phase 1: Foundation

- [ ] Create `.github/copilot-instructions.md` with project overview
- [ ] Create `base/comps/.instructions.md` for component guidance
- [ ] Create `distro/.instructions.md` for distro config guidance

### Phase 2: Skills

- [ ] Create `.github/skills/azl-add-component.md`
- [ ] Create `.github/skills/azl-update-component.md`
- [ ] Create `.github/skills/azl-fix-overlay.md`
- [ ] Create `.github/skills/azl-debug-build.md`

### Phase 3: File-Type Instructions

- [ ] Create `.instructions.md` for `*.comp.toml` files
- [ ] Create `.instructions.md` for `*.spec` files (hand-coded)
- [ ] Create `.instructions.md` for `*.spec` files (generated) - pending directory structure

### Phase 4: Prompts

- [ ] Create `.github/prompts/add-component.prompt.md`
- [ ] Create `.github/prompts/update-component.prompt.md`
- [ ] Create `.github/prompts/review-component.prompt.md`
- [ ] Create `.github/prompts/debug-overlay.prompt.md`
- [ ] Create `.github/prompts/debug-build.prompt.md` - Debug build failures using mock shell
- [ ] Create `.github/prompts/migrate-component.prompt.md`

### Phase 5: Experimental Agents

- [ ] Evaluate need for Component Hygiene agent
- [ ] Evaluate need for Overlay Specialist agent
- [ ] Implement 0-2 agents based on evaluation

### Phase 6: MCP and VS Code Integration

- [ ] Create `.vscode/mcp.json` configuration for azldev MCP tools
- [ ] Document MCP tool usage in instructions once end-to-end flow is complete

## Areas to Revisit Regularly

These aspects of the PRD should be reviewed and updated as the project evolves:

| Area | Trigger for Review | Notes |
| ---- | ------------------ | ----- |
| **azldev commands** | New azldev release | Command syntax or new features may change |
| **MCP integration** | MCP server available | Switch from shell to MCP tools in instructions |
| **CI/CD guidance** | CI pipeline added | Add validation/testing instructions |
| **Overlay patterns** | New overlay types | Document new overlay capabilities |
| **Hygiene rules** | Team feedback | Rules may need adjustment based on practice |
| **Skills coverage** | Common support requests | Add skills for frequently asked workflows |
| **Prompts coverage** | User feedback | Add prompts for common interactive workflows |
| **External contributors** | Public launch | Review for internal assumptions |
| **Policy alignment** | CONTRIBUTING.md updates | Ensure agent instructions match human-readable policies |

## Success Criteria

### Quantitative

- Agents can add a simple component with ≤2 human corrections
- Agents can diagnose common overlay errors and suggest fixes
- 95% of component definitions pass hygiene checks

### Qualitative

- Team members report agents are "helpful" for component workflows
- Reduced time spent explaining basic concepts to new contributors
- Overlay debugging is faster with agent assistance

## Open Questions

1. **Generated spec location:** Where will generated specs be stored (if implemented)? This affects file-type instruction placement.

2. **Hygiene enforcement:** Should agents enforce hygiene rules strictly, or just warn?
   - **Resolution:** Agents should warn and explain, not block. The goal is AI code reviewers flagging bad practices and ensuring new agent-written code is clean. Enforcement checks will be added incrementally over time.

3. **Skill naming convention:** Should skills be prefixed (`azl-`) or namespaced differently?

4. **Agent scope:** Should experimental agents be repo-specific or potentially shared across Azure Linux repos? Should azldev have a command to install the resources into other repos?

5. **Prompts vs Skills overlap:** Some workflows exist as both skills and prompts (e.g., add-component). Should we consolidate, or keep both for different use cases (reference vs interactive)?
   - **Resolution:** Keep both. Skills are reference documentation (passive); prompts are interactive workflows (active). They serve different purposes even when covering similar topics. The prompt may refer to the skill for deeper understanding.

## Appendix: Key azldev Capabilities

**Note:** azldev is under active development. Command syntax may change. Always reference `azldev --help` for current usage.

**Core component operations:**

- Listing components in the project
- Querying component details and resolved spec information
- Adding new components from upstream
- Building components (produces RPMs via mock)
- Preparing sources with overlays applied
- Interactive debugging via mock shell

**Project operations:**

- Querying project-level configuration
- Managing distro definitions

## Appendix: Overlay Quick Reference

Overlays modify upstream specs without forking. Below are illustrative examples; see `external/schemas/azldev.schema.json` for the complete overlay type definitions and required fields. Also reference `overlays.toml` from `azldev` for up-to-date patterns.

### Example 1: Add a build dependency

```toml
[[components.mypackage.overlays]]
description = "Add missing build dependency"
type = "spec-add-tag"
tag = "BuildRequires"
value = "golang >= 1.21"
```

### Example 2: Regex replacement in spec

```toml
[[components.mypackage.overlays]]
description = "Customize vendor string"
type = "spec-search-replace"
regex = "VENDOR=upstream"
replacement = "VENDOR=azurelinux"
```

### Example 3: Append to a section

```toml
[[components.mypackage.overlays]]
description = "Add Azure Linux specific install step"
type = "spec-append-lines"
section = "%install"
lines = "install -D -m 644 azl-config %{buildroot}/etc/mypackage/azl.conf"
```

**Common overlay categories:**

- `spec-*` overlays: Modify RPM spec tags and sections
- `file-*` overlays: Add, remove, rename, or modify source files
