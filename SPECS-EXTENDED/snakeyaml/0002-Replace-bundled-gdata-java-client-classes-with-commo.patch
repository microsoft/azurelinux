From f06ff492f18d7c9cdf861a79293279e5ed55823f Mon Sep 17 00:00:00 2001
From: Michal Srb <msrb@redhat.com>
Date: Fri, 26 Apr 2013 07:32:04 +0200
Subject: [PATCH 2/2] Replace bundled gdata-java-client classes with
 commons-codec

---
 .../gdata/util/common/base/Escaper.java       |  97 ----
 .../util/common/base/PercentEscaper.java      | 281 ----------
 .../util/common/base/UnicodeEscaper.java      | 506 ------------------
 .../org/yaml/snakeyaml/util/UriEncoder.java   |  37 +-
 4 files changed, 28 insertions(+), 893 deletions(-)
 delete mode 100644 src/main/java/org/yaml/snakeyaml/external/com/google/gdata/util/common/base/Escaper.java
 delete mode 100644 src/main/java/org/yaml/snakeyaml/external/com/google/gdata/util/common/base/PercentEscaper.java
 delete mode 100644 src/main/java/org/yaml/snakeyaml/external/com/google/gdata/util/common/base/UnicodeEscaper.java

diff --git a/src/main/java/org/yaml/snakeyaml/external/com/google/gdata/util/common/base/Escaper.java b/src/main/java/org/yaml/snakeyaml/external/com/google/gdata/util/common/base/Escaper.java
deleted file mode 100644
index c26e3cb..0000000
--- a/src/main/java/org/yaml/snakeyaml/external/com/google/gdata/util/common/base/Escaper.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/* Copyright (c) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.yaml.snakeyaml.external.com.google.gdata.util.common.base;
-
-/**
- * An object that converts literal text into a format safe for inclusion in a
- * particular context (such as an XML document). Typically (but not always), the
- * inverse process of "unescaping" the text is performed automatically by the
- * relevant parser.
- * 
- * <p>
- * For example, an XML escaper would convert the literal string
- * {@code "Foo<Bar>"} into {@code "Foo&lt;Bar&gt;"} to prevent {@code "<Bar>"}
- * from being confused with an XML tag. When the resulting XML document is
- * parsed, the parser API will return this text as the original literal string
- * {@code "Foo<Bar>"}.
- * 
- * <p>
- * An {@code Escaper} instance is required to be stateless, and safe when used
- * concurrently by multiple threads.
- * 
- * <p>
- * Several popular escapers are defined as constants in the class
- * {@link CharEscapers}. To create your own escapers, use
- * {@link CharEscaperBuilder}, or extend {@link CharEscaper} or
- * {@code UnicodeEscaper}.
- * 
- * 
- */
-public interface Escaper {
-    /**
-     * Returns the escaped form of a given literal string.
-     * 
-     * <p>
-     * Note that this method may treat input characters differently depending on
-     * the specific escaper implementation.
-     * <ul>
-     * <li>{@link UnicodeEscaper} handles <a
-     * href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a> correctly,
-     * including surrogate character pairs. If the input is badly formed the
-     * escaper should throw {@link IllegalArgumentException}.
-     * <li>{@link CharEscaper} handles Java characters independently and does
-     * not verify the input for well formed characters. A CharEscaper should not
-     * be used in situations where input is not guaranteed to be restricted to
-     * the Basic Multilingual Plane (BMP).
-     * </ul>
-     * 
-     * @param string
-     *            the literal string to be escaped
-     * @return the escaped form of {@code string}
-     * @throws NullPointerException
-     *             if {@code string} is null
-     * @throws IllegalArgumentException
-     *             if {@code string} contains badly formed UTF-16 or cannot be
-     *             escaped for any other reason
-     */
-    public String escape(String string);
-
-    /**
-     * Returns an {@code Appendable} instance which automatically escapes all
-     * text appended to it before passing the resulting text to an underlying
-     * {@code Appendable}.
-     * 
-     * <p>
-     * Note that this method may treat input characters differently depending on
-     * the specific escaper implementation.
-     * <ul>
-     * <li>{@link UnicodeEscaper} handles <a
-     * href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a> correctly,
-     * including surrogate character pairs. If the input is badly formed the
-     * escaper should throw {@link IllegalArgumentException}.
-     * <li>{@link CharEscaper} handles Java characters independently and does
-     * not verify the input for well formed characters. A CharEscaper should not
-     * be used in situations where input is not guaranteed to be restricted to
-     * the Basic Multilingual Plane (BMP).
-     * </ul>
-     * 
-     * @param out
-     *            the underlying {@code Appendable} to append escaped output to
-     * @return an {@code Appendable} which passes text to {@code out} after
-     *         escaping it.
-     */
-    public Appendable escape(Appendable out);
-}
diff --git a/src/main/java/org/yaml/snakeyaml/external/com/google/gdata/util/common/base/PercentEscaper.java b/src/main/java/org/yaml/snakeyaml/external/com/google/gdata/util/common/base/PercentEscaper.java
deleted file mode 100644
index 5e2f902..0000000
--- a/src/main/java/org/yaml/snakeyaml/external/com/google/gdata/util/common/base/PercentEscaper.java
+++ /dev/null
@@ -1,281 +0,0 @@
-/* Copyright (c) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.yaml.snakeyaml.external.com.google.gdata.util.common.base;
-
-/**
- * A {@code UnicodeEscaper} that escapes some set of Java characters using the
- * URI percent encoding scheme. The set of safe characters (those which remain
- * unescaped) can be specified on construction.
- * 
- * <p>
- * For details on escaping URIs for use in web pages, see section 2.4 of <a
- * href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>.
- * 
- * <p>
- * In most cases this class should not need to be used directly. If you have no
- * special requirements for escaping your URIs, you should use either
- * {@link CharEscapers#uriEscaper()} or {@link CharEscapers#uriEscaper(boolean)}.
- * 
- * <p>
- * When encoding a String, the following rules apply:
- * <ul>
- * <li>The alphanumeric characters "a" through "z", "A" through "Z" and "0"
- * through "9" remain the same.
- * <li>Any additionally specified safe characters remain the same.
- * <li>If {@code plusForSpace} was specified, the space character " " is
- * converted into a plus sign "+".
- * <li>All other characters are converted into one or more bytes using UTF-8
- * encoding and each byte is then represented by the 3-character string "%XY",
- * where "XY" is the two-digit, uppercase, hexadecimal representation of the
- * byte value.
- * </ul>
- * 
- * <p>
- * RFC 2396 specifies the set of unreserved characters as "-", "_", ".", "!",
- * "~", "*", "'", "(" and ")". It goes on to state:
- * 
- * <p>
- * <i>Unreserved characters can be escaped without changing the semantics of the
- * URI, but this should not be done unless the URI is being used in a context
- * that does not allow the unescaped character to appear.</i>
- * 
- * <p>
- * For performance reasons the only currently supported character encoding of
- * this class is UTF-8.
- * 
- * <p>
- * <b>Note</b>: This escaper produces uppercase hexidecimal sequences. From <a
- * href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>:<br>
- * <i>"URI producers and normalizers should use uppercase hexadecimal digits for
- * all percent-encodings."</i>
- * 
- * 
- */
-public class PercentEscaper extends UnicodeEscaper {
-    /**
-     * A string of safe characters that mimics the behavior of
-     * {@link java.net.URLEncoder}.
-     * 
-     */
-    public static final String SAFECHARS_URLENCODER = "-_.*";
-
-    /**
-     * A string of characters that do not need to be encoded when used in URI
-     * path segments, as specified in RFC 3986. Note that some of these
-     * characters do need to be escaped when used in other parts of the URI.
-     */
-    public static final String SAFEPATHCHARS_URLENCODER = "-_.!~*'()@:$&,;=";
-
-    /**
-     * A string of characters that do not need to be encoded when used in URI
-     * query strings, as specified in RFC 3986. Note that some of these
-     * characters do need to be escaped when used in other parts of the URI.
-     */
-    public static final String SAFEQUERYSTRINGCHARS_URLENCODER = "-_.!~*'()@:$,;/?:";
-
-    // In some uri escapers spaces are escaped to '+'
-    private static final char[] URI_ESCAPED_SPACE = { '+' };
-
-    private static final char[] UPPER_HEX_DIGITS = "0123456789ABCDEF".toCharArray();
-
-    /**
-     * If true we should convert space to the {@code +} character.
-     */
-    private final boolean plusForSpace;
-
-    /**
-     * An array of flags where for any {@code char c} if {@code safeOctets[c]}
-     * is true then {@code c} should remain unmodified in the output. If
-     * {@code c > safeOctets.length} then it should be escaped.
-     */
-    private final boolean[] safeOctets;
-
-    /**
-     * Constructs a URI escaper with the specified safe characters and optional
-     * handling of the space character.
-     * 
-     * @param safeChars
-     *            a non null string specifying additional safe characters for
-     *            this escaper (the ranges 0..9, a..z and A..Z are always safe
-     *            and should not be specified here)
-     * @param plusForSpace
-     *            true if ASCII space should be escaped to {@code +} rather than
-     *            {@code %20}
-     * @throws IllegalArgumentException
-     *             if any of the parameters were invalid
-     */
-    public PercentEscaper(String safeChars, boolean plusForSpace) {
-        // Avoid any misunderstandings about the behavior of this escaper
-        if (safeChars.matches(".*[0-9A-Za-z].*")) {
-            throw new IllegalArgumentException(
-                    "Alphanumeric characters are always 'safe' and should not be "
-                            + "explicitly specified");
-        }
-        // Avoid ambiguous parameters. Safe characters are never modified so if
-        // space is a safe character then setting plusForSpace is meaningless.
-        if (plusForSpace && safeChars.contains(" ")) {
-            throw new IllegalArgumentException(
-                    "plusForSpace cannot be specified when space is a 'safe' character");
-        }
-        if (safeChars.contains("%")) {
-            throw new IllegalArgumentException("The '%' character cannot be specified as 'safe'");
-        }
-        this.plusForSpace = plusForSpace;
-        this.safeOctets = createSafeOctets(safeChars);
-    }
-
-    /**
-     * Creates a boolean[] with entries corresponding to the character values
-     * for 0-9, A-Z, a-z and those specified in safeChars set to true. The array
-     * is as small as is required to hold the given character information.
-     */
-    private static boolean[] createSafeOctets(String safeChars) {
-        int maxChar = 'z';
-        char[] safeCharArray = safeChars.toCharArray();
-        for (char c : safeCharArray) {
-            maxChar = Math.max(c, maxChar);
-        }
-        boolean[] octets = new boolean[maxChar + 1];
-        for (int c = '0'; c <= '9'; c++) {
-            octets[c] = true;
-        }
-        for (int c = 'A'; c <= 'Z'; c++) {
-            octets[c] = true;
-        }
-        for (int c = 'a'; c <= 'z'; c++) {
-            octets[c] = true;
-        }
-        for (char c : safeCharArray) {
-            octets[c] = true;
-        }
-        return octets;
-    }
-
-    /*
-     * Overridden for performance. For unescaped strings this improved the
-     * performance of the uri escaper from ~760ns to ~400ns as measured by
-     * {@link CharEscapersBenchmark}.
-     */
-    @Override
-    protected int nextEscapeIndex(CharSequence csq, int index, int end) {
-        for (; index < end; index++) {
-            char c = csq.charAt(index);
-            if (c >= safeOctets.length || !safeOctets[c]) {
-                break;
-            }
-        }
-        return index;
-    }
-
-    /*
-     * Overridden for performance. For unescaped strings this improved the
-     * performance of the uri escaper from ~400ns to ~170ns as measured by
-     * {@link CharEscapersBenchmark}.
-     */
-    @Override
-    public String escape(String s) {
-        int slen = s.length();
-        for (int index = 0; index < slen; index++) {
-            char c = s.charAt(index);
-            if (c >= safeOctets.length || !safeOctets[c]) {
-                return escapeSlow(s, index);
-            }
-        }
-        return s;
-    }
-
-    /**
-     * Escapes the given Unicode code point in UTF-8.
-     */
-    @Override
-    protected char[] escape(int cp) {
-        // We should never get negative values here but if we do it will throw
-        // an
-        // IndexOutOfBoundsException, so at least it will get spotted.
-        if (cp < safeOctets.length && safeOctets[cp]) {
-            return null;
-        } else if (cp == ' ' && plusForSpace) {
-            return URI_ESCAPED_SPACE;
-        } else if (cp <= 0x7F) {
-            // Single byte UTF-8 characters
-            // Start with "%--" and fill in the blanks
-            char[] dest = new char[3];
-            dest[0] = '%';
-            dest[2] = UPPER_HEX_DIGITS[cp & 0xF];
-            dest[1] = UPPER_HEX_DIGITS[cp >>> 4];
-            return dest;
-        } else if (cp <= 0x7ff) {
-            // Two byte UTF-8 characters [cp >= 0x80 && cp <= 0x7ff]
-            // Start with "%--%--" and fill in the blanks
-            char[] dest = new char[6];
-            dest[0] = '%';
-            dest[3] = '%';
-            dest[5] = UPPER_HEX_DIGITS[cp & 0xF];
-            cp >>>= 4;
-            dest[4] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];
-            cp >>>= 2;
-            dest[2] = UPPER_HEX_DIGITS[cp & 0xF];
-            cp >>>= 4;
-            dest[1] = UPPER_HEX_DIGITS[0xC | cp];
-            return dest;
-        } else if (cp <= 0xffff) {
-            // Three byte UTF-8 characters [cp >= 0x800 && cp <= 0xffff]
-            // Start with "%E-%--%--" and fill in the blanks
-            char[] dest = new char[9];
-            dest[0] = '%';
-            dest[1] = 'E';
-            dest[3] = '%';
-            dest[6] = '%';
-            dest[8] = UPPER_HEX_DIGITS[cp & 0xF];
-            cp >>>= 4;
-            dest[7] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];
-            cp >>>= 2;
-            dest[5] = UPPER_HEX_DIGITS[cp & 0xF];
-            cp >>>= 4;
-            dest[4] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];
-            cp >>>= 2;
-            dest[2] = UPPER_HEX_DIGITS[cp];
-            return dest;
-        } else if (cp <= 0x10ffff) {
-            char[] dest = new char[12];
-            // Four byte UTF-8 characters [cp >= 0xffff && cp <= 0x10ffff]
-            // Start with "%F-%--%--%--" and fill in the blanks
-            dest[0] = '%';
-            dest[1] = 'F';
-            dest[3] = '%';
-            dest[6] = '%';
-            dest[9] = '%';
-            dest[11] = UPPER_HEX_DIGITS[cp & 0xF];
-            cp >>>= 4;
-            dest[10] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];
-            cp >>>= 2;
-            dest[8] = UPPER_HEX_DIGITS[cp & 0xF];
-            cp >>>= 4;
-            dest[7] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];
-            cp >>>= 2;
-            dest[5] = UPPER_HEX_DIGITS[cp & 0xF];
-            cp >>>= 4;
-            dest[4] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];
-            cp >>>= 2;
-            dest[2] = UPPER_HEX_DIGITS[cp & 0x7];
-            return dest;
-        } else {
-            // If this ever happens it is due to bug in UnicodeEscaper, not bad
-            // input.
-            throw new IllegalArgumentException("Invalid unicode character value " + cp);
-        }
-    }
-}
diff --git a/src/main/java/org/yaml/snakeyaml/external/com/google/gdata/util/common/base/UnicodeEscaper.java b/src/main/java/org/yaml/snakeyaml/external/com/google/gdata/util/common/base/UnicodeEscaper.java
deleted file mode 100644
index 5403185..0000000
--- a/src/main/java/org/yaml/snakeyaml/external/com/google/gdata/util/common/base/UnicodeEscaper.java
+++ /dev/null
@@ -1,506 +0,0 @@
-/* Copyright (c) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.yaml.snakeyaml.external.com.google.gdata.util.common.base;
-
-import java.io.IOException;
-
-/**
- * An {@link Escaper} that converts literal text into a format safe for
- * inclusion in a particular context (such as an XML document). Typically (but
- * not always), the inverse process of "unescaping" the text is performed
- * automatically by the relevant parser.
- * 
- * <p>
- * For example, an XML escaper would convert the literal string
- * {@code "Foo<Bar>"} into {@code "Foo&lt;Bar&gt;"} to prevent {@code "<Bar>"}
- * from being confused with an XML tag. When the resulting XML document is
- * parsed, the parser API will return this text as the original literal string
- * {@code "Foo<Bar>"}.
- * 
- * <p>
- * <b>Note:</b> This class is similar to {@link CharEscaper} but with one very
- * important difference. A CharEscaper can only process Java <a
- * href="http://en.wikipedia.org/wiki/UTF-16">UTF16</a> characters in isolation
- * and may not cope when it encounters surrogate pairs. This class facilitates
- * the correct escaping of all Unicode characters.
- * 
- * <p>
- * As there are important reasons, including potential security issues, to
- * handle Unicode correctly if you are considering implementing a new escaper
- * you should favor using UnicodeEscaper wherever possible.
- * 
- * <p>
- * A {@code UnicodeEscaper} instance is required to be stateless, and safe when
- * used concurrently by multiple threads.
- * 
- * <p>
- * Several popular escapers are defined as constants in the class
- * {@link CharEscapers}. To create your own escapers extend this class and
- * implement the {@link #escape(int)} method.
- * 
- * 
- */
-public abstract class UnicodeEscaper implements Escaper {
-    /** The amount of padding (chars) to use when growing the escape buffer. */
-    private static final int DEST_PAD = 32;
-
-    /**
-     * Returns the escaped form of the given Unicode code point, or {@code null}
-     * if this code point does not need to be escaped. When called as part of an
-     * escaping operation, the given code point is guaranteed to be in the range
-     * {@code 0 <= cp <= Character#MAX_CODE_POINT}.
-     * 
-     * <p>
-     * If an empty array is returned, this effectively strips the input
-     * character from the resulting text.
-     * 
-     * <p>
-     * If the character does not need to be escaped, this method should return
-     * {@code null}, rather than an array containing the character
-     * representation of the code point. This enables the escaping algorithm to
-     * perform more efficiently.
-     * 
-     * <p>
-     * If the implementation of this method cannot correctly handle a particular
-     * code point then it should either throw an appropriate runtime exception
-     * or return a suitable replacement character. It must never silently
-     * discard invalid input as this may constitute a security risk.
-     * 
-     * @param cp
-     *            the Unicode code point to escape if necessary
-     * @return the replacement characters, or {@code null} if no escaping was
-     *         needed
-     */
-    protected abstract char[] escape(int cp);
-
-    /**
-     * Scans a sub-sequence of characters from a given {@link CharSequence},
-     * returning the index of the next character that requires escaping.
-     * 
-     * <p>
-     * <b>Note:</b> When implementing an escaper, it is a good idea to override
-     * this method for efficiency. The base class implementation determines
-     * successive Unicode code points and invokes {@link #escape(int)} for each
-     * of them. If the semantics of your escaper are such that code points in
-     * the supplementary range are either all escaped or all unescaped, this
-     * method can be implemented more efficiently using
-     * {@link CharSequence#charAt(int)}.
-     * 
-     * <p>
-     * Note however that if your escaper does not escape characters in the
-     * supplementary range, you should either continue to validate the
-     * correctness of any surrogate characters encountered or provide a clear
-     * warning to users that your escaper does not validate its input.
-     * 
-     * <p>
-     * See {@link PercentEscaper} for an example.
-     * 
-     * @param csq
-     *            a sequence of characters
-     * @param start
-     *            the index of the first character to be scanned
-     * @param end
-     *            the index immediately after the last character to be scanned
-     * @throws IllegalArgumentException
-     *             if the scanned sub-sequence of {@code csq} contains invalid
-     *             surrogate pairs
-     */
-    protected int nextEscapeIndex(CharSequence csq, int start, int end) {
-        int index = start;
-        while (index < end) {
-            int cp = codePointAt(csq, index, end);
-            if (cp < 0 || escape(cp) != null) {
-                break;
-            }
-            index += Character.isSupplementaryCodePoint(cp) ? 2 : 1;
-        }
-        return index;
-    }
-
-    /**
-     * Returns the escaped form of a given literal string.
-     * 
-     * <p>
-     * If you are escaping input in arbitrary successive chunks, then it is not
-     * generally safe to use this method. If an input string ends with an
-     * unmatched high surrogate character, then this method will throw
-     * {@link IllegalArgumentException}. You should either ensure your input is
-     * valid <a href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a> before
-     * calling this method or use an escaped {@link Appendable} (as returned by
-     * {@link #escape(Appendable)}) which can cope with arbitrarily split input.
-     * 
-     * <p>
-     * <b>Note:</b> When implementing an escaper it is a good idea to override
-     * this method for efficiency by inlining the implementation of
-     * {@link #nextEscapeIndex(CharSequence, int, int)} directly. Doing this for
-     * {@link PercentEscaper} more than doubled the performance for unescaped
-     * strings (as measured by {@link CharEscapersBenchmark}).
-     * 
-     * @param string
-     *            the literal string to be escaped
-     * @return the escaped form of {@code string}
-     * @throws NullPointerException
-     *             if {@code string} is null
-     * @throws IllegalArgumentException
-     *             if invalid surrogate characters are encountered
-     */
-    public String escape(String string) {
-        int end = string.length();
-        int index = nextEscapeIndex(string, 0, end);
-        return index == end ? string : escapeSlow(string, index);
-    }
-
-    /**
-     * Returns the escaped form of a given literal string, starting at the given
-     * index. This method is called by the {@link #escape(String)} method when
-     * it discovers that escaping is required. It is protected to allow
-     * subclasses to override the fastpath escaping function to inline their
-     * escaping test. See {@link CharEscaperBuilder} for an example usage.
-     * 
-     * <p>
-     * This method is not reentrant and may only be invoked by the top level
-     * {@link #escape(String)} method.
-     * 
-     * @param s
-     *            the literal string to be escaped
-     * @param index
-     *            the index to start escaping from
-     * @return the escaped form of {@code string}
-     * @throws NullPointerException
-     *             if {@code string} is null
-     * @throws IllegalArgumentException
-     *             if invalid surrogate characters are encountered
-     */
-    protected final String escapeSlow(String s, int index) {
-        int end = s.length();
-
-        // Get a destination buffer and setup some loop variables.
-        char[] dest = DEST_TL.get();
-        int destIndex = 0;
-        int unescapedChunkStart = 0;
-
-        while (index < end) {
-            int cp = codePointAt(s, index, end);
-            if (cp < 0) {
-                throw new IllegalArgumentException("Trailing high surrogate at end of input");
-            }
-            char[] escaped = escape(cp);
-            if (escaped != null) {
-                int charsSkipped = index - unescapedChunkStart;
-
-                // This is the size needed to add the replacement, not the full
-                // size needed by the string. We only regrow when we absolutely
-                // must.
-                int sizeNeeded = destIndex + charsSkipped + escaped.length;
-                if (dest.length < sizeNeeded) {
-                    int destLength = sizeNeeded + (end - index) + DEST_PAD;
-                    dest = growBuffer(dest, destIndex, destLength);
-                }
-                // If we have skipped any characters, we need to copy them now.
-                if (charsSkipped > 0) {
-                    s.getChars(unescapedChunkStart, index, dest, destIndex);
-                    destIndex += charsSkipped;
-                }
-                if (escaped.length > 0) {
-                    System.arraycopy(escaped, 0, dest, destIndex, escaped.length);
-                    destIndex += escaped.length;
-                }
-            }
-            unescapedChunkStart = index + (Character.isSupplementaryCodePoint(cp) ? 2 : 1);
-            index = nextEscapeIndex(s, unescapedChunkStart, end);
-        }
-
-        // Process trailing unescaped characters - no need to account for
-        // escaped
-        // length or padding the allocation.
-        int charsSkipped = end - unescapedChunkStart;
-        if (charsSkipped > 0) {
-            int endIndex = destIndex + charsSkipped;
-            if (dest.length < endIndex) {
-                dest = growBuffer(dest, destIndex, endIndex);
-            }
-            s.getChars(unescapedChunkStart, end, dest, destIndex);
-            destIndex = endIndex;
-        }
-        return new String(dest, 0, destIndex);
-    }
-
-    /**
-     * Returns an {@code Appendable} instance which automatically escapes all
-     * text appended to it before passing the resulting text to an underlying
-     * {@code Appendable}.
-     * 
-     * <p>
-     * Unlike {@link #escape(String)} it is permitted to append arbitrarily
-     * split input to this Appendable, including input that is split over a
-     * surrogate pair. In this case the pending high surrogate character will
-     * not be processed until the corresponding low surrogate is appended. This
-     * means that a trailing high surrogate character at the end of the input
-     * cannot be detected and will be silently ignored. This is unavoidable
-     * since the Appendable interface has no {@code close()} method, and it is
-     * impossible to determine when the last characters have been appended.
-     * 
-     * <p>
-     * The methods of the returned object will propagate any exceptions thrown
-     * by the underlying {@code Appendable}.
-     * 
-     * <p>
-     * For well formed <a href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a>
-     * the escaping behavior is identical to that of {@link #escape(String)} and
-     * the following code is equivalent to (but much slower than)
-     * {@code escaper.escape(string)}:
-     * 
-     * <pre>
-     * {
-     *     &#064;code
-     *     StringBuilder sb = new StringBuilder();
-     *     escaper.escape(sb).append(string);
-     *     return sb.toString();
-     * }
-     * </pre>
-     * 
-     * @param out
-     *            the underlying {@code Appendable} to append escaped output to
-     * @return an {@code Appendable} which passes text to {@code out} after
-     *         escaping it
-     * @throws NullPointerException
-     *             if {@code out} is null
-     * @throws IllegalArgumentException
-     *             if invalid surrogate characters are encountered
-     * 
-     */
-    public Appendable escape(final Appendable out) {
-        assert out != null;
-
-        return new Appendable() {
-            int pendingHighSurrogate = -1;
-            char[] decodedChars = new char[2];
-
-            public Appendable append(CharSequence csq) throws IOException {
-                return append(csq, 0, csq.length());
-            }
-
-            public Appendable append(CharSequence csq, int start, int end) throws IOException {
-                int index = start;
-                if (index < end) {
-                    // This is a little subtle: index must never reference the
-                    // middle of a
-                    // surrogate pair but unescapedChunkStart can. The first
-                    // time we enter
-                    // the loop below it is possible that index !=
-                    // unescapedChunkStart.
-                    int unescapedChunkStart = index;
-                    if (pendingHighSurrogate != -1) {
-                        // Our last append operation ended halfway through a
-                        // surrogate pair
-                        // so we have to do some extra work first.
-                        char c = csq.charAt(index++);
-                        if (!Character.isLowSurrogate(c)) {
-                            throw new IllegalArgumentException(
-                                    "Expected low surrogate character but got " + c);
-                        }
-                        char[] escaped = escape(Character.toCodePoint((char) pendingHighSurrogate,
-                                c));
-                        if (escaped != null) {
-                            // Emit the escaped character and adjust
-                            // unescapedChunkStart to
-                            // skip the low surrogate we have consumed.
-                            outputChars(escaped, escaped.length);
-                            unescapedChunkStart += 1;
-                        } else {
-                            // Emit pending high surrogate (unescaped) but do
-                            // not modify
-                            // unescapedChunkStart as we must still emit the low
-                            // surrogate.
-                            out.append((char) pendingHighSurrogate);
-                        }
-                        pendingHighSurrogate = -1;
-                    }
-                    while (true) {
-                        // Find and append the next subsequence of unescaped
-                        // characters.
-                        index = nextEscapeIndex(csq, index, end);
-                        if (index > unescapedChunkStart) {
-                            out.append(csq, unescapedChunkStart, index);
-                        }
-                        if (index == end) {
-                            break;
-                        }
-                        // If we are not finished, calculate the next code
-                        // point.
-                        int cp = codePointAt(csq, index, end);
-                        if (cp < 0) {
-                            // Our sequence ended half way through a surrogate
-                            // pair so just
-                            // record the state and exit.
-                            pendingHighSurrogate = -cp;
-                            break;
-                        }
-                        // Escape the code point and output the characters.
-                        char[] escaped = escape(cp);
-                        if (escaped != null) {
-                            outputChars(escaped, escaped.length);
-                        } else {
-                            // This shouldn't really happen if nextEscapeIndex
-                            // is correct but
-                            // we should cope with false positives.
-                            int len = Character.toChars(cp, decodedChars, 0);
-                            outputChars(decodedChars, len);
-                        }
-                        // Update our index past the escaped character and
-                        // continue.
-                        index += (Character.isSupplementaryCodePoint(cp) ? 2 : 1);
-                        unescapedChunkStart = index;
-                    }
-                }
-                return this;
-            }
-
-            public Appendable append(char c) throws IOException {
-                if (pendingHighSurrogate != -1) {
-                    // Our last append operation ended halfway through a
-                    // surrogate pair
-                    // so we have to do some extra work first.
-                    if (!Character.isLowSurrogate(c)) {
-                        throw new IllegalArgumentException(
-                                "Expected low surrogate character but got '" + c + "' with value "
-                                        + (int) c);
-                    }
-                    char[] escaped = escape(Character.toCodePoint((char) pendingHighSurrogate, c));
-                    if (escaped != null) {
-                        outputChars(escaped, escaped.length);
-                    } else {
-                        out.append((char) pendingHighSurrogate);
-                        out.append(c);
-                    }
-                    pendingHighSurrogate = -1;
-                } else if (Character.isHighSurrogate(c)) {
-                    // This is the start of a (split) surrogate pair.
-                    pendingHighSurrogate = c;
-                } else {
-                    if (Character.isLowSurrogate(c)) {
-                        throw new IllegalArgumentException("Unexpected low surrogate character '"
-                                + c + "' with value " + (int) c);
-                    }
-                    // This is a normal (non surrogate) char.
-                    char[] escaped = escape(c);
-                    if (escaped != null) {
-                        outputChars(escaped, escaped.length);
-                    } else {
-                        out.append(c);
-                    }
-                }
-                return this;
-            }
-
-            private void outputChars(char[] chars, int len) throws IOException {
-                for (int n = 0; n < len; n++) {
-                    out.append(chars[n]);
-                }
-            }
-        };
-    }
-
-    /**
-     * Returns the Unicode code point of the character at the given index.
-     * 
-     * <p>
-     * Unlike {@link Character#codePointAt(CharSequence, int)} or
-     * {@link String#codePointAt(int)} this method will never fail silently when
-     * encountering an invalid surrogate pair.
-     * 
-     * <p>
-     * The behaviour of this method is as follows:
-     * <ol>
-     * <li>If {@code index >= end}, {@link IndexOutOfBoundsException} is thrown.
-     * <li><b>If the character at the specified index is not a surrogate, it is
-     * returned.</b>
-     * <li>If the first character was a high surrogate value, then an attempt is
-     * made to read the next character.
-     * <ol>
-     * <li><b>If the end of the sequence was reached, the negated value of the
-     * trailing high surrogate is returned.</b>
-     * <li><b>If the next character was a valid low surrogate, the code point
-     * value of the high/low surrogate pair is returned.</b>
-     * <li>If the next character was not a low surrogate value, then
-     * {@link IllegalArgumentException} is thrown.
-     * </ol>
-     * <li>If the first character was a low surrogate value,
-     * {@link IllegalArgumentException} is thrown.
-     * </ol>
-     * 
-     * @param seq
-     *            the sequence of characters from which to decode the code point
-     * @param index
-     *            the index of the first character to decode
-     * @param end
-     *            the index beyond the last valid character to decode
-     * @return the Unicode code point for the given index or the negated value
-     *         of the trailing high surrogate character at the end of the
-     *         sequence
-     */
-    protected static final int codePointAt(CharSequence seq, int index, int end) {
-        if (index < end) {
-            char c1 = seq.charAt(index++);
-            if (c1 < Character.MIN_HIGH_SURROGATE || c1 > Character.MAX_LOW_SURROGATE) {
-                // Fast path (first test is probably all we need to do)
-                return c1;
-            } else if (c1 <= Character.MAX_HIGH_SURROGATE) {
-                // If the high surrogate was the last character, return its
-                // inverse
-                if (index == end) {
-                    return -c1;
-                }
-                // Otherwise look for the low surrogate following it
-                char c2 = seq.charAt(index);
-                if (Character.isLowSurrogate(c2)) {
-                    return Character.toCodePoint(c1, c2);
-                }
-                throw new IllegalArgumentException("Expected low surrogate but got char '" + c2
-                        + "' with value " + (int) c2 + " at index " + index);
-            } else {
-                throw new IllegalArgumentException("Unexpected low surrogate character '" + c1
-                        + "' with value " + (int) c1 + " at index " + (index - 1));
-            }
-        }
-        throw new IndexOutOfBoundsException("Index exceeds specified range");
-    }
-
-    /**
-     * Helper method to grow the character buffer as needed, this only happens
-     * once in a while so it's ok if it's in a method call. If the index passed
-     * in is 0 then no copying will be done.
-     */
-    private static final char[] growBuffer(char[] dest, int index, int size) {
-        char[] copy = new char[size];
-        if (index > 0) {
-            System.arraycopy(dest, 0, copy, 0, index);
-        }
-        return copy;
-    }
-
-    /**
-     * A thread-local destination buffer to keep us from creating new buffers.
-     * The starting size is 1024 characters. If we grow past this we don't put
-     * it back in the threadlocal, we just keep going and grow as needed.
-     */
-    private static final ThreadLocal<char[]> DEST_TL = new ThreadLocal<char[]>() {
-        @Override
-        protected char[] initialValue() {
-            return new char[1024];
-        }
-    };
-}
diff --git a/src/main/java/org/yaml/snakeyaml/util/UriEncoder.java b/src/main/java/org/yaml/snakeyaml/util/UriEncoder.java
index 4cc18b4..b6a1992 100644
--- a/src/main/java/org/yaml/snakeyaml/util/UriEncoder.java
+++ b/src/main/java/org/yaml/snakeyaml/util/UriEncoder.java
@@ -23,27 +23,46 @@ import java.nio.charset.CharacterCodingException;
 import java.nio.charset.Charset;
 import java.nio.charset.CharsetDecoder;
 import java.nio.charset.CodingErrorAction;
-
+import java.util.BitSet;
+ 
+import org.apache.commons.codec.net.URLCodec;
 import org.yaml.snakeyaml.error.YAMLException;
-import org.yaml.snakeyaml.external.com.google.gdata.util.common.base.Escaper;
-import org.yaml.snakeyaml.external.com.google.gdata.util.common.base.PercentEscaper;
 
 public abstract class UriEncoder {
     private static final CharsetDecoder UTF8Decoder = Charset.forName("UTF-8").newDecoder()
             .onMalformedInput(CodingErrorAction.REPORT);
-    // Include the [] chars to the SAFEPATHCHARS_URLENCODER to avoid
-    // its escape as required by spec. See
-    // http://yaml.org/spec/1.1/#escaping%20in%20URI/
-    private static final String SAFE_CHARS = PercentEscaper.SAFEPATHCHARS_URLENCODER + "[]/";
-    private static final Escaper escaper = new PercentEscaper(SAFE_CHARS, false);
 
+	// default safe characters which can appear within URI and shouldn't be escaped
+    private static final BitSet allowedCharacters = new BitSet(256);
+
+    static {
+        for (int i = 'a'; i <= 'z'; i++) {
+            allowedCharacters.set(i);
+        }
+        for (int i = 'A'; i <= 'Z'; i++) {
+            allowedCharacters.set(i);
+        }
+        for (int i = '0'; i <= '9'; i++) {
+            allowedCharacters.set(i);
+        }
+        // http://yaml.org/spec/1.1/#escaping%20in%20URI/
+        for (char c : "-_.!~*'()@:$&,;=/[]".toCharArray()) {
+            allowedCharacters.set(c);
+        }
+    }
     /**
      * Escape special characters with '%'
      * @param uri URI to be escaped
      * @return encoded URI
      */
     public static String encode(String uri) {
-        return escaper.escape(uri);
+        try {
+            byte[] rawdata = URLCodec.encodeUrl(allowedCharacters,
+                    uri.getBytes("UTF-8"));
+            return new String(rawdata, 0, rawdata.length, "US-ASCII");
+        } catch (UnsupportedEncodingException e) {
+            throw new YAMLException(e);
+        }
     }
 
     /**
-- 
2.20.1

