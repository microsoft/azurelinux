--- rdist-6.1.5/src/gram.y.cleanup	2003-12-17 11:38:16.000000000 +0100
+++ rdist-6.1.5/src/gram.y	2003-12-17 11:38:16.000000000 +0100
@@ -33,7 +33,7 @@
  * SUCH DAMAGE.
  */
 
-#ifndef lint
+#if 0
 static char RCSid[] = 
 "$Id: gram.y,v 6.30 1998/11/10 04:10:42 mcooper Exp $";
 
@@ -163,7 +163,7 @@
 		;
 
 cmd:		  INSTALL options opt_namelist ';' {
-			register struct namelist *nl;
+			struct namelist *nl;
 
 			$1->sc_options = $2 | options;
 			if ($3 != NULL) {
@@ -233,11 +233,11 @@
 int	yylineno = 1;
 extern	FILE *fin;
 
-yylex()
+int yylex()
 {
 	static char yytext[INMAX];
-	register int c;
-	register char *cp1, *cp2;
+	int c;
+	char *cp1, *cp2;
 	static char quotechars[] = "[]{}*?$";
 	
 again:
@@ -402,8 +402,8 @@
  * some of the characters we use.
  */
 extern int any(c, str)
-	register int c;
-	register char *str;
+	int c;
+	char *str;
 {
 	while (*str)
 		if (c == *str++)
@@ -414,13 +414,14 @@
 /*
  * Insert or append ARROW command to list of hosts to be updated.
  */
+void
 insert(label, files, hosts, subcmds)
 	char *label;
 	struct namelist *files, *hosts;
 	struct subcmd *subcmds;
 {
-	register struct cmd *c, *prev, *nc;
-	register struct namelist *h, *lasth;
+	struct cmd *c, *prev, *nc;
+	struct namelist *h, *lasth;
 
 	debugmsg(DM_CALL, "insert(%s, %x, %x, %x) start, files = %s", 
 		 label == NULL ? "(null)" : label,
@@ -468,13 +469,14 @@
  * Append DCOLON command to the end of the command list since these are always
  * executed in the order they appear in the distfile.
  */
+void
 append(label, files, stamp, subcmds)
 	char *label;
 	struct namelist *files;
 	char *stamp;
 	struct subcmd *subcmds;
 {
-	register struct cmd *c;
+	struct cmd *c;
 
 	c = ALLOC(cmd);
 	c->c_type = DCOLON;
@@ -494,6 +496,7 @@
 /*
  * Error printing routine in parser.
  */
+void
 yyerror(s)
 	char *s;
 {
@@ -523,7 +526,7 @@
 makenl(name)
 	char *name;
 {
-	register struct namelist *nl;
+	struct namelist *nl;
 
 	debugmsg(DM_CALL, "makenl(%s)", name == NULL ? "null" : name);
 
@@ -620,7 +623,7 @@
 makesubcmd(type)
 	int type;
 {
-	register struct subcmd *sc;
+	struct subcmd *sc;
 
 	sc = ALLOC(subcmd);
 	sc->sc_type = type;
--- rdist-6.1.5/src/rdist.c.cleanup	1998-11-10 05:13:50.000000000 +0100
+++ rdist-6.1.5/src/rdist.c	2003-12-17 11:38:16.000000000 +0100
@@ -32,7 +32,7 @@
  * SUCH DAMAGE.
  */
 
-#ifndef lint
+#if 0
 static char RCSid[] = 
 "$Id: rdist.c,v 6.66 1998/11/10 04:13:49 mcooper Exp $";
 
@@ -74,7 +74,7 @@
 	char *name;
 	struct namelist **hostlist;
 {
-	register struct namelist *ptr, *new;
+	struct namelist *ptr, *new;
 
 	if (!name || !hostlist)
 		return;
@@ -91,14 +91,15 @@
 		*hostlist = new;
 }
 
+int
 main(argc, argv, envp)
 	int argc;
 	char *argv[];
 	char **envp;
 {
 	struct namelist *hostlist = NULL;
-	register int x;
-	register char *cp;
+	int x;
+	char *cp;
 	int cmdargs = 0;
 	int c;
 
@@ -108,7 +109,7 @@
 	 */
 	setprogname(argv);
 
-	if (cp = msgparseopts(localmsglist, TRUE)) {
+	if ((cp = msgparseopts(localmsglist, TRUE))) {
 		error("Bad builtin log option (%s): %s.", 
 		      localmsglist, cp);
 		usage();
@@ -152,7 +153,7 @@
 	while ((c = getopt(argc, argv, optchars)) != -1)
 		switch (c) {
 		case 'l':
-			if (cp = msgparseopts(optarg, TRUE)) {
+			if ((cp = msgparseopts(optarg, TRUE))) {
 				error("Bad log option \"%s\": %s.", optarg,cp);
 				usage();
 			}
@@ -200,7 +201,7 @@
 
 		case 'D':
 			debug = DM_ALL;
-			if (cp = msgparseopts("stdout=all,debug", TRUE)) {
+			if ((cp = msgparseopts("stdout=all,debug", TRUE))) {
 				error("Enable debug messages failed: %s.", cp);
 				usage();
 			}
@@ -239,7 +240,7 @@
 				error("No path specified to \"-P\".");
 				usage();
 			}
-			if (cp = searchpath(optarg))
+			if ((cp = searchpath(optarg)))
 				path_remsh = strdup(cp);
 			else {
 				error("No component of path \"%s\" exists.",
@@ -291,7 +292,7 @@
 	else {
 		if (fin == NULL)
 			fin = opendist(distfile);
-		(void) yyparse();
+		yyparse();
 		/*
 		 * Need to keep stdin open for child processing later
 		 */
@@ -342,6 +343,7 @@
 /*
  * Print usage message and exit.
  */
+void
 usage()
 {
 	char *sopts = "cDFnv";
@@ -373,12 +375,13 @@
 /*
  * rcp like interface for distributing files.
  */
+void
 docmdargs(nargs, args)
 	int nargs;
 	char *args[];
 {
-	register struct namelist *nl, *prev;
-	register char *cp;
+	struct namelist *nl, *prev;
+	char *cp;
 	struct namelist *files, *hosts;
 	struct subcmd *cmds;
 	char *dest;
@@ -427,10 +430,10 @@
  * Get a list of NAME blocks (mostly for debugging).
  */
 extern char *getnlstr(nl)
-	register struct namelist *nl;
+	struct namelist *nl;
 {
 	static char buf[16384];
-	register int count = 0, len = 0;
+	int count = 0, len = 0;
 
 	(void) sprintf(buf, "(");
 
--- rdist-6.1.5/src/client.c.cleanup	2003-12-17 11:38:16.000000000 +0100
+++ rdist-6.1.5/src/client.c	2003-12-17 11:38:16.000000000 +0100
@@ -32,7 +32,7 @@
  * SUCH DAMAGE.
  */
 
-#ifndef lint
+#if 0
 static char RCSid[] = 
 "$Id: client.c,v 6.82 1998/11/10 04:08:47 mcooper Exp $";
 
@@ -78,7 +78,7 @@
 	int destdir;
 {
 	extern struct namelist *filelist;
-	register char *lname, *cp;
+	char *lname, *cp;
 	static char buff[BUFSIZ];
 	int srclen, pathlen;
 	char *p;
@@ -140,7 +140,7 @@
 	struct namelist *list;
 	char *file;
 {
-	register struct namelist *nl;
+	struct namelist *nl;
 
 	for (nl = list; nl != NULL; nl = nl->n_next)
 		if (strcmp(file, nl->n_name) == 0)
@@ -157,7 +157,7 @@
 	char *rname;
 	int destdir;
 {
-	register struct subcmd *sc;
+	struct subcmd *sc;
 	extern struct subcmd *subcmds;
 	char *rfile;
 
@@ -194,7 +194,7 @@
 {
 	char *rfile;
 	struct namelist *new;
-	register struct subcmd *sc;
+	struct subcmd *sc;
 	extern struct subcmd *subcmds;
 	int isokay = 0;
 
@@ -221,7 +221,7 @@
  */
 static void freecmdspecialfiles()
 {
-	register struct namelist *ptr, *save;
+	struct namelist *ptr, *save;
 
 	for (ptr = updfilelist; ptr; ) {
 		if (ptr->n_name) (void) free(ptr->n_name);
@@ -243,10 +243,8 @@
 	char **filev;
 	opt_t opts;
 {
-	register struct subcmd *sc;
-	register struct namelist *f;
-	register char **cpp;
-	char *file;
+	struct subcmd *sc;
+	struct namelist *f;
 	int first = TRUE;
 
 	for (sc = cmd->c_cmds; sc != NULL; sc = sc->sc_next) {
@@ -288,7 +286,7 @@
 int checkfilename(name)
 	char *name;
 {
-	register char *cp;
+	char *cp;
 
 	if (strchr(name, '\n')) {
 		for (cp = name; *cp; cp++)
@@ -495,7 +493,7 @@
 static int rmchk(opts)
 	opt_t opts;
 {
-	register u_char *s;
+	u_char *s;
 	struct stat stb;
 	int didupdate = 0;
 	int n;
@@ -612,7 +610,7 @@
 	
 	optarget = ptarget;
 	len = ptarget - target;
-	while (dp = readdir(d)) {
+	while ((dp = readdir(d))) {
 		if (!strcmp(dp->d_name, ".") ||
 		    !strcmp(dp->d_name, ".."))
 			continue;
@@ -625,7 +623,7 @@
 		if (ptarget[-1] != '/')
 			*ptarget++ = '/';
 		cp = dp->d_name;
-		while (*ptarget++ = *cp++)
+		while ((*ptarget++ = *cp++))
 			;
 		ptarget--;
 		if (sendit(dp->d_name, opts, destdir) > 0)
@@ -764,13 +762,13 @@
 	opt_t opts;
 	struct stat *statp;
 {
-	register off_t size;
-	register time_t mtime;
+	off_t size;
+	time_t mtime;
 	unsigned short lmode;
 	unsigned short rmode;
 	char *owner = NULL, *group = NULL;
 	int done, n;
-	u_char *cp;
+	char *cp;
 
 	debugmsg(DM_CALL, "update(%s, 0x%x, 0x%x)\n", rname, opts, statp);
 
@@ -1029,7 +1026,6 @@
 	int destdir;
 {
 	static struct stat stb;
-	extern struct subcmd *subcmds;
 	char *user, *group;
 	int u, len;
 	int didupdate = 0;
@@ -1151,7 +1148,7 @@
 	(void) unlink(statfile);
 #endif
 
-	if (file = getnotifyfile())
+	if ((file = getnotifyfile()))
 		(void) unlink(file);
 }
 
--- rdist-6.1.5/src/child.c.cleanup	1998-11-10 05:18:57.000000000 +0100
+++ rdist-6.1.5/src/child.c	2003-12-17 11:38:16.000000000 +0100
@@ -32,7 +32,7 @@
  * SUCH DAMAGE.
  */
 
-#ifndef lint
+#if 0
 static char RCSid[] = 
 "$Id: child.c,v 6.29 1998/11/10 04:18:56 mcooper Exp $";
 
@@ -84,7 +84,7 @@
 static void removechild(child)
 	CHILD *child;
 {
-	register CHILD *pc, *prevpc;
+	CHILD *pc, *prevpc;
 
 	debugmsg(DM_CALL, "removechild(%s, %d, %d) start",
 		 child->c_name, child->c_pid, child->c_readfd);
@@ -142,7 +142,7 @@
 static CHILD *copychild(child)
 	CHILD *child;
 {
-	register CHILD *newc;
+	CHILD *newc;
 
 	newc = (CHILD *) xmalloc(sizeof(CHILD));
 
@@ -161,7 +161,7 @@
 static void addchild(child)
 	CHILD *child;
 {
-	register CHILD *pc;
+	CHILD *pc;
 
 	debugmsg(DM_CALL, "addchild() start\n");
 
@@ -274,7 +274,7 @@
  */
 static void reap()
 {
-	register CHILD *pc;
+	CHILD *pc;
 	int status = 0;
 	pid_t pid;
 
@@ -330,7 +330,7 @@
  */
 static void childscan() 
 {
-	register CHILD *pc, *nextpc;
+	CHILD *pc, *nextpc;
 	
 	debugmsg(DM_CALL, "childscan() start");
 
@@ -360,8 +360,8 @@
 extern void waitup()
 {
 #if	defined(HAVE_SELECT)
-	register int count;
-	register CHILD *pc;
+	int count;
+	CHILD *pc;
 	fd_set rchildfds;
 
 	debugmsg(DM_CALL, "waitup() start\n");
--- rdist-6.1.5/src/docmd.c.cleanup	2003-12-17 11:38:16.000000000 +0100
+++ rdist-6.1.5/src/docmd.c	2003-12-17 11:38:16.000000000 +0100
@@ -32,7 +32,7 @@
  * SUCH DAMAGE.
  */
 
-#ifndef lint
+#if 0
 static char RCSid[] = 
 "$Id: docmd.c,v 6.87 1998/11/10 04:08:32 mcooper Exp $";
 
@@ -93,10 +93,10 @@
  */
 static void notify(rhost, to, lmod)
 	char *rhost;
-	register struct namelist *to;
+	struct namelist *to;
 	time_t lmod;
 {
-	register int fd, len;
+	int fd, len;
 	FILE *pf, *popen();
 	struct stat stb;
 	static char buf[BUFSIZ];
@@ -215,7 +215,7 @@
 	struct cmd *cmd;
 	struct cmd *cmdlist;
 {
-	register struct cmd *pcmd;
+	struct cmd *pcmd;
 	
 	for (pcmd = cmdlist; pcmd; pcmd = pcmd->c_next) {
 		checkcmd(pcmd);
@@ -232,7 +232,7 @@
 	struct cmd *cmd;
 	struct cmd *cmdlist;
 {
-	register struct cmd *pc;
+	struct cmd *pc;
 
 	if (!cmd) {
 		debugmsg(DM_MISC, "markfailed() NULL cmd parameter");
@@ -303,7 +303,7 @@
 static int makeconn(rhost)
 	char *rhost;
 {
-	register char *ruser, *cp;
+	char *ruser, *cp;
 	static char *cur_host = NULL;
 	extern char *locuser;
 	extern long min_freefiles, min_freespace;
@@ -424,9 +424,9 @@
 	struct cmd *cmd;
 	char **filev;
 {
-	register struct namelist *f;
-	register struct subcmd *sc;
-	register char **cpp;
+	struct namelist *f;
+	struct subcmd *sc;
+	char **cpp;
 	int n, ddir, destdir, opts = options;
 	struct namelist *files;
 	struct subcmd *sbcmds;
@@ -561,7 +561,6 @@
 		}
 	}
 
-done:
 	/*
 	 * Run any commands for the entire cmd
 	 */
@@ -578,7 +577,7 @@
 			notify(rhost, sc->sc_args, (time_t) 0);
 
 	if (!nflag) {
-		register struct linkbuf *nextl, *l;
+		struct linkbuf *nextl, *l;
 
 		for (l = ihead; l != NULL; freelinkinfo(l), l = nextl) {
 			nextl = l->nextp;
@@ -595,11 +594,12 @@
 	setjmp_ok = FALSE;
 }
 
+int
 okname(name)
-	register char *name;
+	char *name;
 {
-	register char *cp = name;
-	register int c, isbad;
+	char *cp = name;
+	int c, isbad;
 
 	for (isbad = FALSE; *cp && !isbad; ++cp) {
 		c = *cp;
@@ -621,9 +621,9 @@
 	struct subcmd *sbcmds;
 	char **env;
 {
-	register DIR *d;
-	register DIRENTRY *dp;
-	register char *cp;
+	DIR *d;
+	DIRENTRY *dp;
+	char *cp;
 	char *optarget;
 	int len;
 
@@ -635,7 +635,7 @@
 	}
 	optarget = ptarget;
 	len = ptarget - target;
-	while (dp = readdir(d)) {
+	while ((dp = readdir(d))) {
 		if (!strcmp(dp->d_name, ".") || !strcmp(dp->d_name, ".."))
 			continue;
 		if (len + 1 + (int)strlen(dp->d_name) >= BUFSIZ - 1) {
@@ -645,7 +645,7 @@
 		ptarget = optarget;
 		*ptarget++ = '/';
 		cp = dp->d_name;
-		while (*ptarget++ = *cp++)
+		while ((*ptarget++ = *cp++))
 			;
 		ptarget--;
 		cmptime(target, sbcmds, env);
@@ -734,9 +736,9 @@
 	struct cmd *cmd;
 	char **filev;
 {
-	register struct subcmd *sc;
-	register struct namelist *f;
-	register char *cp, **cpp;
+	struct subcmd *sc;
+	struct namelist *f;
+	char *cp, **cpp;
 	struct stat stb;
 	struct namelist *files = cmd->c_files;
 	struct subcmd *sbcmds = cmd->c_cmds;
@@ -818,8 +818,8 @@
 extern int except(file)
 	char *file;
 {
-	register struct	subcmd *sc;
-	register struct	namelist *nl;
+	struct	subcmd *sc;
+	struct	namelist *nl;
 
 	debugmsg(DM_CALL, "except(%s)", file);
 
@@ -912,8 +912,8 @@
 	int argc;
 	char **argv;
 {
-	register struct namelist *f;
-	register int i;
+	struct namelist *f;
+	int i;
 
 	if (argc) {
 		for (i = 0; i < argc; i++) {
@@ -956,9 +956,9 @@
 	int argc;
 	char **argv;
 {
-	register struct cmd *c;
-	register char *cp;
-	register int i;
+	struct cmd *c;
+	char *cp;
+	int i;
 
 	(void) signal(SIGHUP, sighandler);
 	(void) signal(SIGINT, sighandler);
@@ -1026,7 +1026,7 @@
 
 		if (hostlist) {
 			/* Do specific hosts as specified on command line */
-			register struct namelist *nlptr;
+			struct namelist *nlptr;
 
 			for (nlptr = hostlist; nlptr; nlptr = nlptr->n_next)
 				/*
--- rdist-6.1.5/src/distopt.c.cleanup	1998-11-10 05:09:11.000000000 +0100
+++ rdist-6.1.5/src/distopt.c	2003-12-17 11:38:16.000000000 +0100
@@ -25,7 +25,7 @@
  * SUCH DAMAGE.
  */
 
-#ifndef lint
+#if 0
 static char RCSid[] = 
 "$Id: distopt.c,v 6.12 1998/11/10 04:09:11 mcooper Exp $";
 
@@ -74,7 +74,7 @@
 extern DISTOPTINFO *getdistopt(name)
 	char *name;
 {
-	register int i;
+	int i;
 
 	for (i = 0; distoptinfo[i].do_name; ++i)
 		if (strcasecmp(name, distoptinfo[i].do_name) == 0)
@@ -93,7 +93,7 @@
 	opt_t *optptr;
 	int doerrs;
 {
-	register char *string, *optstr;
+	char *string, *optstr;
 	DISTOPTINFO *distopt;
 	int negate;
 
@@ -112,7 +112,7 @@
 		 * and the option starts with "no", strip "no"
 		 * from option and retry lookup.
 		 */
-		if (distopt = getdistopt(optstr)) {
+		if ((distopt = getdistopt(optstr))) {
 			FLAG_ON(*optptr, distopt->do_value);
 			continue;
 		}
@@ -135,7 +135,7 @@
  */
 extern char *getdistoptlist()
 {
-	register int i;
+	int i;
 	static char buf[1024];
 
 	for (i = 0, buf[0] = CNULL; distoptinfo[i].do_name; ++i) {
@@ -157,7 +157,7 @@
 extern char *getondistoptlist(opts)
 	opt_t opts;
 {
-	register int i;
+	int i;
 	static char buf[1024];
 
 	for (i = 0, buf[0] = CNULL; distoptinfo[i].do_name; ++i) {
--- rdist-6.1.5/src/expand.c.cleanup	1998-11-10 05:09:31.000000000 +0100
+++ rdist-6.1.5/src/expand.c	2003-12-17 11:38:16.000000000 +0100
@@ -32,7 +32,7 @@
  * SUCH DAMAGE.
  */
 
-#ifndef lint
+#if 0
 static char RCSid[] = 
 "$Id: expand.c,v 6.19 1998/11/10 04:09:31 mcooper Exp $";
 
@@ -75,9 +75,9 @@
 		      sizeof(*sortbase), argcmp), sortbase = &eargv[eargc]
 
 static void Cat(s1, s2)				/* quote in s1 and s2 */
-	register u_char *s1, *s2;
+	u_char *s1, *s2;
 {
-	register char *cp;
+	char *cp;
 	int len = strlen((char *)s1) + strlen((char *)s2) + 2;
 
 	if ((eargc + 1) >= MAXEARGS) {
@@ -91,12 +91,12 @@
 	do { 
 		if (*s1 == QUOTECHAR) 
 			s1++; 
-	} while (*cp++ = *s1++);
+	} while ((*cp++ = *s1++));
 	cp--;
 	do { 
 		if (*s2 == QUOTECHAR) 
 			s2++; 
-	} while (*cp++ = *s2++);
+	} while ((*cp++ = *s2++));
 }
 
 static void addpath(c)
@@ -125,8 +125,8 @@
 	struct namelist *list;
 	int wh;
 {
-	register struct namelist *nl, *prev;
-	register int n;
+	struct namelist *nl, *prev;
+	int n;
 	char pathbuf[BUFSIZ];
 
 	if (debug)
@@ -176,7 +176,7 @@
 	u_char *str;
 	int ch;
 {
-	register u_char *cp;
+	u_char *cp;
 
 	for (cp = str; cp && *cp != CNULL; ++cp)
 		if (ch == *cp)
@@ -188,8 +188,8 @@
 void expstr(s)
 	u_char *s;
 {
-	register u_char *cp, *cp1;
-	register struct namelist *tp;
+	u_char *cp, *cp1;
+	struct namelist *tp;
 	u_char *tail;
 	u_char ebuf[BUFSIZ];
 	u_char varbuff[BUFSIZ];
@@ -296,7 +296,7 @@
 			cp1 = (u_char *)pw->pw_dir;
 			s = cp;
 		}
-		for (cp = (u_char *)path; *cp++ = *cp1++; )
+		for (cp = (u_char *)path; (*cp++ = *cp1++); )
 			;
 		tpathp = pathp = (char *)cp - 1;
 	} else {
@@ -320,7 +320,7 @@
 	sort();
 }
 
-static
+static int
 argcmp(a1, a2)
 	char **a1, **a2;
 {
@@ -335,8 +335,8 @@
 void expsh(s)				/* quote in s */
 	u_char *s;
 {
-	register u_char *cp, *oldcp;
-	register char *spathp;
+	u_char *cp, *oldcp;
+	char *spathp;
 	struct stat stb;
 
 	spathp = pathp;
@@ -374,7 +374,7 @@
 	char *pattern;
 {
 	struct stat stb;
-	register DIRENTRY *dp;
+	DIRENTRY *dp;
 	DIR *dirp;
 
 	dirp = opendir(path);
@@ -411,11 +411,12 @@
 	yyerror(path);
 }
 
+int
 execbrc(p, s)				/* quote in p */
 	u_char *p, *s;
 {
 	u_char restbuf[BUFSIZ + 2];
-	register u_char *pe, *pm, *pl;
+	u_char *pe, *pm, *pl;
 	int brclev = 0;
 	u_char *lm, savec;
 	char *spathp;
@@ -501,11 +502,12 @@
 	return (0);
 }
 
+int
 match(s, p)					/* quote in p */
 	char *s, *p;
 {
-	register int c;
-	register char *sentp;
+	int c;
+	char *sentp;
 	char sexpany = expany;
 
 	if (*s == '.' && *p != '.')
@@ -518,11 +520,12 @@
 	return (c);
 }
 
+int
 amatch(s, p)					/* quote in p */
-	register char *s;
-	register u_char *p;
+	char *s;
+	u_char *p;
 {
-	register int scc;
+	int scc;
 	int ok, lc;
 	char *spathp;
 	struct stat stb;
@@ -539,7 +542,7 @@
 		case '[':
 			ok = 0;
 			lc = 077777;
-			while (cc = *p++) {
+			while ((cc = *p++)) {
 				if (cc == ']') {
 					if (ok)
 						break;
@@ -593,7 +596,7 @@
 			while (*s)
 				addpath(*s++);
 			addpath('/');
-			if (stat(path, &stb) == 0 && S_ISDIR(stb.st_mode))
+			if (stat(path, &stb) == 0 && S_ISDIR(stb.st_mode)) {
 				if (*p == CNULL) {
 					if (which & E_TILDE)
 						Cat((u_char *)path, 
@@ -603,6 +606,7 @@
 						    (u_char *)tpathp);
 				} else
 					expsh(p);
+			}
 			pathp = spathp;
 			*pathp = CNULL;
 			return (0);
--- rdist-6.1.5/src/lookup.c.cleanup	1998-11-10 05:12:56.000000000 +0100
+++ rdist-6.1.5/src/lookup.c	2003-12-17 11:38:16.000000000 +0100
@@ -32,7 +32,7 @@
  * SUCH DAMAGE.
  */
 
-#ifndef lint
+#if 0
 static char RCSid[] = 
 "$Id: lookup.c,v 6.9 1998/11/10 04:12:56 mcooper Exp $";
 
@@ -62,11 +62,12 @@
 /*
  * Define a variable from a command line argument.
  */
+void
 define(name)
 	char *name;
 {
-	register char *cp, *s;
-	register struct namelist *nl;
+	char *cp, *s;
+	struct namelist *nl;
 	struct namelist *value;
 
 	debugmsg(DM_CALL, "define(%s)", name);
@@ -131,9 +132,9 @@
 	int action;
 	struct namelist *value;
 {
-	register unsigned n;
-	register char *cp;
-	register struct syment *s;
+	unsigned n;
+	char *cp;
+	struct syment *s;
 	char ebuf[BUFSIZ];
 
 	debugmsg(DM_CALL, "lookup(%s, %d, %x)", name, action, value);
--- rdist-6.1.5/src/isexec.c.cleanup	1998-11-10 05:11:42.000000000 +0100
+++ rdist-6.1.5/src/isexec.c	2003-12-17 11:38:16.000000000 +0100
@@ -31,7 +31,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
-#ifndef lint
+#if 0
 static char RCSid[] = 
 "$Id: isexec.c,v 6.22 1998/11/10 04:11:42 mcooper Exp $";
 
--- rdist-6.1.5/src/signal.c.cleanup	1998-11-10 05:16:13.000000000 +0100
+++ rdist-6.1.5/src/signal.c	2003-12-17 11:38:16.000000000 +0100
@@ -32,7 +32,7 @@
  * SUCH DAMAGE.
  */
 
-#ifndef lint
+#if 0
 static char RCSid[] = 
 "$Id: signal.c,v 6.2 1998/11/10 04:16:13 mcooper Exp $";
 
--- rdist-6.1.5/src/rshrcmd.c.cleanup	1998-11-10 05:15:07.000000000 +0100
+++ rdist-6.1.5/src/rshrcmd.c	2003-12-17 11:38:16.000000000 +0100
@@ -29,7 +29,7 @@
  * Chris Siebenmann <cks@utcc.utoronto.ca>.
  */
 
-#ifndef lint
+#if 0
 static char RCSid[] = 
 "$Id: rshrcmd.c,v 1.9 1998/11/10 04:15:07 mcooper Exp $";
 
@@ -53,6 +53,7 @@
  * program in place of a direct rcmd() function call so as to
  * avoid having to be root.
  */
+int
 rshrcmd(ahost, port, luser, ruser, cmd, fd2p)
 	char  	**ahost;
 	u_short	port;
@@ -127,6 +128,7 @@
 		(void) wait(0);
 		return sp[0];
 	}
+	return -1;
 	/*NOTREACHED*/
 }
 
--- rdist-6.1.5/src/common.c.cleanup	1998-11-10 05:09:01.000000000 +0100
+++ rdist-6.1.5/src/common.c	2003-12-17 11:38:16.000000000 +0100
@@ -32,7 +32,7 @@
  * SUCH DAMAGE.
  */
 
-#ifndef lint
+#if 0
 static char RCSid[] = 
 "$Id: common.c,v 6.84 1998/11/10 04:09:01 mcooper Exp $";
 
@@ -81,14 +81,14 @@
 /* 
  * Front end to write() that handles partial write() requests.
  */
-extern WRITE_RETURN_T xwrite(fd, buf, len)
+WRITE_RETURN_T xwrite(fd, buf, len)
 	int fd;
 	void *buf;
 	WRITE_AMT_T len;
 {
     	WRITE_AMT_T nleft = len;
 	WRITE_RETURN_T nwritten;
-	register char *ptr = buf;
+	char *ptr = buf;
          
 	while (nleft > 0) {
 	    	if ((nwritten = write(fd, ptr, nleft)) <= 0) {
@@ -104,14 +104,14 @@
 /*
  * Set program name
  */
-extern void setprogname(argv)
+void setprogname(argv)
 	char **argv;
 {
-	register char *cp;
+	char *cp;
 
 	if (!progname) {
 		progname = strdup(argv[0]);
-		if (cp = strrchr(progname, '/'))
+		if ((cp = strrchr(progname, '/')))
 			progname = cp + 1;
 	}
 }
@@ -119,14 +119,14 @@
 /*
  * Do run-time initialization
  */
-extern int init(argc, argv, envp)
+int init(argc, argv, envp)
 	/*ARGSUSED*/
 	int argc;
 	char **argv;
 	char **envp;
 {
-	register int i;
-	register char *cp;
+	int i;
+	char *cp;
 
 	if (!isserver)
 		(void) signal(SIGSEGV, sighandler);
@@ -176,7 +176,7 @@
 /*
  * Finish things up before ending.
  */
-extern void finish()
+void finish()
 {
 	extern jmp_buf finish_jmpbuf;
 
@@ -210,7 +210,7 @@
 /*
  * Handle lost connections
  */
-extern void lostconn()
+void lostconn()
 {
 	/* Prevent looping */
 	(void) signal(SIGPIPE, SIG_IGN);
@@ -226,7 +226,7 @@
 /*
  * Do a core dump
  */
-extern void coredump()
+void coredump()
 {
 	error("Segmentation violation - dumping core [PID = %d, %s]",
 	      getpid(), 
@@ -239,7 +239,7 @@
 /*
  * General signal handler
  */
-extern void sighandler(sig)
+void sighandler(sig)
 	int sig;
 {
 	debugmsg(DM_CALL, "sighandler() received signal %d\n", sig);
@@ -319,7 +319,7 @@
 /*
  * Stdarg frontend to sendcmdmsg()
  */
-extern int sendcmd(char cmd, char *fmt, ...)
+int sendcmd(char cmd, char *fmt, ...)
 {
 	static char buf[BUFSIZ];
 	va_list args;
@@ -339,7 +339,7 @@
 /*
  * Varargs frontend to sendcmdmsg()
  */
-extern int sendcmd(va_alist)
+int sendcmd(va_alist)
 	va_dcl
 {
 	static char buf[BUFSIZ];
@@ -366,7 +366,7 @@
  * Stupid frontend to sendcmdmsg()
  */
 /*VARARGS2*/
-extern int sendcmd(cmd, fmt, a1, a2, a3, a4, a5, a6, a7, a8)
+int sendcmd(cmd, fmt, a1, a2, a3, a4, a5, a6, a7, a8)
 	char cmd;
 	char *fmt;
 {
@@ -427,13 +427,13 @@
  * errors, call cleanup() or lostconn().  In other words, unless
  * the third argument is nonzero, this routine never returns failure.
  */
-extern int remline(buffer, space, doclean)
-	register u_char *buffer;
+int remline(buffer, space, doclean)
+	u_char *buffer;
 	int space;
 	int doclean;
 {
-	register int c, left = space;
-	register u_char *p = buffer;
+	int c, left = space;
+	u_char *p = buffer;
 
 	if (rem_r < 0) {
 		error("Cannot read remote input: Remote descriptor not open.");
@@ -488,9 +488,9 @@
 /*
  * Non-line-oriented remote read.
  */
-readrem(p, space)
+int readrem(p, space)
 	char *p;
-	register int space;
+	int space;
 {
 	if (remleft <= 0) {
 		/*
@@ -521,7 +521,7 @@
 /*
  * Get the user name for the uid.
  */
-extern char *getusername(uid, file, opts)
+char *getusername(uid, file, opts)
 	UID_T uid;
 	char *file;
 	opt_t opts;
@@ -560,7 +560,7 @@
 /*
  * Get the group name for the gid.
  */
-extern char *getgroupname(gid, file, opts)
+char *getgroupname(gid, file, opts)
 	GID_T gid;
 	char *file;
 	opt_t opts;
@@ -598,7 +598,7 @@
 /*
  * Read a response from the remote host.
  */
-extern int response()
+int response()
 {
 	static u_char resp[BUFSIZ];
 	u_char *s;
@@ -640,6 +640,7 @@
 			message(MT_FERROR, "%s", s);
 		finish();
 	}
+	return -1;
 	/*NOTREACHED*/
 }
 
@@ -651,11 +652,11 @@
  * user's home directory path name. Return a pointer in buf to the
  * part corresponding to `file'.
  */
-extern char *exptilde(ebuf, file)
+char *exptilde(ebuf, file)
 	char *ebuf;
-	register char *file;
+	char *file;
 {
-	register char *s1, *s2, *s3;
+	char *s1, *s2, *s3;
 	extern char *homedir;
 
 	if (*file != '~') {
@@ -688,12 +689,12 @@
 			*s3 = '/';
 		s2 = pw->pw_dir;
 	}
-	for (s1 = ebuf; *s1++ = *s2++; )
+	for (s1 = ebuf; (*s1++ = *s2++); )
 		;
 	s2 = --s1;
 	if (s3 != NULL) {
 		s2++;
-		while (*s1++ = *s3++)
+		while ((*s1++ = *s3++))
 			;
 	}
 	return(s2);
@@ -704,7 +705,7 @@
  * Set our effective user id to the user running us.
  * This should be the uid we do most of our work as.
  */
-extern int becomeuser()
+int becomeuser()
 {
 	int r = 0;
 
@@ -726,7 +727,7 @@
 /*
  * Set our effective user id to "root" (uid = 0)
  */
-extern int becomeroot()
+int becomeroot()
 {
 	int r = 0;
 
@@ -747,7 +748,7 @@
 /*
  * Set access and modify times of a given file
  */
-extern int setfiletime(file, atime, mtime)
+int setfiletime(file, atime, mtime)
 	char *file;
 	time_t atime;
 	time_t mtime;
@@ -784,7 +785,7 @@
 /*
  * Get version info
  */
-extern char *getversion()
+char *getversion()
 {
 	static char buff[BUFSIZ];
 
@@ -805,7 +806,7 @@
 {
 	int fd[2], pid, i;
 	int status;
-	register char *cp, *s;
+	char *cp, *s;
 	char sbuf[BUFSIZ], buf[BUFSIZ];
 
 	if (pipe(fd) < 0) {
@@ -927,12 +928,12 @@
 /*
  * Private version of basename()
  */
-extern char *xbasename(path)
+char *xbasename(path)
 	char *path;
 {
-	register char *cp;
+	char *cp;
  
-	if (cp = strrchr(path, '/'))
+	if ((cp = strrchr(path, '/')))
 		return(cp+1);
 	else
 		return(path);
@@ -943,11 +944,11 @@
  * search until a component of that path is found and
  * return the found file name.
  */
-extern char *searchpath(path)
+char *searchpath(path)
 	char *path;
 {
-	register char *cp;
-	register char *file;
+	char *cp;
+	char *file;
 	struct stat statbuf;
 
 	for (; ;) {
@@ -971,8 +972,7 @@
 /*
  * Set line buffering.
  */
-extern void
-mysetlinebuf(fp)
+void mysetlinebuf(fp)
 	FILE *fp;
 {
 #if	SETBUF_TYPE == SETBUF_SETLINEBUF
@@ -989,8 +989,7 @@
 /*
  * Our interface to system call to get a socket pair.
  */
-int
-getsocketpair(domain, type, protocol, sv)
+int getsocketpair(domain, type, protocol, sv)
 	int domain;
 	int type;
 	int protocol;
--- rdist-6.1.5/src/message.c.cleanup	1998-11-10 05:13:30.000000000 +0100
+++ rdist-6.1.5/src/message.c	2003-12-17 11:38:16.000000000 +0100
@@ -32,7 +32,7 @@
  * SUCH DAMAGE.
  */
 
-#ifndef lint
+#if 0
 static char RCSid[] = 
 "$Id: message.c,v 6.25 1998/11/10 04:13:30 mcooper Exp $";
 
@@ -91,7 +91,7 @@
  */
 extern void msgprusage()
 {
-	register int i, x;
+	int i, x;
 
 	(void) fprintf(stderr, "\nWhere <msgopt> is of form\n");
 	(void) fprintf(stderr, 
@@ -114,7 +114,7 @@
  */
 extern void msgprconfig()
 {
-	register int i, x;
+	int i, x;
 	static char buf[MSGBUFSIZ];
 
 	debugmsg(DM_MISC, "Current message logging config:");
@@ -139,7 +139,7 @@
 static MSGFACILITY *getmsgfac(name)
 	char *name;
 {
-	register int i;
+	int i;
 
 	for (i = 0; msgfacility[i].mf_name; ++i)
 		if (strcasecmp(name, msgfacility[i].mf_name) == 0)
@@ -154,7 +154,7 @@
 static MSGTYPE *getmsgtype(name)
 	char *name;
 {
-	register int i;
+	int i;
 
 	for (i = 0; msgtypes[i].mt_name; ++i)
 		if (strcasecmp(name, msgtypes[i].mt_name) == 0)
@@ -172,9 +172,9 @@
 	char *str;
 {
 	static char ebuf[BUFSIZ];
-	register char *cp;
-	register char *strptr, *word;
-	register MSGTYPE *mtp;
+	char *cp;
+	char *strptr, *word;
+	MSGTYPE *mtp;
 
 	/*
 	 * MF_SYSLOG is the only supported message facility for the server
@@ -234,11 +236,11 @@
 	msgfac->mf_msgtypes = 0;	/* Start from scratch */
 	while (strptr) {
 		word = strptr;
-		if (cp = strchr(strptr, ','))
+		if ((cp = strchr(strptr, ',')))
 			*cp++ = CNULL;
 		strptr = cp;
 
-		if (mtp = getmsgtype(word)) {
+		if ((mtp = getmsgtype(word))) {
 			msgfac->mf_msgtypes |= mtp->mt_type;
 			/*
 			 * XXX This is really a kludge until we add real
@@ -266,8 +266,8 @@
 	int doset;
 {
 	static char ebuf[BUFSIZ], msgbuf[MSGBUFSIZ];
-	register char *cp, *optstr;
-	register char *word;
+	char *cp, *optstr;
+	char *word;
 	MSGFACILITY *msgfac;
 
 	if (msgstr == NULL)
@@ -302,7 +302,7 @@
 		if (doset) {
 			char *mcp;
 
-			if (mcp = setmsgtypes(msgfac, cp))
+			if ((mcp = setmsgtypes(msgfac, cp)))
 				return(mcp);
 		}
 	}
@@ -456,8 +456,9 @@
 		return;
 
 	if (!msgfac->mf_fptr) {
-		register char *cp;
+		char *cp;
 		char *getenv();
+		int fd;
 
 		/*
 		 * Create and open a new temporary file
@@ -469,7 +470,10 @@
 		(void) sprintf(tempfile, "%s/%s", cp, _RDIST_TMP);
 
 		msgfac->mf_filename = tempfile;
-		(void) mktemp(msgfac->mf_filename);
+		fd = mkstemp(msgfac->mf_filename);
+			if (fd < 0)
+				fatalerr("Cannot open notify file for writing: %s: %s.", msgfac->mf_filename, SYSERR);
+		close(fd);
 		if ((msgfac->mf_fptr = fopen(msgfac->mf_filename, "w"))==NULL)
 			fatalerr("Cannot open notify file for writing: %s: %s.",
 			      msgfac->mf_filename, SYSERR);
@@ -509,15 +513,15 @@
 	int flags;
 	char *msgbuf;
 {
-	register int i, x;
-	register char *cp;
+	int i, x;
+	char *cp;
 	static char mbuf[2048];
 
 	if (msgbuf && *msgbuf) {
 		/*
 		 * Ensure no stray newlines are present
 		 */
-		if (cp = strchr(msgbuf, '\n'))
+		if ((cp = strchr(msgbuf, '\n')))
 			*cp = CNULL;
 
 		checkhostname();
@@ -857,7 +861,7 @@
  */
 extern char *getnotifyfile()
 {
-	register int i;
+	int i;
 
 	for (i = 0; msgfacility[i].mf_name; i++)
 		if (msgfacility[i].mf_msgfac == MF_NOTIFY &&
--- rdist-6.1.5/src/setargs.c.cleanup	2003-12-17 11:38:16.000000000 +0100
+++ rdist-6.1.5/src/setargs.c	2003-12-17 11:38:16.000000000 +0100
@@ -32,7 +32,7 @@
  * SUCH DAMAGE.
  */
 
-#ifndef lint
+#if 0
 static char RCSid[] = 
 "$Id: setargs.c,v 6.5 1998/11/10 04:15:56 mcooper Exp $";
 
@@ -60,12 +60,12 @@
 /*
  * Settup things for using setproctitle()
  */
-setargs_settup(argc, argv, envp)
+void setargs_settup(argc, argv, envp)
 	int			argc;
 	char		      **argv;
 	char		      **envp;
 {
-	register int 		i;
+	int 		i;
 	extern char 	      **environ;
 
   	/* Remember the User Environment */
@@ -86,10 +86,10 @@
 /*
  * Set process title
  */
-extern void _setproctitle(msg)
+void _setproctitle(msg)
         char *msg;
 {
-	register int i;
+	int i;
 	char *p;
 	
 	p = Argv[0];
@@ -113,7 +113,7 @@
 /*
  * Varargs front-end to _setproctitle()
  */
-extern void setproctitle(va_alist)
+void setproctitle(va_alist)
 	va_dcl
 {
 	static char buf[BUFSIZ];
@@ -132,7 +132,7 @@
 /*
  * Stdarg front-end to _setproctitle()
  */
-extern void setproctitle(char *fmt, ...)
+void setproctitle(char *fmt, ...)
 {
 	static char buf[BUFSIZ];
 	va_list args;
@@ -149,7 +149,7 @@
  * Non-Varargs front-end to _setproctitle()
  */
 /*VARARGS1*/
-extern void setproctitle(fmt, a1, a2, a3, a4, a5, a6)
+void setproctitle(fmt, a1, a2, a3, a4, a5, a6)
 	char *fmt;
 {
 	static char buf[BUFSIZ];
--- rdist-6.1.5/src/rdistd.c.cleanup	1998-11-10 05:14:06.000000000 +0100
+++ rdist-6.1.5/src/rdistd.c	2003-12-17 11:38:16.000000000 +0100
@@ -32,7 +32,7 @@
  * SUCH DAMAGE.
  */
 
-#ifndef lint
+#if 0
 static char RCSid[] = 
 "$Id: rdistd.c,v 6.23 1998/11/10 04:14:06 mcooper Exp $";
 
@@ -47,21 +47,12 @@
 
 #include "defs.h"
 
-/*
- * Print usage message
- */
-static void usage()
-{
-	fprintf(stderr, "usage: %s -S [ -DV ]\n", progname);
-	exit(1);
-}
-
 char	localmsglist[] = "syslog=ferror";
 
 /*
  * The Beginning
  */
-main(argc, argv, envp)
+int main(argc, argv, envp)
 	int argc;
 	char **argv;
 	char **envp;
@@ -89,7 +80,8 @@
 		case '?':
 		default:
 			error("Bad command line option.");
-			usage();
+			fprintf(stderr, "usage: %s -S [ -DV ]\n", progname);
+			exit(1);
 		}
 
 	if (!isserver) {
@@ -102,7 +94,7 @@
 	rem_w = fileno(stdout);
 
 	/* Set logging */
-	if (cp = msgparseopts(localmsglist, TRUE))
+	if ((cp = msgparseopts(localmsglist, TRUE)))
 		fatalerr("Bad message logging option (%s): %s", 
 			 localmsglist, cp);
 
--- rdist-6.1.5/src/server.c.cleanup	2003-12-17 11:38:16.000000000 +0100
+++ rdist-6.1.5/src/server.c	2003-12-17 11:38:16.000000000 +0100
@@ -31,7 +31,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
-#ifndef lint
+#if 0
 static char RCSid[] = 
 "$Id: server.c,v 6.86 1998/11/10 04:15:31 mcooper Exp $";
 
@@ -191,7 +191,7 @@
 	static UID_T last_uid = (UID_T)-2;
 	static GID_T last_primegid;
 	extern char *locuser;
-	register int i;
+	int i;
 	UID_T uid;
 	GID_T gid;
 	GID_T primegid = (GID_T)-2;
@@ -246,7 +246,7 @@
 	        /*
 		 * Invalid cached values so we need to do a new lookup.
 		 */
-		if (gr = mygetgroup(group)) {
+		if ((gr = mygetgroup(group))) {
 			last_gid = gid = gr->gr_gid;
 			strcpy(last_group, gr->gr_name);
 		} else {
@@ -319,7 +319,7 @@
 {
 	DIR *d;
 	static DIRENTRY *dp;
-	register char *cp;
+	char *cp;
 	struct stat stb;
 	char *optarget;
 	int len, failures = 0;
@@ -356,7 +356,7 @@
 
 	optarget = ptarget;
 	len = ptarget - target;
-	while (dp = readdir(d)) {
+	while ((dp = readdir(d))) {
 		if ((D_NAMLEN(dp) == 1 && dp->d_name[0] == '.') ||
 		    (D_NAMLEN(dp) == 2 && dp->d_name[0] == '.' &&
 		     dp->d_name[1] == '.'))
@@ -370,7 +370,7 @@
 		ptarget = optarget;
 		*ptarget++ = '/';
 		cp = dp->d_name;;
-		while (*ptarget++ = *cp++)
+		while ((*ptarget++ = *cp++))
 			;
 		ptarget--;
 		if (lstat(target, &stb) < 0) {
@@ -408,10 +408,10 @@
  * for extraneous files and remove them.
  */
 static void doclean(cp)
-	register char *cp;
+	char *cp;
 {
 	DIR *d;
-	register DIRENTRY *dp;
+	DIRENTRY *dp;
 	struct stat stb;
 	char *optarget, *ep;
 	int len;
@@ -430,7 +430,7 @@
 
 	optarget = ptarget;
 	len = ptarget - target;
-	while (dp = readdir(d)) {
+	while ((dp = readdir(d))) {
 		if ((D_NAMLEN(dp) == 1 && dp->d_name[0] == '.') ||
 		    (D_NAMLEN(dp) == 2 && dp->d_name[0] == '.' &&
 		     dp->d_name[1] == '.'))
@@ -444,7 +444,7 @@
 		ptarget = optarget;
 		*ptarget++ = '/';
 		cp = dp->d_name;;
-		while (*ptarget++ = *cp++)
+		while ((*ptarget++ = *cp++))
 			;
 		ptarget--;
 		if (lstat(target, &stb) < 0) {
@@ -475,7 +475,7 @@
  * Frontend to doclean().
  */
 static void clean(cp)
-	register char *cp;
+	char *cp;
 {
 	doclean(cp);
 	(void) sendcmd(CC_END, NULL);
@@ -503,7 +503,7 @@
  */
 static void docmdspecial()
 {
-	register char *cp;
+	char *cp;
 	char *cmd, *env = NULL;
 	int n;
 	int len;
@@ -661,7 +661,7 @@
 	char *name;
 	opt_t opts;
 {
-	register char *cp;
+	char *cp;
 	struct stat stb;
 	int r = -1;
 
@@ -754,7 +754,7 @@
 {
 	int f, wrerr, olderrno, lastwashole = 0, wassparse = 0;
 	off_t i;
-	register char *cp;
+	char *cp;
 	char *savefile = NULL;
 	static struct stat statbuff;
 
@@ -981,7 +981,7 @@
 	char *owner, *group;
 {
 	static char lowner[100], lgroup[100];
-	register char *cp;
+	char *cp;
 	struct stat stb;
 	int s;
 
@@ -1038,7 +1038,7 @@
 
 				o = (owner[0] == ':') ? opts & DO_NUMCHKOWNER :
 					opts;
-				if (cp = getusername(stb.st_uid, target, o))
+				if ((cp = getusername(stb.st_uid, target, o)))
 					if (strcmp(owner, cp))
 						(void) strcpy(lowner, cp);
 			}
@@ -1047,7 +1047,7 @@
 
 				o = (group[0] == ':') ? opts & DO_NUMCHKGROUP :
 					opts;
-				if (cp = getgroupname(stb.st_gid, target, o))
+				if ((cp = getgroupname(stb.st_gid, target, o)))
 					if (strcmp(group, cp))
 						(void) strcpy(lgroup, cp);
 			}
@@ -1101,8 +1101,8 @@
 	if (s < 0) {
 		if (errno == ENOENT) {
 			if (mkdir(target, mode) == 0 ||
-			    chkparent(target, opts) == 0 && 
-			    mkdir(target, mode) == 0) {
+			    (chkparent(target, opts) == 0 && 
+			     mkdir(target, mode) == 0)) {
 				message(MT_NOTICE, "%s: mkdir", target);
 				(void) fchog(-1, target, owner, group, mode);
 				ack();
@@ -1298,7 +1298,7 @@
 static void setconfig(cmd)
 	char *cmd;
 {
-	register char *cp = cmd;
+	char *cp = cmd;
 	char *estr;
 
 	switch (*cp++) {
@@ -1332,7 +1332,7 @@
 		break;
 
 	case SC_LOGGING:	/* Logging options */
-		if (estr = msgparseopts(cp, TRUE)) {
+		if ((estr = msgparseopts(cp, TRUE))) {
 			fatalerr("Bad message option string (%s): %s", 
 				 cp, estr);
 			return;
@@ -1449,7 +1449,7 @@
 		sptarget[catname] = ptarget;
 		if (catname++) {
 			*ptarget++ = '/';
-			while (*ptarget++ = *file++)
+			while ((*ptarget++ = *file++))
 			    ;
 			ptarget--;
 		}
@@ -1457,6 +1457,7 @@
 		/*
 		 * Create name of temporary file
 		 */
+		int fd;
 		if (catname && cattarget(file) < 0) {
 			error("Cannot set file name.");
 			return;
@@ -1471,7 +1472,12 @@
 			(void) sprintf(new, "%s/%s", target, tempname);
 			*file = '/';
 		}
-		(void) mktemp(new);
+		fd = mkstemp(new);
+		if (fd < 0) {
+			error("Cannot set file name.");
+			return;
+		}
+		close(fd);
 	}
 
 	/*
@@ -1575,8 +1581,8 @@
 extern void server()
 {
 	static char cmdbuf[BUFSIZ];
-	register char *cp;
-	register int n;
+	char *cp;
+	int n;
 	extern jmp_buf finish_jmpbuf;
 
 	if (setjmp(finish_jmpbuf)) {
--- rdist-6.1.5/src/filesys.c.cleanup	1998-11-10 05:10:18.000000000 +0100
+++ rdist-6.1.5/src/filesys.c	2003-12-17 11:38:16.000000000 +0100
@@ -32,7 +32,7 @@
  * SUCH DAMAGE.
  */
 
-#ifndef lint
+#if 0
 static char RCSid[] = 
 "$Id: filesys.c,v 6.25 1998/11/10 04:10:17 mcooper Exp $";
 
@@ -66,7 +66,7 @@
 	static char last_pathname[MAXPATHLEN];
 	static char file[MAXPATHLEN + 3];
 	static struct stat filestat;
-	register char *p;
+	char *p;
 
 	/*
 	 * Mark the statbuf as invalid to start with.
@@ -119,7 +119,7 @@
 			 * Normally we want to change /dir1/dir2/file
 			 * into "/dir1/dir2/."
 			 */
-			if (p = (char *) strrchr(file, '/')) {
+			if ((p = (char *) strrchr(file, '/'))) {
 				*++p = '.';
 				*++p = CNULL;
 			} else {
@@ -177,7 +177,7 @@
 	struct stat *filest;
 	struct mntinfo *mntinfo;
 {
-	register struct mntinfo *mi;
+	struct mntinfo *mi;
 
 	for (mi = mntinfo; mi; mi = mi->mi_nxt) {
 		if (mi->mi_mnt->me_flags & MEFLAG_IGNORE)
@@ -196,7 +196,7 @@
 	mntent_t *mnt;
 	struct mntinfo *mntinfo;
 {
-	register struct mntinfo *m;
+	struct mntinfo *m;
 
 	for (m = mntinfo; m; m = m->mi_nxt)
 		if (strcmp(m->mi_mnt->me_path, mnt->me_path) == 0)
@@ -241,7 +241,7 @@
 	}
 
 	mntinfo = mi;
-	while (mnt = getmountent(mfp)) {
+	while ((mnt = getmountent(mfp))) {
 		debugmsg(DM_MISC, "mountent = '%s' (%s)", 
 			 mnt->me_path, mnt->me_type);
 
@@ -302,7 +302,7 @@
 	static struct stat filestat;
 	struct stat *pstat;
 	struct mntinfo *tmpmi;
-	register mntent_t *mnt;
+	mntent_t *mnt;
 
 	/*
 	 * Use the supplied stat buffer if not NULL or our own.
@@ -324,16 +324,16 @@
 	/*
 	 * Find the mnt that pathname is on.
 	 */
-	if (mnt = findmnt(pstat, mntinfo))
+	if ((mnt = findmnt(pstat, mntinfo)))
 		return(mnt);
 
 	/*
 	 * We failed to find correct mnt, so maybe it's a newly
 	 * mounted filesystem.  We rebuild mntinfo and try again.
 	 */
-	if (tmpmi = makemntinfo(mntinfo)) {
+	if ((tmpmi = makemntinfo(mntinfo))) {
 		mntinfo = tmpmi;
-		if (mnt = findmnt(pstat, mntinfo))
+		if ((mnt = findmnt(pstat, mntinfo)))
 			return(mnt);
 	}
 
--- rdist-6.1.5/src/filesys-os.c.cleanup	1998-11-10 05:09:59.000000000 +0100
+++ rdist-6.1.5/src/filesys-os.c	2003-12-17 11:38:16.000000000 +0100
@@ -32,7 +32,7 @@
  * SUCH DAMAGE.
  */
 
-#ifndef lint
+#if 0
 static char RCSid[] = 
 "$Id: filesys-os.c,v 6.18 1998/11/10 04:09:58 mcooper Exp $";
 
@@ -308,7 +308,7 @@
 
 	bzero((char *)&me, sizeof(mntent_t));
 
-	if (mntent = getmntent(fptr)) {
+	if ((mntent = getmntent(fptr))) {
 		me.me_path = mntent->mnt_dir;
 		me.me_type = mntent->mnt_type;
 		if (mntent->mnt_opts && hasmntopt(mntent, MNTOPT_RO))
--- rdist-6.1.5/src/strcasecmp.c.cleanup	1998-11-10 05:16:52.000000000 +0100
+++ rdist-6.1.5/src/strcasecmp.c	2003-12-17 11:38:16.000000000 +0100
@@ -70,9 +70,9 @@
 };
 
 strcasecmp(s1, s2)
-	register char *s1, *s2;
+	char *s1, *s2;
 {
-	register char *cm = charmap;
+	char *cm = charmap;
 
 	while (cm[*s1] == cm[*s2++])
 		if (*s1++ == '\0')
@@ -81,10 +81,10 @@
 }
 
 strncasecmp(s1, s2, n)
-	register char *s1, *s2;
-	register int n;
+	char *s1, *s2;
+	int n;
 {
-	register char *cm = charmap;
+	char *cm = charmap;
 
 	while (--n >= 0 && cm[*s1] == cm[*s2++])
 		if (*s1++ == '\0')
--- rdist-6.1.5/src/strtol.c.cleanup	1994-03-17 00:25:50.000000000 +0100
+++ rdist-6.1.5/src/strtol.c	2003-12-17 11:38:16.000000000 +0100
@@ -54,13 +54,13 @@
 strtol(nptr, endptr, base)
 	char *nptr;
 	char **endptr;
-	register int base;
+	int base;
 {
-	register char *s = nptr;
-	register unsigned long acc;
-	register int c;
-	register unsigned long cutoff;
-	register int neg = 0, any, cutlim;
+	char *s = nptr;
+	unsigned long acc;
+	int c;
+	unsigned long cutoff;
+	int neg = 0, any, cutlim;
 
 	/*
 	 * Skip white space and pick up leading +/- sign if any.
--- rdist-6.1.5/src/regex.c.cleanup	1998-11-10 05:14:28.000000000 +0100
+++ rdist-6.1.5/src/regex.c	2003-12-17 11:39:14.000000000 +0100
@@ -136,10 +136,8 @@
  */
 char *
 re_comp(sp)
-	register char	*sp;
 {
-	register int	c;
-	register char	*ep = expbuf;
+	char	*ep = expbuf;
 	int	cclcnt, numbra = 0;
 	char	*lastep = 0;
 	char	bracket[NBRA];
@@ -260,10 +258,10 @@
  */
 int
 re_exec(p1)
-	register char	*p1;
+	char	*p1;
 {
-	register char	*p2 = expbuf;
-	register int	c;
+	char	*p2 = expbuf;
+	int	c;
 	int	rv;
 
 	for (c = 0; c < NBRA; c++) {
@@ -300,9 +298,9 @@
  */
 static	int
 advance(lp, ep)
-	register char	*lp, *ep;
+	char	*lp, *ep;
 {
-	register char	*curlp;
+	char	*curlp;
 	int	ct, i;
 	int	rv;
 
@@ -407,10 +405,10 @@
 }
 
 backref(i, lp)
-	register int	i;
-	register char	*lp;
+	int	i;
+	char	*lp;
 {
-	register char	*bp;
+	char	*bp;
 
 	bp = braslist[i];
 	while (*bp++ == *lp++)
@@ -421,10 +419,10 @@
 
 int
 cclass(set, c, af)
-	register char	*set, c;
+	char	*set, c;
 	int	af;
 {
-	register int	n;
+	int	n;
 
 	if (c == 0)
 		return(0);
--- rdist-6.1.5/include/defs.h.cleanup	2003-12-17 11:38:16.000000000 +0100
+++ rdist-6.1.5/include/defs.h	2003-12-17 11:38:16.000000000 +0100
@@ -49,11 +49,13 @@
 #include <grp.h>
 #include <syslog.h>
 #include <setjmp.h>
+#include <time.h>
 #include <sys/types.h>
 #include <sys/param.h>
 #include <sys/file.h>
-#include <sys/time.h>
 #include <sys/stat.h>
+#include <sys/wait.h>
+#include <sys/socket.h>
 
 #include "version.h"
 #include "config-def.h"
@@ -67,6 +69,9 @@
 #endif	/* yacc */
 
 #include <signal.h>
+#define _REGEX_RE_COMP
+#include <regex.h>
+
 
 /*
  * This belongs in os-svr4.h but many SVR4 OS's
@@ -340,12 +345,11 @@
 /*
  * Our own declarations.
  */
-char			       *exptilde();
 char			       *makestr();
 char	       		       *xcalloc();
 char	       		       *xmalloc();
 char	       		       *xrealloc();
-extern char		       *xbasename();
+extern char		       *exptilde();
 extern char		       *getdistoptlist();
 extern char		       *getgroupname();
 extern char		       *getnlstr();
@@ -355,44 +359,75 @@
 extern char		       *getversion();
 extern char		       *msgparseopts();
 extern char		       *searchpath();
+extern char		       *xbasename();
+extern int			amatch();
 extern int			any();
+extern int			becomeroot();
+extern int			becomeuser();
+extern int			except();
+extern int			execbrc();
+extern int			getfilesysinfo();
+extern int			getsocketpair();
 extern int			init();
 extern int			install();
 extern int			isexec();
+extern int			is_nfs_mounted();
+extern int			is_ro_mounted();
+extern int			is_symlinked();
+extern int			match();
+extern int			okname();
 extern int			parsedistopts();
+extern int			readrem();
 extern int			remline();
+extern int			response();
+extern int			rshrcmd();
 extern int			setfiletime();
+extern int			setnonblocking();
 extern int			spawn();
+extern int			yylex();
+extern int			yyparse();
 extern struct subcmd 	       *makesubcmd();
+extern void			append();
 extern void			checkhostname();
 extern void			cleanup();
 extern void			complain();
+extern void			coredump();
+extern void			define();
+extern void			docmdargs();
 extern void			docmds();
 extern void			finish();
-extern void			log();
+extern void			freelinkinfo();
+extern void			insert();
 extern void			logmsg();
 extern void			lostconn();
 extern void			markassigned();
+extern void			msgprconfig();
 extern void			msgprusage();
+extern void			mysetlinebuf();
 extern void			note();
 extern void			runcmdspecial();
 extern void			runcommand();
 extern void			server();
+extern void			setargs_settup();
 extern void			setprogname();
 extern void			sighandler();
+extern void			usage();
 extern void			waitup();
+extern void			yyerror();
+extern WRITE_RETURN_T		xwrite();
 struct namelist		       *expand();
 struct namelist		       *lookup();
 struct namelist		       *makenl();
-extern WRITE_RETURN_T		xwrite();
 
 #if	defined(ARG_TYPE) && ARG_TYPE == ARG_STDARG
+extern int			sendcmd(char cmd, char *fmt, ...);
 extern void			debugmsg(int, char *, ...);
 extern void			error(char *, ...);
 extern void			fatalerr(char *, ...);
 extern void			message(int, char *, ...);
 extern void			setproctitle(char *fmt, ...);
 #else
+extern int			sendcmd(va_alist);
 extern void			debugmsg();
 extern void			error();
 extern void			fatalerr();
