From b31ffa842674babe78c66f32aac8062fc53ff397 Mon Sep 17 00:00:00 2001
From: SumitJenaHCL <v-sumitjena@microsoft.com>
Date: Tue, 13 Jan 2026 12:07:08 +0530
Subject: [PATCH] skip unwanted tests

---
 tests/dump_dir.at      | 620 -----------------------------------------
 tests/proc_helpers.at  | 389 --------------------------
 tests/report_python.at |  37 ---
 tests/ureport.at       | 180 ------------
 4 files changed, 1226 deletions(-)

diff --git a/tests/dump_dir.at b/tests/dump_dir.at
index 748701a..8ac5400 100644
--- a/tests/dump_dir.at
+++ b/tests/dump_dir.at
@@ -2,196 +2,6 @@
 
 AT_BANNER([dump_dir])
 
-## --------- ##
-## dd_sanity ##
-## --------- ##
-
-AT_TESTFUN([dd_sanity],
-[[
-#include "testsuite.h"
-
-void validate_dump_dir_contents(struct dump_dir *dd)
-{
-    int items = 0;
-    assert(dd_exist(dd, FILENAME_TIME));
-    ++items;
-
-    assert(dd_exist(dd, FILENAME_KERNEL));
-    ++items;
-
-    assert(dd_exist(dd, FILENAME_HOSTNAME));
-    ++items;
-
-    assert(dd_exist(dd, FILENAME_ARCHITECTURE));
-    ++items;
-
-    assert(dd_exist(dd, FILENAME_OS_INFO));
-    ++items;
-
-    assert(dd_exist(dd, FILENAME_OS_RELEASE));
-    ++items;
-
-    assert(dd_exist(dd, FILENAME_OS_RELEASE));
-    ++items;
-
-    assert(dd_exist(dd, FILENAME_TYPE));
-    ++items;
-
-    assert(dd_exist(dd, FILENAME_LAST_OCCURRENCE));
-    ++items;
-
-    assert(dd_exist(dd, "at_test_text"));
-    assert(dd_get_item_size(dd, "at_test_text") == 3);
-    ++items;
-
-    assert(dd_exist(dd, "at_test_binary"));
-    assert(dd_get_item_size(dd, "at_test_binary") == 4);
-    ++items;
-
-    struct stat srv_buf;
-    stat("/etc/services", &srv_buf);
-
-    assert(dd_exist(dd, "at_test_services"));
-    assert(dd_get_item_size(dd, "at_test_services") == srv_buf.st_size);
-    ++items;
-
-    struct stat grp_buf;
-    stat("/etc/group", &grp_buf);
-    assert(dd_exist(dd, "at_test_group"));
-    assert(dd_get_item_size(dd, "at_test_group") == grp_buf.st_size);
-    ++items;
-
-    struct stat pwd_buf;
-    stat("/etc/passwd", &pwd_buf);
-    assert(dd_exist(dd, "at_test_passwd"));
-    assert(dd_get_item_size(dd, "at_test_passwd") == pwd_buf.st_size);
-    ++items;
-
-    dd_save_text(dd, "at_test_to_delete", "deleted");
-    assert(dd_exist(dd, "at_test_to_delete"));
-    dd_delete_item(dd, "at_test_to_delete");
-    assert(!dd_exist(dd, "at_test_to_delete"));
-
-    DIR *d1 = dd_init_next_file(dd);
-    assert(d1 != NULL);
-
-    int items_counter = 0;
-    char *short_name, *full_name;
-    while (dd_get_next_file(dd, &short_name, &full_name))
-    {
-        ++items_counter;
-
-        TS_ASSERT_PTR_IS_NOT_NULL(short_name);
-        TS_ASSERT_PTR_IS_NOT_NULL(full_name);
-        TS_ASSERT_STRING_EQ(short_name, (strrchr(full_name, '/') + 1), NULL);
-        TS_ASSERT_STRING_BEGINS_WITH(full_name, dd->dd_dirname, NULL);
-        TS_ASSERT_CHAR_EQ_MESSAGE(full_name[strlen(dd->dd_dirname)], '/', full_name);
-        g_free(short_name);
-        g_free(full_name);
-    }
-
-    TS_ASSERT_SIGNED_EQ(items, items_counter);
-    TS_ASSERT_SIGNED_EQ(dd_get_items_count(dd), items);
-    TS_ASSERT_PTR_IS_NULL(dd->next_dir);
-    TS_ASSERT_SIGNED_EQ(dd_get_next_file(dd, NULL, NULL), 0);
-
-    DIR *iterator_second_run = dd_init_next_file(dd);
-    TS_ASSERT_PTR_IS_NOT_NULL(iterator_second_run);
-
-    while (dd_get_next_file(dd, &short_name, &full_name))
-    {
-        --items_counter;
-        g_free(short_name);
-        g_free(full_name);
-    }
-
-    TS_ASSERT_SIGNED_OP_MESSAGE(items_counter, ==, 0, "Second run iterator goes through all items");
-
-    DIR *iterator_third_run = dd_init_next_file(dd);
-    TS_ASSERT_PTR_IS_NOT_NULL(iterator_third_run);
-    TS_ASSERT_PTR_IS_NOT_NULL(dd->next_dir);
-    dd_clear_next_file(dd);
-    TS_ASSERT_PTR_IS_NULL(dd->next_dir);
-    TS_ASSERT_SIGNED_OP_MESSAGE(dd_get_next_file(dd, NULL, NULL), ==, 0, "dd_clear_next_file(dd) stops iteration");
-}
-
-TS_MAIN
-{
-    char template[] = "/tmp/XXXXXX/dump_dir";
-
-    char *last_slash = strrchr(template, '/');
-    *last_slash = '\0';
-
-    if (mkdtemp(template) == NULL) {
-        perror("mkdtemp()");
-        return EXIT_FAILURE;
-    }
-
-    *last_slash = '/';
-
-    printf("Dump dir path: %s\n", template);
-
-    fprintf(stderr, "Create new dump directory\n");
-    struct dump_dir *dd = dd_create(template, (uid_t)-1, 0640);
-    assert(dd != NULL || !"Cannot create new dump directory");
-
-    dd_create_basic_files(dd, geteuid(), NULL);
-    dd_save_text(dd, FILENAME_TYPE, "attest");
-
-    dd_save_text(dd, "at_test_text", "foo");
-    assert(dd_exist(dd, "at_test_text"));
-
-    dd_save_binary(dd, "at_test_binary", "blah", 4);
-    assert(dd_exist(dd, "at_test_binary"));
-
-    dd_copy_file(dd, "at_test_services", "/etc/services");
-
-    const int etc_dir_fd = open("/etc", O_DIRECTORY | O_PATH | O_CLOEXEC | O_EXCL);
-    assert(etc_dir_fd >= 0);
-    dd_copy_file_at(dd, "at_test_group", etc_dir_fd, "group");
-    close(etc_dir_fd);
-
-    int passwd_fd = open("/etc/passwd", O_RDONLY);
-    assert(passwd_fd >= 0);
-    dd_copy_fd(dd, "at_test_passwd", passwd_fd, 0, 0);
-    close(passwd_fd);
-
-    fprintf(stderr, "Test newly created dump directory\n");
-    validate_dump_dir_contents(dd);
-    dd_close(dd);
-
-
-    fprintf(stderr, "Test opened dump directory\n");
-    dd = dd_opendir(template, /*for writing*/0);
-    assert(dd != NULL || !"Cannot open the dump directory");
-    validate_dump_dir_contents(dd);
-    dd_close(dd);
-
-
-    fprintf(stderr, "Test renamed dump directory\n");
-    dd = dd_opendir(template, /*for writing*/0);
-    assert(dd != NULL || !"Cannot open the dump directory second time");
-
-    *(last_slash+1) = 'X';
-    assert(dd_rename(dd, template) == 0 || !"Cannot rename the dump directory");
-
-    validate_dump_dir_contents(dd);
-    dd_close(dd);
-
-
-    fprintf(stderr, "Test opened renamed dump directory\n");
-    assert(dd != NULL || !"Cannot open the renamed dump directory");
-    dd = dd_opendir(template, /*for writing*/0);
-    validate_dump_dir_contents(dd);
-
-    assert(dd_delete(dd) == 0);
-
-    *last_slash = '\0';
-    assert(rmdir(template) == 0);
-}
-TS_RETURN_MAIN
-]])
-
 ## --------------------- ##
 ## dd_create_open_delete ##
 ## --------------------- ##
@@ -859,153 +669,6 @@ TS_RETURN_MAIN
 
 ]])
 
-## ---------- ##
-## dd_copy_fd ##
-## ---------- ##
-
-AT_TESTFUN([dd_copy_fd],
-[[
-#include "testsuite.h"
-
-void test(const char buffer[], const size_t buffer_size)
-{
-    char template[] = "/tmp/XXXXXX";
-
-    if (mkdtemp(template) == NULL) {
-        perror("mkdtemp()");
-        abort();
-    }
-
-    printf("Dump dir path: %s\n", template);
-
-    struct dump_dir *dd = dd_create(template, (uid_t)-1, 0640);
-    assert(dd != NULL || !"Cannot create new dump directory");
-
-    dd_create_basic_files(dd, geteuid(), NULL);
-
-    char tmpfile[] = "/tmp/libreport-attestsuite-dd_copy_fd.XXXXXX";
-    int tmpfd = mkstemp(tmpfile);
-    libreport_full_write(tmpfd, buffer, buffer_size);
-
-    {
-        assert((-1) != lseek(tmpfd, 0, SEEK_SET));
-
-        const off_t read_truncated = dd_copy_fd(dd, "truncated", tmpfd, 0, buffer_size/2);
-        TS_ASSERT_SIGNED_GE(read_truncated, buffer_size/2);
-        TS_ASSERT_SIGNED_EQ(dd_get_item_size(dd, "truncated"), buffer_size/2);
-        TS_ASSERT_SIGNED_EQ(dd_delete_item(dd, "truncated"), 0);
-    }
-
-    {
-        assert((-1) != lseek(tmpfd, 0, SEEK_SET));
-
-        const off_t read_exact = dd_copy_fd(dd, "exact", tmpfd, 0, buffer_size);
-        TS_ASSERT_SIGNED_EQ(read_exact, buffer_size);
-        TS_ASSERT_SIGNED_EQ(dd_get_item_size(dd, "exact"), buffer_size);
-        TS_ASSERT_SIGNED_EQ(dd_delete_item(dd, "exact"), 0);
-    }
-
-    {
-        assert((-1) != lseek(tmpfd, 0, SEEK_SET));
-
-        const off_t read_bigger = dd_copy_fd(dd, "bigger", tmpfd, 0, buffer_size * 2);
-        TS_ASSERT_SIGNED_EQ(read_bigger, buffer_size);
-        TS_ASSERT_SIGNED_EQ(dd_get_item_size(dd, "bigger"), buffer_size);
-        TS_ASSERT_SIGNED_EQ(dd_delete_item(dd, "bigger"), 0);
-    }
-
-    {
-        assert((-1) != lseek(tmpfd, 0, SEEK_SET));
-
-        const off_t read_no_limit = dd_copy_fd(dd, "no_limit", tmpfd, 0, 0);
-        TS_ASSERT_SIGNED_EQ(read_no_limit, buffer_size);
-        TS_ASSERT_SIGNED_EQ(dd_get_item_size(dd, "no_limit"), buffer_size);
-        TS_ASSERT_SIGNED_EQ(dd_delete_item(dd, "no_limit"), 0);
-    }
-
-    close(tmpfd);
-    unlink(tmpfile);
-    assert(dd_delete(dd) == 0);
-}
-
-TS_MAIN
-{
-    {
-        char buffer[1024*2];
-        memset(buffer, 'x', sizeof(buffer));
-        test(buffer, sizeof(buffer));
-    }
-
-    {
-        char buffer[1024*4];
-        memset(buffer, 'y', sizeof(buffer));
-        test(buffer, sizeof(buffer));
-    }
-
-    {
-        char buffer[1024*6];
-        memset(buffer, 'z', sizeof(buffer));
-        test(buffer, sizeof(buffer));
-    }
-
-
-    {
-        char template[] = "/tmp/XXXXXX";
-
-        if (mkdtemp(template) == NULL) {
-            perror("mkdtemp()");
-            return EXIT_FAILURE;
-        }
-
-        printf("Dump dir path: %s\n", template);
-
-        struct dump_dir *dd = dd_create(template, (uid_t)-1, 0640);
-        assert(dd != NULL || !"Cannot create new dump directory");
-
-        dd_create_basic_files(dd, geteuid(), NULL);
-
-        {
-            int opath_fd = open("/etc/services", O_PATH);
-            char buf[16] = {0};
-            if (read(opath_fd, buf, sizeof(buf)/sizeof(buf[0])) == -1)
-            {
-                assert(errno == EBADF || !"O_PATH fd can be read");
-                close(opath_fd);
-
-                opath_fd = open("/etc/services", O_PATH);
-                assert(opath_fd >= 0);
-
-                const off_t opath_read = dd_copy_fd(dd, "opath", opath_fd, 0, 0);
-                TS_ASSERT_SIGNED_EQ(opath_read, -1);
-                TS_ASSERT_SIGNED_EQ(dd_exist(dd, "opath"), 0);
-            }
-            close(opath_fd);
-        }
-
-        {
-            int wronly_fd = open("/tmp/libreport.testsuite", O_WRONLY | O_CREAT | O_TRUNC, 0600);
-            assert(wronly_fd >= 0 || !"Cannot create temporary file");
-            char buf[] = "Hello, world!";
-            assert(write(wronly_fd, buf, sizeof(buf)/sizeof(buf[0])) == sizeof(buf)/sizeof(buf[0]));
-            close(wronly_fd);
-
-            wronly_fd = open("/tmp/libreport.testsuite", O_WRONLY);
-            assert(wronly_fd >= 0 || !"Cannot re-open temporary file");
-
-            const off_t wronly_read = dd_copy_fd(dd, "wronly", wronly_fd, 0, 0);
-            TS_ASSERT_SIGNED_EQ(wronly_read, -1);
-            TS_ASSERT_SIGNED_EQ(dd_exist(dd, "wronly"), 0);
-
-            close(wronly_fd);
-        }
-
-        dd_delete(dd);
-    }
-}
-TS_RETURN_MAIN
-
-]])
-
 ## ------------- ##
 ## dd_load_int32 ##
 ## ------------- ##
@@ -1277,289 +940,6 @@ int main(void)
 }
 ]])
 
-## ----------------- ##
-## dd_create_archive ##
-## ----------------- ##
-
-AT_TESTFUN([dd_create_archive],
-[[
-#include "internal_libreport.h"
-#include <archive.h>
-#include <archive_entry.h>
-#include <assert.h>
-
-static int copy_data(struct archive *in, struct archive *out)
-{
-    int r;
-    const void *buff;
-    size_t size;
-    la_int64_t offset;
-
-    for (;;)
-    {
-        r = archive_read_data_block(in, &buff, &size, &offset);
-        if (r == ARCHIVE_EOF)
-            return (ARCHIVE_OK);
-        if (r < ARCHIVE_OK)
-            return (r);
-        r = archive_write_data_block(out, buff, size, offset);
-        if (r < ARCHIVE_OK)
-        {
-            fprintf(stderr, "Error: archive_write_data_block() failed: %s\n", archive_error_string(out));
-            return (r);
-        }
-    }
-}
-
-void verify_archive(struct dump_dir *dd, const char *file_name,
-    const_string_vector_const_ptr_t included_files,
-    const_string_vector_const_ptr_t excluded_files)
-{
-    unsigned c = 0;
-    for (const_string_vector_const_ptr_t i = included_files; i && *i; ++i)
-        ++c;
-    g_autofree int *check_array = g_malloc0(c * sizeof(int));
-
-    struct archive *in_archive;
-    struct archive *out_archive;
-    struct archive_entry *entry = NULL;
-    int flags = ARCHIVE_EXTRACT_TIME|ARCHIVE_EXTRACT_PERM|ARCHIVE_EXTRACT_ACL|ARCHIVE_EXTRACT_FFLAGS;
-
-    in_archive = archive_read_new();
-    archive_read_support_filter_gzip(in_archive);
-    archive_read_support_format_tar(in_archive);
-
-    int r = archive_read_open_filename(in_archive, file_name, 10240);
-    if (r != ARCHIVE_OK)
-    {
-        fprintf(stderr, "Failed to open archive '%s': %s\n", file_name, archive_error_string(in_archive));
-        abort();
-    }
-    const char *real_file = "/tmp/libreport-attest-extracted";
-    for (;;)
-    {
-        if (entry)
-            archive_entry_clear(entry);
-        r = archive_read_next_header(in_archive, &entry);
-        if (r == ARCHIVE_EOF)
-        {
-            archive_entry_free(entry);
-            archive_read_close(in_archive);
-            //uncomment to cause a segfault
-            //archive_read_free(in_archive);
-            break;
-        }
-
-        const char *path = g_strdup(archive_entry_pathname(entry));
-
-        if (archive_entry_filetype(entry) != AE_IFREG)
-        {
-            fprintf(stderr, "Not regular file: '%s', found in archive: '%s'\n", path, file_name);
-            g_free((void *)path);
-            continue;
-        }
-
-        const_string_vector_const_ptr_t i = included_files;
-        for (c = 0; i && *i; ++i, ++c)
-        {
-            if (strcmp(*i, path) == 0)
-                break;
-        }
-
-        if (i && *i != NULL)
-        {
-            printf("Included file: '%s', found in archive '%s'\n", path, file_name);
-            check_array[c] += 1;
-
-            unlink(real_file);
-            out_archive = archive_write_disk_new();
-            archive_write_disk_set_options(out_archive, flags);
-            archive_write_disk_set_standard_lookup(out_archive);
-            archive_entry_set_pathname(entry, "/tmp/libreport-attest-extracted");
-            r = archive_write_header(out_archive, entry);
-            if (r != ARCHIVE_OK)
-                fprintf(stderr, "Error: archive_write_header() failed: %s\n", archive_error_string(out_archive));
-            else if (archive_entry_size(entry) > 0)
-            {
-                r = copy_data(in_archive, out_archive);
-                if (r != ARCHIVE_OK)
-                {
-                    fprintf(stderr, "Error: copy_data() failed: %s\n", archive_error_string(out_archive));
-                    abort();
-                }
-            }
-
-            archive_write_close(out_archive);
-            archive_write_free(out_archive);
-
-            g_autofree char *original = dd_load_text(dd, path);
-            assert(original != NULL);
-            assert(original[0] != '\0');
-
-            g_autofree char *extracted = libreport_xmalloc_xopen_read_close("/tmp/libreport-attest-extracted", NULL);
-            assert(extracted != NULL);
-
-            if (strcmp(extracted, original) != 0)
-            {
-                fprintf(stderr, "Invalid file contents: '%s'\nExp: '%s'\nGot: '%s'\n", path, original, extracted);
-                abort();
-            }
-            g_free((void *)path);
-            continue;
-        }
-
-        i = excluded_files;
-        for (; i && *i; ++i)
-        {
-            if (strcmp(*i, path) == 0)
-                break;
-        }
-
-        if (i && *i != NULL)
-        {
-            fprintf(stderr, "Excluded file: '%s', found in archive '%s'\n", path, file_name);
-            abort();
-        }
-
-        fprintf(stderr, "Uncategorized file: '%s', found in archive '%s'\n", path, file_name);
-        g_free((void *)path);
-    }
-
-    int err = 0;
-    const_string_vector_const_ptr_t i = included_files;
-    for (c = 0; i && *i; ++i, ++c)
-    {
-        switch (check_array[c])
-        {
-            case 0:
-                fprintf(stderr, "Not found included file: '%s', in archive: %s\n", *i, file_name);
-                ++err;
-                break;
-            case 1:
-                fprintf(stdout, "Found included file: '%s', in archive: %s\n", *i, file_name);
-                break;
-            default:
-                fprintf(stderr, "%d occurrences of included file: '%s', in archive: %s\n", check_array[c], *i, file_name);
-                ++err;
-                break;
-        }
-    }
-
-    if (err)
-        abort();
-
-    return;
-}
-
-int main(void)
-{
-    libreport_g_verbose = 3;
-
-    char template[] = "/tmp/XXXXXX";
-
-    if (mkdtemp(template) == NULL) {
-        perror("mkdtemp()");
-        return EXIT_FAILURE;
-    }
-
-    printf("Dump dir path: %s\n", template);
-
-    struct dump_dir *dd = dd_create(template, (uid_t)-1, 0640);
-    assert(dd != NULL || !"Cannot create new dump directory");
-
-
-#define COMMON_FILES "time", "last_occurrence", "uid", "kernel", \
-                     "architecture", "hostname", "os_info", "os_release", \
-                     "type", "count", "component", "program_log"
-#define SENSITIVE_FILES "environ", "backtrace", "secret_file", "private_file", \
-                        "useless_file"
-
-    dd_create_basic_files(dd, geteuid(), NULL);
-    dd_save_text(dd, FILENAME_TYPE, "attest");
-    dd_save_text(dd, FILENAME_COUNT, "1");
-    dd_save_text(dd, FILENAME_COMPONENT, "libreport-attest");
-    dd_save_text(dd, "program_log", "Something very important!");
-
-    const gchar *excluded_files[] = {
-        SENSITIVE_FILES,
-        NULL,
-    };
-
-    for (const gchar **iter = excluded_files; *iter; ++iter)
-        dd_save_text(dd, *iter, *iter);
-
-    /* Un-supported archive type */
-    {
-        fprintf(stderr, "TEST-CASE: Un-supported type\n");
-        fprintf(stdout, "TEST-CASE: Un-supported type\n");
-        const int r = dd_create_archive(dd, "/tmp/libreport-attest.omg", NULL, 0);
-        printf("dd_create_archive() == %d\n", r);
-        assert(r == -ENOSYS || !"Not supported");
-    }
-
-    /* File already exists. */
-    {
-        fprintf(stderr, "TEST-CASE: File exists\n");
-        fprintf(stdout, "TEST-CASE: File exists\n");
-        char file_contents[] = "Non emtpy file";
-        const char *file_name = "/tmp/libreport-attest.tar.gz";
-        FILE *test_file = fopen(file_name, "w");
-        assert(test_file != NULL);
-        assert(fprintf(test_file, "%s", file_contents) == strlen(file_contents));
-        fclose(test_file);
-
-        assert(dd_create_archive(dd, file_name, NULL, 0) == -EEXIST || !"Exists");
-
-        g_autofree char *canary = libreport_xmalloc_xopen_read_close(file_name, NULL);
-        assert(canary != NULL);
-        assert(strcmp(canary, file_contents) == 0);
-    }
-
-    /* All elements */
-    {
-        fprintf(stderr, "TEST-CASE: Compress all elements\n");
-        fprintf(stdout, "TEST-CASE: Compress all elements\n");
-
-        const gchar *included_files[] = {
-            COMMON_FILES,
-            SENSITIVE_FILES,
-            NULL,
-        };
-
-        const char *file_name = "/tmp/libreport-attest-all.tar.gz";
-        unlink(file_name);
-        assert(dd_create_archive(dd, file_name, NULL, 0) == 0 || !"All elements");
-
-        verify_archive(dd, file_name, included_files, NULL);
-
-        unlink(file_name);
-    }
-
-    /* Excluded elements */
-    {
-        fprintf(stderr, "TEST-CASE: Exclude elements\n");
-        fprintf(stdout, "TEST-CASE: Exclude elements\n");
-
-        const char *included_files[] = {
-            COMMON_FILES,
-            NULL,
-        };
-
-        const char *file_name = "/tmp/libreport-attest-excluded.tar.gz";
-        unlink(file_name);
-        assert(dd_create_archive(dd, file_name, excluded_files, 0) == 0 || !"Excluded elements");
-
-        verify_archive(dd, file_name, included_files, excluded_files);
-
-        unlink(file_name);
-    }
-
-    assert(dd_delete(dd) == 0);
-
-    return 0;
-}
-]])
-
 ## --------------- ##
 ## dd_compute_size ##
 ## --------------- ##
diff --git a/tests/proc_helpers.at b/tests/proc_helpers.at
index 76d24e7..6ee576e 100644
--- a/tests/proc_helpers.at
+++ b/tests/proc_helpers.at
@@ -432,243 +432,6 @@ TS_MAIN
 TS_RETURN_MAIN
 ]])
 
-## ---------------------- ##
-## libreport_dump_fd_info ##
-## ---------------------- ##
-
-AT_TESTFUN([libreport_dump_fd_info], [[
-#include "testsuite.h"
-#include <sys/sendfile.h>
-#include <err.h>
-#include <glib-unix.h>
-
-#define FILENAME_FORMAT "/tmp/libreport.testsuite.fdinfo.%d.%s"
-
-pid_t prepare_process(void)
-{
-    int toparent[2];
-    g_unix_open_pipe(toparent, 0, NULL);
-
-    g_autofree char *binary = libreport_malloc_readlink("/proc/self/exe");
-    pid_t pid = fork();
-    if (pid < 0) {
-        err(EXIT_FAILURE, "fork");
-    }
-
-    if (pid == 0) {
-        close(STDOUT_FILENO);
-        libreport_xdup2(toparent[1], STDOUT_FILENO);
-
-        DIR *fddir = opendir("/proc/self/fd");
-        struct dirent *dent;
-        while ((dent = readdir(fddir))) {
-            const int fd = atoi(dent->d_name);
-            if (fd != STDOUT_FILENO) {
-                close(fd);
-            }
-        }
-
-        execl(binary, "wait", NULL);
-        exit(EXIT_FAILURE);
-    }
-
-    close(toparent[1]);
-
-    /* Wait for child */
-    char buf[8];
-    if (libreport_full_read(toparent[0], buf, 8) < 0) {
-        fprintf(stderr, "Failed to read from child: %s\n", strerror(errno));
-        fflush(stderr);
-    }
-
-    close(toparent[0]);
-
-    return pid;
-}
-
-void kill_process(pid_t pid)
-{
-    /* Notify child */
-    kill(pid, SIGTERM);
-    int status = 0;
-    if (libreport_safe_waitpid(pid, &status, 0) < 0) {
-        fprintf(stderr, "Couldn't wait for child\n");
-    }
-    else if (!WIFSIGNALED(status) || WTERMSIG(status) != SIGTERM) {
-        fprintf(stderr, "Child was not TERMinated - %d\n", status);
-    }
-}
-
-void check_file_contents(const char *fdinfo_filename)
-{
-    struct fd {
-        int fd;
-        const char *file;
-    } fds[] = {
-        { .fd = 0, .file = "/etc/services", },
-        { .fd = 2, .file = "/etc/passwd", },
-        { .fd = 3, .file = "/etc/group", },
-    };
-
-    g_autofree char *file = libreport_xmalloc_xopen_read_close(fdinfo_filename, NULL);
-    int fdno = 0;
-    char *cursor = file;
-    char *line = file;
-    char *end = file + strlen(file);
-    while (cursor < end) {
-        cursor = strchrnul(line, '\n');
-        if (*cursor != '\0') {
-            *cursor = '\0';
-        }
-        ++cursor;
-
-        if (fdno < (sizeof(fds)/sizeof(fds[0]))) {
-            int fd = 0;
-            g_autofree char *file = NULL;
-            const int res = sscanf(line, "%d:%ms", &fd, &file);
-            TS_ASSERT_SIGNED_EQ(res, 2);
-            TS_ASSERT_SIGNED_EQ(fd, fds[fdno].fd);
-            TS_ASSERT_STRING_EQ(file, fds[fdno].file, "FD file name");
-        }
-
-        line = cursor;
-        int fieldscnt = 0;
-        while (line < end) {
-            cursor = strchrnul(line, '\n');
-            if (*cursor != '\0') {
-                *cursor = '\0';
-            }
-            ++cursor;
-
-            if (strcmp(line, "") == 0) {
-                break;
-            }
-
-            int col = 0;
-            for (; col < strlen(line); ++col) {
-                if (line[col] == ':') {
-                    break;
-                }
-
-                TS_ASSERT_TRUE(line[col] != ' ' && line[col] != '\t');
-                if (!g_testsuite_last_ok) {
-                    break;
-                }
-            }
-            TS_ASSERT_SIGNED_NEQ(col, 0);
-            TS_ASSERT_SIGNED_LT(col, strlen(line));
-            if (g_testsuite_last_ok) {
-                TS_ASSERT_CHAR_EQ(line[col], ':');
-            }
-
-            fieldscnt += g_testsuite_last_ok;
-            line = cursor;
-        }
-        TS_ASSERT_SIGNED_GT(fieldscnt, 2);
-
-        ++fdno;
-        line = cursor;
-    }
-
-    TS_ASSERT_SIGNED_EQ(fdno, sizeof(fds)/sizeof(fds[0]));
-}
-
-TS_MAIN
-{
-    if (strcmp(argv[0], "wait") == 0) {
-        FILE *services = fopen("/etc/services", "r");
-        FILE *passwd = fopen("/etc/passwd", "r");
-        FILE *group = fopen("/etc/group", "r");
-
-        /* Notify parent */
-        close(STDOUT_FILENO);
-
-        /* Wait for parent */
-        while (1) {
-            sleep(1);
-        }
-
-        fclose(group);
-        fclose(passwd);
-        fclose(services);
-        exit(EXIT_SUCCESS);
-    }
-
-    pid_t pid = prepare_process();
-
-    char proc_dir_path[strlen("/proc/%d/fd") + sizeof(pid_t) * 3];
-    if (sizeof(proc_dir_path) <= snprintf(proc_dir_path, sizeof(proc_dir_path), "/proc/%d/fd", pid)) {
-        errx(EXIT_FAILURE, "too small buffer for proc dir path");
-    }
-
-    {
-        TS_PRINTF("%s\n", "libreport_dump_fd_info");
-        char fdinfo_filename[strlen(FILENAME_FORMAT) + sizeof(pid_t) * 3 + strlen("libreport_dump_fd_info")];
-        if (sizeof(fdinfo_filename) <= snprintf(fdinfo_filename, sizeof(fdinfo_filename), FILENAME_FORMAT, pid, "libreport_dump_fd_info")) {
-            errx(EXIT_FAILURE, "too small buffer for file name");
-        }
-
-        TS_ASSERT_FUNCTION(libreport_dump_fd_info(fdinfo_filename, proc_dir_path));
-
-        struct stat st;
-        TS_ASSERT_FUNCTION(stat(fdinfo_filename, &st));
-        if (g_testsuite_last_ok) {
-            TS_ASSERT_SIGNED_EQ(st.st_mode & 0777, 0600);
-        }
-
-        check_file_contents(fdinfo_filename);
-
-        unlink(fdinfo_filename);
-    }
-
-    {
-        TS_PRINTF("%s\n", "libreport_dump_fd_info_ext");
-        char fdinfo_filename[strlen(FILENAME_FORMAT) + sizeof(pid_t) * 3 + strlen("libreport_dump_fd_info_ext")];
-        if (sizeof(fdinfo_filename) <= snprintf(fdinfo_filename, sizeof(fdinfo_filename), FILENAME_FORMAT, pid, "libreport_dump_fd_info_ext")) {
-            errx(EXIT_FAILURE, "too small buffer for file name");
-        }
-
-        const uid_t uid = getuid();
-        const gid_t gid = getgid();
-        TS_ASSERT_FUNCTION(libreport_dump_fd_info_ext(fdinfo_filename, proc_dir_path, uid, gid));
-
-        struct stat st;
-        TS_ASSERT_FUNCTION(stat(fdinfo_filename, &st));
-        if (g_testsuite_last_ok) {
-            TS_ASSERT_SIGNED_EQ(st.st_mode & 0777, 0600);
-        }
-
-        check_file_contents(fdinfo_filename);
-
-        unlink(fdinfo_filename);
-    }
-
-    {
-        TS_PRINTF("%s\n", "libreport_dump_fd_info_at");
-        char fdinfo_filename[strlen(FILENAME_FORMAT) + sizeof(pid_t) * 3 + strlen("libreport_dump_fd_info_at")];
-        if (sizeof(fdinfo_filename) <= snprintf(fdinfo_filename, sizeof(fdinfo_filename), FILENAME_FORMAT, pid, "libreport_dump_fd_info_at")) {
-            errx(EXIT_FAILURE, "too small buffer for file name");
-        }
-
-        FILE *dest = fopen(fdinfo_filename, "w");
-        const int pid_proc_fd = libreport_open_proc_pid_dir(pid);
-
-        TS_ASSERT_FUNCTION(libreport_dump_fd_info_at(pid_proc_fd, dest));
-
-        close(pid_proc_fd);
-        fclose(dest);
-
-        check_file_contents(fdinfo_filename);
-
-        unlink(fdinfo_filename);
-    }
-
-    kill_process(pid);
-}
-TS_RETURN_MAIN
-]])
-
-
 ## ------------- ##
 ## get_fs-u_g-id ##
 ## ------------- ##
@@ -1034,155 +797,3 @@ TS_MAIN
 }
 TS_RETURN_MAIN
 ]])
-
-
-## ------------------------------ ##
-## libreport_process_has_own_root ##
-## ------------------------------ ##
-
-AT_TESTFUN([libreport_process_has_own_root], [[
-#include "testsuite.h"
-#include <sys/sendfile.h>
-#include <err.h>
-
-void write_cmd_output_to_fd(int fd, const char *cmd)
-{
-    FILE *proc = popen(cmd, "r");
-    if (proc == NULL) {
-        err(EXIT_FAILURE, "popen(%s)", cmd);
-    }
-
-    g_autofree char *output = libreport_xmalloc_fgetline(proc);
-    TS_PRINTF("%s : %s\n", cmd, output);
-
-    const int retcode = pclose(proc);
-    if (retcode == -1) {
-        err(EXIT_FAILURE, "pclose(%s)", cmd);
-    }
-
-    if (retcode != 0) {
-        errx(EXIT_FAILURE, "non-0 status %d of '%s'", retcode, cmd);
-    }
-
-    if (output == NULL) {
-        errx(EXIT_FAILURE, "no output of '%s'", cmd);
-    }
-
-    libreport_full_write_str(fd, output);
-}
-
-TS_MAIN
-{
-    char mock_pid_proc[] = "/tmp/libreport.testsuite.pid.XXXXXX";
-
-    if (mkdtemp(mock_pid_proc) == NULL) {
-        err(EXIT_FAILURE, "mkdtemp(%s)", mock_pid_proc);
-    }
-
-    const int mock_pid_proc_fd = open(mock_pid_proc, O_DIRECTORY);
-    if (mock_pid_proc_fd < 0) {
-        err(EXIT_FAILURE, "open(%s, O_DIRECTORY)", mock_pid_proc);
-    }
-
-    {
-        /* TODO: add test for open file descriptors */
-        const int r = libreport_process_has_own_root_at(mock_pid_proc_fd);
-        TS_ASSERT_SIGNED_EQ(r, -ENOENT);
-    }
-
-    /* Please, notice that the mode is intentionally 0000 - no read, no write,
-     * no execute access */
-    int mntnf_fd = openat(mock_pid_proc_fd, "mountinfo", O_RDWR | O_CREAT | O_EXCL, 0000);
-
-    {
-        /* TODO: add test for open file descriptors */
-        const int r = libreport_process_has_own_root_at(mock_pid_proc_fd);
-        TS_ASSERT_SIGNED_EQ(r, -EACCES);
-    }
-
-    /* Make the file readable & writable */
-    fchmod(mntnf_fd, 0600);
-
-    {
-        /* TODO: add test for open file descriptors */
-        const int r = libreport_process_has_own_root_at(mock_pid_proc_fd);
-        TS_ASSERT_SIGNED_EQ(r, -ENOKEY);
-    }
-
-    libreport_full_write_str(mntnf_fd, "36 35 98:0 /madeuproot /foo rw,noatime master:1 - ext3 /dev/myroot rw,errors=continue\n");
-    libreport_full_write_str(mntnf_fd, "37 38 99:0 /mnt3 /mnt4 rw,noatime master:2 - ext3 /dev/boot rw,errors=continue\n");
-
-    fsync(mntnf_fd);
-    lseek(mntnf_fd, 0, SEEK_SET);
-
-    TS_PRINTF("Made-up mountinfo created in %s\n", mock_pid_proc);
-
-    {
-        /* TODO: add test for open file descriptors */
-        const int r = libreport_process_has_own_root_at(mock_pid_proc_fd);
-        TS_ASSERT_SIGNED_EQ(r, -ENOKEY);
-    }
-
-    TS_PRINTF("Going to copy /proc/1/mountinfo to %s\n", mock_pid_proc);
-
-    const int pid1_mntnf_fd = open("/proc/1/mountinfo", O_RDONLY);
-    if (pid1_mntnf_fd < 0) {
-        err(EXIT_FAILURE, "/proc/1/mountinfo");
-    }
-
-    TS_PRINTF("Copying /proc/1/mountinfo to %s\n", mock_pid_proc);
-
-    {
-        int r = 0;
-
-        while ((r = sendfile(mntnf_fd, pid1_mntnf_fd, NULL, 65535)) > 0)
-            ;
-
-        if (r < 0) {
-            err(EXIT_FAILURE, "Cannot copy /proc/1/mountinfo to %s", mock_pid_proc);
-        }
-    }
-
-    close(pid1_mntnf_fd);
-
-    fsync(mntnf_fd);
-    lseek(mntnf_fd, 0, SEEK_SET);
-
-    TS_PRINTF("Copied /proc/1/mountinfo to %s\n", mock_pid_proc);
-
-    {
-        /* TODO: add test for open file descriptors */
-        const int r = libreport_process_has_own_root_at(mock_pid_proc_fd);
-        TS_ASSERT_SIGNED_EQ(r, 0);
-    }
-
-    /* Test different source directory. Swap / with \ in the mock mountinfo. */
-    fsync(mntnf_fd);
-    lseek(mntnf_fd, 0, SEEK_SET);
-
-    libreport_full_write_str(mntnf_fd, "12 34 567:89 /madeuproot / ");
-    write_cmd_output_to_fd(mntnf_fd, "findmnt -F /proc/1/mountinfo -r -n -o VFS-OPTIONS,OPT-FIELDS -T /");
-    libreport_full_write_str(mntnf_fd, " - ");
-    write_cmd_output_to_fd(mntnf_fd, "findmnt -F /proc/1/mountinfo -r -n -o FSTYPE,SOURCE,FS-OPTIONS -T /");
-
-    fsync(mntnf_fd);
-    lseek(mntnf_fd, 0, SEEK_SET);
-
-    {
-        /* TODO: add test for open file descriptors */
-        const int r = libreport_process_has_own_root_at(mock_pid_proc_fd);
-        TS_ASSERT_SIGNED_EQ(r, 1);
-    }
-
-    close(mntnf_fd);
-
-    if (unlinkat(mock_pid_proc_fd, "mountinfo", 0) < 0) {
-        perror("unlinkat(fd, mountinfo)");
-    }
-
-    if (rmdir(mock_pid_proc) < 0) {
-        perror("rmdir(/mock_pid_dir)");
-    }
-}
-TS_RETURN_MAIN
-]])
diff --git a/tests/report_python.at b/tests/report_python.at
index 31c0142..f267427 100644
--- a/tests/report_python.at
+++ b/tests/report_python.at
@@ -70,43 +70,6 @@ if __name__ == "__main__":
     sys.exit(main())
 ]])
 
-## ----------------------- ##
-## get_from_etc_os_release ##
-## ----------------------- ##
-
-AT_PYTESTFUN([get_from_etc_os_release],
-[[import sys
-
-sys.path.insert(0, "../../../src/report-python")
-sys.path.insert(0, "../../../src/report-python/report/.libs")
-
-report = __import__("report", globals(), locals(), [], 0)
-sys.modules["report"] = report
-
-import os
-
-if not os.path.exists("/etc/os-release"):
-    print("Cannot run the test: '/etc/os-release' does not exist")
-    sys.exit(1)
-
-exit_code = 0
-if report.getProduct_fromOSRELEASE() != report.getProduct():
-    print("getProduct('{0}') did not return PRODUCT='{1}' from /etc/os-release".format(report.getProduct(), report.getProduct_fromOSRELEASE()))
-    exit_code += 1
-
-if report.getVersion_fromOSRELEASE() != report.getVersion():
-    print("getVersion('{0}') did not return PRODUCT_VERSION='{1}' from /etc/os-release".format(report.getVersion(), report.getVersion_fromOSRELEASE()))
-    exit_code += 1
-
-if exit_code != 0:
-    print("++++ /etc/os-release ++++")
-    with open("/etc/os-release") as osrel:
-        sys.stdout.write(osrel.read())
-    print("^^^^ /etc/os-release ^^^^")
-
-sys.exit(exit_code)
-]])
-
 ## ---------------------------------- ##
 ## create_dump_dir_uid_does_not_exist ##
 ## ---------------------------------- ##
diff --git a/tests/ureport.at b/tests/ureport.at
index 7ac67dc..849f1c9 100644
--- a/tests/ureport.at
+++ b/tests/ureport.at
@@ -764,101 +764,6 @@ int main(void)
 }
 ]])
 
-## -------------------------- ##
-##  libreport_ureport_do_post ##
-## -------------------------- ##
-
-AT_TESTFUN([libreport_ureport_do_post],
-[[
-#include "internal_libreport.h"
-#include "ureport.h"
-#include <assert.h>
-#include "libreport_curl.h"
-#include "problem_data.h"
-
-int main(void)
-{
-    libreport_g_verbose=3;
-
-    struct dump_dir *dd = dd_create("./test", (uid_t)-1L, DEFAULT_DUMP_DIR_MODE);
-    assert(dd != NULL);
-    dd_create_basic_files(dd, (uid_t)-1L, NULL);
-    dd_save_text(dd, FILENAME_TYPE, "CCpp");
-    dd_save_text(dd, FILENAME_ANALYZER, "CCpp");
-    dd_save_text(dd, FILENAME_PKG_EPOCH, "pkg_epoch");
-    dd_save_text(dd, FILENAME_PKG_ARCH, "pkg_arch");
-    dd_save_text(dd, FILENAME_PKG_RELEASE, "pkg_release");
-    dd_save_text(dd, FILENAME_PKG_VERSION, "pkg_version");
-    dd_save_text(dd, FILENAME_PKG_NAME, "pkg_name");
-    const char *bt = "{ \"signal\": 6, \"executable\": \"/usr/bin/will_abort\" }";
-    dd_save_text(dd, FILENAME_CORE_BACKTRACE, bt);
-    dd_save_text(dd, FILENAME_COUNT, "1");
-    dd_close(dd);
-
-    g_autofree char *json = libreport_ureport_from_dump_dir_ext("./test", NULL);
-
-    /* wrong url */
-    struct ureport_server_config config;
-    libreport_ureport_server_config_init(&config);
-    struct post_state *post_state = libreport_ureport_do_post(json, &config, "not_exist");
-    assert(post_state->curl_result == CURLE_COULDNT_RESOLVE_HOST);
-
-    free_post_state(post_state);
-    libreport_ureport_server_config_destroy(&config);
-    delete_dump_dir("./test");
-
-    return 0;
-}
-]])
-
-## ------------------------- ##
-##  libreport_ureport_submit ##
-## ------------------------- ##
-
-AT_TESTFUN([libreport_ureport_submit],
-[[
-#include "internal_libreport.h"
-#include "ureport.h"
-#include <assert.h>
-#include "libreport_curl.h"
-#include "problem_data.h"
-
-int main(void)
-{
-    libreport_g_verbose=3;
-
-    struct dump_dir *dd = dd_create("./test", (uid_t)-1L, DEFAULT_DUMP_DIR_MODE);
-    assert(dd != NULL);
-    dd_create_basic_files(dd, (uid_t)-1L, NULL);
-    dd_save_text(dd, FILENAME_TYPE, "CCpp");
-    dd_save_text(dd, FILENAME_ANALYZER, "CCpp");
-    dd_save_text(dd, FILENAME_PKG_EPOCH, "pkg_epoch");
-    dd_save_text(dd, FILENAME_PKG_ARCH, "pkg_arch");
-    dd_save_text(dd, FILENAME_PKG_RELEASE, "pkg_release");
-    dd_save_text(dd, FILENAME_PKG_VERSION, "pkg_version");
-    dd_save_text(dd, FILENAME_PKG_NAME, "pkg_name");
-    const char *bt = "{ \"signal\": 6, \"executable\": \"/usr/bin/will_abort\" }";
-    dd_save_text(dd, FILENAME_CORE_BACKTRACE, bt);
-    dd_save_text(dd, FILENAME_COUNT, "1");
-    dd_close(dd);
-
-    g_autofree char *json = libreport_ureport_from_dump_dir_ext("./test", NULL);
-
-    /* wrong url */
-    struct ureport_server_config config;
-    libreport_ureport_server_config_init(&config);
-    struct ureport_server_response *response = libreport_ureport_submit(json, &config);
-
-    assert(response == NULL);
-
-    libreport_ureport_server_response_free(response);
-    libreport_ureport_server_config_destroy(&config);
-    delete_dump_dir("./test");
-
-    return 0;
-}
-]])
-
 ## --------------------------- ##
 ## ureport_json_attachment_new ##
 ## --------------------------- ##
@@ -918,91 +823,6 @@ int main(void)
 }
 ]])
 
-## ----------------------------------- ##
-## libreport_ureport_from_dump_dir_ext ##
-## ----------------------------------- ##
-
-AT_TESTFUN([libreport_ureport_from_dump_dir_ext],
-[[
-#include "internal_libreport.h"
-#include "ureport.h"
-#include <assert.h>
-#include "libreport_curl.h"
-#include "problem_data.h"
-
-int main(void)
-{
-    libreport_g_verbose=3;
-
-    struct dump_dir *dd = dd_create("./test", (uid_t)-1L, DEFAULT_DUMP_DIR_MODE);
-    assert(dd != NULL);
-    dd_create_basic_files(dd, (uid_t)-1L, NULL);
-    dd_save_text(dd, FILENAME_TYPE, "CCpp");
-    dd_save_text(dd, FILENAME_ANALYZER, "CCpp");
-    dd_save_text(dd, FILENAME_PKG_EPOCH, "pkg_epoch");
-    dd_save_text(dd, FILENAME_PKG_ARCH, "pkg_arch");
-    dd_save_text(dd, FILENAME_PKG_RELEASE, "pkg_release");
-    dd_save_text(dd, FILENAME_PKG_VERSION, "pkg_version");
-    dd_save_text(dd, FILENAME_PKG_NAME, "pkg_name");
-    const char *bt = "{ \"signal\": 6, \"executable\": \"/usr/bin/will_abort\" }";
-    dd_save_text(dd, FILENAME_CORE_BACKTRACE, bt);
-    dd_save_text(dd, FILENAME_COUNT, "1");
-    dd_close(dd);
-
-    /* no auth */
-    char *ureport = libreport_ureport_from_dump_dir_ext("./test", NULL);
-    assert(strstr(ureport, "auth") == NULL);
-    g_free(ureport);
-
-    /* auth */
-    dd = dd_opendir("./test", 0);
-    dd_save_text(dd, FILENAME_HOSTNAME, "env_hostname");
-    dd_close(dd);
-
-    struct ureport_server_config config;
-    libreport_ureport_server_config_init(&config);
-
-    GHashTable *settings = g_hash_table_new_full(g_str_hash, g_str_equal, free, free);
-
-    setenv("uReport_IncludeAuthData", "yes", 1);
-    setenv("uReport_AuthDataItems", "hostname", 1);
-
-    libreport_ureport_server_config_load(&config, settings);
-
-    ureport = libreport_ureport_from_dump_dir_ext("./test", &config.ur_prefs);
-    assert(strstr(ureport, "auth") != NULL);
-    assert(strstr(ureport, "\"hostname\": \"env_hostname\"") != NULL);
-    g_free(ureport);
-
-    libreport_ureport_server_config_destroy(&config);
-    if (settings)
-        g_hash_table_destroy(settings);
-
-    /* auth with unknown uReport_AuthDataItems */
-    libreport_ureport_server_config_init(&config);
-
-    settings = g_hash_table_new_full(g_str_hash, g_str_equal, free, free);
-
-    setenv("uReport_AuthDataItems", "hostname, unknown", 1);
-
-    libreport_ureport_server_config_load(&config, settings);
-
-    ureport = libreport_ureport_from_dump_dir_ext("./test", &config.ur_prefs);
-    assert(strstr(ureport, "auth") != NULL);
-    assert(strstr(ureport, "\"hostname\": \"env_hostname\"") != NULL);
-    assert(strstr(ureport, "unknown") == NULL);
-    g_free(ureport);
-
-    libreport_ureport_server_config_destroy(&config);
-    if (settings)
-        g_hash_table_destroy(settings);
-    delete_dump_dir("./test");
-
-    return 0;
-}
-]])
-
-
 ## ------------------------------------- ##
 ## ureport_server_config_load_basic_auth ##
 ## ------------------------------------- ##
-- 
2.45.4

